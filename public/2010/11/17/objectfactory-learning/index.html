<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="对象工厂，顾名思义，就是产生对象的一个“工厂”。根据传入的一个参数而产生相应的不同种类的对象。
　　用于批量生成同一个父类的不同子类的对象时用到。
　　本学习笔记基于Singleton（单件模式）基础上进行扩展。
　　看《C++单件模式：Singleton学习笔记》请点击链接。
　　对于工厂模式，网"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>C++对象工厂模式：ObjectFactory学习笔记 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>C++对象工厂模式：ObjectFactory学习笔记</h1><span class="post-meta">写于<time> 2010 年 11 月 17 日 15 时 49 分</time><br>更新于<time> 2016 年 12 月 27 日 15 时 54 分</time></span><div class="article-toc"><strong>大纲</strong></div><p>　　对象工厂，顾名思义，就是产生对象的一个“工厂”。根据传入的一个参数而产生相应的不同种类的对象。</p>
<p>　　用于批量生成同一个父类的不同子类的对象时用到。</p>
<p>　　本学习笔记基于Singleton（单件模式）基础上进行扩展。</p>
<p>　　看《C++单件模式：Singleton学习笔记》请点击<a href="/2010/11/13/singleton-learning/">链接</a>。</p>
<p>　　对于工厂模式，网上有很多不同的实现方法。我这里是一个HGE的RPG Demo中所用的，这段代码本身写的非常的好，开始好些语句没看懂，虽然就这么几句话。花了一点时间去研究了其代码，并自己重新实现了一遍，加上了通俗易懂的注释。</p>
<p>　　工厂类以模板形式实现，基于Singleton：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**--------------------------------</span><br><span class="line"> * 对象工厂模式(Object Factory)</span><br><span class="line"> *</span><br><span class="line"> * Code by XadillaX</span><br><span class="line"> * http://www.xcoder.in</span><br><span class="line"> * Created at 2010-11-17 1:33</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OBJECTFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECTFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../单件模式/Singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> ObjectFactory : <span class="keyword">public</span> Singleton&lt;ObjectFactory&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* (*tCreator)();                               <span class="comment">///&lt; 重定义对象生成函数指针</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, tCreator&gt; tCreatorMap;    <span class="comment">///&lt; 对象生成函数指针map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 注册新“生产车间”</span><br><span class="line">     * 将生成对象的函数加入对象工厂</span><br><span class="line">     *</span><br><span class="line">     * @param *name 类名称</span><br><span class="line">     * @param procedure “生产”对象的函数</span><br><span class="line">     * @return 是否成功注册</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(<span class="keyword">char</span> *type, tCreator procedure)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 找到“生产车间”</span><br><span class="line">     * 根据传入的类名返回相应的新对象的生成函数</span><br><span class="line">     *</span><br><span class="line">     * @param &amp;type 类名</span><br><span class="line">     * @return 相应的新对象的生成函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">T* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** “生产车间”映射 */</span></span><br><span class="line">    tCreatorMap _map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> ObjectFactory&lt;T&gt;::Register(<span class="keyword">char</span> *type, tCreator procedure)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(type)</span></span>;</span><br><span class="line">    <span class="comment">/** 将新函数加入map中 */</span></span><br><span class="line">    _map[tmp] = procedure;</span><br><span class="line">    <span class="keyword">return</span> _map[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T* ObjectFactory&lt;T&gt;::Create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 在映射中找到相应“生产车间” */</span></span><br><span class="line">    tCreatorMap::iterator iter = _map.find(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 检测“车间”是否存在 */</span></span><br><span class="line">    <span class="keyword">if</span>(iter != _map.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 让返回值为相应的“生产车间” */</span></span><br><span class="line">        tCreator r = iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 返回“生产车间” */</span></span><br><span class="line">        <span class="keyword">return</span> r();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　以上就是基於单件模式而实现的工厂模式了。</p>
<p>　　在样例中，我建立了一个基类Base，然后用A和B来继承它。</p>
<p>　　在一个for循环中，交替建立了A对象和B对象。这只是一个Demo，看不出有什么方便的，感觉用一个if来各自生成就好了，就像</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == <span class="string">"A"</span>) p = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">else</span> p = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<p>　　<strong>当然，上面也是一种方法。但是，试想一下，我们将要创建的A、B、C、D、E、F、G类放到一个配置文件中，然后我们从配置文件中读取这些数据并创建相应的对象，并且这些对象的顺序是打乱的，你就要有n个if来判断了，而且扩展性不高。用一个对象工厂进行封装的话，俨然形成了一个静而有序的生产工厂，有秩序地管理着不同的对象车间，不觉得这是一件非常美妙的事情么？</strong></p>
<p>　　好了，话不多说，直接上Demo。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ObjectFactory.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/** 基类 */</span></span><br><span class="line"><span class="keyword">class</span> Base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base类及其子类的对象工厂 */</span></span><br><span class="line"><span class="keyword">typedef</span> ObjectFactory&lt;Base&gt; BaseFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;&#125;;</span><br><span class="line">    ~Base()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"An A object created."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A B object Created."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对象A的“生产车间” */</span></span><br><span class="line"><span class="function">Base* <span class="title">ACreator</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对象B的“生产车间” */</span></span><br><span class="line"><span class="function">Base* <span class="title">BCreator</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 主函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** 将A、B的“生产车间”注册到对象工厂中 */</span></span><br><span class="line">    <span class="keyword">bool</span> AFlag = BaseFactory::Instance().Register(<span class="string">"A"</span>, ACreator);</span><br><span class="line">    <span class="keyword">bool</span> BFlag = BaseFactory::Instance().Register(<span class="string">"B"</span>, BCreator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 若注册失败则退出 */</span></span><br><span class="line">    <span class="keyword">if</span>(!AFlag || !BFlag) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Base *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> type = (i % <span class="number">2</span>) ? <span class="built_in">string</span>(<span class="string">"A"</span>) : <span class="built_in">string</span>(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** p用相应“生产车间”进行生产 */</span></span><br><span class="line">        p = BaseFactory::Instance().Create(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr><section class="comment"><div class="ds-thread" data-thread-key="/2010/11/17/objectfactory-learning/" data-title="C++对象工厂模式：ObjectFactory学习笔记" data-url="https://xcoder.in/2010/11/17/objectfactory-learning/"></div></section><script>var _shortName = "xcoder-ghost";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2016<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : $(block).attr("class")) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>