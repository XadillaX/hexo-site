<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[艾克斯の編碼者]]></title>
  <subtitle><![CDATA[一個偽宅级别的蒟蒻碼畜。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xcoder.in//"/>
  <updated>2014-05-20T10:08:43.654Z</updated>
  <id>http://xcoder.in//</id>
  
  <author>
    <name><![CDATA[小鳥遊死月]]></name>
    <email><![CDATA[admin@xcoder.in]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[「NBUT 2014 校赛·网络同步赛」题解 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/"/>
    <id>http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/</id>
    <published>2014-05-05T06:08:39.000Z</published>
    <updated>2014-05-20T10:07:24.000Z</updated>
    <content type="html"><![CDATA[<p>这次比赛由 <a href="http://blog.163.com/surgy_han/" target="_blank">Hungar</a>，<a href="http://www.cnblogs.com/Wine93/" target="_blank">8Mao</a> 以及我负责的。明明都读研了，还诈尸回来出题——归结起来大概是因为各种面试不顺吧，想来虐虐学弟妹们怒刷存在感。结果网络赛还是被虐得死去活来。（果然我是蒟蒻 (◓Д◒)✄╰⋃╯</p>
<p>　　好了废话不多说，还是直接上题解吧。</p>
<h2 id="Minecraft_Server_Bug">Minecraft Server Bug</h2>
<p>　　题意大概就是说一排岩浆和水，你要拿一桶水和岩浆，并且水的下标小于岩浆。</p>
<p>　　为了更便于理解，我们从后往前做。首先将序列读进来之后从后往前遍历——若是岩浆，那么岩浆数加一，如果是水，那么这桶水能选择后面岩浆的任意一桶，也就是说答案加上当前的岩浆数即可。</p>
<blockquote>
<p>注意用 <code>__int64</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n;
    <span class="keyword">char</span> ch[<span class="number">1000005</span>];
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &n))
    {
        <span class="keyword">char</span> tmp;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        {
            <span class="built_in">scanf</span>(<span class="string">"%c%c"</span>, ch + i, &tmp);
        }
        
        __int64 ans = <span class="number">0</span>;
        <span class="keyword">int</span> cnt = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)
        {
            <span class="keyword">if</span>(ch[i] == <span class="string">'L'</span>) cnt++;
            <span class="keyword">else</span> ans += (__int64)cnt;
        }
        
        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);
    }
    
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h2 id="Beautiful_Walls">Beautiful Walls</h2>
<p>　　一堵墙，每单位高度不定。你需要选择其中任意连续的墙，使得你选择的墙每单位的高度都是唯一的——问有多少种选法。</p>
<p>　　先求出总的种数，然后求不满足的数量，最后用总数减去不满足数即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="preprocessor">#define lint long long</span>
<span class="preprocessor">#define N 100005</span>
<span class="keyword">int</span> p[N], A[N];
lint solution(lint n)
{
    <span class="built_in">memset</span>(p, -<span class="number">1</span>, <span class="keyword">sizeof</span>(p));
    lint ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>, Max = <span class="number">0</span>;
    <span class="keyword">for</span>(lint i=<span class="number">0</span>; i &lt; n; ++i)
    {
        <span class="keyword">if</span>(~p[A[i]])
        {
            <span class="keyword">if</span>(Max &lt; p[A[i]]) Max = p[A[i]];
            p[A[i]] = i + <span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            p[A[i]] = i + <span class="number">1</span>;
        }
        ans -= Max;
    }
    <span class="keyword">return</span> ans;
}

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n, x;
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &n))
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)
        {
            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);
        }
        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solution(n));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="ACM" scheme="http://xcoder.in/tags/ACM/"/>
    
      <category term="算法" scheme="http://xcoder.in/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://xcoder.in/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[死月出品：Hero Snake 英雄蛇]]></title>
    <link href="http://xcoder.in/2014/04/11/hero-snake/"/>
    <id>http://xcoder.in/2014/04/11/hero-snake/</id>
    <published>2014-04-11T04:53:35.000Z</published>
    <updated>2014-04-11T06:30:00.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注：备份到这篇日志的时候，感觉眼睛进了什么奇怪的东西。（才……才不是眼泪呢，那一定是沙子！(;´༎ຶД༎ຶ`)</p>
<p>主要引起感伤的还是这首轩辕剑的 BGM 吧。因为 Hero Snake 的BGM就是这个。</p>
<p>这篇文章原文是在 2011年5月1日 发的。游戏是跟 <strong>MatRush</strong> 在2011年寒假一起写的，虽然是我边教边写的。呵呵，转眼间三年过去了。</p>
<p>想当年我还是那么执着于游戏行业，现在纠结于到底要从事游戏行业还是互联网呢？半年真的能改变很多，要是我当时没有去汽族网实习，也许现在并不会有那么大的改变吧。</p>
<p>自从被 <a href="http://weibo.com/shyvo" target="_blank">@朴大</a> 刷了之后，我又开始着重考虑了。是不是我玩互联网只是觉得新鲜好玩而已呢？毕竟我是半路出家的，虽然有着十来年的 <code>Web经历</code>，但那都是小打小闹哇。还记得小学的时候买的第一本电脑书——<a href="http://www.amazon.cn/%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6-%E6%9C%B1%E6%83%A0%E5%BC%BA/dp/B0011A9QSA/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1397196202&amp;sr=1-1&amp;keywords=%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6" target="_blank">《在网上安个家》</a>，到现在还记得那个时候捧着书的激动心情。</p>
<p>我是不是有点偏离了自己本身的轨道呢？总之还是在这两块领域犹豫不决。</p>
<p>废话有点扯远了，还是把文章从 Capture 备份回来再说吧。</p>
</blockquote>
<p>　　这是一款正宗基于HGE的小游戏，算是我做的游戏中自己比较满意的小游戏吧。</p>
<p>　　幕后故事是这样的：MatRush寒假找我一起做游戏，因为他们学校弄了一个蛋疼的游戏制作比赛。然后命题是贪吃蛇，于是我们加了一点自己的小创意，给他讲解了一些HGE的基础之后，就写了这个游戏了。然后因为我们都比较喜欢轩辕剑，于是BGM就是轩辕剑的《永远的三个人的快乐时光》，由于MatRush比较喜欢MapleStory，便有了素材是那些像素画面。</p>
<p>　　首先这个游戏有两种模式：单人模式和双人模式。</p>
<p>　　关于单人模式，这是一个闯关型模式，大家在每一关必须通过吃道具获得一定的分数以及吃圈圈获得一定圈圈数才能开启通往下一关的门，默认一共20关，可以自己编辑关卡，这是后话。下面是几种道具的解说：</p>
<blockquote>
<p><img src="treasure0.png" alt="开山斧"></p>
<p>开山斧：捡到这货随机获得1~3个斧头并且附赠100分数。斧头的作用是能破开木桶，安全通过，一个斧头用一次。斧头数在左下角的Axe(s)后面。</p>
<p><img src="treasure1.png" alt="命运之剪"></p>
<p>命运之剪：捡到这个之后获得100分并且给你断掉一个尾巴以降低难度。</p>
<p><img src="treasure2.png" alt="降速器"></p>
<p>降速器：因为你每吃一个圈圈会增加一定速度，而这个降速器是降低你的速度让你容易些。并且附赠100分。</p>
<p><img src="treasure8.png" alt="药水"></p>
<p>药水：药水是装饰变色用的，其实是送分的。前四种药水100分，紫色的300分。</p>
<p><img src="treasure3.png" alt="降速器"></p>
<p>骷髅头：想死的话就碰碰它试试。</p>
<p><img src="door.png" alt="传送门"></p>
<p>传送门：遇到这货就说明你功德圆满了。恭喜，可以通过它前往下一关。</p>
</blockquote>
<p>　　接下去是双人模式。双人模式因为当初设想有些问题，所以实现起来仅仅是简单的双人走啊走，看谁碰到谁谁就输。在双人模式中，先要选择一张对战地图，然后开始双人走啊走啊走。</p>
<p>　　然后Rank是排行榜，Option是游戏的一些选项，Introduction是游戏介绍，这个介绍有些蛋疼，最后不用说Exit就是退出了。</p>
<p>　　下面是关于地图编辑器的说明：</p>
<p>　　首先在游戏目录小有一个config.ini文件，是一些游戏设置。其中levelnum是游戏关卡数。注意这个数字必须要跟地图数量一致或者小于它，否则会因为找不到之后的地图而出错。地图就存在data里，命名方式是mapX.txt，从0开始。地图编辑器则在MapEditor文件夹下。操作很简单，说明都在编辑器下方的文字上，就几个快捷键。可以用鼠标操作也可以用上下左右控制方向。</p>
<p>　　最后，预祝大家玩得愉快。附上下载地址和几张预览图吧：</p>
<p>　　<a href="bin.7z">点击下载</a></p>
<p>　　<a href="https://github.com/XadillaX/hero-snake" target="_blank">代码地址</a></p>
<p><img src="1.png" alt="标题画面"><br><img src="2.png" alt="玩的画面"><br><img src="4.png" alt="双人模式"></p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="HGE" scheme="http://xcoder.in/tags/HGE/"/>
    
      <category term="游戏开发" scheme="http://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 3 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/"/>
    <id>http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/</id>
    <published>2014-04-06T07:15:39.000Z</published>
    <updated>2014-05-20T10:07:31.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2014/04/03/nodejs-cpp-addons-2/">上一章</a>我们偷偷学习了如何在 <code>C++</code> 中实现 <code>Node.js</code> 调用时传参数和调用回调函数，并且我自己也心血来潮写了个<a href="/2014/04/05/cpp-class-inline-keng/#simpleini">小 Demo</a> 供大家参考。</p>
<p>　　今天我们就不复习了，直捣黄龙吧。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中类成员函数 inline 的坑]]></title>
    <link href="http://xcoder.in/2014/04/05/cpp-class-inline-keng/"/>
    <id>http://xcoder.in/2014/04/05/cpp-class-inline-keng/</id>
    <published>2014-04-05T07:55:57.000Z</published>
    <updated>2014-04-05T08:21:28.000Z</updated>
    <content type="html"><![CDATA[<p>今天我来讲一讲 <code>C++</code> 中类成员函数 <code>inline</code> 修饰符的一个坑。</p>
<p>　　这个坑是我在尝试着写我的第一个 <code>Node.js</code> 扩展 <code>simpleini</code> 时候遇到的。</p>
<h2 id="坑描述">坑描述</h2>
<p>　　因为只是尝试着写，所以懒得自己实现，于是网上找了个开源的 <code>C++</code> 阅读 ini 文件的项目，名不见经传，叫 <a href="http://miniini.tuxfamily.org/" target="_blank">miniini</a>。</p>
<p>　　好了，问题来了，当我写好我的源文件的时候，然后写好了我的 <code>binding.gyp</code> ，总之一切大功告成开始编译的时候—— <code>Windows</code> 下没问题，<code>MacOS</code> 下也可以正常运行，但是在 <code>Linux</code> 下就出问题了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>node: symbol lookup err: <span class="keyword">...</span>/simpleIni.node: undefined symbol: _ZNK10INISection10ReadStringEPKcRS1_
</pre></td></tr></table></figure>

<p>　　大致的意思呢就是说找不到 <code>INISection</code> 的 <code>ReadString</code> 函数符号。</p>
<h2 id="问题分析">问题分析</h2>
<p>　　又是怀着崇敬的心情去 <a href="http://stackoverflow.com/questions/22868307/undefined-symbol-in-node-js-c-addon-under-linux-why" target="_blank">SO</a> 求解了。</p>
<p>　　最后的解答大概<a href="http://isocpp.org/wiki/faq/inline-functions#inline-member-fns" target="_blank">如下</a>：</p>
<blockquote>
<p>内联成员函数的声明看起来像一个非内联函数的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">class</span> Fred {
<span class="keyword">public</span>:
    <span class="keyword">void</span> f(<span class="keyword">int</span> i, <span class="keyword">char</span> c);
};
</pre></td></tr></table></figure>

<p>但是你的内敛成员函数定义前面又加了 <code>inline</code> 这个关键字时，你必须把这个定义放到头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">inline</span>
<span class="keyword">void</span> Fred::f(<span class="keyword">int</span> i, <span class="keyword">char</span> c)
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>这么做的原因就是为了避免链接器 <code>unresolved external</code> 的发生。如果你不这么做，这个错误就将会在你从另外一个 <code>.cpp</code> 文件中调用它时出现。</p>
</blockquote>
<p>　　好嘛，原来是原作者自己写的代码有问题啊。但是不得不说一下又涨姿势了。C++还真是有千奇百怪的坑和错误啊。</p>
<h2 id="解决方案">解决方案</h2>
<p>　　最后的解决方案大致就是把函数定义放到头文件中去，或者在函数声明前面也加上 <code>inline</code> 关键字。</p>
<h2 id="simpleini">simpleini</h2>
<p>　　我的第一个 <code>C++</code> 模块，叫 <code>simpleini</code> ，其实只是抱着试试看 <code>Node.j</code> 的 <code>C++</code> 模块是不是这么写的而已，并没有多大实际用处。Repo 在 <a href="https://github.com/XadillaX/node-simple-ini" target="_blank">Github</a> 上。</p>
<p>　　然后用法很简单，先安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install simpleini
</pre></td></tr></table></figure>

<p>　　然后下面的代码就是例子了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> simpleIni = <span class="built_in">require</span>(<span class="string">"simpleini"</span>);

console.log(simpleIni.open(<span class="string">"./node_modules/simpleini/src/miniini-0.9/test/test.ini"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>));
console.log(simpleIni.read(<span class="string">"SETTINGS"</span>, <span class="string">"sections"</span>));
console.log(simpleIni.read(<span class="string">"vals"</span>, <span class="string">"float"</span>));
</pre></td></tr></table></figure>

<p>　　读取配置的时候第一个参数是 <code>Section</code>，第二个参数是 <code>Key</code>，第三个参数是取不到该值时的默认值。</p>
]]></content>
    
    
      <category term="Programming" scheme="http://xcoder.in/tags/Programming/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 2]]></title>
    <link href="http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/"/>
    <id>http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/</id>
    <published>2014-04-03T13:37:15.000Z</published>
    <updated>2014-04-04T05:47:45.000Z</updated>
    <content type="html"><![CDATA[<p>好，今天让我们更深入地搞基吧！</p>
<h2 id="温故而知新，可以为湿矣">温故而知新，可以为湿矣</h2>
<p>　　首先请大家记住这个 V8 的在线手册——<a href="http://izs.me/v8-docs/main.html" target="_blank">http://izs.me/v8-docs/main.html</a>。</p>
<p>　　还记得上次的 <code>building.gyp</code> 文件吗？</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"addon"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"addon.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>

<p>　　就像这样，举一反三，如果多几个 <code>*.cc</code> 文件的话就是这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>"sources": [ "addon.cc", "myexample.cc" ]
</pre></td></tr></table></figure>

<p>　　上次我们把俩步骤分开了，实际上配置和编译可以放在一起的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure build
</pre></td></tr></table></figure>

<p>　　复习完了吗？没？！</p>
<p><img src="mama.jpg" alt="啪"></p>
<p>　　好的，那我们继续吧。</p>
<h2 id="表番">表番</h2>
<h3 id="函数参数">函数参数</h3>
<p>　　现在我们终于要讲参数了呢。</p>
<p>　　让我们设想有这样一个函数 <code>add(a, b)</code> 代表把 <code>a</code> 和 <code>b</code> 相加返回结果，所以先把函数外框写好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;

    <span class="comment">//... 又来！</span>
}
</pre></td></tr></table></figure>

<h4 id="Arguments">Arguments</h4>
<p>　　这个就是函数的参数了。我们不妨先看看 v8 的<a href="http://izs.me/v8-docs/classv8_1_1Arguments.html" target="_blank">官方手册参考</a>。</p>
<ul>
<li><code>int Length() const</code></li>
<li><code>Local&lt;Value&gt; operator[](int i) const</code></li>
</ul>
<p>　　其它的我们咱不关心，这两个可重要了！一个代表传入函数的参数个数，另一个中括号就是通过下标索引来访问第 <code>n</code> 个参数的。</p>
<p>　　所以如上的需求，我们大致就可以理解为 <code>args.Length()</code> 为 <code>2</code>，<code>args[0]</code> 代表 <code>a</code> 以及 <code>args[1]</code> 代表 <code>b</code> 了。并且我们要判断这两个数的类型必须得是 <code>Number</code>。</p>
<p>　　注意到没，中括号的索引操作符返回结果是一个 <code>Local&lt;Value&gt;</code> 也就是 <code>Node.js</code> 的所有类型基类。所以传进来的参数类型不定的，我们必须得自己判断是什么参数。这就关系到了这个 <code>Value</code> 类型的一些<a href="http://izs.me/v8-docs/classv8_1_1Value.html" target="_blank">函数</a>了。</p>
<ul>
<li><code>IsArray()</code></li>
<li><code>IsBoolean()</code></li>
<li><code>IsDate()</code></li>
<li><code>IsFunction()</code></li>
<li><code>IsInt32()</code></li>
<li><code>IsNativeError()</code></li>
<li><code>IsNull()</code></li>
<li><code>IsNumber()</code></li>
<li><code>IsRegExp()</code></li>
<li><code>IsString()</code></li>
<li>…</li>
</ul>
<p>　　我就不一一列举了，剩下的自己看文档。｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡</p>
<h4 id="ThrowException">ThrowException</h4>
<p>　　这个是我们等下要用到的一个函数。具体在 <a href="http://izs.me/v8-docs/namespacev8.html#a2469af0ac719d39f77f20cf68dd9200e" target="_blank">v8 文档</a>中可以找到。</p>
<p>　　顾名思义，就是抛出错误啦。执行这个语句之后，相当于在 <code>Node.js</code> 本地文件中执行了一条 <code>throw()</code> 语句一样。比如说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
</pre></td></tr></table></figure>

<p>　　就相当于执行了一条 <code>Node.js</code> 的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong number of arguments"</span>);
</pre></td></tr></table></figure>

<h4 id="Undefined()">Undefined()</h4>
<p>　　这个函数呢也在<a href="http://izs.me/v8-docs/namespacev8.html#ad39cfade81e77137fc11ff3a24284340" target="_blank">文档</a>里面。</p>
<p>　　具体就是一个空值，因为有些函数并不需要返回什么具体的值，或者说没有返回值，这个时候就需要用 <code>Undefined()</code> 来代替了。</p>
<h4 id="动手吧骚年！">动手吧骚年！</h4>
<p>　　在理解了以上的几个要点之后，我相信你们很快就能写出 <code>a + b</code> 的逻辑了，我就把 <code>Node.js</code> 官方手册的代码抄过来给你们过一遍就算完事了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    
    <span class="comment">// 代表了可以传入 2 个以上的参数，但实际上我们只用前两个</span>
    <span class="keyword">if</span>(args.Length() &lt; <span class="number">2</span>)
    {
        <span class="comment">// 抛出错误</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
        
        <span class="comment">// 返回空值</span>
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 若前两个参数其中一个不是数字的话</span>
    <span class="keyword">if</span>(!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber())
    {
        <span class="comment">// 抛出错误并返回空值</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong arguments"</span>)));
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 具体参考 v8 文档</span>
    <span class="comment">//     http://izs.me/v8-docs/classv8_1_1Value.html#a6eac2b07dced58f1761bbfd53bf0e366)</span>
    <span class="comment">// 的 `NumberValue` 函数</span>
    Local&lt;Number&gt; num = Number::New(args[<span class="number">0</span>]-&gt;NumberValue() + args[<span class="number">1</span>]-&gt;NumberValue());
    
    <span class="keyword">return</span> scope.Close(num);
}
</pre></td></tr></table></figure>

<p>　　函数大功告成！</p>
<p>　　最后把尾部的导出函数给写好就 OK 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> Init(Handle&lt;Object&gt; exports)
{
    exports-&gt;Set(String::NewSymbol(<span class="string">"add"</span>),
        FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　等你编译好之后，我们就能这样用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> addon = <span class="built_in">require</span>(<span class="string">'./build/Release/addon'</span>);
console.log(addon.add(<span class="number">1</span>, <span class="number">1</span>) + <span class="string">"b"</span>);
</pre></td></tr></table></figure>

<p>　　你会看到一个 <code>2b</code> ！✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p>
<h3 id="回调函数">回调函数</h3>
<p>　　上一章我们只讲了个 <code>Hello world</code>，这一章阿婆主就良心发现一下，再来个回调函数的写法。</p>
<p>　　惯例我们先写好框架：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
  HandleScope scope;

  <span class="comment">// ... 噼里啪啦噼里啪啦</span>

  <span class="keyword">return</span> scope.Close(Undefined());
}
</pre></td></tr></table></figure>

<p>　　然后我们决定它的用法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>func(<span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
    console.log(msg);
});
</pre></td></tr></table></figure>

<p>　　即它会给回调函数传入一个参数，我们设想它是一个字符串，然后我们可以 <code>console.log()</code> 出来看。</p>
<h4 id="首先你要有一个字符串系列">首先你要有一个字符串系列</h4>
<p>　　废话不多说，先给它一个字符串喂饱了再说吧。<em>(√ ζ ε:)</em></p>
<p>　　不过我们得让这个字符串是通用类型的，因为 <code>Node.js</code> 代码是弱类型的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>));
</pre></td></tr></table></figure>

<p>　　什么？你问我什么是 <code>Local&lt;Value&gt;</code>？</p>
<p>　　那我稍稍讲一下吧，参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>和<a href="http://izs.me/v8-docs/classv8_1_1Local.html" target="_blank">V8参考文档</a>。</p>
<p>　　如文档所示，<code>Local&lt;T&gt;</code> 实际上继承自 <code>Handle&lt;T&gt;</code>，我记得<a href="/2014/04/02/nodejs-cpp-addons-1/#Handle&lt;Value">上一章</a>已经讲过 <code>Handle&lt;T&gt;</code> 这个东西了。</p>
<p>　　然后下面就是讲 Local 了。</p>
<blockquote>
<p>Handle 有两种类型， Local Handle 和 Persistent Handle ，类型分别是 <code>Local&lt;T&gt; : Handle&lt;T&gt;</code> 和 <code>Persistent&lt;T&gt; : Handle&lt;T&gt;</code> ，前者和 <code>Handle&lt;T&gt;</code> 没有区别生存周期都在 scope 内。而后者的生命周期脱离 scope ，你需要手动调用 <code>Persistent::Dispose</code> 结束其生命周期。也就是说 Local Handle 相当于在 C++`在栈上分配对象而 Persistent Handle 相当于 C++ 在堆上分配对象。</p>
</blockquote>
<h4 id="然后你要有个参数表系列">然后你要有个参数表系列</h4>
<p>　　终端命令行调用 C/C++ 之后怎么取命令行参数？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>　　对了，这里的 <code>argc</code> 就是命令行参数个数，<code>argv[]</code> 就是各个参数了。那么调用 <code>Node.js</code> 的回调函数，<code>v8</code> 也采用了类似的<a href="http://izs.me/v8-docs/classv8_1_1Function.html#ac61877494d2d8bb81fcef96003ec4059" target="_blank">方法</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>V8EXPORT Local&lt;Value&gt; v8::Function::Call(Handle&lt;Object&gt;recv,
    <span class="keyword">int</span> argc,
    Handle&lt;Value&gt; argv[]
);
</pre></td></tr></table></figure>

<blockquote>
<p><del>QAQ 卡在了 <code>Handle&lt;Object&gt; recv</code> 了！！！明天继续写。</del></p>
</blockquote>
<p>　　好吧，新的一天开始了我感觉我充满了力量。(∩^o^)⊃━☆ﾟ.*･｡</p>
<p>　　经过我多方面求证（<a href="http://segmentfault.com/q/1010000000456217" target="_blank">SegmentFault</a>和<a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a>以及一个扣扣群），终于解决了上面这个函数仨参数的意思。</p>
<p>　　后面两个参数就不多说了，一个是参数个数，另一个就是一个参数的数组了。至于第一个参数 <code>Handle&lt;Object&gt; recv</code>，StackOverflow 仁兄的解释是这样的：</p>
<blockquote>
<p>It is the same as apply in JS. In JS, you do</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> context = ...;
cb.apply(context, [ ...args...]);
</pre></td></tr></table></figure>

<p>The object passed as the first argument becomes this within the function scope. More documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank">MDN</a>. If you don’t know JS well, you can read more about JS’s this here: <a href="http://unschooled.org/2012/03/understanding-javascript-this/" target="_blank">http://unschooled.org/2012/03/understanding-javascript-this/</a></p>
<p style="text-align: right;">—— 摘自 <a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a></p>

</blockquote>
<p>　　总之其作用就是指定了被调用函数的 <code>this</code> 指针。这个 <code>Call</code> 的用法就跟 JavaScript 中的 <code>bind()</code>、<code>call()</code>、<code>apply()</code> 类似。</p>
<p>　　所以我们要做的事情就是先把参数表建好，然后传入这个 <code>Call</code> 函数供其执行。</p>
<p>　　第一步，显示转换函数，因为本来是 <code>Object</code> 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
</pre></td></tr></table></figure>

<p>　　第二步，建立参数表（数组）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
</pre></td></tr></table></figure>

<h4 id="最后调用函数系列">最后调用函数系列</h4>
<p>　　调用 <code>cb</code> ，把参数传进去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>cb-&gt;Call(Context::GetCurrent()-&gt;Global(), <span class="number">1</span>, argv);
</pre></td></tr></table></figure>

<p>　　这里第一个参数 <code>Context::GetCurrent()-&gt;Global()</code> 所代表的意思就是获取全局上下文作为函数的 <code>this</code>；第二个参数就是参数表中的个数（毕竟虽然 <code>Node.js</code> 的数组是有长度属性的，但是 <code>C++</code> 里面数组的长度实际上系统是不知道的，还得你自己传进一个数来说明数组长度）；最后一个参数就是刚才我们建立好的参数表了。</p>
<h4 id="终章之结束文件系列">终章之结束文件系列</h4>
<p>　　相信这一步大家已经轻车熟路了吧，就是把函数写好，然后放进导出函数里面，最后申明一下。</p>
<p>　　我就直接放出代码吧，或者直接跑去 <code>Node.js</code> 的<a href="http://nodejs.org/api/addons.html#addons_callbacks" target="_blank">文档</a>看也行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">1</span>;
    Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
    cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);
    
    <span class="keyword">return</span> scope.Close(Undefined());
}

<span class="keyword">void</span> Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module)
{
    module-&gt;Set(String::NewSymbol(<span class="string">"exports"</span>),
        FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　Well done! 最后剩下的步骤就自己去吧。至于 <code>Js</code> 里面这么调用这个函数，我在<a href="#回调函数">之前</a>已经提到过了。</p>
<h2 id="番外">番外</h2>
<p>　　嘛嘛，我感觉我的学习笔记写得越来越奔放了求破～</p>
<p>　　今天就先写到这里吧，写学习笔记的过程中我又涨姿势了，比如说那个 <code>Call</code> 函数的参数意义。</p>
<p>　　如果你们觉得本系列学习笔记对你们还有帮助的话，就来和我一起搞基吧么么哒～Σ&gt;―(〃°ω°〃)♡→</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 1]]></title>
    <link href="http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/"/>
    <id>http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/</id>
    <published>2014-04-01T15:53:22.000Z</published>
    <updated>2014-04-01T17:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>N久之前的一个坑——用 <strong>Node.js</strong> 来重构 NBUT 的 <strong>Online Judge</strong>，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧</p>
<p>　　总之我们现在要做的其实简而言之就是——用C/C++来实现 <strong>Node.js</strong> 的模块。</p>
<h2 id="准备工作">准备工作</h2>
<p>　　工欲善其事，必先<del>耍流氓</del>利其器。</p>
<h3 id="node-gyp">node-gyp</h3>
<p>　　首先你需要一个 <code>node-gyp</code> 模块。</p>
<p>　　在任意角落，执行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install node<span class="attribute">-gyp</span> <span class="attribute">-g</span>
</pre></td></tr></table></figure>


<p>　　在进行一系列的 <code>blahblah</code> 之后，你就安装好了。</p>
<h3 id="Python">Python</h3>
<p>　　然后你需要有个 <code>python</code> 环境。</p>
<p>　　自己去<a href="http://python.org/" target="_blank">官网</a>搞一个来。</p>
<blockquote>
<p><strong>注意：</strong> 根据 <code>node-gyp</code> 的<a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">GitHub</a>显示，请务必保证你的 <code>python</code> 版本介于 <code>2.5.0</code> 和 <code>3.0.0</code> 之间。</p>
</blockquote>
<h3 id="编译环境">编译环境</h3>
<p>　　嘛嘛，我就偷懒点不细写了，还请自己移步到 <a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">node-gyp</a> 去看编译器的需求。并且倒腾好。</p>
<h2 id="入门">入门</h2>
<p>　　我就拿<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官网的入门 Hello World</a>说事儿了。</p>
<h3 id="Hello_World">Hello World</h3>
<p>　　请准备一个 <code>C++</code> 文件，比如就叫 <del>sb.cc</del> hello.cc。</p>
<p>　　然后我们一步步来，先往里面搞出头文件和定义好命名空间：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="preprocessor">#include &lt;v8.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;
</pre></td></tr></table></figure>


<h4 id="主要函数">主要函数</h4>
<p>　　接下去我们写一个函数，其返回值是 <code>Handle&lt;Value&gt;</code>。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(const Arguments&amp; args)
{
    //<span class="keyword">...</span> 嗷嗷待写
}
</pre></td></tr></table></figure>


<p>　　然后我来粗粗解析一下这些东西：</p>
<h5 id="Handle&lt;Value&gt;">Handle&lt;Value&gt;</h5>
<p>　　做人要有节操，我事先申明我是从<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>(<a href="http://cnodejs.org/user/fool" target="_blank">@fool</a>)参考的。</p>
<blockquote>
<p>V8 里使用 Handle 类型来托管 JavaScript 对象，与 C++ 的 std::sharedpointer 类似，Handle 类型间的赋值均是直接传递对象引用，但不同的是，V8 使用自己的 GC 来管理对象生命周期，而不是智能指针常用的引用计数。</p>
<p>JavaScript 类型在 C++ 中均有对应的自定义类型，如 String 、 Integer 、 Object 、 Date 、 Array 等，严格遵守在 JavaScript 中的继承关系。 C++ 中使用这些类型时，必须使用 Handle 托管，以使用 GC 来管理它们的生命周期，而不使用原生栈和堆。</p>
</blockquote>
<p>　　而这个所谓的 <strong>Value</strong> ，从 V8 引擎的头文件 <a href="http://code.google.com/p/v8/source/browse/trunk/include/v8.h#1417" target="_blank">v8.h</a> 中的各种继承关系中可以看出来，其实就是 JavaScript 中各种对象的基类。</p>
<p>　　在了解了这件事之后，我们大致能明白上面那段函数的申明的意思就是说，我们写一个 <code>Hello</code> 函数，其返回的是一个不定类型的值。</p>
<blockquote>
<p><strong>注意：</strong> 我们只能返回特定的类型，即在 Handle 托管下的 String 啊 Integer 啊等等等等。</p>
</blockquote>
<h5 id="Arguments">Arguments</h5>
<p>　　这个就是传入这个函数的参数了。我们都知道在 <code>Node.js</code> 中，参数个数是乱来的。而这些参数传进去到 <code>C++</code> 中的时候，就转变成了这个 <code>Arguments</code> 类型的对象了。</p>
<p>　　具体的用法我们在后面再说，在这里只需要明白这个是个什么东西就好。（为毛要卖关子？因为 <code>Node.js</code> 官方文档中的<a href="https://github.com/rvagg/node-addon-examples" target="_blank">例子</a>就是分开来讲的，我现在只是讲第一个 <code>Hello World</code> 的例子而已( ´థ౪థ）σ</p>
<h4 id="添砖加瓦">添砖加瓦</h4>
<p>　　接下去我们就开始添砖加瓦了。就最简单的两句话：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(<span class="keyword">const</span> Arguments&amp; args)
{
    HandleScope <span class="keyword">scope</span>;
    <span class="keyword">return</span> <span class="keyword">scope</span>.Close(String::New(<span class="string">"world"</span>));
}
</pre></td></tr></table></figure>


<p>　　这两句话是什么意思呢？大致的意思就是返回一个 <code>Node.js</code> 中的字符串 <code>&quot;world&quot;</code>。</p>
<h5 id="HandleScope">HandleScope</h5>
<p>　　同参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>。</p>
<blockquote>
<p>Handle 的生命周期和 C++ 智能指针不同，并不是在 C++ 语义的 scope 内生存（即{} 包围的部分），而需要通过 HandleScope 手动指定。HandleScope 只能分配在栈上，HandleScope 对象声明后，其后建立的 Handle 都由 HandleScope 来管理生命周期，HandleScope 对象析构后，其管理的 Handle 将由 GC 判断是否回收。</p>
</blockquote>
<p>　　所以呢，我们得在需要管理他的生命周期的时候申明这个 <code>Scope</code> 。好的，那么为什么我们的代码不这么写呢？</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Handle</span><span class="subst">&lt;</span>Value<span class="subst">&gt;</span> Hello(const Arguments<span class="subst">&amp;</span> args)
{
    HandleScope scope;
    <span class="keyword">return</span> <span class="built_in">String</span><span class="tag">::New</span>(<span class="string">"world"</span>);
}
</pre></td></tr></table></figure>


<p>　　因为当函数返回时，<code>scope</code> 会被析构，其管理的Handle也都将被回收，所以这个 <code>String</code> 就会变得没有意义。</p>
<p>　　所以呢 V8 就想出了个神奇的点子——<code>HandleScope::Close(Handle&lt;T&gt; Value)</code> 函数！这个函数的用处就是关闭这个 Scope 并且把里面的参数转交给上一个 Scope 管理，也就是进入这个函数前的 Scope。</p>
<p>　　于是就有了我们之前的代码 <code>scope.Close(String::New(&quot;world&quot;));</code>。</p>
<h5 id="String::New">String::New</h5>
<p>　　这个 <code>String</code> 类所对应的就是 <code>Node.js</code> 中原生的字符串类。继承自 <code>Value</code> 类。与此类似，还有：</p>
<ul>
<li>Array</li>
<li>Integer</li>
<li>Boolean</li>
<li>Object</li>
<li>Date</li>
<li>Number</li>
<li>Function</li>
<li>…</li>
</ul>
<p>　　这些东西有些是继承自 <code>Value</code>，有些是二次继承。我们这里就不多做研究，自己可以看看 V8 的代码（至少是头文件）研究研究或者看看这个<a href="http://bespin.cz/~ondras/html/classv8_1_1Value.html#a70d4afaccc7903e6a01f40a46ad04188" target="_blank">手册</a>。</p>
<p>　　而这个 <code>New</code> 呢？<a href="http://bespin.cz/~ondras/html/classv8_1_1String.html" target="_blank">这里</a>可以看的。就是新建一个 <code>String</code> 对象。</p>
<p>　　至此，这个主要函数我们就解析完毕了。</p>
<h4 id="导出对象">导出对象</h4>
<p>　　我们来温习一下，如果是在 <code>Node.js</code> 里面写的话，我们怎么导出函数或者对象什么的呢？</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>exports.hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
</pre></td></tr></table></figure>


<p>　　那么，在 <code>C++</code> 中我们该如何做到这一步呢？</p>
<h5 id="初始化函数">初始化函数</h5>
<p>　　首先，我们写个初始化函数：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>void init(Handle&lt;Object&gt; exports)
{
    //<span class="keyword">...</span> 嗷嗷待写你妹啊！<span class="comment">#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</span>
}
</pre></td></tr></table></figure>


<p>　　这是龟腚！函数名什么的无所谓，但是传入的参数一定是一个 <code>Handle&amp;lt;Object&gt;</code>，代表我们下面将要在这货上导出东西。</p>
<p>　　然后，我们就在这里面写上导出的东西了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="literal">void</span> init(<span class="keyword">Handle</span><span class="subst">&lt;</span>Object<span class="subst">&gt;</span> exports)
{
    exports<span class="subst">-&gt;</span><span class="built_in">Set</span>(<span class="built_in">String</span><span class="tag">::NewSymbol</span>(<span class="string">"hello"</span>),
        FunctionTemplate<span class="tag">::New</span>(Hello)<span class="subst">-&gt;</span>GetFunction());
}
</pre></td></tr></table></figure>


<p>　　大致的意思就是说，为这个 <code>exports</code> 对象添加一个字段叫 <code>hello</code>，所对应的东西是一个<a href="http://bespin.cz/~ondras/html/classv8_1_1FunctionTemplate.html" target="_blank">函数</a>，而这个函数就是我们亲爱的 <code>Hello</code> 函数了。</p>
<p>　　用伪代码写直白点就是：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">void</span> init(Handle&lt;Object&gt; <span class="built_in">exports</span>)
{
    <span class="built_in">exports</span>.Set(<span class="string">"hello"</span>, <span class="reserved">function</span> hello);
}
</pre></td></tr></table></figure>


<p>　　大功告成！</p>
<p>　　（大功告成你妹啊！闭嘴( ‘д‘⊂彡☆))Д´)</p>
<h5 id="真·导出">真·导出</h5>
<p>　　这才是最后一步，我们最后要申明，这个就是导出的入口，所以我们在代码的末尾加上这一行：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">NODE_MODULE(hello, init)</span>
</pre></td></tr></table></figure>


<p>　　纳了个尼？！这又是什么东西？</p>
<p>　　别着急，这个 <code>NODE_MODULE</code> 是一个宏，它的意思呢就是说我们采用 <code>init</code> 这个初始化函数来把要导出的东西导出到 <code>hello</code> 中。那么这个 <code>hello</code> 哪来呢？</p>
<p>　　<strong>它来自文件名！</strong>对，没错，它来自文件名。你并不需要事先申明它，你也不必担心不能用，总之你的这个最终编译好的二进制文件名叫什么，这里的 <code>hello</code> 你就填什么，当然要除去后缀名了。</p>
<p>　　详见<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官方文档</a>。</p>
<blockquote>
<p>Note that all Node addons must export an initialization function:</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> Initialize (Handle&lt;<span class="built_in">Object</span>&gt; exports);
NODE_MODULE(module_name, Initialize)
</pre></td></tr></table></figure>

<p>There is no semi-colon after NODE_MODULE as it’s not a function (see node.h).</p>
<p>The module_name needs to match the filename of the final binary (minus the .node suffix).</p>
</blockquote>
<h3 id="编译_(๑•́_₃_•̀๑)">编译 (๑•́ ₃ •̀๑)</h3>
<p>　　来吧，让我们一起编译吧！</p>
<p>　　我们再新建一个类似于 <code>Makefile</code> 的归档文件吧——<code>binding.gyp</code>。</p>
<p>　　并且在里面添加这样的<a href="https://github.com/TooTallNate/node-gyp#the-bindinggyp-file" target="_blank">代码</a>：</p>
<figure class="highlight"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"hello"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"hello.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>


<p>　　为什么这么写呢？可以参考 <code>node-gyp</code> 的<a href="http://code.google.com/p/gyp/wiki/GypUserDocumentation#Skeleton_of_a_typical_Chromium_.gyp_file" target="_blank">官方文档</a>。</p>
<h4 id="configure">configure</h4>
<p>　　在文件搞好之后，我们要在这个目录下面执行这个命令了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure
</pre></td></tr></table></figure>


<p>　　如果一切正常的话，应该会生成一个 <code>build</code> 的目录，然后里面有相关文件，也许是 <strong>M$ Visual Studio</strong> 的 <code>vcxproj</code> 文件等，也许是 <code>Makefile</code> ，视平台而定。</p>
<h4 id="build">build</h4>
<p>　　<code>Makefile</code> 也生成好之后，我们就开始构造编译了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp build
</pre></td></tr></table></figure>


<p>　　等到一切编译完成，才算是真正的大功告成了！不信你去看看 <code>build/Release</code> 目录，下面是不是有一个 <code>hello.node</code> 文件了？没错，这个就是 C++ 等下要给 Node.js 捡的肥皂！</p>
<h3 id="搞基吧！Node_ヽ(✿ﾟ▽ﾟ)ノ_C++">搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</h3>
<p>　　我们在刚才那个目录下新建一个文件 <code>jianfeizao.js</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> addon = <span class="built_in">require</span>(<span class="string">"./build/Release/hello"</span>);
<span class="built_in">console</span>.log(addon.hello());
</pre></td></tr></table></figure>


<p>　　看到没！看到没！出来了出来了！Node.js 和 C++ 搞基的结果！这个 <code>addon.hello()</code> 就是我们之前在 C++ 代码中写的 <code>Handle&lt;Value&gt; Hello(const Arguments&amp; args)</code> 了，我们现在就已经把它返回的值给输出了。</p>
<h2 id="洗洗睡吧，下节更深入">洗洗睡吧，下节更深入</h2>
<p>　　时间不早了，今天就写到这里了，至此为止大家都能搞出最基础的 <strong>Hello world</strong> 的 C++ 扩展了吧。下一次写的应该会更深入一点，至于下一次是什么时候，我也不知道啦其实。<br>　　（喂喂喂，撸主怎么可以这么不负责！(ｏﾟﾛﾟ)┌┛Σ(ﾉ´<em>ω</em>`)ﾉ</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[～公众档所～项目解析]]></title>
    <link href="http://xcoder.in/2014/03/27/node-public-file-house/"/>
    <id>http://xcoder.in/2014/03/27/node-public-file-house/</id>
    <published>2014-03-26T16:34:04.000Z</published>
    <updated>2014-03-27T08:38:09.000Z</updated>
    <content type="html"><![CDATA[<p>所谓“公众档所”，其实就是一个公共的临时网盘了。这个东西是一个老物了，在我刚接触 <code>Expressjs</code> 的时候写的。当时还随便搞了一下 <code>backbone.js</code>，但是没有深入，勿笑。关于深入构架 <code>Expressjs</code> 方面也没做，只是粗粗写了下最基础的路由，所以整个文件结构也不是很规范。但是应该能比较适合刚学 <code>Node.js</code> 以及刚接触 <code>Expressjs</code> 的人吧。</p>
<p>　　Repo地址在<a href="https://github.com/XadillaX/public-file-house" target="_blank">我的Github</a>上。Demo地址在 <a href="http://dang.kacaka.ca/" target="_blank">http://dang.kacaka.ca/</a>，由于个人电脑的不稳定性，所以不保证你们随时可以访问，保不定哪天就失效了，所以最好的办法还是自己 <code>clone</code> 下来啪啪啪。</p>
<p>　　它所需要的东西大致就是 <code>Expressjs</code> + <code>Redis</code> + <code>Backbone</code> 了。不过都是最最基础的代码。</p>
<h2 id="部署">部署</h2>
<p>　　把部署写在最前面是为了能让你们自己电脑上有一个能跑的环境啦。公众档所在我自己这边的环境里面是由三台电脑组成的。</p>
<ul>
<li>网关“服务器”。这是我这边环境一致对外的机器。实际上是一片树莓派，装了 <code>nginx</code>，然后对内部做反向代理。</li>
<li>本体“服务器”。跑了 <strong>公众档所</strong> 本体。</li>
<li>数据库“服务器”。我们用的数据库实际上不是严格意义上的数据库，只是 <code>redis</code> 罢了，也没做与其它数据库的持久化，只是用了他内部自带的持久化。</li>
</ul>
<p>　　<strong>如果你们装一台机子上，那么就是：</strong></p>
<p>　　将 <code>repo</code> 给 clone 到自己的机子上。</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="constant">XadillaX</span>/public-file-house
</pre></td></tr></table></figure>


<p>　　装好 <strong>redis</strong>，并根据需要修改 <code>redis.conf</code> 文件。</p>
<p>　　执行 <code>redis.sh</code> 文件开启数据库。如果你自己本身已经开启数据库或者用其它方法开启了，请忽略上面数据库相关步骤。</p>
<p>　　然后打开 <code>commonConst.js</code> 文件进行编辑，把相关的一些信息改成自己所需要的。</p>
<p>　　哦对了，还有一个“洁癖相关”的步骤。我以前年轻不懂事，把 <code>node_modules</code> 文件夹也给加到版本库中了，而且也在里面居然自己加了两个没有弄到 <code>nmp</code> 去的模块（<strong>而且这两个模块本来就不应该放在这个文件夹下，但是不要在意这些细节，反正我现在肯定不会做这么傻的事了</strong>）。</p>
<p>　　至于为什么不要这么做，就跟 <code>node_modules</code> 文件夹的意义相关了。而且里面有可能有一些在我本机编译好的模块，所以最好还是清理下自己重新装一遍为佳。</p>
<p>　　具体呢大致就是把 <code>node_modules</code> 文件夹里面的 <code>alphaRandomer.js</code> 文件和 <code>smpEncoder.js</code> 文件拷贝出来备份到任意文件夹，然后删除整个 <code>node_module</code> 文件夹。接下去跑到项目根目录执行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install
</pre></td></tr></table></figure>


<p>　　把三方模块重新装好之后，把刚才拷出去的俩文件放回这个目录下。（<strong>但是以后你们自己写别的项目的话千万别学我这个坏样子啊，以前年轻不懂事 QAQ</strong>）</p>
<p>　　最后跑起来就行啦：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node pfh.js
</pre></td></tr></table></figure>


<h2 id="解析">解析</h2>
<p>接下去就是要剖析这小破东西了。</p>
<h3 id="基础文件">基础文件</h3>
<h4 id="pfh-js">pfh.js</h4>
<p>　　这个文件其实是 <code>Expressjs</code> 自动生成的，以前不是很懂他，所以也没怎么动，基本上是保持原封不动的。</p>
<h4 id="router-js">router.js</h4>
<p>　　这个是路由定义的文件。比较丑陋的一种方法，把需要定义的所有路由都写进两个 <code>json</code> 对象中，一个 <code>POST</code> 和一个 <code>GET</code>。</p>
<p>　　看过 <code>Expressjs</code> 文档的人或者教程的人都知道，最基础的路由注册写法其实就是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>app.<span class="keyword">get</span>(<span class="keyword">KEY</span>, <span class="keyword">FUNCTION</span>);
</pre></td></tr></table></figure>


<p>　　或者：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>app.post(KEY, <span class="function"><span class="keyword">FUNCTION</span>);</span>
</pre></td></tr></table></figure>


<p>　　所以我下面有一个函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>exports.setRouter = <span class="function"><span class="keyword">function</span><span class="params">(app)</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.getRouter) {
        app.<span class="keyword">get</span>(key, <span class="keyword">this</span>.getRouter[key]);
    }

    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.postRouter) {
        app.post(key, <span class="keyword">this</span>.postRouter[key]);
    }
};
</pre></td></tr></table></figure>


<p>　　其大致意思就是把之前我们定义好的两个路由对象里的内容一一给注册到系统的路由当中去。这个是我最初最简陋的思想，不过后来我把它稍稍完善了一下写到<a href="https://github.com/XadillaX/exframess/blob/master/config/router.js#L17" target="_blank">别的地方</a>去了。</p>
<h3 id="模型">模型</h3>
<h4 id="model/fileModel-js">model/fileModel.js</h4>
<p>　　这个就是模型层了，主要就是 <code>redis</code> 的一些操作了。在这里我用的是 <a href="https://github.com/mranney/node_redis" target="_blank"><code>redis</code></a> 这个模块，具体的用法大家可以看它 <code>repo</code> 的 <code>README.md</code> 文件。</p>
<p>　　大致就三个函数：</p>
<ol>
<li><code>fileModel.prototype.keyExists</code>: 判断某个提取码存在与否。</li>
<li><code>fileModel.prototype.get</code>: 获取某个验证码的文件信息。</li>
<li><code>fileModel.prototype.addFile</code>: 添加一个文件信息。</li>
</ol>
<blockquote>
<p>不过有个坏样子大家不要学，<code>Node.js</code> 大家都约定俗成的回调函数参数一般都是 <code>callback(err, data, blahblah...)</code> 的，第一个参数都是错误，如果没错误都是 <code>null</code> 或者是 <code>undefined</code> 的。但是以前也没这种意识，所以回调函数的参数也都是比较乱的。</p>
</blockquote>
<h3 id="控制器">控制器</h3>
<h4 id="action/index-js">action/index.js</h4>
<p>　　这是一些基础控制器。</p>
<h5 id="exports-index">exports.index</h5>
<p>　　纯粹的首页显示。</p>
<h5 id="exports-download">exports.download</h5>
<p>　　文件下载控制器。由代码可知，首先获取 <code>token</code> 和 <code>code</code>。 <code>token</code> 是验证 <strong>URL</strong> 的有效性而 <code>code</code> 即提取码了。</p>
<p>　　期间我们验证了下 <code>token</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>if(!functions<span class="preprocessor">.verifyBlahblah</span>(token)) {
    resp<span class="preprocessor">.redirect</span>(baseConfig<span class="preprocessor">.webroot</span>)<span class="comment">;</span>
}
</pre></td></tr></table></figure>


<p>　　而这个 <code>verifyBlahblah</code> 函数就在<a href="https://github.com/XadillaX/public-file-house/blob/master/plugin/functions.js#L21" target="_blank">这个文件</a>里面。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>exports.verifyBlahblah = <span class="function"><span class="keyword">function</span><span class="params">(blahblah)</span> {</span>
    <span class="keyword">var</span> <span class="keyword">array</span> = blahblah.split(<span class="string">"^"</span>);
    <span class="keyword">var</span> time = <span class="keyword">array</span>[<span class="keyword">array</span>.length - <span class="number">1</span>];
    <span class="keyword">array</span>.pop();

    <span class="keyword">var</span> encoder = <span class="keyword">require</span>(<span class="string">"smpEncoder"</span>);

    <span class="keyword">try</span> {
        <span class="keyword">var</span> text = encoder.norBack(<span class="keyword">array</span>, time.toString());
        text = encoder.decode(text);
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">var</span> now = text.substr(<span class="number">0</span>, <span class="number">10</span>);
    <span class="keyword">var</span> token = text.substr(<span class="number">10</span>);

    <span class="keyword">if</span>(parseInt(Date.now() / <span class="number">1000</span>) - parseInt(now) &gt; <span class="number">300</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">if</span>(token !== <span class="keyword">require</span>(<span class="string">"../commonConst"</span>).token) <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">return</span> <span class="keyword">true</span>;
};
</pre></td></tr></table></figure>


<p>　　大体意思就是把其打散到数组里面，其中时间戳是最后一位。然后解密。最后验证解密后的 <code>token</code> 是否等于系统的 <code>token</code> 以及时间戳有没有过期。</p>
<p>　　大家通过截取 <code>Chrome</code> 或者 <code>Firefox</code> 的请求信息，不难发现有这么个地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="xml">Request URL:http://localhost/download?file=</span><span class="number">662</span><span class="xml">ZE&amp;token=</span><span class="number">65</span><span class="xml"></span><span class="keyword">^97</span><span class="xml"></span><span class="keyword">^74</span><span class="xml"></span><span class="keyword">^68</span><span class="xml"></span><span class="keyword">^106</span><span class="xml"></span><span class="keyword">^125</span><span class="xml"></span><span class="keyword">^88</span><span class="xml"></span><span class="keyword">^115</span><span class="xml"></span><span class="keyword">^65</span><span class="xml"></span><span class="keyword">^96</span><span class="xml"></span><span class="keyword">^66</span><span class="xml"></span><span class="keyword">^105</span><span class="xml"></span><span class="keyword">^127</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^87</span><span class="xml"></span><span class="keyword">^123</span><span class="xml"></span><span class="keyword">^123</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^84</span><span class="xml"></span><span class="keyword">^124</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^125</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^121</span><span class="xml"></span><span class="keyword">^99</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^100</span><span class="xml"></span><span class="keyword">^118</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^98</span><span class="xml"></span><span class="keyword">^124</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^109</span><span class="xml"></span><span class="keyword">^98</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^100</span><span class="xml"></span><span class="keyword">^80</span><span class="xml"></span><span class="keyword">^119</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^87</span><span class="xml"></span><span class="keyword">^119</span><span class="xml"></span><span class="keyword">^105</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^8</span><span class="xml"></span><span class="keyword">^1395904110</span><span class="xml">
Request Method:GET
Status Code:</span><span class="number">200</span><span class="xml"> OK</span>
</pre></td></tr></table></figure>


<p>　　而这一坨 <code>65^97^74^68^106^125^88^115^65^96^66^105^127^114^87^123^123^114^84...^1395904110</code> 便是所谓的 <code>token</code> 了。而且本来就是个demo，这个 <code>token</code> 也就是随便做做样子罢了。</p>
<p>　　接下去通过验证之后，便可以从数据库中读取文件信息了。如果有文件，那么通过 <code>resp.download</code> 函数呈现给用户。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> fileModel = <span class="keyword">new</span> FileModel();
fileModel.get(code, <span class="function"><span class="keyword">function</span><span class="params">(status, error, obj)</span> {</span>
    <span class="keyword">if</span>(error) resp.redirect(baseConfig.webroot);
    <span class="keyword">else</span> {
        <span class="keyword">if</span>(obj === <span class="literal">null</span>) {
            resp.redirect(baseConfig.webroot + <span class="string">"/get/"</span> + code + <span class="string">"/not-exist"</span>);
        } <span class="keyword">else</span> {
            resp.download(baseConfig.uploadDir + code, <span class="built_in">require</span>(<span class="string">"urlencode"</span>)(obj.filename));
        }
    }
});
</pre></td></tr></table></figure>


<h5 id="exports-getToken">exports.getToken</h5>
<p>　　这个函数就是生产一个有效的 <code>token</code> 用的。在前端是通过 <strong>ajax</strong> 来获取的。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> encoder = <span class="built_in">require</span>(<span class="string">"smpEncoder"</span>);
<span class="keyword">var</span> token = baseConfig.token;
<span class="keyword">var</span> now = <span class="built_in">parseInt</span>(<span class="built_in">Date</span>.now() / <span class="number">1000</span>);
<span class="keyword">var</span> result = encoder.encode(now + token);
result = encoder.norGo(result, now.toString());
<span class="keyword">var</span> resultString = <span class="string">""</span>;
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++) resultString += (result[i] + <span class="string">"^"</span>);
</pre></td></tr></table></figure>


<p>　　大体呢就是根据目前的时间戳和系统 <code>token</code> 一起加密生产一个有效的 <code>token</code>。</p>
<h5 id="exports-send2fetion">exports.send2fetion</h5>
<p>　　通过自己的飞信给自己发送提取码以备忘。</p>
<p>　　这里的话用了一个 <code>fetion-sender</code> 的模块。<code>Repo</code> 在<a href="https://github.com/XadillaX/fetion-sender" target="_blank">这里</a>。</p>
<h4 id="action/upload-js">action/upload.js</h4>
<p>　　这个文件里面其实就一个 <code>exports.upload</code> 函数，另一个是生成提取码用的。</p>
<h5 id="function_genAlphaKey(time,_callback)">function genAlphaKey(time, callback)</h5>
<p>　　生成提取码。我们假设最多尝试10次，若尝试10次还没有生成唯一的验证码就输出错误让用户重试。所以就有了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">genAlphaKey</span><span class="params">(time, callback)</span> {</span>
    <span class="keyword">var</span> keyLength = config.uploadLen;
    <span class="keyword">var</span> filename = alphaRandomer.rand(keyLength);
    <span class="keyword">var</span> fileModel = <span class="keyword">new</span> FileModel();

    fileModel.keyExists(filename, <span class="function"><span class="keyword">function</span><span class="params">(status, result)</span> {</span>
        <span class="keyword">if</span>(!status) {
            <span class="keyword">if</span>(time &lt; maxTryTime) {
                genAlphaKey(time + <span class="number">1</span>, callback);
            }
            <span class="keyword">else</span> {
                callback(<span class="literal">false</span>, result, <span class="string">""</span>);
            }

            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(result) genAlphaKey(time, callback);
            <span class="keyword">else</span> {
                callback(<span class="literal">true</span>, <span class="string">""</span>, filename);
            }
        }
    });
}
</pre></td></tr></table></figure>


<p>　　不断地生成定长的提取码，然后通过模型的 <code>keyExists</code> 函数来确定这个提取码是否存在，如果存在了就递归调用重新生成，否则就直接回调。</p>
<h5 id="exports-upload">exports.upload</h5>
<p>　　上传文件的页面了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>if(req<span class="preprocessor">.files</span><span class="preprocessor">.files</span><span class="preprocessor">.length</span> !== <span class="number">1</span>) {
    result<span class="preprocessor">.status</span> = false<span class="comment">;</span>
    result<span class="preprocessor">.msg</span> = <span class="string">"请用正确的姿势喂我文件。"</span><span class="comment">;</span>
    resp<span class="preprocessor">.send</span>(<span class="number">200</span>, result)<span class="comment">;</span>
    return<span class="comment">;</span>
}

var fileInfo = req<span class="preprocessor">.files</span><span class="preprocessor">.files</span>[<span class="number">0</span>]<span class="comment">;</span>
if(fileInfo<span class="preprocessor">.size</span> &gt; config<span class="preprocessor">.maxUploadSize</span>) {
    result<span class="preprocessor">.status</span> = false<span class="comment">;</span>
    result<span class="preprocessor">.msg</span> = <span class="string">"文件太大啦，公众档所一次只能吃10M的文件哦。"</span><span class="comment">;</span>
    resp<span class="preprocessor">.send</span>(<span class="number">200</span>, result)<span class="comment">;</span>
    return<span class="comment">;</span>
}
</pre></td></tr></table></figure>


<p>　　前面一堆话大致就是做下有效性判断而已。然后调用函数来生成有效的提取码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>genAlphaKey(<span class="number">1</span>, <span class="keyword">function</span>(status, msg, filename) {
    <span class="keyword">...</span>
});
</pre></td></tr></table></figure>


<p>　　如果生成成功的话就往数据库中添加文件信息：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>var fileModel = new FileModel();
fileModel.addFile(filename,
    fileInfo.name,
    fileInfo.headers[<span class="string">"content-type"</span>],
    <span class="keyword">function</span>(status, msg) {
        <span class="keyword">...</span>
    }
);
</pre></td></tr></table></figure>


<p>　　如果添加也成功了的话，那么把刚上传到临时文件夹的文件给移动到上传文件储存目录中，以便以后可以被下载：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fs.rename(fileInfo.path, uploadDir + filename, <span class="keyword">function</span>(err) {
    <span class="keyword">...</span>
});
</pre></td></tr></table></figure>


<p>　　如果移动也成功了的话，那么返回一个成功的json信息：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">result</span>.status = <span class="keyword">true</span>;
<span class="keyword">result</span>.code = filename;
resp.send(<span class="number">200</span>, <span class="keyword">result</span>);
</pre></td></tr></table></figure>


<h3 id="视图">视图</h3>
<p>　　这里视图就一个 <code>index.ejs</code> 。然后通过 <code>backbone.js</code> 来调用不同的页内模板和逻辑来实现的类似于 <strong>SPA <del>(Solus Par Agula)</del> (Single Page Application)</strong> 的效果。</p>
<h4 id="views/index/index-ejs">views/index/index.ejs</h4>
<p>　　像类似于下面的这种就是 <code>backbone.js</code> 的模板概念了：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;script type=<span class="string">"text/template"</span> id=<span class="string">"faq-template"</span>&gt;
<span class="keyword">...</span>
&lt;/script&gt;
</pre></td></tr></table></figure>


<p>　　到时候就可以通过 <code>backbone.js</code> 中的函数来填充到页面实体当中去。</p>
<h4 id="public/js/index-js">public/js/index.js</h4>
<p>　　在拥有了所有的前端js依赖之后，这个文件就是这个 <code>SPA</code> 的入口了。</p>
<p>　　逻辑很简单：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> workspace = <span class="literal">null</span>;
$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    workspace = <span class="keyword">new</span> Workspace();
    Backbone.history.start({ pushState: <span class="literal">true</span>, hashChange: <span class="literal">false</span> });
});
</pre></td></tr></table></figure>


<p>　　新建一个 <code>Workscpace</code>，然后对 <code>backbone</code> 进行一点配置。</p>
<blockquote>
<p>To indicate that you’d like to use HTML5 pushState support in your application, use Backbone.history.start({pushState: true}). If you’d like to use pushState, but have browsers that don’t support it natively use full page refreshes instead, you can add {hashChange: false} to the options.</p>
<p style="text-align: right">——摘自 <a href="http://backbonejs.org/#History-start" target="_blank">backbonejs.org</a></p>

</blockquote>
<p>　　然后这个 <code>Workspace</code> 即这个 <code>SPA</code> 的本体了。</p>
<h4 id="public/backbone/router/workspace-js">public/backbone/router/workspace.js</h4>
<p>　　这里定义了几个路由，即什么路由要用哪个类去处理。这样才能在 <code>URL</code> 当中各种跳转。其实无非就是把待渲染元素渲染成页内模板，然后把页面的各种事件响应逻辑改掉即可。对于 <code>Backbone</code> 我其实只用过两次，现在也忘不大多了，怕误人子弟，所以一些具体的函数啊用法啊还是去参考下官网比较好来着。</p>
<h4 id="public/backbone/view/*-js">public/backbone/view/*.js</h4>
<p>　　就是各路由所对应的视图了。</p>
<h5 id="uploadView-js">uploadView.js</h5>
<p>　　比如说 <code>uploadView.js</code> 文件当中，执行渲染函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    render      : <span class="keyword">function</span>() {
        $(this.el).html(Mustache.to_html(
            this.template
        ));

        $(<span class="string">"#uploadfile"</span>).fileupload({
            url         : <span class="string">"../../upload.pfh"</span>,
            dataType    : <span class="string">"json"</span>,
            done        : this.uploaded,
            progressall : this.processUpload,
            start       : this.startUpload
        });

        $(<span class="string">".template"</span>).show(<span class="string">"normal"</span>);

        <span class="keyword">return</span> this;
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　就是用页内模板来渲染：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$(this<span class="preprocessor">.el</span>)<span class="preprocessor">.html</span>(Mustache<span class="preprocessor">.to</span>_html(
    this<span class="preprocessor">.template</span>
))<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>　　而这个 <code>this.el</code> 是在 <code>Workspace</code> 中定义的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    upload      : <span class="keyword">function</span>() {
        var uploadView = new UploadView({ el: <span class="string">"#main-template-container"</span> });
        uploadView.render();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　如你所见，就是这个 <code>#main-template-container</code> 了。</p>
<p>　　这个渲染完毕之后，然后把 <code>#uploadfile</code> 给变成上传按钮（用了 <strong>jquery.fileupload.js</strong>）。再然后把渲染好的页面给 <code>show</code> 出来。</p>
<p>　　然后这个　<code>uploadView.js</code> 中还定义了两个<a href="http://backbonejs.org/#View-delegateEvents" target="_blank">响应事件</a>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    events      : {
        <span class="string">"click .upbutton"</span>   : <span class="string">"upload"</span>,
        <span class="string">"click #uploadpage-to-download"</span> : <span class="string">"goDownload"</span>
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　即在按下 <code>.upbutton</code> 的时候会执行 <code>upload</code> 函数，在按下“去下载”的按钮时会执行 <code>goDownload</code> 函数。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    upload      : <span class="keyword">function</span>() {
        $(<span class="string">"#uploadfile"</span>).click();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　执行上传函数的时候，实际上是自动触动了 <code>#uploadfile</code> 按钮的 <code>click</code> 事件。这个时候就会按照之前定义好的 <code>$(&quot;#uploadfile&quot;).fileupload(...)</code> 去处理了。</p>
<h5 id="getView-js">getView.js</h5>
<p>　　这个是获取文件的视图。</p>
<p>　　渲染时会获取 <code>code</code> 。这个 <code>code</code> 同样是 <code>Workspace</code> 传入的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    get         : <span class="keyword">function</span>(code, err) {
        var getView = new GetView({ el: <span class="string">"#main-template-container"</span> });
        getView.setCode(code);
        <span class="keyword">if</span>(err !== undefined) getView.setError(err);
        getView.render();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　上面关于 <code>get</code> 的路由是 <code>get/:code</code> 之类的，所以这个 <code>code</code> 会作为一个路由参数传给 <code>get</code> 函数。</p>
<p>　　有了这个 <code>code</code> 之后就可以把页面渲染出来了。这就是为什么我们地址输入 <code>http://localhost/get/XXXXX</code> 的时候输入框里面就有提取码了。把这个渲染出来之后，我们对“二维码”的两张图片做下响应：鼠标移动上去会显示出来。再然后我们要获取二维码了（<code>this.genQRCode()</code>）：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>    ...,
    
    genQRCode   : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> code = <span class="keyword">this</span>.code;

        <span class="keyword">var</span> dpage = <span class="string">"http://dang.kacaka.ca/get/"</span> + code;
        dpage = UrlEncode(dpage);
        <span class="keyword">var</span> img = <span class="string">'&lt;img style="width: 150; height: 150;" src="https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl='</span> + dpage + <span class="string">'" /&gt;'</span>;

        $(<span class="string">"#download-page-qr"</span>).attr(<span class="string">"data-content"</span>, img);

        <span class="keyword">var</span> opage = <span class="string">"http://dang.kacaka.ca/download?"</span>;
        <span class="keyword">this</span>.getToken(<span class="function"><span class="keyword">function</span><span class="params">(token)</span> {</span>
            <span class="keyword">if</span>(<span class="literal">undefined</span> === token) {
                $(<span class="string">"#download-origin-qr"</span>).attr(<span class="string">"data-content"</span>, <span class="string">'&lt;div style="text-align: center;"&gt;二维码生成失败。&lt;/div&gt;'</span>);
                <span class="keyword">return</span>;
            }

            opage += <span class="string">"token="</span> + token;
            opage += <span class="string">"&amp;file="</span> + code;
            opage = UrlEncode(opage);
            <span class="keyword">var</span> img = <span class="string">'&lt;div style="text-align: center;"&gt;&lt;img style="width: 150; height: 150;" src="https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl='</span> + opage + <span class="string">'" /&gt;&lt;br /&gt;&lt;small&gt;该二维码有效期五分钟。&lt;/small&gt;&lt;/div&gt;'</span>;
            $(<span class="string">"#download-origin-qr"</span>).attr(<span class="string">"data-content"</span>, img);
        });

        <span class="keyword">if</span>(<span class="string">""</span> === <span class="keyword">this</span>.code) {
            $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
        } <span class="keyword">else</span> $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"inline-block"</span>);
    }
</pre></td></tr></table></figure>


<p>　　无非就是调用谷歌的 API 然后生成图片地址放上去罢了。一个地址就是当前页面地址，另一个就是加上 <code>token</code> 之后的直接下载地址。</p>
<p>　　如你所见，获取token是通过ajax往服务器请求的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    getToken    : <span class="keyword">function</span>(callback) {
        $.get(<span class="string">"../../blahblah"</span>, {}, <span class="keyword">function</span>(e) {
            callback(e.token);
        });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　然后事件的话：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    events      : {
        <span class="string">"click #downloadpage-to-upload"</span> : <span class="string">"toUpload"</span>,
        <span class="string">"click #download-btn"</span>   : <span class="string">"toDownload"</span>,
        <span class="string">"keydown #download-code"</span>: <span class="string">"toDownloadKeydown"</span>,

        <span class="string">"keyup #download-code"</span>  : <span class="string">"navCode"</span>
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　按了“去上传”按钮会跑去上传。如果按下“下载”按钮就下载文件了。然后输入框里面弹起键盘的话，会导致输入框文字变化，这个时候就要更新二维码以及URL了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    navCode     : <span class="keyword">function</span>() {
        var code = $(<span class="string">"#download-code"</span>).val();
        workspace.navigate(<span class="string">"get/"</span> + code);
        this.code = code;

        <span class="keyword">if</span>(code === <span class="string">""</span>) {
            $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
        } <span class="keyword">else</span> {
            this.genQRCode();
        }
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　每当输入框变化之后，地址栏就要变成新的 <code>get/:code</code> (<code>workspace.navigate(&quot;get/&quot; + code)</code>) 了，然后重新获取一遍二维码。</p>
<p>　　下载按钮的逻辑代码如下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    toDownload  : <span class="keyword">function</span>() {
        var code = $(<span class="string">"#download-code"</span>).val();
        workspace.navigate(<span class="string">"get/"</span> + code);
        this.getToken(<span class="keyword">function</span>(token) {
            <span class="keyword">if</span>(token === undefined) {
                alert(<span class="string">"获取验证信息失败，请稍后重试。"</span>);
            } <span class="keyword">else</span> {
                var url = <span class="string">"../../download?file="</span> + code + <span class="string">"&amp;token="</span> + token;
                window.location.href = url;
            }
        });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　反正就是根据 <code>code</code> 来生成地址，然后从获取token的地址中把token拿出来拼接成下载地址之后再访问（<code>window.location.href = url</code>）就好了。</p>
<h5 id="uploadedView-js">uploadedView.js</h5>
<p>　　这个视图是上传成功视图。功能很简单，就是现实下提取码，然后飞信能发送一下，以及能复制验证码罢了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>    ...,
    
    render      : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(<span class="literal">undefined</span> === <span class="keyword">this</span>.code) {
            workspace.navigate(<span class="string">"upload"</span>, { trigger: <span class="literal">true</span>, replace: <span class="literal">true</span> });
            <span class="keyword">return</span>;
        }

        $(<span class="keyword">this</span>.el).html(Mustache.to_html(
            <span class="keyword">this</span>.template,
            { code: <span class="keyword">this</span>.code }
        ));

        <span class="keyword">var</span> phoneinfo = store.get(<span class="string">"fetion-info"</span>);
        <span class="keyword">if</span>(<span class="literal">undefined</span> !== phoneinfo) {
            $(<span class="string">"#phonenumber"</span>).val(phoneinfo.phonenumber);
            $(<span class="string">"#password"</span>).val(phoneinfo.password);
        }

        $(<span class="string">".template"</span>).show(<span class="string">"normal"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            $(<span class="string">'#copy-code-btn-parent'</span>).zclip({
                path:<span class="string">'../../ZeroClipboard.swf'</span>,
                copy:<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                    <span class="keyword">return</span> $(<span class="string">"#code-input"</span>).val();
                },
                afterCopy: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                    alert(<span class="string">"提取码已经成功复制到剪切板了。"</span>);
                }
            });
        });

        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    
    ...
</pre></td></tr></table></figure>


<p>　　通过判断有没有 <code>code</code> 来判断是否上传成功。这个 <code>code</code> 的来源是 <code>uploadView.js</code> 中的 <code>uploaded (done: this.uploaded)</code> 函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    uploaded    : <span class="keyword">function</span>(e, data) {
        var result = data.result;
        <span class="keyword">if</span>(!result.status) {
            $(<span class="string">"#progress"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).html(<span class="string">"已上传 0%"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).attr(<span class="string">"aria-valuenow"</span>, <span class="string">"0"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).css(<span class="string">"width"</span>, <span class="string">"0%"</span>);

            $(<span class="string">"#upload-div #feed-doc"</span>).removeClass(<span class="string">"alert-info"</span>);
            $(<span class="string">"#upload-div #feed-doc"</span>).addClass(<span class="string">"alert-danger"</span>);
            $(<span class="string">"#upload-div #feed-doc"</span>).html(result.msg);
            $(<span class="string">"#upload-div #feed-doc"</span>).css(<span class="string">"display"</span>, <span class="string">"block"</span>);
            <span class="keyword">return</span>;
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {
            store.set(<span class="string">"code"</span>, result.code);
            workspace.navigate(<span class="string">"uploaded"</span>, { trigger: true, replace: true });

            <span class="keyword">return</span>;
        }
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　<code>e</code> 和 <code>data</code> 这两个参数哪来？首先这个 <code>uploaded</code> 函数是在之前渲染的时候定义成 <code>jquery.fileupload</code> 的上传结束回调函数的，所以这两个参数自然是 <code>jquery.fileupload</code> 传过来的。详见<a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Options#done" target="_blank">这里</a>。</p>
<p>　　总之就是上次成功之后，这个upload函数会获取一个 <code>code</code>，然后它就会拿这个 <code>code</code> 存到 <code>store</code> 中。这个 <code>store.js</code> 是一个 <code>localStorage</code> 的封装。它的代码和文档在<a href="https://github.com/cloudhead/store.js" target="_blank">这里</a>。</p>
<p>　　存好之后让 <code>Workspace</code> 给导航到 <code>uploaded</code> 视图中。</p>
<p>　　而这个 <code>uploaded</code> 视图的初始化函数里面有这样的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    initialize  : <span class="keyword">function</span>() {
        this.code = store.get(<span class="string">"code"</span>);
        var self = this;

        $(<span class="string">"#sending"</span>).click(self.sending);
        $(<span class="string">"#cancel-sending"</span>).click(self.cancelSending);
        $(<span class="string">"#phonenumber, #password"</span>).keydown(<span class="keyword">function</span>(e) { <span class="keyword">if</span>(e.keyCode === <span class="number">13</span>) self.sending(); });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　就是初始化的时候，从 <code>localStorage</code> 中把 <code>code</code> 给取出来。</p>
<h2 id="结束">结束</h2>
<p>　　代码量少，用到的东西也是基础；不过以前的代码由于不了解 <code>Node.js</code> 啊 <code>Expressjs</code> 啊等等的，所以导致代码杂乱无章、脏乱无比，所以一定程度上阻碍了可读性的存在。</p>
<p>　　希望本文能给各位看官稍稍理清思路。我也不必写得面面俱到，只是在某个程度上点题一下而已。更多的大家自己看代码即可了。不过希望还不要把大家给误导了就好，毕竟这代码我自己现在看觉得好丢脸啊 QAQ。大家就去其糟粕取其精华吧。（喂喂喂，我去年买了个表，哪有什么精华啊！</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="Project Parse" scheme="http://xcoder.in/tags/Project%20Parse/"/>
    
      <category term="Document" scheme="http://xcoder.in/categories/Document/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浙江大学XPlan项目新闻爬虫手机屏幕适配文档]]></title>
    <link href="http://xcoder.in/2013/12/28/xplan-spider-doc/"/>
    <id>http://xcoder.in/2013/12/28/xplan-spider-doc/</id>
    <published>2013-12-28T00:00:00.000Z</published>
    <updated>2014-03-26T16:51:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><strong>XPlan</strong> 是一个“基于校园强关系的社交应用”的开发代号。其中有一个功能是从学校网站上通过网络爬虫（Web Crawler）形式将学校新闻抓取到XPlan自身的数据库当中。</p>
<p>而这里出现的一个问题就是学校网站上面的文章是通过类似于 <a href="http://kindeditor.net/" target="_blank"><code>KindEditor</code></a>、<a href="http://ueditor.baidu.com/website/" target="_blank"><code>UEditor</code></a>这类<strong>在线富文本编辑器</strong>生成的代码。</p>
<p>这类代码有几个共性：</p>
<ol>
<li>代码有大量冗余、多重无用嵌套。</li>
<li>非常低的代码可读性。</li>
<li>在PC浏览器中表现力不错，往往能以低效的代码实现预期排版。</li>
</ol>
<p>所以这些富文本编辑器可以在PC各大内核浏览器中表现良好，但是不便人工修改代码。</p>
<p>而 <strong>XPlan</strong> 确是一个由智能手机主导的应用，新闻将会通过一个 <strong>WebView</strong> 体现出来。所以就需要一定的方法将这些脏乱的代码适配成手机屏幕下表现力良好的代码。</p>
<h2 id="预处理">预处理</h2>
<p>在这里，我们将新闻的代码锁定在新闻内容排版，而排除了其它类似于新闻标题、新闻作者等其它信息。</p>
<p>以我们浙江大学软件学院为例，我们爬取的新闻内容代码将如下：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;div class=<span class="string">"vid_wz"</span>&gt;
    <span class="keyword">...</span>
&lt;/div&gt;
</pre></td></tr></table></figure>


<p>所有内容将被包括在这个类型为 <code>vid_wz</code> 的 <code>div</code> 当中。</p>
<p>这时，我们将其包括在一个自己实现定义好的模板当中。该模板与新闻内容将会形成一个完整的网页，包括完整的 <code>html</code>、<code>head</code>、<code>body</code> 等标签。</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>新闻内页<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">article</span> <span class="attribute">id</span>=<span class="value">"_xplan-wrapper"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"vid_wz"</span>&gt;</span>
            ...
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">article</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>这里需要注意的一点的就是其中的一个 <code>meta</code> 标签：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
</pre></td></tr></table></figure>


<p>它的意思是定义 <code>viewport</code> 的一些属性，实现了初步的手机网页适配。</p>
<h3 id="Viewport">Viewport</h3>
<p>手机浏览器是把页面放在一个虚拟窗口（即 <code>viewport</code>）中，用户可以通过平移和缩放来看网页的不同部分。</p>
<p>通过 <code>viewport</code> 我们能对页面的一些缩放进行手机适配。</p>
<p>我们所需要做的仅是在 <code>head</code> 中插入一个 <code>meta</code> 标签，命名为 <code>viewport</code>，然后定义好其 <code>content</code>。</p>
<p><code>content</code> 的语法如下：</p>
<h4 id="width">width</h4>
<p>控制 <code>viewport</code> 的宽度，可以指定一个值或者特殊的值，如 <code>device-width</code> 为设备宽度。</p>
<h4 id="height">height</h4>
<p>与 <code>width</code> 相对应，指定高度</p>
<h4 id="initial-scale">initial-scale</h4>
<p>初始缩放，即页面初始缩放程度。这是一个浮点值，是页面大小的一个乘数。例如，如果你设置初始缩放为 <code>1.0</code>，那么页面在展现的时候就会以分辨率的1:1来展现。如果你设置为<code>2.0</code>，那么这个页面就会放大为2倍。</p>
<h4 id="maximum-scale">maximum-scale</h4>
<p>最大放大倍数。</p>
<h4 id="user-scaleble">user-scaleble</h4>
<p>用户调整缩放，即用户是否能改变页面缩放程度。如果为 <code>yes</code> 即为可以， <code>no</code> 为不可以。</p>
<h2 id="Cheerio模块*">Cheerio模块*</h2>
<p>由于 <strong>XPlan</strong> 的后端是基于 <code>node.js</code> 构架的，所以 <strong>cheerio</strong> 模块是一个 <code>node.js</code> 专有的模块。</p>
<p>它的作用是将一段HTML代码转换为一棵DOM元素树。</p>
<p>在其官网上是这么诠释的：为服务端定制的快速、灵活、轻量级实现的 jQuery 内核。通常熟悉 jQuery 使用的开发者应该会对其使用方法比较熟悉。</p>
<p>所以在我们做接下去适配修改的之前，我们需要将我们刚才生成的完整HTML代码 转换为一棵我们可以操作的DOM元素树。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var cheerio = <span class="keyword">require</span>(<span class="string">"cheerio"</span>);
$ = cheerio.load(<span class="keyword">...</span>);
</pre></td></tr></table></figure>


<p>这时我们便能以熟悉的jQuery模式对其进行操作了，如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"p"</span>).html(<span class="string">"hello foo!"</span>);
</pre></td></tr></table></figure>


<h2 id="Bootstrap">Bootstrap</h2>
<p>Bootstrap是Twitter推出的一个开源的用于前端开发的工具包。它有一个非常好的响应式的页面风格，使其在个尺寸屏幕上表现良好。</p>
<p>为了能更好适应屏幕，我们决定采用其自带的栅格系统，于是刚才的页面模板就有了新的变化：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>新闻内页<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">article</span> <span class="attribute">class</span>=<span class="value">"container"</span> <span class="attribute">id</span>=<span class="value">"_xplan-wrapper"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-md-12"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"vid_wz"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">article</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>首先最外框的 <code>container</code>，用其包裹的元素将实现居中对齐。在不同的媒体查询阈值范围内都为 <code>container</code> 设置了 <code>width</code>，用以匹配栅格系统。</p>
<p><code>row</code> 是一行栅格系统的外包元素。一行可以有12个栅格。</p>
<p>以 <code>.col-md-</code> 开头的栅格的最大 <code>container</code> 宽度为970，最大列宽为78，并能自适应屏幕。</p>
<h2 id="细节处理">细节处理</h2>
<p>在完成了以上操作以后，我们将对各元素进行微调处理。</p>
<p>好在在手机浏览器或者 <code>WebView</code> 中，对各种字体的设置不是非常敏感，所以我们仍然可以不处理一些关于字体变更的设置，以减轻开发量。</p>
<p>这里距几个微调的例子。</p>
<h3 id="&lt;img_/&gt;">&lt;img /&gt;</h3>
<p>在新闻当中，图片充当的基本上是新闻照片的角色，在手机当中以单行出现为佳。</p>
<p>而 Bootstrap 当中本身就有元素类型来让图片元素响应屏幕宽度，并可以加上圆角边框。</p>
<p>所以我们需要做的就是为所有图片加上响应的类型：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"img"</span>).addClass(<span class="string">"img-thumbnail"</span>);
<span class="variable">$(</span><span class="string">"img"</span>).addClass(<span class="string">"img-responsive"</span>);
<span class="variable">$(</span><span class="string">"img"</span>).removeAttr(<span class="string">"style"</span>);
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意：</strong> 最后的一个移除 <code>img</code> 元素自带的 <code>style</code> 属性是因为在文章发布的时候，有可能会被富文本编辑器自动加上一些宽高、边框等信息。为了统一所有图片风格以及让响应式生效，需要将其 <code>style</code> 属性全部移除。</p>
</blockquote>
<p>下面是是适配前与适配后的对比：</p>
<p><img src="./xplan-news-2.jpg" alt="适配前"><br><img src="./xplan-news-1.jpg" alt="适配后"></p>
<h3 id="&lt;table&gt;&lt;/table&gt;">&lt;table&gt;&lt;/table&gt;</h3>
<p>对于 <code>table</code> 元素也需要对它进行自适配，不然很有可能会溢出屏幕，使其多出了一个横向的滚动条。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"table"</span>).removeAttr(<span class="string">"style"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).removeAttr(<span class="string">"border"</span>);

<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table-bordered"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table-striped"</span>);
</pre></td></tr></table></figure>


<p>上面两句是移除 <code>table</code> 的原有的一些风格信息以及属性。后面是为其加上 Bootstrap 特有的 <code>table</code> 类型。</p>
<p>当然，更多的 <code>table</code> 元素还需要其它更多操作。不过就目前为止，<strong>XPlan</strong> 还没有着手关于 <code>table</code> 的更深一层容错处理。不过这里可以提供一个思路。</p>
<p>比如说 <a href="http://www.cst.zju.edu.cn/index.php?c=Index&amp;a=detail&amp;catid=72&amp;id=1885" target="_blank">这篇文章中</a>，不知道是谁给的在线富文本编辑器勇气，使其下面几张图片都各自被一个 <code>table</code> 及其子元素所包含。更有甚者，有一篇文章的一个段落被一个 <code>table</code> 所包容，并且在其左侧还有一个看不见的 <code>td</code> 元素。</p>
<p>我们可以提供的思路就是如果一个 <code>table</code> 只有一行一列就直接将其内容取出并删除该 <code>table</code> 。</p>
<h3 id="&lt;a_/&gt;">&lt;a /&gt;</h3>
<p>超链接元素是一个新闻与用户互动的比较重要的元素之一。我们需要保持其美观性。</p>
<p>举几个例子来说，我们可以将超链接以一个类按钮的形式出现：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"a"</span>).removeAttr(<span class="string">"style"</span>);
<span class="variable">$(</span><span class="string">"a"</span>).addClass(<span class="string">"btn btn-default btn-xs btn-info"</span>);
</pre></td></tr></table></figure>


<p>然后我们甚至可以对其做一些细微的词汇修改。</p>
<p>比如当新闻发布者上传了一个附件然后不负责任地直接将文件名贴上的时候，我们可以贴心地将其显示文字改为“下载附件”。</p>
<p>再比如发布者直接以URL形式显示一个超链接的时候，我们可以贴心地将其改变为“打开链接”等等。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>$(<span class="string">"a"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">(idx, elem)</span> {</span>
    <span class="keyword">if</span>($(<span class="keyword">this</span>).html().match(<span class="regexp">/.*\.(doc|xls|ppt|docx|xlsx|pptx)/</span>)) {
        $(<span class="keyword">this</span>).html(<span class="string">"&lt;i class='glyphicon glyphicon-paperclip'&gt;&lt;/i&gt; 下载附件"</span>);
        $(<span class="keyword">this</span>).removeClass(<span class="string">"btn-info"</span>);
        $(<span class="keyword">this</span>).addClass(<span class="string">"btn-warning"</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span>($(<span class="keyword">this</span>).html().match(<span class="regexp">/http.*\/\/.*/</span>)) {
        $(<span class="keyword">this</span>).html(<span class="string">"&lt;i class='glyphicon glyphicon-flag'&gt;&lt;/i&gt; 打开链接"</span>);
        $(<span class="keyword">this</span>).removeClass(<span class="string">"btn-info"</span>);
        $(<span class="keyword">this</span>).addClass(<span class="string">"btn-warning"</span>);
    }
});
</pre></td></tr></table></figure>


<p>然后我们再处理几个由于误操作而增加的错误链接，如在经上面操作后，还存在着url与显示内容相关的超链接可以直接取消，如这类：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>让我们荡<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"起双桨"</span>&gt;</span>起双桨<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>


<h2 id="结束语">结束语</h2>
<p>至此，当下版本的 <strong>XPlan</strong> 的新闻爬虫手机屏幕适配基本完成。其中当然还存在着一些细节处理和显示错误处理的不足，但是已经定下了基本的适配思路。</p>
<p>我们还在探索更好的适配方法，而当下的适配形式暂时已经可以满足了我们项目的需求。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="XPlan" scheme="http://xcoder.in/tags/XPlan/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TopCoder SRM 589 DIV 2]]></title>
    <link href="http://xcoder.in/2013/08/31/srm-589-div2/"/>
    <id>http://xcoder.in/2013/08/31/srm-589-div2/</id>
    <published>2013-08-31T00:00:00.000Z</published>
    <updated>2014-03-24T13:59:55.000Z</updated>
    <content type="html"><![CDATA[<p>好久没撸 <strong>TC</strong> 了，手都生了。前两天刚折腾好 <strong>LinuxMint</strong> + <strong>Cinnamon</strong>，顺便手贱把 <strong>TC</strong> 环境配好了。</p>
<p>　　随便进去扯了一套最新的 <strong>SRM</strong> 来搞，全跑完之后才发现原来这场比赛还处于 <strong>System Running</strong> 阶段。于是知道了比赛一结束还在 <strong>Running</strong> 的时候你就已经可以自己拉出来做了。小绿名大家不要笑。</p>
<!-- 我是小小分割符 -->

<h2 id="Summary">Summary</h2>
<p>　　这次 <strong>DIV 2</strong> 的难度一般，一道签到题加两道普通的 <strong>DP</strong>。</p>
<p>　　<a href="https://github.com/XadillaX/xadillax-topcoder/tree/master/code/SRM589-DIV2" target="_blank">Code on GitHub</a>.</p>
<h2 id="250pt_-_Goose_Tattarrattat">250pt - Goose Tattarrattat</h2>
<p>题意很简单，就是给你一个字符串，问你最少改变多少字符让字符串所有字符都一样。</p>
<p>签到题，找最多的字符跟总长度一减就OK了。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">#define SIZE(x) ((int)(x.size()))</span>
<span class="preprocessor">#define LENGTH(x) ((int)(x.length()))</span>
<span class="keyword">class</span> GooseTattarrattatDiv2 
{
<span class="keyword">public</span>:
    <span class="keyword">int</span> getmin(<span class="built_in">string</span> S);
};

<span class="keyword">int</span> GooseTattarrattatDiv2::getmin(<span class="built_in">string</span> S)
{
    <span class="keyword">int</span> maxsame = <span class="number">0</span>;
    <span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;</span> mp;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(S); i++)
    {
    	mp[S[i]]++;
    	maxsame = max(maxsame, mp[S[i]]);
    }
    
    <span class="keyword">return</span> LENGTH(S) - maxsame;
}
</pre></td></tr></table></figure>


<h2 id="500pt_-_Gears">500pt - Gears</h2>
<p>有 <strong><em>N</em></strong> 个齿轮围成一圈，相邻两个齿轮要反方向转才能正常运转不卡到其它轮子。你要从中间拿掉几个齿轮（留空了就不影响其左边的左边的齿轮），问最少拿掉几个使得所有齿轮能正常转。</p>
<p>我们建两个二维 <strong><em>dp</em></strong> 数组，或者一个三维 <strong><em>dp</em></strong> 数组：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>dp[<span class="link_label">i</span>][<span class="link_reference">0|1</span>][<span class="link_label">0|1</span>]
</pre></td></tr></table></figure>


<p>第一维 <code>i</code> 代表当前是第 <code>i</code> 个齿轮。第二维若是 <code>0</code> 则表示这个齿轮拿走，若是 <code>1</code> 代表留下。第三维若是 <code>0</code> 则代表第一个齿轮拿走，<code>1</code> 代表第一个齿轮留下。整个数组的每个元素就代表该齿轮留下或者拿走且第一个齿轮是留下或者拿走的情况下的最少拿走齿轮数。</p>
<p>所以我们能得到几个状态转移方程：</p>
<blockquote>
<h3 id="第一个齿轮">第一个齿轮</h3>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp[<span class="link_label">i</span>][<span class="link_reference">0</span>][<span class="link_label">0</span>] = 1;
dp[<span class="link_label">i</span>][<span class="link_reference">0</span>][<span class="link_label">1</span>] = INF;
dp[<span class="link_label">i</span>][<span class="link_reference">1</span>][<span class="link_label">1</span>] = 0;
dp[<span class="link_label">i</span>][<span class="link_reference">1</span>][<span class="link_label">0</span>] = INF;
</pre></td></tr></table></figure>


<blockquote>
<h3 id="第二个齿轮">第二个齿轮</h3>
<p>如果与第一个同向那么就有了一留一走或者两个都走的情况。否则就是四种情况都可以。</p>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">if</span>(与第一个齿轮同向)
<span class="cell">{
    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = INF;
}</span>
<span class="keyword">else</span> 
<span class="cell">{
    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
    dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
    dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
    dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
}</span>
</pre></td></tr></table></figure>


<blockquote>
<h3 id="之后的所有齿轮">之后的所有齿轮</h3>
<p>若该齿轮与前一个齿轮方向相同 ，那么该齿轮留下的时候，前一个齿轮必须得走，那么就是 <code>dp[i - 1][0][?]</code>;该齿轮走的时候，前一个齿轮可走可留，就是 <code>dp[i - 1][0|1][?] + 1</code> 的稍微小一点那个。</p>
<p>若方向不相同 ，那么就是该齿轮留下的时候，前一个齿轮也可以留下。</p>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">if</span>(与前一个齿轮同向)
{
    dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];
    dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>];

    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
    dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + <span class="number">1</span>;
}
<span class="keyword">else</span> 
{
    dp [i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);
    dp [i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);

    dp [i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
    dp [i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;
}
</pre></td></tr></table></figure>


<p>最后若最后一个齿轮与第一个齿轮同向，那么在 <code>dp[i - 1][0][0]</code>、<code>dp[i - 1][0][1]</code>、<code>dp[i - 1][1][0]</code> 中挑一个。若不同向，那么多了个 <code>dp[i - 1][1][1]</code> 这个选择。</p>
<p>下面就是代码了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre>class GearsDiv2 
{
public:
    <span class="keyword">int</span> getmin(<span class="keyword">string</span> Directions);
};

<span class="keyword">int</span> GearsDiv2::getmin(<span class="keyword">string</span> Directions)
{
    <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">2</span>][<span class="number">2</span>];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(Directions); i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
        {
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">10000000</span>;
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">10000000</span>;
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(i == <span class="number">1</span>)
        {
            <span class="keyword">if</span>(Directions[i] == Directions[i - <span class="number">1</span>])
            {
                dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
                
                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
                dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10000000</span>;
            }
            <span class="keyword">else</span>
            {
                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
                dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
            }
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(Directions[i] == Directions[i - <span class="number">1</span>])
        {
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>];
            
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) + <span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);
            
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;
        }
    }
    
    <span class="keyword">int</span> ans;
    <span class="keyword">int</span> mi = LENGTH(Directions) - <span class="number">1</span>;
    <span class="keyword">if</span>(Directions[mi] == Directions[<span class="number">0</span>])
    {
        ans = <span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">0</span>], <span class="keyword">min</span>(dp[mi][<span class="number">1</span>][<span class="number">0</span>], dp[mi][<span class="number">0</span>][<span class="number">1</span>]));
    }
    <span class="keyword">else</span>
    {
        ans = <span class="keyword">min</span>(<span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">0</span>], dp[mi][<span class="number">1</span>][<span class="number">1</span>]), <span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">1</span>], dp[mi][<span class="number">1</span>][<span class="number">0</span>]));
    }
    
    <span class="keyword">return</span> ans;
}
</pre></td></tr></table></figure>


<h2 id="1000pt_-_Flipping_Bits">1000pt - Flipping Bits</h2>
<p>给你一个 <strong>01串</strong> 与一个正整数 <strong><em>M</em></strong>。<strong>01串</strong> 有如下三种操作:</p>
<ul>
<li>随便反转一位（0 -&gt; 1, 1 -&gt; 0）。</li>
<li>将开头 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
<li>将末尾 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
</ul>
<p>问最少需要几步将整个字符串变成都是 <code>1</code>。</p>
<p>这又是一个 <strong>DP</strong> 的题目。</p>
<p>我们先设有 <strong><em>G</em></strong> 组，一组 <strong><em>M</em></strong> 个 <code>01字符</code>。那么就能有</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">0|1</span>]
dp2[<span class="link_label">i</span>][<span class="link_reference">0|1</span>]
</pre></td></tr></table></figure>


<p>其中 <code>i</code> 代表第 <code>i</code> 组，第二维如果是 <code>0</code> 就代表这一组采用一位位反转的操作将这组全变成 <code>1</code>，如果是 <code>1</code> 则将整组全部反转再采用一位位反转的操作将这组全变成 <code>1</code> 。至于 <code>dp1</code> 和 <code>dp2</code> 则代表从头到尾和从尾到头。</p>
<p>由于只有 <code>0</code> 和 <code>1</code> 反转，那么一组反转两次就能还原原状——这是一个非常重要的性质。</p>
<p>如果某一组采用<strong>整组反转</strong>的操作，若前一组也是<strong>整组反转</strong>，那么就相当于操作次数不变，只是将前一组的反转范围延续到这一组；若前一组是<strong>非整组反转</strong>，那么就相当于从头到这一组反转之后，前面的所有组再反转回去——相当于是多了两次操作。于是就有了（先只拿 <code>dp1</code> 作为例子）：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">1</span>] = min(
<span class="code">    dp[i - 1][0] + 这一组1的数量 + 2,</span>
<span class="code">    dp[i - 1][1] + 这一组1的数量 </span>
);
</pre></td></tr></table></figure>


<p>如果某一组采用<strong>非整组反转</strong>，那么操作次数就是前一组的<strong>整组反转</strong>或者<strong>非整组反转</strong>的操作次数加上这一组 <code>0</code> 的数量：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">0</span>] = min(
<span class="code">    dp[i - 1][0] + 这一组0的数量,</span>
<span class="code">    dp[i - 1][0] + 这一组0的数量</span>
);
</pre></td></tr></table></figure>


<p>用上面的转移方程把正反向都求了一遍之后，我们就可以求总答案了，总答案就是我们枚举中间只有<strong>操作1</strong>的段的首尾，加上该中间段前部分的 <strong><em>dp</em></strong> 答案和其后部分的 <strong><em>dp</em></strong> 答案，取出最小值就是了。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre><span class="keyword">class</span> FlippingBitsDiv2 
{
<span class="keyword">public</span>:
    <span class="keyword">int</span> getmin(<span class="stl_container"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;</span> S, <span class="keyword">int</span> M);
    
    <span class="built_in">string</span> str;
    <span class="keyword">int</span> group;
    <span class="keyword">int</span> tn1[<span class="number">2600</span>], tnsum1[<span class="number">2600</span>];
    <span class="keyword">int</span> tn2[<span class="number">2600</span>], tnsum2[<span class="number">2600</span>];
    
    <span class="keyword">int</span> dp1[<span class="number">2600</span>][<span class="number">2</span>];
    <span class="keyword">int</span> dp2[<span class="number">2600</span>][<span class="number">2</span>];
    
    <span class="keyword">int</span> calcsum(<span class="keyword">int</span> l, <span class="keyword">int</span> r)
    {
        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> tot = tnsum1[r] - tnsum1[l - <span class="number">1</span>];
        <span class="keyword">return</span> tot;
    }
};

<span class="keyword">int</span> FlippingBitsDiv2::getmin(<span class="stl_container"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;</span> S, <span class="keyword">int</span> M)
{
    str = <span class="string">""</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE(S); i++) str += S[i];
    group = LENGTH(str) / M;
    ZERO(tn1);
    ZERO(tn2);
    
    <span class="comment">// init.</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++)
    {
        <span class="keyword">int</span> op = i * M;
        <span class="keyword">int</span> ed = op + M;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = op; j &lt; ed; j++)
        {
            <span class="keyword">if</span>(str[j] == <span class="string">'0'</span>) tn1[i]++, tn2[group - i - <span class="number">1</span>]++;
        }
        
        dp1[i][<span class="number">0</span>] = <span class="number">100000</span>;
        dp1[i][<span class="number">1</span>] = <span class="number">100000</span>;
        dp2[i][<span class="number">0</span>] = <span class="number">100000</span>;
        dp2[i][<span class="number">1</span>] = <span class="number">100000</span>;
    }
    
    <span class="comment">// tnsum</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>) tnsum1[<span class="number">0</span>] = tn1[<span class="number">0</span>], tnsum2[<span class="number">0</span>] = tn2[<span class="number">0</span>];
        <span class="keyword">else</span>
        {
            tnsum1[i] = tnsum1[i - <span class="number">1</span>] + tn1[i];
            tnsum2[i] = tnsum2[i - <span class="number">1</span>] + tn2[i];
        }
    }
    
    <span class="comment">// dp.</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= group; i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
        {
            dp1[i][<span class="number">0</span>] = dp1[i][<span class="number">1</span>] = dp2[i][<span class="number">0</span>] = dp2[i][<span class="number">1</span>] = <span class="number">0</span>;
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(i == <span class="number">1</span>)
        {
            <span class="comment">// head -&gt; tail</span>
            dp1[i][<span class="number">0</span>] = tn1[i - <span class="number">1</span>];
            dp1[i][<span class="number">1</span>] = <span class="number">1</span> + (M - tn1[i - <span class="number">1</span>]);
            
            <span class="comment">// tail -&gt; head</span>
            dp2[i][<span class="number">0</span>] = tn2[i - <span class="number">1</span>];
            dp2[i][<span class="number">1</span>] = <span class="number">1</span> + (M - tn2[i - <span class="number">1</span>]);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// head -&gt; tail</span>
            dp1[i][<span class="number">0</span>] = min(
                dp1[i - <span class="number">1</span>][<span class="number">0</span>] + tn1[i - <span class="number">1</span>],
                dp1[i - <span class="number">1</span>][<span class="number">1</span>] + tn1[i - <span class="number">1</span>]
            );
            dp1[i][<span class="number">1</span>] = min(
                dp1[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> + (M - tn1[i - <span class="number">1</span>]),
                dp1[i - <span class="number">1</span>][<span class="number">1</span>] + (M - tn1[i - <span class="number">1</span>])
            );
            
            <span class="comment">// tail -&gt; head</span>
            dp2[i][<span class="number">0</span>] = min(
                dp2[i - <span class="number">1</span>][<span class="number">0</span>] + tn2[i - <span class="number">1</span>],
                dp2[i - <span class="number">1</span>][<span class="number">1</span>] + tn2[i - <span class="number">1</span>]
            );
            dp2[i][<span class="number">1</span>] = min(
                dp2[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> + (M - tn2[i - <span class="number">1</span>]),
                dp2[i - <span class="number">1</span>][<span class="number">1</span>] + (M - tn2[i - <span class="number">1</span>])
            );
        }
    }
    
    <span class="keyword">int</span> minans = <span class="number">100000000</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= group; i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= group - i; j++)
        {
            <span class="keyword">int</span> zzl = i;
            <span class="keyword">int</span> zzr = group - j - <span class="number">1</span>;
            
            minans = min(minans,
                min(dp1[i][<span class="number">0</span>], dp1[i][<span class="number">1</span>]) +
                min(dp2[j][<span class="number">0</span>], dp2[j][<span class="number">1</span>]) +
                calcsum(zzl, zzr)
                );
        }
    }
    
    <span class="keyword">return</span> minans;
}
</pre></td></tr></table></figure>
]]></content>
    
    
      <category term="TopCoder" scheme="http://xcoder.in/tags/TopCoder/"/>
    
      <category term="SRM" scheme="http://xcoder.in/tags/SRM/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（壹）——基本语法和类型]]></title>
    <link href="http://xcoder.in/2013/08/16/node-4-base/"/>
    <id>http://xcoder.in/2013/08/16/node-4-base/</id>
    <published>2013-08-16T00:00:00.000Z</published>
    <updated>2014-03-24T13:40:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Node.js</strong> 的基础是 <strong>JavaScript</strong> 这门 <strong><em>脚本语言</em></strong>。而大多数的脚本语言一个共同的特点就是“<a href="http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.92.8C.E5.BC.B1.E5.9E.8B.E5.88.A5" target="_blank">弱类型</a>”。</p>
<p>　　不同于 <strong>PHP</strong> 的是，<strong>PHP</strong> 就是是有了新变量也无需申明，而 <strong>JavaScript</strong> 则还是需要 <code>var</code> 来申明一下的。而这个 <code>var</code> 涵盖了 <strong>C++</strong> 中的<code>int</code>、<code>string</code>、<code>char</code>等一切类型的含义，甚至是 <code>function</code>。</p>
<p>　　本篇以及后篇的所有内容都是在 <strong>Linux</strong> 或者 <strong>Cygwin</strong> 下用 <strong>vim</strong> 进行编辑（若不是则请自行转变成你自己的方法），然后在命令行下进行查看结果的。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="基本语法">基本语法</h2>
<h3 id="变量声明">变量声明</h3>
<p>在 <strong>C/C++</strong> 中，我们这么声明变量的：</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">void</span> foo() {}

<span class="keyword">int</span> a = <span class="number">0</span>;
<span class="keyword">char</span> b = <span class="string">'a'</span>;
<span class="keyword">float</span> c = <span class="number">1.0f</span>;
<span class="keyword">void</span> (*d)() = foo;  <span class="comment">///&lt; 忘了是不是这么写的了，总之是函数指针</span>
</pre></td></tr></table></figure>


<p>而在 <strong>Node.js</strong> 中则是这样的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>}

<span class="keyword">var</span> a = <span class="number">0</span>;
<span class="keyword">var</span> b = <span class="string">'a'</span>;
<span class="keyword">var</span> c = <span class="number">1.0</span>;
<span class="keyword">var</span> d = foo;
</pre></td></tr></table></figure>


<p>所以，无论是什么类型的变量，在 <strong>Node.js</strong> 中都是以一个 <code>var</code> 来解决的。</p>
<h3 id="循环语句">循环语句</h3>
<h4 id="for…i">for…i</h4>
<p>这个循环语句基本上跟 <strong>C/C++</strong> 一样，都是</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; foo; i++)
{
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<p>而鉴于 <strong>Node.js</strong> 是弱类型，所以只需要：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; foo; i++) {
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<h4 id="for…in">for…in</h4>
<p>这是一种后有型的循环语句，类似于 <strong>PHP</strong> 的 <code>foreach</code>。</p>
<p>比如我们有一个 <strong>JSON对象</strong> 如下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = {
    <span class="string">"hello"</span>     : <span class="string">"world"</span>,
    <span class="string">"node"</span>      : <span class="string">"js"</span>,
    <span class="string">"blahblah"</span>  : <span class="string">"bar"</span>
};
</pre></td></tr></table></figure>


<p>这个时候我们就可以用 <code>for...in</code> 来循环遍历了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="reserved">var</span> key <span class="keyword">in</span> foo) {
    <span class="built_in">console</span>.log(key + <span class="string">": "</span> + foo[key]);
}
</pre></td></tr></table></figure>


<p>我们如果在命令行中打入下面的命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node foo.js
</pre></td></tr></table></figure>


<p>屏幕上就会显示下面的内容了：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">hello</span>: <span class="string">world</span>
<span class="attribute">node</span>: <span class="string">js</span>
<span class="attribute">blahblah</span>: <span class="string">bar</span>
</pre></td></tr></table></figure>


<blockquote>
<p><strong>提示</strong>：由上可知，<code>for...in</code> 语句是用来遍历 <strong>JSON对象</strong>、<strong>数组</strong>、<strong>对象</strong>的键名的，而不提供键值的遍历。如果要获取键值，只能通过</p>
</blockquote>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>foo[<span class="tag">&lt;<span class="title">当前键名</span>&gt;</span>]
</pre></td></tr></table></figure>


<p>的形式来获取。这个跟 <strong>PHP</strong> 的 <code>foreach</code> 还是有一定区别的。</p>
<h4 id="while…do,_do…while">while…do, do…while</h4>
<p>这个就不多做解释了，跟其它语言没什么大的区别，无非就是如果有变量声明的话，需要用 <code>var</code> 就够了。</p>
<h3 id="运算符">运算符</h3>
<h4 id="+,_-,_*,_/">+, -, *, /</h4>
<p>这几个运算符也就这样，要注意的是 <code>+</code>。它既可以作用于字符串，也可以作用于数值运算。弱类型语言虽然说类型是弱的，数字有时候可以以字符串的形态出现，字符串有时候可以用数值的形态出现，但是在必要的时候也还是要说一下它是什么类型的，我们可以用下面的代码去看看结果：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">var</span> a = <span class="string">"1"</span>;
<span class="reserved">var</span> b = <span class="number">2</span>;
<span class="built_in">console</span>.log(a + b);
<span class="built_in">console</span>.log(parseInt(a) + b);
</pre></td></tr></table></figure>


<blockquote>
<p>这里的 <code>parseInt</code> 是 <strong>Node.js</strong> 的一个内置函数，作用是将一个字符串解析成 <code>int</code> 类型的变量。</p>
</blockquote>
<p>上面的代码执行结果是</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>12
3
</pre></td></tr></table></figure>


<p>第一个 <code>console.log</code> 结果是 <code>12</code>，由于 <code>a</code> 是字符串，所以 <code>b</code> 也被系统以字符串的姿态进行加操作，结果就是将两个字符串黏连在一起就变成了 <code>12</code>。而第二个 <code>console.log</code> 结果是 <code>3</code>，是因为我们将第一个 <code>a</code> 转变为了 <code>int</code> 类型，两个 <code>int</code> 型的变量相加即数值相加，结果当然就是 <code>3</code> 了。</p>
<h4 id="==,_===,_!=,_!==">==, ===, !=, !==</h4>
<p>这里有一点要解释，当这个逻辑运算符长度为 <code>2</code> 的时候（<code>==</code>, <code>!=</code>），只是判断外在的值是不是一样的，而不会判断类型。如</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="literal">a</span> = <span class="number">1</span>, b = <span class="string">"1"</span><span class="comment">;</span>
console.log(<span class="literal">a</span> == b)<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>它输出的结果就是 <code>true</code>。但是如果我们在中间判断的时候再加上一个等号，那么就是严格判断了，需要类型和值都一样的时候才会是 <code>true</code>，否则就是 <code>false</code>。也就是说</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="literal">a</span> = <span class="number">1</span>, b = <span class="string">"1"</span><span class="comment">;</span>
console.log(<span class="literal">a</span> === b)<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>的时候，返回的结果就是 <code>false</code> 了，因为 <code>a</code> 是 <code>int</code> 型的，而 <code>b</code> 则是字符串。</p>
<blockquote>
<p>顺带着就把条件语句讲了吧，其实这里的 <code>if</code> 跟别的语言没什么两样，就是几个逻辑运算符两个等号三个等号的问题。所以就不多做累述了。</p>
</blockquote>
<h4 id="typeof">typeof</h4>
<p>这里我姑且把它当成是一个运算符而不是函数了。</p>
<p>这个运算符的作用是判断一个变量的类型，会返回一个字符串，即类型名，具体的执行下面的代码就知道了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="reserved">function</span> foo() {}

<span class="reserved">var</span> a = <span class="number">0</span>;
<span class="reserved">var</span> b = <span class="string">'嘘~蛋花汤在睡觉。'</span>;
<span class="reserved">var</span> c = <span class="number">1.0</span>;
<span class="reserved">var</span> d = foo;
<span class="reserved">var</span> e = { <span class="string">"a"</span> : a };
<span class="reserved">var</span> f = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];
<span class="reserved">var</span> g = <span class="literal">null</span>;
<span class="reserved">var</span> h = <span class="literal">undefined</span>;

<span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> g);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> h);
</pre></td></tr></table></figure>


<p>这里的执行结果就将会是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="built_in">number</span>
<span class="keyword">string</span>
<span class="built_in">number</span>
<span class="function"><span class="keyword">function</span></span>
object
object
object
undefined
</pre></td></tr></table></figure>


<h3 id="null,_undefined,_NaN">null, undefined, NaN</h3>
<p>在 <strong>JavaScript</strong> 中，有三个特殊的值，如标题所示。其中第一个大家可能都比较熟悉吧，<strong>C/C++</strong> 里面也有，不过是大写的，其本质就是一个</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#<span class="keyword">define</span> NULL 0</span>
</pre></td></tr></table></figure>


<p>而在 <strong>JavaScript</strong> 中，这三个值所代表的意义都不同。</p>
<h4 id="null">null</h4>
<p><code>null</code> 是一种特殊的 <strong>object</strong>，大致的意思就是空。比如说：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">null</span>;
</pre></td></tr></table></figure>


<p>大家都能看懂，就不多做解释了。但是跟 <strong>C/C++</strong> 不同的是，这个 <code>null</code> 跟 <code>0</code> 不相等。</p>
<h4 id="undefined">undefined</h4>
<p>这个东西的意思就是说这个变量未声明。为了能够更好地区分 <code>null</code>，我们的样例代码如下写：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="reserved">var</span> a = {
    <span class="string">"foo"</span>       : <span class="literal">null</span>
};
<span class="built_in">console</span>.log(a[<span class="string">"foo"</span>]);
<span class="built_in">console</span>.log(a[<span class="string">"bar"</span>]);
</pre></td></tr></table></figure>


<p>上面的代码中，我们让 <code>a[&quot;foo&quot;]</code> 的值为空，即 <code>null</code>。而压根没有声明 <code>a[&quot;bar&quot;]</code> 这个东西，它连空都不是。输出的结果大家都差不多应该猜到了：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="literal">null</span>
<span class="literal">undefined</span>
</pre></td></tr></table></figure>


<h4 id="NaN">NaN</h4>
<p>这是一个空的数值，是一个特殊的 <code>number</code>。它的全称是 <code>Not a Number</code>。有点奇怪，大家可以理解为 <strong>不是数字形态，或者数值出错的 <code>number</code> 类型变量</strong>。</p>
<p>多在浮点型数值运算错误（如被0除）的情况下出现，甚至可以是用户自己让一个变量等于 <code>NaN</code> 以便返回一个错误值让大家知道这个函数运算出错了云云。</p>
<h3 id="小杂碎">小杂碎</h3>
<p>其它剩余的语句也跟已存在的其它语言差不多，比如说 <code>break</code> 啊、<code>switch</code> 啊、<code>continue</code> 啊等等等等。</p>
<h2 id="变量类型">变量类型</h2>
<p>这一节主要讲的是 <strong>JavaScript</strong> 对象，其它类型差不多一带而过吧。</p>
<h3 id="基础类型">基础类型</h3>
<p><strong>Node.js</strong> 包含的基础类型差不多有如下几个：</p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>array</li>
</ul>
<p>其中前三种类型可以直接赋值，而 <code>array</code> 的赋值只是一个引用赋值而已，在新变量中改变某个值的话旧变量的值也会改变，直接可以试试下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">var</span> foo = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];
<span class="reserved">var</span> bar = foo;
bar[<span class="number">0</span>] = <span class="number">3</span>;
<span class="built_in">console</span>.log(foo);
</pre></td></tr></table></figure>


<p>它得出的结果是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[ <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span> ]
</pre></td></tr></table></figure>


<p>也就是说 <code>array</code> 要是复制出一个新的数组的话，不能用直接赋值的方法，而必须“<strong><a href="#深拷贝">深拷贝</a></strong>”。</p>
<p>这里有必要讲一下 <code>array</code> 的三种创建方法。</p>
<p>第一种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="built_in">Array</span>();
dog[<span class="number">0</span>] = <span class="string">"嘘~"</span>;
dog[<span class="number">1</span>] = <span class="string">"蛋花汤"</span>;
dog[<span class="number">2</span>] = <span class="string">"在睡觉"</span>;
</pre></td></tr></table></figure>


<p>第二种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="string">"嘘~"</span>, <span class="string">"蛋花汤"</span>, <span class="string">"在睡觉"</span> );
</pre></td></tr></table></figure>


<p>第四种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = [
    <span class="string">"嘘~"</span>,
    <span class="string">"蛋花汤"</span>,
    <span class="string">"在睡觉"</span>
];
</pre></td></tr></table></figure>


<p>我个人比较喜欢第三种写法，比较简洁。</p>
<h3 id="JSON对象">JSON对象</h3>
<p>这里我把 <strong>JSON对象</strong> 单独拎出来而不是把它归类为 <strong>JavaScript对象</strong>，如果觉得我有点误人子弟就可以直接跳过这一节了。</p>
<p>本人对于 <strong>JSON对象</strong> 和 <strong>JavaScript</strong> 对象的区分放在 <strong>是否只用来存储数据，而并非是一个类的实例化</strong>。其实 <strong>JSON</strong> 的本质便是 <strong>JavaScript Object Notation</strong>。</p>
<blockquote>
<p>更多有关 <strong><a href="http://zh.wikipedia.org/wiki/JSON" target="_blank">JSON</a></strong> 的信息请自行百科。</p>
</blockquote>
<p>在 <strong>Node.js</strong> 中声明一个 <strong>JSON对象</strong> 非常简单：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = {
    <span class="string">"pre"</span>       : <span class="string">"嘘~"</span>,
    <span class="string">"sub"</span>       : {
        <span class="string">"name"</span>  : <span class="string">"蛋花汤"</span>,
        <span class="string">"act"</span>   : <span class="string">"在睡觉"</span>,
        <span class="string">"time"</span>  : <span class="number">12</span>
    },

    <span class="string">"suf"</span>       : [ <span class="string">"我说了"</span>, <span class="string">"它在睡觉"</span>, <span class="string">"就是在睡觉"</span> ]
};
</pre></td></tr></table></figure>


<p>有两种方式能得到 <strong>JSON对象</strong> 中的某个键名的键值，第一种是用点连接，第二种是用中括号：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>dog<span class="preprocessor">.pre</span><span class="comment">;</span>
dog[<span class="string">"pre"</span>]<span class="comment">;</span>
</pre></td></tr></table></figure>


<blockquote>
<p><strong>试试看</strong>：现在你自己动手试试看，用 <code>for...in</code> 的形式遍历一遍上面的 <code>JSON对象</code>。别忘了用上 <code>typeof</code> 喵~</p>
</blockquote>
<h3 id="类（对象）的基础">类（对象）的基础</h3>
<p>严格意义上来讲，<strong>Node.js</strong> 的类不能算是类，其实它只是一个函数的集合体，加一些成员变量。它的本质其实是一个函数。</p>
<p>不过为了通俗地讲，我们接下去以及以后都将其称为“类”，实例化的叫“对象”。</p>
<p>因为类有着很多 <strong>函数</strong> 的特性，或者说它的本质就是一个 <strong>函数</strong>，所以这里面我们可能一不留神就顺带着把函数基础给讲了。</p>
<h4 id="类的声明和实例化">类的声明和实例化</h4>
<p>声明一个类非常简单，大家不要笑：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">function</span> foo() {
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<p>好了，我们已经写好了一个 <code>foo</code> 类了。</p>
<blockquote>
<p>真的假的？！真的。</p>
</blockquote>
<p>不信？不信你可以接下去打一段代码看看：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = <span class="keyword">new</span> foo();
</pre></td></tr></table></figure>


<p>别看它是一个函数，如果以这样的形式（<code>new</code>）写出来，它就是这个类的实例化。</p>
<p>而这个所谓的 <code>foo()</code> 其实就是这个 <code>foo()</code> 类的构造函数。</p>
<h4 id="成员变量">成员变量</h4>
<p>成员变量有好两种方法。</p>
<p>第一种就是在类的构造函数或者任何构造函数中使用 <code>this.&lt;变量名&gt;</code> 。你可以在任何时候声明一个成员变量，在外部不影响使用，反正就算在还未声明的时候使用它，也会有一个 <code>undefined</code> 来撑着。所以说这就是第一种方法：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
}
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意</strong>：只有在加了 <code>this</code> 的时候才是调用类的<strong>成员变量</strong>，否则只是函数内的一个局部变量而已。要分清楚有没有 <code>this</code> 的时候变量的作用范围。</p>
</blockquote>
<p>第二种方法就是在构造函数或者任何成员函数外部声明，其格式是 <code>&lt;类名&gt;.prototype.&lt;变量名&gt;</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">function</span> foo() {
    //<span class="keyword">...</span>
}

foo.prototype.hello = <span class="string">"world"</span>;
</pre></td></tr></table></figure>


<p>无聊上面哪种方法都是对成员变量的声明，我们可以看看效果：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> bar = <span class="keyword">new</span> foo();
<span class="built_in">console</span>.log(bar.hello);
</pre></td></tr></table></figure>


<p>甚至你可以这么修改这个类：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
}

foo.prototype.hello = <span class="string">"蛋花汤"</span>;
</pre></td></tr></table></figure>


<p>然后再用上面的代码输出。</p>
<blockquote>
<p>想想看为什么输出的还是 <code>world</code> 而不是 <code>蛋花汤</code>。</p>
</blockquote>
<h4 id="构造函数">构造函数</h4>
<p>我们之前说过了这个 <code>foo()</code> 实际上是一个 <strong>构造函数</strong>。那么显然我们可以给构造函数传参数，所以就有了下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 代码2.1</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(hello)</span> {</span>
    <span class="keyword">if</span>(hello === <span class="literal">undefined</span>) {
        <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">this</span>.hello = hello;
    }
}
</pre></td></tr></table></figure>


<p>我们看到上面有一个奇葩的判断 <code>if(hello === undefined)</code>，这个判断有什么用呢？第一种可能，就是开发者很蛋疼地特意传进去一个 <code>undefined</code> 进去，这个时候它是 <code>undefined</code> 无可厚非。</p>
<p>还有一种情况。我们一开始就说了 <strong>JavaScript</strong> 是一门弱类型语言，其实不仅仅是弱类型，它的传参数也非常不严谨。你可以多传或者少传（只要保证你多传或者少传的时候可以保证程序不出错，或者逻辑不出错），原则上都是可以的。多传的参数会被自动忽略，而少传的参数会以 <code>undefined</code> 补足。</p>
<p>看看下面的代码就明白了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
<span class="keyword">var</span> bar1 = <span class="keyword">new</span> foo();
<span class="keyword">var</span> bar2 = <span class="keyword">new</span> foo(<span class="string">"蛋花汤"</span>);
</pre></td></tr></table></figure>


<p>请自行输出一下两个 <code>bar</code> 的 <code>hello</code> 变量，会发现一个是 <strong>world</strong> 一个是 <strong>蛋花汤</strong>。显而易见，我们的第一个 <code>bar1</code> 在声明的时候，被 <strong>Node.js</strong> 自动看成了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> bar1 = <span class="keyword">new</span> foo(<span class="literal">undefined</span>);
</pre></td></tr></table></figure>


<p>所以就有了它是 <strong>world</strong> 一说。</p>
<p>还有就是在这个构造函数中，我们看到了传进去的参数是 <code>hello</code> 而这个类中本来就有个成员变量就是 <code>this.hello</code>。不过我们之前说过了有 <code>this</code> 和没 <code>this</code> 的时候作用域不同，那个参数只是作用于构造函数中，而加了 <code>this</code> 的那个则是成员变量。用一个 <code>this</code> 就马上区分开来他们了，所以即使同名也没关系。</p>
<h4 id="成员函数">成员函数</h4>
<h5 id="成员函数声明">成员函数声明</h5>
<p>成员函数的声明跟成员变量的第二种声明方法差不多，即 <code>&lt;类名&gt;.prototype.&lt;函数名&gt; = &lt;函数&gt;;</code></p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
<span class="function"><span class="keyword">function</span> <span class="title">setHello</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
foo.prototype.setHello = setHello;

bar1.setHello(<span class="string">"鸡蛋饼"</span>);
</pre></td></tr></table></figure>


<p>上面这段代码显而易见，我们实现了 <code>foo</code> 类的 <code>setHello</code> 函数，能通过它修改 <code>foo.hello</code> 的值。</p>
<p>但是这么写是不是有点麻烦？接下去我要讲一个 <strong>JavaScript</strong> 函数重要的特性了。</p>
<h4 id="★_匿名函数">★ 匿名函数</h4>
<p>很多时候我们的某些函数只在一个地方被引用或者调用，那么我们为这个函数起一个名字就太不值了，没必要，所以我们可以临时写好这个函数，直接让引用它的人引用它，调用它的人调用它。所以函数可以省略函数名，如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>至于怎么引用或者调用呢？如果是上面的那个类需要引用的话，就是写成这样的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>foo.prototype.setHello = <span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>这样的写法跟 <strong><a href="#成员函数声明">2.3.3.1. 成员函数声明</a></strong> 是一个效果的，而且省了很多的代码量。而且实际上，基本上的类成员函数的声明都是采用这种匿名函数的方式来声明的。</p>
<p>至于说怎么样让匿名函数被调用呢？这通常用于传入一个只被某个函数调用的函数时这样写。</p>
<p>比如我们有一个函数的原型是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 我们将传入a，b两个变量，
 * 在算出a+b的值后，交由func(num)
 * 去进行输出
 */</span>
function sumab(a, b, func) {
    <span class="keyword">var</span> c = a + b;
    func(a, b, c);
}
</pre></td></tr></table></figure>


<p>比如我们有两个版本的输出函数，一个是中文输出，一个是英文输出，那么如果不用匿名函数时候是这么写的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">zh</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" + "</span> + b + <span class="string">" 的值是："</span> + <span class="built_in">sum</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">en</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" plus "</span> + b + <span class="string">" is "</span> + <span class="built_in">sum</span>);
}

sumab(<span class="number">1</span>, <span class="number">2</span>, zh);
sumab(<span class="number">3</span>, <span class="number">4</span>, en);
</pre></td></tr></table></figure>


<p>执行一遍这段代码，输出的结果将会是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="number">1</span> + <span class="number">2</span> 的值是：<span class="number">3</span>
<span class="number">3</span> plus <span class="number">4</span> <span class="keyword">is</span> <span class="number">7</span>
</pre></td></tr></table></figure>


<p>这样的代码如果采用匿名函数的形式则将会是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>sumab(<span class="number">1</span>, <span class="number">2</span>, <span class="function"><span class="keyword">function</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" + "</span> + b + <span class="string">" 的值是："</span> + <span class="built_in">sum</span>);
});
sumab(<span class="number">3</span>, <span class="number">4</span>, <span class="function"><span class="keyword">function</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" plus "</span> + b + <span class="string">" is "</span> + <span class="built_in">sum</span>);
});
</pre></td></tr></table></figure>


<p>这种形式通常使用于回调函数。回调机制算是 <strong>Node.js</strong> 或者说 <strong>JavaScript</strong> 的精髓。在以后的篇章会做介绍。</p>
<h4 id="成员函数声明的匿名函数声明方式">成员函数声明的匿名函数声明方式</h4>
<p>虽然上一节讲过了，不过还是再讲一遍吧。</p>
<p>通常我们声明类的成员函数时候都是用匿名函数来声明的，因为反正那个函数也就是这个类的一个成员函数而已，不会在其它地方被单独引用或者调用，所以就有了下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
foo.prototype.setHello = <span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>这样我们就使得 <code>foo</code> 类有了 <code>setHello</code> 这个函数了。</p>
<h4 id="类的随意性">类的随意性</h4>
<p>这个又是我胡扯的。所谓类的随意性即 <strong>JavaScript</strong> 中你可以在任何地方修改你的类，这跟 <strong>Ruby</strong> 有着一定的相似之处。</p>
<p>比如说 <code>string</code> ，它其实也是一个类，有着诸如 <code>length</code> 这样的成员变量，也有 <code>indexOf</code>、<code>substr</code> 等成员函数。但是万一我们觉得这个 <code>string</code> 有些地方不完善，想加自己的方法，那么可以在你想要的地方给它增加一个函数，比如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="built_in">String</span>.prototype.sb = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> newstr = <span class="string">""</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {
        <span class="keyword">if</span>(i % <span class="number">2</span> === <span class="number">0</span>) newstr += <span class="string">"s"</span>;
        <span class="keyword">else</span> newstr += <span class="string">"b"</span>;
    }

    <span class="keyword">return</span> newstr;
};
</pre></td></tr></table></figure>


<p>这个函数的意思就是填充一个字符串，使其变成 <code>sb</code> 的化身。</p>
<p>我们来测试一下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="keyword">str</span> = <span class="string">"嘘~蛋花汤在睡觉。"</span>;
console.<span class="keyword">log</span>(<span class="keyword">str</span>.sb());
</pre></td></tr></table></figure>


<p>你将会得到这样的结果：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbsbsbsbs
</pre></td></tr></table></figure>


<blockquote>
<p>你跟你的电脑说“嘘~蛋花汤在睡觉。”，你的电脑会骂你四次半傻逼。（赶快砸了它）</p>
</blockquote>
<h2 id="附">附</h2>
<h3 id="深拷贝">深拷贝</h3>
<p>所谓深拷贝就是自己新建一个数组或者对象，把源数组或者对象中的基础类型变量值一个个手动拷过去，而不是只把源数组或者对象的引用拿过来。所以这就涉及到了一个递归的调用什么的。</p>
<p>下面是我实现的一个深拷贝函数，大家可以写一个自己的然后加入到自己的 <strong>Node.js</strong> 知识库中。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span><span class="params">(src)</span> {</span>
    <span class="keyword">var</span> dest = {};
    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> src) {
        <span class="keyword">if</span>(<span class="keyword">typeof</span> src === <span class="string">"object"</span>) dest[key] = cloneObject(src[key]);
        <span class="keyword">else</span> dest[key] = src[key];
    }

    <span class="keyword">return</span> dest;
}
</pre></td></tr></table></figure>


<h3 id="系统默认对象参考手册">系统默认对象参考手册</h3>
<ul>
<li><strong>字符串</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_string.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_string.asp</a></li>
<li><strong>数字</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_number.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_number.asp</a></li>
<li><strong>数组</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_array.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_array.asp</a></li>
<li><strong>布尔</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_boolean.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_boolean.asp</a></li>
<li><strong>日期</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_date.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_date.asp</a></li>
<li><strong>数学库</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_math.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_math.asp</a></li>
</ul>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（负贰）——环境]]></title>
    <link href="http://xcoder.in/2013/08/15/node-2-environment-in-windows/"/>
    <id>http://xcoder.in/2013/08/15/node-2-environment-in-windows/</id>
    <published>2013-08-15T00:00:00.000Z</published>
    <updated>2014-03-24T13:43:21.000Z</updated>
    <content type="html"><![CDATA[<p>由于<a href="#linux-环境">Linux</a>中的环境搭建比较简单，所以草草略过。</p>
<p>　　其实<a href="#windows-环境">Windows</a>下也不算麻烦，但是这里会讲一定量的别的环境的搭建。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="Linux_环境">Linux 环境</h2>
<p>讲到这个就很简单了，跟着下面的 <strong>bash</strong> 操作即可：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$ cd /usr/<span class="built_in">local</span>/bin
$ wget http:<span class="comment">//nodejs.org/dist/v0.00.00/node-v0.00.00-linux-x00.tar.gz</span>
$ tar zxf node<span class="attribute">-v0</span><span class="number">.00</span><span class="number">.00</span><span class="attribute">-linux</span><span class="attribute">-x00</span><span class="built_in">.</span>tar<span class="built_in">.</span>gz
$ cd node<span class="attribute">-v0</span><span class="number">.00</span><span class="number">.00</span><span class="attribute">-linux</span><span class="attribute">-x00</span>
</pre></td></tr></table></figure>


<blockquote>
<p>其中将上方的 <strong>v0.00.00</strong> 替换成 <strong>Node.js</strong> 最新的版本号，把 <strong>x00</strong> 替换成你自己电脑的位数。</p>
<p>也可以直接去官网 <a href="http://nodejs.org/download/" target="_blank">http://nodejs.org/download/</a> 找到相应的地址。</p>
</blockquote>
<p>最后将其的连接加入到 <code>/usr/bin</code> 下即可。</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$ </span>cd bin
<span class="variable">$ </span>ln node /usr/bin
<span class="variable">$ </span>ln npm /usr/bin
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意</strong>： 该用 <code>sudo</code> 的地方就用 <code>sudo</code> 或者 <code>su</code> 。</p>
</blockquote>
<p>至此，<strong>Linux</strong> 下的 <strong>Node.js</strong> 环境基本搭建完毕。</p>
<h2 id="Windows_环境">Windows 环境</h2>
<h3 id="Cygwin_安装和配置">Cygwin 安装和配置</h3>
<p><strong><em>Cygwin</em></strong> 是一个在 <strong><em>Windows</em></strong> 平台上运行的 <strong><em>Unix</em></strong> 模拟环境。对于学习 <strong><em>Unix/Linux</em></strong> 操作环境，或者从 <strong><em>Unix</em></strong> 到 <strong><em>Windows</em></strong> 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 <strong><em>GNU工具集</em></strong> 在 <strong><em>Windows</em></strong> 上进行嵌入式系统开发，非常有用。</p>
<h4 id="Cygwin_安装">Cygwin 安装</h4>
<p>我们先跑到 <strong>Cygwin</strong> 的官网上去把东西下来：</p>
<blockquote>
<p><a href="http://cygwin.com/install.html" target="_blank">http://cygwin.com/install.html</a></p>
<blockquote>
<p>注意，最好下 <strong>x86</strong> 的包，因为我们之后要讲一个 <code>cyg-apt</code> 的脚本插件，这是一个能让 <strong>Cygwin</strong> 能跟 <strong>Linux</strong> 一样通过脚本从源安装软件包的脚本。为了方便修改，我们将其下成 <strong>x86</strong> 的版本。</p>
</blockquote>
</blockquote>
<p>然后就是安装步骤了。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-1.png" alt="从网络安装"></center><br><center><small>[图2.1]</small></center>

<p>到 <strong>[图2.1]</strong> 这个步骤的时候，选择默认的 <code>Install from Internet</code> 即可。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-2.png" alt="选择安装路径"></center><br><center><small>[图2.2]</small></center>

<p>在 <strong>[图2.2]</strong> 的时候选一个安装路径。</p>
<blockquote>
<p><strong>注意</strong>：尽可能让这个安装路径简单，而不要是类似于</p>
<p><code>c:\Program Files\blahblah</code></p>
<p>这样的文件路径。</p>
</blockquote>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-3.png" alt="本地包路径"></center><br><center><small>[图2.3]</small></center>

<p><strong>[图2.3]</strong> 的时候选一个本地包的路径，我这里选的是 <code>e:\cygwin\tmp</code>。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-4.png" alt="直连"></center><br><center><small>[图2.4]</small></center>

<p><strong>[图2.4]</strong> 选择直接连接。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-5.png" alt="163"></center><br><center><small>[图2.5]</small></center>

<p>我们国内的用户源还是选择 <code>163</code> 的速度比较快。所以在 <strong>[图2.5]</strong> 这一步的时候就直接选用默认的 <code>163</code> 的源了。如果不是默认的话，请选中它。</p>
<p>在 <strong>Select Package</strong> 也就是选择预安装的软件的时候，把下列表中的软件包勾选起来：</p>
<blockquote>
<ul>
<li><strong>wget</strong>: 在 <strong>Utils</strong> 中</li>
<li><strong>vim</strong>: 在 <strong>Editors</strong> 中</li>
<li><strong>gcc</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>gcc-g++</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>make</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>cmake</strong>: 在 <strong>Devel</strong> 中</li>
</ul>
</blockquote>
<p>若是这些选项已经被选起来了就不用再选了，如果没有选起来则把它选中。</p>
<p>勾选好了之后就可以下一步安装了，直至安装完毕，你就可以打开你的 <strong>Cygwin</strong> 了。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-6.png" alt="Cygwin"></center><br><center><small>[图2.6]</small></center>

<blockquote>
<p><strong>提示</strong>：你可以点击窗口左上角的小图片，然后里面的 <strong>Options</strong> 中，你可以调整你自己的 <strong>Cygwin</strong> 外观。</p>
</blockquote>
<h3 id="vim_配置">vim 配置</h3>
<p>上一步我们已经选中了 <strong>vim</strong> ，也就是说我们已经在 <strong>Cygwin</strong> 中装上了 <strong>vim</strong>。但是由于这里的 <strong>vim</strong> 默认配置非常蛋疼，所以我们得改一下。</p>
<p>在你的 <strong>Cygwin</strong> 中一句句输入下面的命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>$ cd /home/&lt;你自己的用户名&gt;
$ wget http://blog-xcoder-<span class="keyword">in</span><span class="preprocessor">.qiniudn</span><span class="preprocessor">.com</span>/<span class="preprocessor">.vimrc</span>
$ mkdir <span class="preprocessor">.vim</span>
$ cd <span class="preprocessor">.vim</span>
$ mkdir colors
$ cd colors
$ wget http://blog-xcoder-<span class="keyword">in</span><span class="preprocessor">.qiniudn</span><span class="preprocessor">.com</span>/molokai<span class="preprocessor">.vim</span>
</pre></td></tr></table></figure>


<p>这样你的 <strong>vim</strong> 就用上了上面的那个地址的配置文件，当然你也可以编辑你自己的配置文件或者说从网上下别的配置文件以满足你的个性化需求。</p>
<p><strong>vim</strong> 配置以及使用请参照：<a href="https://wiki.archlinux.org/index.php/Vim" target="_blank">https://wiki.archlinux.org/index.php/Vim</a></p>
<blockquote>
<p>事无巨细问 <strong>ArchWiki</strong>。</p>
<div style="text-align: right;"><em>— <a href="https://github.com/kalxd" target="_blank">kalxd</a></em></div>

</blockquote>
<h3 id="apt-cyg">apt-cyg</h3>
<blockquote>
<p>apt-cyg is a command-line installer for Cygwin which cooperates with Cygwin Setup and uses the same repository. The syntax is similar to apt-get.</p>
<div style="text-align: right;"><em>— From apt-cyg googlecode page</em></div>

</blockquote>
<p>总之意思就是说 <code>apt-cyg</code> 是类似于 <strong>Linux</strong> 中的 <code>apt-get</code>， <code>yum</code>, <code>zypper</code> 等命令行软件包安装器一样，可以通过</p>
<ul>
<li><code>apt-cyg install &lt;package names&gt;</code> 来安装软件包</li>
<li><code>apt-cyg remove &lt;package names&gt;</code> 来移除软件包</li>
<li><code>apt-cyg update</code> 来更新 setup.ini</li>
<li><code>apt-cyg show</code> 来列出已安装的软件包</li>
<li><code>apt-cyg find &lt;pattern(s)&gt;</code> 来查找符合条件的软件包</li>
<li><code>apt-cyg describe &lt;pattern(s)&gt;</code> 来描述符合条件的软件包</li>
<li><code>apt-cyg packageof &lt;commands or files&gt;</code> 来定位其父软件包</li>
</ul>
<h4 id="apt-cyg_安装">apt-cyg 安装</h4>
<p>其实也不能说是安装，纯粹是把脚本从网络上拷到自己的 <strong>Cygwin</strong> 的环境目录中。</p>
<p>在你的 <strong>Cygwin</strong> 中输入以下命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>cd /usr/local/bin
<span class="variable">$ </span>wget <span class="symbol">http:</span>/<span class="regexp">/apt-cyg.googlecode.com/svn</span><span class="regexp">/trunk/apt</span>-cyg
</pre></td></tr></table></figure>


<p>这样你就“安装”好了 <strong>apt-cyg</strong> 了。不过这里用的是默认的源，所有东西都是默认的。</p>
<p>如果你现在已经心安理得或者不想折腾了可以跳过 <strong><a href="#apt-cyg-修改">2.1.3.2. apt-cyg 修改</a></strong>，如果你想把源换成 <code>163</code> 的话那么稍微看一下吧。</p>
<h4 id="apt-cyg_修改">apt-cyg 修改</h4>
<p>接下去我们要对 <strong>apt-cyg</strong> 做一些编辑。</p>
<p>你有下面两个选择：</p>
<ol>
<li>如果你想学习 <strong>vim</strong> 操作或者你已经熟悉了，那么直接使用 <code>vim apt-cyg</code> 来进行编辑。</li>
<li>如果你是懒人还是想要直接编辑的话，请跑到你的 <strong>Cygwin</strong> 的安装目录，找到 <strong>usr</strong> 文件夹，飞进 <strong>local/bin</strong> 目录中去，用你自己喜欢的文本编辑器打开并编辑。</li>
</ol>
<p>大约是 <code>68</code> 行上下吧，有一句是：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>  mirror=ftp://mirror<span class="preprocessor">.mcs</span><span class="preprocessor">.anl</span><span class="preprocessor">.gov</span>/pub/cygwin
</pre></td></tr></table></figure>


<p>将其改成：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">  mirror</span>=<span class="string">http://mirrors.163.com/cygwin</span>
</pre></td></tr></table></figure>


<p>还有就是大概在 <code>98</code> 行和 <code>105</code> 行左右：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    wget -N $mirror/setup.bz2
    <span class="keyword">...</span>
    wget -N $mirror/setup.ini
</pre></td></tr></table></figure>


<p>修改成：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    wget -N $mirror/x86/setup.bz2
    <span class="keyword">...</span>
    wget -N $mirror/x86/setup.ini
</pre></td></tr></table></figure>


<p>至此，你的 <strong>Cygwin</strong> 环境基本完成，以后可以再慢慢完善。</p>
<h3 id="Node-js_安装">Node.js 安装</h3>
<p>这个就很简单了，打开 <strong><a href="http://nodejs.org/download/" target="_blank">Node.js</a></strong> 官网下载安装即可。</p>
<blockquote>
<p>选择 <strong>Windows Installer (.msi)</strong> 或者 <strong>Windows Binary (.exe)</strong>。</p>
</blockquote>
<p>安装好后就能直接在 <strong>Cygwin</strong> 里面使用了。</p>
<h2 id="真·Hello_World">真·Hello World</h2>
<p>现在，无论你是 <strong>Linux</strong> 用户还是 <strong>Windows</strong> 用户，都可以用一样的步骤来完成下面的 <code>Hello World</code> 了。</p>
<p>随便跑一个目录里面新建一个文件并且用 <strong>vim</strong> 编辑：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>vim hello.js
</pre></td></tr></table></figure>


<p>在里面输入下面的东西：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"Hello world!"</span>);
</pre></td></tr></table></figure>


<p>然后退出 <strong>vim</strong> 执行：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node hello.js
</pre></td></tr></table></figure>


<p>终于，<strong>真·Hello world</strong> 出现在了你的眼前，而不需要借助 <strong><a href="http://ideone.com/" target="_blank">IDEOne</a></strong> 了。</p>
<p><strong><em>To be continued…</em></strong></p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（负叁）——概述]]></title>
    <link href="http://xcoder.in/2013/08/13/node-1-summary/"/>
    <id>http://xcoder.in/2013/08/13/node-1-summary/</id>
    <published>2013-08-13T00:00:00.000Z</published>
    <updated>2014-03-24T13:40:41.000Z</updated>
    <content type="html"><![CDATA[<p>本系列教程主要是写给我带的那帮熊孩子们看的。我自己的 <strong>Node.js</strong> 水平半斤八两，措辞之中也免不了有自己错误的理解，会误人子弟。但是对于初学者来说，某些自己助记的理解还是可取的。有些概念性的错误可以等他们进一步深入研究之后再自行更正。</p>
<p>　　由于那帮人大多还处于使用 <strong>M$ Windows</strong> 的令人不愉快的阶段，所以本教程将会退而求其次，使其在 <strong>Cygwin</strong> 中模拟 <strong>linux</strong> 的命令（Windows的bat脚本实在是让人不敢恭维）。以及在这里会讲述一些 <strong>Git</strong> 操作的初步。当然，如果你已经在使用 <strong>linux</strong> 进行开发的话，可以跳过前面一堆令人感到厌烦的环境配置章节。或者你在使用 <strong>M$ Windows</strong> 但却不想改变自己的脚本习惯的话，也可以选择性地跳过一些章节和步骤。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="Node-JS是什么？">Node.JS是什么？</h2>
<p>很多人都知道JS是一门语言，而且是一门脚本语言，其全称就是 <strong>JavaScript</strong>，而且与所谓的 <strong>Java</strong> 没有一个屁的关系。</p>
<h3 id="前端_JavaScript">前端 JavaScript</h3>
<p>在好多年前，<strong>JavaScript</strong> 是网页的一个寄生虫，它必须依赖于网页的浏览器中才能执行，并且作为网页的一部分，以</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="comment">//blahblah...</span>
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<p>标签进行包含，这样才能提供其上下文环境。或者说将其单独写入一个 <code>*.js</code> 文件中，并且在网页里以</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"foo/bar.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<p>的形式将其包含进来。</p>
<p>但总而言之，<strong>JavaScript</strong> 只是寄生在网页里面的一只小小可怜虫罢了。它的作用无非就是使网页的交互性更强，页面效果更多而已。</p>
<p>后来，这帮不甘寂寞的人类将 <strong>JavaScript</strong> 从网页（或者说前端）的帝国中独立了出来（小心快递），于是就出现了 <strong>CommonJS</strong>。</p>
<h3 id="CommonJS">CommonJS</h3>
<p><strong>CommonJS</strong> 其实不是一门新的语言，甚至都不能说它是一个新的解释器——实际上它只是一个概念或者是一个规范。</p>
<p>在这个规范中，它定义了很多 <strong>API</strong> ，讲通俗点或者直截了当点就是函数啊类啊什么的，而这些 <strong>API</strong> 是为那些普通应用程序（Native App）而非浏览器应用使用。它的终极目标就是提供一个类似于 <strong>Python</strong>、<strong>Ruby</strong> 之类的脚本一样的标准库，开发者可以用这样的东西一样来做到 <strong>Python</strong>、<strong>Ruby</strong> 能做到的事，而非仅仅局限于网页中的效果或者功能实现，它也可以跑在本地。</p>
<p>所以说下面的事情对于 <strong>JavaScript</strong> 来说不再是梦：</p>
<ul>
<li>服务端JavaScript应用</li>
<li>命令行工具</li>
<li>图形界面应用</li>
<li>混合应用（Titanium、Adobe AIR等）</li>
</ul>
<p>那么，它具体弥补了 <strong>前端JavaScript</strong> 的哪些空白呢？其实这也涉及了很多 <strong>前端JavaScript</strong> 所没有涉及的东西，如二进制、编码、IO、文件、系统、断言测试、套接字、事件队列、Worker、控制台等等。</p>
<p>关于 <strong>CommonJS</strong> 的更进一步了解可以翻阅一下其 <strong><a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank">Wiki</a></strong>。</p>
<h3 id="Node-JS">Node.JS</h3>
<p>上面讲了那么多，却始终停留在“规范”这个层面上。而 <strong>Node.JS</strong> 的出现便是让 <strong>CommonJS</strong> 成为了现实。</p>
<p>这里要大家明确的一点的就是 <strong>Node.JS</strong> 并不是一门新的语言，它的语言还是 <strong>JavaScript</strong> ，硬要说是一门新的语言那也应该是 <strong>Common JavaScript</strong>。<strong>Node.JS</strong> 只是 <strong>CommonJS</strong> 的一个<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8" target="_blank">解释器</a>罢了。</p>
<p>它是基于 <strong>Google</strong> 的 <strong>V8虚拟机</strong>(Chrome浏览器所使用的JavaScript执行环境) 的一个解释器。</p>
<p>很多人印象中的概念还是没能摆脱 <strong>前端JavaScript</strong> 的阴霾，认为 <strong>JavaScript</strong> 就是做网站的， <strong>Node.JS</strong> 也是如此。</p>
<p>包括本人在 <strong><a href="http://cnodejs.org/" target="_blank">cnodejs.org</a></strong> 中看到的帖子大多也都是讲 <strong>Node.JS</strong> 如何如何做网站（服务端）云云，如何如何使用 <strong>Express</strong> 模块来搭建一个网站云云。</p>
<blockquote>
<p>这是一个误区。</p>
</blockquote>
<p><strong>PHP</strong> 还能用 <strong><a href="http://www.php-cli.com/" target="_blank">PHP-CLI</a></strong> 来写个脚本放本地跑呢，<strong>Node.JS</strong> 更是可以写任何程序。虽然这么讲有些夸大了，但是我这么说的理由是希望大家能摆脱这么一个误区。</p>
<p>举个简单的例子吧，大家都是搞过 <strong>ACM</strong> 的孩子了，总对终端窗口的输入输出有一定感觉了吧。现在给我以最快速度码一个 <strong><em><a href="http://acm.nbut.edu.cn/problem/view.xhtml?id=1000" target="_blank">A + B Problem</a></em></strong> 给我看看。</p>
<p>轻车熟路，我知道。但是你们现在做的事用 <strong>Node.JS</strong> 同样能做到。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>process.stdin.resume();
process.stdin.setEncoding(<span class="string">"utf8"</span>);
process.stdin.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
    <span class="keyword">var</span> datas = chunk.trim().split(<span class="string">"\n"</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; datas.length; i++) {
        <span class="keyword">var</span> ab = datas[i].trim().split(<span class="string">" "</span>);
        <span class="keyword">var</span> a = <span class="built_in">parseInt</span>(ab[<span class="number">0</span>]);
        <span class="keyword">var</span> b = <span class="built_in">parseInt</span>(ab[<span class="number">1</span>]);
        console.log(a + b);
    }
});
</pre></td></tr></table></figure>


<p>由于<del>我们学校</del>我的前任学校OJ不支持 <strong>Node.JS</strong>，所以请你们移步到 <strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1000" target="_blank">AIZU OJ</a></strong> 去把上面的代码交过去看看结果看。</p>
<blockquote>
<p><strong>注意</strong>：语言要选择 <strong>JavaScript</strong>。</p>
</blockquote>
<p>怎么样，同样能过题的对吧？</p>
<h2 id="小结">小结</h2>
<p>上面对这些东西做了个简单的介绍，我需要你们知道的东西很简单：</p>
<ol>
<li><strong>Node.JS</strong> 是一个脚本解释器，用的语言是 <strong>JavaScript</strong>。</li>
<li><strong>Node.JS</strong> 功能很强大，不是只能拿来做网站的，眼光放开阔些。</li>
<li>给我好好学。</li>
</ol>
<h2 id="番外">番外</h2>
<blockquote>
<p>有个码畜老了，想学学书法来修身养性。当他展开宣纸，犹豫了半天之后，终于挥毫泼墨，在纸上龙飞凤舞写下几个大字：</p>
<blockquote>
<p><strong><em>Hello World</em></strong></p>
</blockquote>
</blockquote>
<p>虽然这一篇文章没有讲到任何 <strong>Node.JS</strong> 的语法，但是还是可以让你们练练书法的。</p>
<p><strong>C语言</strong> 的标准输出函数是 <code>printf</code>，而 <strong>Node.JS</strong> 的标准输出则是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"blahblah..."</span>);
</pre></td></tr></table></figure>


<p>好的，即使没有装上 <strong>Node.JS</strong> 环境也阻止不了我们向世界问好。</p>
<p>打开 <strong><a href="http://ideone.com/" target="_blank">IDEOne</a></strong>，将你的 <code>Hello World</code> 贴到编辑框中，然后在左侧的语言栏里面选中 <strong>Node.JS</strong> ，点击送出，你就能看到你的第一个 <strong>Node.JS</strong> 程序的运行结果了。</p>
<p><strong><em>To be continued…</em></strong></p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于JavaScript中callback函数的this指针重定义]]></title>
    <link href="http://xcoder.in/2013/07/15/javascript-callback-this-bind/"/>
    <id>http://xcoder.in/2013/07/15/javascript-callback-this-bind/</id>
    <published>2013-07-15T05:20:29.000Z</published>
    <updated>2014-04-11T04:19:06.000Z</updated>
    <content type="html"><![CDATA[<p>最近在写 <strong>NBUT Virtual Judge</strong> 的内核框架，用的又是 <strong>Node.JS</strong> 了，把它当作一个本地运行的脚本不断进行轮询。</p>
<p>　　众所周知JS中的一个精髓就是异步回调。</p>
<p>　　所以在我自己写的框架中也经常会出现类似于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>foo.bar(a, b, <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>});
</pre></td></tr></table></figure>

<p>　　总而言之就是写一个函数，这个函数将会调用一个回调函数。</p>
<p>　　但是问题出现了：在那个回调函数 <code>function</code> 中，你如果使用了一个 <code>this</code> 指针的话，它将会指向根，而不是 <code>foo</code> 的本体。</p>
<p>　　那么如果我们想在 <code>function</code> 中也用 <code>this</code> 来指代这个 <code>foo</code> 对象该怎么办呢？</p>
<p>　　结果还是IRC有用。本人跑 <strong>Node.JS</strong> 的 <strong>IRC</strong> 上问了这个问题，结果有人就这样回复我了：</p>
<blockquote>
<p>13:07 &lt;shama&gt; xadillax: foo(a, b callback.bind(foo))</p>
<p>13:10 &lt;olalonde&gt; foo (a, b fn) { fn = fn.bind(this); …. }</p>
</blockquote>
<p>　　然后还很热心地给了我个网址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>
<p>　　总之最后得出的结论就是说：</p>
<p>　　你只要给你的 <code>callback</code> 函数指定一个 <code>this</code> 指针即可。</p>
<p>　　如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> cb = callback.bind(foo);
foo.bar(a, b, cb);
</pre></td></tr></table></figure>

<p>　　这样就能在回调函数中使用foo来作为其this指针了。</p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Node.js下的MongoDB阻塞模式实现]]></title>
    <link href="http://xcoder.in/2013/03/29/nodejs-mongodb-sync/"/>
    <id>http://xcoder.in/2013/03/29/nodejs-mongodb-sync/</id>
    <published>2013-03-29T00:31:38.000Z</published>
    <updated>2014-04-11T04:39:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>注：本文仅为我初学 Node.JS 的时候的稚嫩笔记。是从 <a href="http://web.archive.org/" target="_blank">http://web.archive.org/</a> 扒回来的。现在看来已无多大参考价值，各位可以略过。我只是把它扒回来纪念一下而已，以记录我的历程。而那个相对应的 <code>SevenzJS</code> 也已经被遗弃</em></strong></p>
<h2 id="背景">背景</h2>
<p>　　最近在做公司项目的一个模块，主要用于 <strong>JSON Api</strong> 的传输，所以开发环境的目标就锁定在了 <strong>Node.js</strong>。而这一块的登陆用户又是存在 <strong>MongoDB</strong> 里面的，所以就有了如下的问题。</p>
<ul>
<li>网上的 Node.JS 框架都比较重型或者臃肿的，学了 Node 之后还需要学额外的东西。</li>
<li>所以我就打算自己写一个专注于 JSON Api 的快速开发框架，于是有了 SevenJS。</li>
<li>问题出现了，虽然 Node.JS 极度推崇异步非阻塞模式，但是阻塞模式在平常开发中还是太常用了。</li>
</ul>
<p>　　我们试想一下，如果我们有几句MongoDB的查询之类的，用node-mongodb-native来写的话是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> client = <span class="keyword">new</span> Db(<span class="string">'test'</span>, <span class="keyword">new</span> Server(<span class="string">"127.0.0.1"</span>, <span class="number">27017</span>, {}));
<span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="params">(err, collection)</span> {</span>
    collection.insert({a:<span class="number">2</span>}, <span class="function"><span class="keyword">function</span><span class="params">(err, docs)</span> {</span>
        collection.count(<span class="function"><span class="keyword">function</span><span class="params">(err, count)</span> {</span>
            test.assertEquals(<span class="number">1</span>, count); });

            <span class="comment">// Locate all the entries using find</span>
            collection.find().toArray(<span class="function"><span class="keyword">function</span><span class="params">(err, results)</span> {</span>
            test.assertEquals(<span class="number">1</span>, results.length);
            test.assertTrue(results[<span class="number">0</span>].a === <span class="number">2</span>);

            <span class="comment">// Let's close the db</span>
            client.close();
        });
    });
};

client.open(<span class="function"><span class="keyword">function</span><span class="params">(err, client)</span> {</span>
    client.collection(<span class="string">'test_insert'</span>, test);
});
</pre></td></tr></table></figure>

<p>　　各种嵌套回调有木有！这不是我们想要的，尤其是我的那个框架，因为我的框架是流式的。</p>
<p>　　所以我就想有这样的一种方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> client = mongodb.connect();
<span class="keyword">var</span> collection = mongodb.getCollection(client, <span class="string">"dbname"</span>);
<span class="keyword">var</span> result = mongodb.find({ <span class="string">"foo"</span> : <span class="string">"bar"</span> });
</pre></td></tr></table></figure>

<p>　　使得这样就能找出dbname表下的foo为bar值的记录了。</p>
<h2 id="正题">正题</h2>
<p>　　出于这样的想法，我在网上找遍了大江南北，除了 CNode 社区有人问到了类似的问题以外，再也找不到音信了，而且那里也没有一个好的回答。</p>
<p>　　不过这也正常，因为 Node.js 官方本身就不推荐这么做——他们认为异步非阻塞是非常优雅的一件事情。</p>
<p>　　包括我在 Node.js 的 IRC 聊天室里面问了这个问题，也有人是这么回答我的：</p>
<blockquote>
<p>You can’t use a car as a boat. If you want a boat, use a boat.</p>
</blockquote>
<p>　　言简意赅，直截了当地说明 Node.js 是不支持这样的，如果你想这样做，就用 python 或者 ruby 去吧。</p>
<p>　　不过好在后来 IRC 里面有人推荐了我一个模块：<a href="https://github.com/laverdet/node-fibers" target="_blank">fibers</a>。</p>
<p>　　有了这个模块好啊，直接能用了有木有！</p>
<p>　　接下来就来讲一下如何使用吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(collection, selector, callback)</span> {</span>
    collection.find(selector).toArray(callback);
}

<span class="keyword">var</span> Fiber = <span class="built_in">require</span>(<span class="string">'fibers'</span>);
<span class="keyword">var</span> Future = <span class="built_in">require</span>(<span class="string">'fibers/future'</span>);
<span class="keyword">var</span> wait = Future.wait;

Fiber(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> wrapper = Future.wrap(fund);

    <span class="comment">/** 这里就是正题了，我们假设已经获取一个collection了 */</span>
    <span class="keyword">var</span> result = wrapper(collection, { <span class="string">"foo"</span> : <span class="string">"bar"</span> }).wait();
    console.log(<span class="built_in">JSON</span>.stringify(result));
}).run();
</pre></td></tr></table></figure>

<p>　　这就是一个非常简单的同步查询 MongoDB 的例子了，实际上本质还是一个异步，注意到没有，其实 <code>Fiber()</code> 内部的那个 <code>function</code> 本质上还是一个回调函数，只不过在这个回调函数里面，里面的所有 <code>callback</code> 都可以被同步了。不过我们只需要小动一些手脚就能加上这个外壳了。具体请参见 <a href="https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/sevenz/sRouter.js" target="_blank">sRouter.js</a> 约 121 行的外壳以及 <a href="https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/sevenz/sMongoSync.js" target="_blank">sMongoSync.js</a> 的实现，加上 <a href="http://web.archive.org/web/20130726042859/https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/actions/index.js" target="_blank">index.js</a> 中的查询 demo。</p>
<h2 id="结尾">结尾</h2>
<p>　　所以说当我们做不到某件事的时候，多去IRC看看，多去社区混混，也多去找找模块，要真没有的话就只能自己丰衣足食了（我还没到那水平，笑）。总之这次Fibers帮了我一个大忙。</p>
<p>　　最后，SevenzJS 欢迎 <a href="https://github.com/XadillaX/SevenzJS" target="_blank">Fork</a>。</p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="Node.JS" scheme="http://xcoder.in/tags/Node.JS/"/>
    
      <category term="MongoDB" scheme="http://xcoder.in/tags/MongoDB/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于jQuery中“animate()”函数对颜色变化的支持]]></title>
    <link href="http://xcoder.in/2012/12/24/jquery-animate-color-support/"/>
    <id>http://xcoder.in/2012/12/24/jquery-animate-color-support/</id>
    <published>2012-12-24T00:20:16.000Z</published>
    <updated>2014-04-11T04:37:09.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做一个汽车团购网的项目，由于老大力求简洁，所以界面做得有些小清新。不过得说一下页面不是我设计的，是一位美工同志。</p>
<p>　　废话不多说，直接切入正题吧——</p>
<p>　　我要做得就是让下面一段代码生效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$(<span class="string">"#yourid"</span>).stop().animate({ <span class="string">"backgroundColor"</span> : <span class="string">"#rrggbb"</span>, <span class="string">"color"</span> : <span class="string">"#rrggbb"</span> }, <span class="string">"fast"</span>);
</pre></td></tr></table></figure>

<p>　　但是，很遗憾，一点也没有动。本来效果应该跟这个版本的xcoder博客的天头导航条一样有个动态效果（只不过xcoder的导航条是透明度变化，而项目中我想让它背景色变化）。</p>
<p>　　原因是什么呢？死月上网查了很久，找到的东西都很简单地说明了一下，貌似都可以。嘛，也许是jQuery新版本不支持这个特性了吧。</p>
<p>　　最后，死月在jQuery的官方文档中找到了下面这段话——</p>
<blockquote>
<p>All animated properties should be animated to <strong><em>a single numeric value</em></strong>, except as noted below; most properties that are non-numeric cannot be animated using basic jQuery functionality (For example, width, height, or left can be animated but background-color cannot be, unless the <a href="https://github.com/jquery/jquery-color" target="_blank">jQuery.Color()</a> plugin is used). Property values are treated as a number of pixels unless otherwise specified. The units em and % can be specified where applicable.</p>
<p style="text-align: right">—— <a href="http://api.jquery.com/animate/" target="_blank">jQuery官方文檔 .animate()</a></p>

</blockquote>
<p>　　大致的意思就是说所有动画属性都必须是一个单数字值，所以说大多数非数字的属性是不能被动画化的。例如高度、宽度等可以被动画化，但是背景色就不信了。<span style="color: red;"><strong><em>除非你用了jQuery.Color()插件</em></strong></span>。</p>
<p>　　所以说问题找到了，我们必须得用一个jQuery.Color()插件来对一些颜色进行动画操作。</p>
<p>　　话不多说，我们去下一个jQuery.Color()插件。把它加在我们的页面中，然后就可以用如下方式来进行动画操作了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$(<span class="keyword">this</span>).stop().animate({
    <span class="string">"backgroundColor"</span> : jQuery.Color(<span class="string">"rrggbb"</span>),
    <span class="string">"color"</span> : jQuery.Color(<span class="string">"rrggbb"</span>)
}, <span class="string">"fast"</span>);
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="jQuery" scheme="http://xcoder.in/tags/jQuery/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程安全——Scope Lock模式]]></title>
    <link href="http://xcoder.in/2012/09/08/scope-lock/"/>
    <id>http://xcoder.in/2012/09/08/scope-lock/</id>
    <published>2012-09-07T16:31:59.000Z</published>
    <updated>2014-04-11T04:44:23.000Z</updated>
    <content type="html"><![CDATA[<p><strong><em>嘛，本文是建立在M$的Visual Studio基础上的，linux☭勿喷。</em></strong></p>
<p>　　我最先用到 ScopeLock 模式是在自己开发 <strong>XAE引擎</strong> 的时候。在里面用到挺多的线程函数，那么如何解决临界区就成了一个重要的课题。可能大家想，不就一个线程锁临界区什么的么，一个 <code>EnterCriticalSection</code> 和一个 <code>LeaveCriticalSection</code> 不就解决了么？</p>
<p>　　其实不然。在 <strong>M$</strong> 中，最常用的当然就是 <code>CRITICAL_SECTION</code> 了，但是如果临界区上锁却木有解锁呢？这就会发生死锁现象。对于一个粗心的程序猿来说这样的错误还是有几率发生的。就算你足够细心，还是有时候会一失足成千古恨。</p>
<p>　　所以就有了这么一种方法来杜绝这种死锁的产生—— <code>ScopeLock</code>。</p>
<p>　　那么什么叫 <code>ScopeLock</code>？</p>
<p>　　我们试想一下如果有这么一个类——在构造的时候，你传进去一个 <code>CRITICAL_SECTION</code> 的引用并且将其 <code>EnterCriticalSection</code> 进入到临界区。当它析构的时候，我们直接 <code>LeaveCriticalSection</code> 就好了。</p>
<p>　　也许你会问，这样的一个类会有什么用呢？</p>
<p>　　那么我下面演示一段简单的 ScopeLock 代码先吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">struct</span> ScopeLock
{
    CRITICAL_SECTION& m_cs;

    ScopeLock(CRITICAL_SECTION cs) : m_cs(cs)
    {
        EnterCriticalSection(&m_cs);
    }

    ~ScopeLock()
    {
        LeaveCriticalSection(&m_cs);
    }
};

<span class="keyword">int</span> i;
CRITICAL_SECTION cs;

<span class="comment">// ...假设我们已经初始化好了这个临界区</span>

<span class="keyword">void</span> ScopeLockTest()
{
    ScopeLock oLock(cs);
    i = <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>　　我们可以发现，当我们刚进入 <code>ScopeLockTest</code> 函数的时候，声明了一个 <code>oLock</code> 对象，这个时候运行 <code>oLock</code> 的构造函数，也就是进入了 <code>cs</code> 这个临界区。而当 <code>ScopeLockTest</code> 函数运行完毕要退出这个函数的时候，<code>oLock</code> 对象的生命周期也就走到了尽头，对应的，它将会执行析构函数，那么就自然而然地退出了 <code>cs</code> 临界区。</p>
<p>　　其实无论 <code>ScopeLockTest</code> 这个函数怎么写，哪怕是中间有一些 <code>if</code> 判断直接 <code>return</code> 掉，只要是 <code>ScopeLockTest</code> 这个函数执行完毕，<code>oLock</code> 就会自动析构，从而达到了解锁过程。那么不管粗心还是细心的童鞋们都不用为忘记退出临界区而烦恼了。</p>
<p>　　而且 <code>ScopeLock</code> 模式只是一种思想，并不是对于 <strong>M$</strong> 的临界区的一种专用性物品。例如在QT里，我们一样可以用 <code>ScopeLock</code> 来对线程的一些 <code>MutexLock</code> 之类的东西进行操作。</p>
<p>　　上面所写的例子只是思路的一种形成，并不是一个完整的ScopeLock类（结构体），虽然说它现在已经可以用了。你可以在上面完善，加上自己的东西，使其能确确实实在项目中使用。由于代码的关联性，我单单发出我的 <code>ScopeLock</code> 的话会缺少很多关联的东西，所以咱就不发了，思路在这里，相信谁都能写出自己的一个 <code>ScopeLock</code> 吧。</p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="ScopeLock" scheme="http://xcoder.in/tags/ScopeLock/"/>
    
      <category term="线程安全" scheme="http://xcoder.in/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程死锁" scheme="http://xcoder.in/tags/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CodeForces Round 128 DIV2]]></title>
    <link href="http://xcoder.in/2012/07/04/codeforces-128-div2/"/>
    <id>http://xcoder.in/2012/07/04/codeforces-128-div2/</id>
    <published>2012-07-04T02:38:59.000Z</published>
    <updated>2014-04-11T04:58:57.000Z</updated>
    <content type="html"><![CDATA[<p>这次玩脱了。好不容易四题都做出来，却因为小细节挂了两题。</p>
<h2 id="Description">Description</h2>
<h3 id="Two_Problems">Two Problems</h3>
<p>　　题意就是说，CF有两题，每题初始分A和B，然后每题在每分钟会扣DA和DB分。给你比赛总时间T，问你某个人可不可能拿到X分。（注意可能做出一题、两题或者一题也没做出）</p>
<p>　　(0 ≤ x ≤ 600; 1 ≤ t, a, b, da, db ≤ 300且保证及时比赛时间到了各题的分数也不会小于0)</p>
<h3 id="Game_on_Paper">Game on Paper</h3>
<p>　　有一个 N<em>N 方格纸。在上面的方格里一格格涂黑。每一步涂一格一共涂 m 次，给定 xi 和 yi。问最少涂几步方格纸里会出现一个 3</em>3 的正方形。</p>
<p>　　(1 ≤ n ≤ 1000, 1 ≤ m ≤ min(n· n, 105))</p>
<h3 id="Photographer">Photographer</h3>
<p>　　照相内存卡里有d容量。其中高质量照片占a容量、低质量占b容量。然后有n个顾客，每个顾客需要xi张高质量照片和yi张低质量照片。摄影师如果给一个人拍照了，就应该满足他所有要求（即给xi张高质量照片和yi张低质量照片）。问摄影师最多能给几个人拍照。</p>
<p>　　(1 ≤ n ≤ 105, 1 ≤ d ≤ 109, 1 ≤ a ≤ b ≤ 104, 0 ≤ xi, yi ≤ 105)</p>
<h3 id="Hit_Ball">Hit Ball</h3>
<p>　　封闭房间里，从房间的一头最底下的中间以某个方向踢球（一定是网对面踢），问踢到另一头的墙上的时候，x、z各是多少。</p>
<p>　　(各坐标以及向量都是小于等于100的正整数)</p>
<p><img src="hit-ball.png" alt="Hit Ball"></p>
<h3 id="Transportation">Transportation</h3>
<p>　　还没看。</p>
<h2 id="Analysis">Analysis</h2>
<h3 id="Two_Problems-1">Two Problems</h3>
<p>　　这题只要注意几个trick就行了：可以做出0题、1题或者2题。直接两个for枚举各题在几分钟内做出来，然后做一下0题、1题的特殊判断就好了。</p>
<h3 id="Game_on_Paper-1">Game on Paper</h3>
<p>　　在每次涂的时候，以当前涂的点位中心，设它为九宫格的其中一个位置（一共九种位置），对于每种位置，都判断其对应的九宫格是不是 3*3 的黑色就好了。(我做的时候在设位置的时候 x - 1, y - 1 手贱敲成了 x - 1, y - 2，lock 之后才发现。悲剧)</p>
<h3 id="Photographer-1">Photographer</h3>
<p>　　贪心。对于每个人将其所需的总容量算出来再进行递增排序。最后求的时候推荐累减的方式判断，因为我累加然后用 int 最后爆范围了。</p>
<h3 id="Hit_Ball-1">Hit Ball</h3>
<p>　　首先拿出空间几何的线面相交模板。然后来一个 <code>while</code>，每次循环的时候判断当前所在的点与方向适量形成的直线与 (X, 0, Z) 面的交点在不在终点墙壁大小的范围内。若不是则说明中途撞墙了判断方向向量：x &lt; 0则线面相交判断是不是撞左墙，若是则 x 正负值变一下；x &gt; 0 则线面相交判断是不是撞右墙，若是则 x 正负值变一下。z &lt; 0则判断是不是以求抢地，若是则 z 正负变一下。最后 z &gt; 0 则判断是不是撞天花板，若是则z正负值变一下。然后以球撞击的点为新的起点，与新的方向向量形成新的直线，继续下一次循环。因为房间大小最大是 100 <em> 100 </em> 100，而方向向量各方向是 1 到 100 的整数，不是小数，则撞击次数不会很多，直接 <code>while</code> 撞击也不会超。</p>
<h2 id="Code">Code</h2>
<h3 id="Two_Problems-1">Two Problems</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> x, t, a, b, da, db;
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &x, &t, &a, &b, &da, &db))
    {
        <span class="keyword">bool</span> flag = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)
        {
            <span class="keyword">if</span>(x == a - i * da)
            {
                flag = <span class="keyword">true</span>;
                <span class="keyword">break</span>;
            }

            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)
            {
                <span class="keyword">if</span>(x == b - j * db)
                {
                    flag = <span class="keyword">true</span>;
                    <span class="keyword">break</span>;
                }

                <span class="keyword">if</span>(x == a - i * da + b - j * db)
                {
                    flag = <span class="keyword">true</span>;
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(<span class="number">0</span> == x) flag = <span class="keyword">true</span>;

        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, flag ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h3 id="Game_on_Paper-1">Game on Paper</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">bool</span> mat[<span class="number">1015</span>][<span class="number">1015</span>];

<span class="keyword">bool</span> check2(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy)
{
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)
        {
            <span class="comment">//if(i == 1 && j == 1) continue;</span>

            <span class="keyword">if</span>(!mat[sx + i][sy + j]) <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> check(<span class="keyword">int</span> x, <span class="keyword">int</span> y)
{
    <span class="keyword">if</span>(check2(x, y)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n, m;
    <span class="keyword">int</span> x, y;
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &n, &m))
    {
        <span class="keyword">int</span> ans = -<span class="number">1</span>;
        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)
        {
            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &x, &y);
            mat[x + <span class="number">1</span>][y + <span class="number">1</span>] = <span class="keyword">true</span>;

            <span class="keyword">if</span>(ans == -<span class="number">1</span>)
            {
                <span class="keyword">if</span>(check(x + <span class="number">1</span>, y + <span class="number">1</span>))
                {
                    ans = i + <span class="number">1</span>;
                }
            }
        }

        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h3 id="Photographer-2">Photographer</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">struct</span> client
{
    <span class="keyword">int</span> id;
    <span class="keyword">int</span> memo;
};

<span class="keyword">bool</span> cmp(client a, client b)
{
    <span class="keyword">return</span> a.memo &lt; b.memo;
}

client c[<span class="number">100005</span>];

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n;
    __int64 d;
    <span class="keyword">int</span> a, b;
    <span class="keyword">int</span> x, y;

    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>, &n, &d))
    {
        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &a, &b);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        {
            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &x, &y);
            c[i].id = i + <span class="number">1</span>;
            c[i].memo = a * x + b * y;
        }

        sort(c, c + n, cmp);
        __int64 sum = <span class="number">0L</span>;
        <span class="keyword">int</span> maxi = -<span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        {
            <span class="keyword">if</span>(sum + c[i].memo &lt;= d) sum += c[i].memo, maxi = i;
            <span class="keyword">else</span> <span class="keyword">break</span>;
        }

        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxi + <span class="number">1</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxi; i++)
        {
            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, c[i].id, i == maxi ? <span class="string">'\n'</span> : <span class="string">' '</span>);
        }
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h3 id="Hit_Ball-1">Hit Ball</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="preprocessor">#define eps 1e-8</span>
<span class="preprocessor">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span>
<span class="keyword">struct</span> point3{<span class="keyword">double</span> x,y,z;};
<span class="keyword">struct</span> line3{point3 a,b;};
<span class="keyword">struct</span> plane3{point3 a,b,c;};

point3 xmult(point3 u,point3 v){
    point3 ret;
    ret.x=u.y*v.z-v.y*u.z;
    ret.y=u.z*v.x-u.x*v.z;
    ret.z=u.x*v.y-u.y*v.x;
    <span class="keyword">return</span> ret;
}

point3 subt(point3 u,point3 v){
    point3 ret;
    ret.x=u.x-v.x;
    ret.y=u.y-v.y;
    ret.z=u.z-v.z;
    <span class="keyword">return</span> ret;
}

point3 pvec(plane3 s){
    <span class="keyword">return</span> xmult(subt(s.a,s.b),subt(s.b,s.c));
}

point3 intersection(line3 l,plane3 s){
    point3 ret=pvec(s);
    <span class="keyword">double</span> t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/
        (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));
    ret.x=l.a.x+(l.b.x-l.a.x)*t;
    ret.y=l.a.y+(l.b.y-l.a.y)*t;
    ret.z=l.a.z+(l.b.z-l.a.z)*t;
    <span class="keyword">return</span> ret;
}

<span class="keyword">int</span> main()
{
    <span class="keyword">double</span> a, b, m;
    <span class="keyword">double</span> vx, vy, vz;

    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &a, &b, &m, &vx, &vy, &vz))
    {
        <span class="comment">/** 5 walls */</span>
        plane3 door, lw, rw, top, ground;
        door.a.x = <span class="number">0</span>, door.a.y = <span class="number">0</span>, door.a.z = <span class="number">0</span>;
        door.b.x = <span class="number">1</span>, door.b.y = <span class="number">0</span>, door.b.z = <span class="number">0</span>;
        door.c.x = <span class="number">0</span>, door.c.y = <span class="number">0</span>, door.c.z = <span class="number">1</span>;
        lw.a.x = <span class="number">0</span>, lw.a.y = <span class="number">0</span>, lw.a.z = <span class="number">0</span>;
        lw.b.x = <span class="number">0</span>, lw.b.y = <span class="number">1</span>, lw.b.z = <span class="number">0</span>;
        lw.c.x = <span class="number">0</span>, lw.c.y = <span class="number">0</span>, lw.c.z = <span class="number">1</span>;
        rw.a.x = a, rw.a.y = <span class="number">0</span>, rw.a.z = <span class="number">0</span>;
        rw.b.x = a, rw.b.y = <span class="number">1</span>, rw.b.z = <span class="number">0</span>;
        rw.c.x = a, rw.c.y = <span class="number">0</span>, rw.c.z = <span class="number">1</span>;
        ground.a.x = <span class="number">0</span>, ground.a.y = <span class="number">0</span>, ground.a.z = <span class="number">0</span>;
        ground.b.x = a, ground.b.y = <span class="number">0</span>, ground.b.z = <span class="number">0</span>;
        ground.c.x = a / <span class="number">2</span>, ground.c.y = m, ground.c.z = <span class="number">0</span>;
        top.a.x = <span class="number">0</span>, top.a.y = <span class="number">0</span>, top.a.z = b;
        top.b.x = a, top.b.y = <span class="number">0</span>, top.b.z = b;
        top.c.x = a / <span class="number">2</span>, top.c.y = m, top.c.z = b;

        line3 l;

        l.a.x = a / <span class="number">2</span>;
        l.a.y = m;
        l.a.z = <span class="number">0</span>;

        l.b.x = (a / <span class="number">2</span>) + vx;
        l.b.y = m + vy;
        l.b.z = vz;

        point3 v;
        v.x = vx, v.y = vy, v.z = vz;

        point3 myans;
        <span class="keyword">while</span>(<span class="keyword">true</span>)
        {
            point3 ans, ans1, ans2, ans3, ans4;
            <span class="built_in">memset</span>(&ans1, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));
            <span class="built_in">memset</span>(&ans2, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));
            <span class="built_in">memset</span>(&ans3, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));
            <span class="built_in">memset</span>(&ans4, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));

            ans = intersection(l, door);
            <span class="keyword">if</span>(ans.x &gt;= <span class="number">0</span> && ans.z &gt;= <span class="number">0</span> && ans.x &lt;= a && ans.z &lt;= b)
            {
                myans = ans;
                <span class="keyword">break</span>;
            }

            point3 totans;

            <span class="keyword">if</span>(v.x &lt; <span class="number">0</span>)
            {
                ans1 = intersection(l, lw);
                <span class="keyword">if</span>(ans1.z &gt;= <span class="number">0</span> && ans1.z &lt;= b)
                {
                    v.x = -v.x;
                    totans = ans1;
                }
            }
            <span class="keyword">else</span>
            <span class="keyword">if</span>(v.x &gt; <span class="number">0</span>)
            {
                ans2 = intersection(l, rw);
                <span class="keyword">if</span>(ans2.z &gt;= <span class="number">0</span> && ans2.z &lt;= b)
                {
                    v.x = -v.x;
                    totans = ans2;
                }
            }

            <span class="keyword">if</span>(v.z &gt; <span class="number">0</span>)
            {
                ans3 = intersection(l, top);
                <span class="keyword">if</span>(ans3.x &gt;= <span class="number">0</span> && ans3.x &lt;= a)
                {
                    v.z = -v.z;
                    totans = ans3;
                }
            }
            <span class="keyword">else</span>
            <span class="keyword">if</span>(v.z &lt; <span class="number">0</span>)
            {
                ans4 = intersection(l, ground);
                <span class="keyword">if</span>(ans4.x &gt;= <span class="number">0</span> && ans4.x &lt;= a)
                {
                    v.z = -v.z;
                    totans = ans4;
                }
            }

            l.a = totans;
            l.b = totans;
            l.b.x += v.x;
            l.b.y += v.y;
            l.b.z += v.z;
        }

        <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, myans.x, myans.z);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="CodeForces" scheme="http://xcoder.in/tags/CodeForces/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HGE做格斗游戏的热点图片碰撞检测法]]></title>
    <link href="http://xcoder.in/2011/10/18/hge-hotspot-collision/"/>
    <id>http://xcoder.in/2011/10/18/hge-hotspot-collision/</id>
    <published>2011-10-18T06:22:21.000Z</published>
    <updated>2014-04-11T05:18:04.000Z</updated>
    <content type="html"><![CDATA[<p>碰撞检测始终是做2D游戏中的一个热点话题，我本人并没有做过这类游戏，所以一切只是理论而已，不过正打算做这么个小游戏练练手。</p>
<p>　　前几天在HGE的群里看到有人突然问到如何判断鼠标有没有点到人（点到纹理的透明区域不算），从而引申出了碰撞检测问题。</p>
<p>　　他的问题相对好实现，只要算出纹理所按的点是不是透明即可。</p>
<p>　　接下来我得做下碰撞检测的笔记：</p>
<p>　　碰撞检测最常用一个方法就是关节设置（当然我并没有做过），关节设置的话因为只是判断多边形的重叠状况，算法的复杂度低、效率高，虽然做工有点粗，但总体效果还是性价比比较高的一种方法。当然，这样的方法需要对每一帧的纹理都设置一个关节，对于人工的代价就稍微大了一些了，并且还要写个关节编辑器啊神马的，于是乎代码量又增加了。我这次是和同寝室木有一点基础的童鞋一起练手的，所以并没有打算引进这个方法。</p>
<p>　　于是我就用了另一种稍微“非主流”一些的方法了——逐像素判断。</p>
<p>　　但是逐像素判断还是有问题的——如果你的一个“效果”因为“温度过高”而不需要显示，直接隐藏，但又算伤害，这时纹理的逐像素就失去了意义。于是又有了个“臃肿”的办法，为需要“额外附加像素”的纹理另做一张图片，这张图片上有两种区域——热点区和非热点区。我们把需要“当做空气”的那些区域一律用某一种极其不常用的颜色覆盖，如 <code>ff00ff</code> 这种变态的粉色，然后其它区域的颜色就随你怎么搞了。我们载入的时候两张纹理一起载入，显示的时候显示正常的纹理，而在碰撞检测的时候用“热点图片”来进行逐像素检测。</p>
<p>　　与上面的关节设置法比较的话，人工的工作量我个人认为是大大地减少了，至于对于机器的执行能力来说，把时间复杂度提到了 <code>O(mn)</code> ，平方级的复杂度了，即纹理相交区域的宽和高。</p>
<p>　　我们来看一下这种碰撞检测的大体流程吧：</p>
<ol>
<li>获得两个精灵的矩形，并得到相交矩形。若无相交则直接返回 <code>false</code>。</li>
<li>根据相交矩形，我们可以得到精灵1、2的纹理中需要检测的初始坐标。</li>
<li>将精灵1、精灵2的热点图片的相交区域的那一部分像素拷贝出来备用。（因为有可能两个纹理句柄是一样的，不好同时 <code>lock</code>）</li>
<li>开始对于拷贝出来的像素信息逐一判断对应像素点是否都“不是空气”，若都“不是空气”则可以判断为碰撞。</li>
</ol>
<p>　　当然以上的流程我们还可以优化一下，省去拷贝的那一段时间。我们可以直接 <code>hge-&gt;Texture_Lock()</code> 来进行得到两个纹理的像素信息的首指针，如果两个纹理其实只是一个纹理的话，则只需 <code>hge-&gt;Texture_Lock()</code> 一次，而另一个指针也只想 <code>hge-&gt;Texture_Lock</code> 即可，然后直接开始判断。</p>
<p>　　下面献上我这个函数的实现以及测试代码和素材：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="code"><pre><span class="comment">/**
 * @brief   Test the collision by the "hot" texture
 * @author  XadillaX
 * @email   admin@xcoder.in
 * @date    2011/10/18
 * @http://xcoder.in
 *
 * @param spr1 The first sprite to test the collision
 * @param x1 "x" of top-left corner of sprite 1
 * @param y1 "y" of top-left corner of sprite 1
 * @param spr2 The second sprite to test the collision
 * @param x2 "x" of top-left corner of sprite 2
 * @param y2 "y" of top-left corner of sprite 2
 * @param hot1 The "hot" texture for sprite 1. It will be the default texture of spr1 if it equal to 0
 * @param hot2 The "hot" texture for sprite 2. It will be the default texture of spr2 if it equal to 0
 * @param airColor The color which considered of "air"
 *
 * @return if they are collided, return true
 */</span>
<span class="keyword">bool</span> IsCollision(hgeSprite* spr1, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, hgeSprite* spr2, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, HTEXTURE hot1 = <span class="number">0</span>, HTEXTURE hot2 = <span class="number">0</span>, DWORD airColor = <span class="number">0xffff00ff</span>)
{
    <span class="comment">/** Set the rect */</span>
    hgeRect r1, r2;
    r1.Set(x1, y1, x1 + spr1-&gt;GetWidth(), y1 + spr1-&gt;GetHeight());
    r2.Set(x2, y2, x2 + spr2-&gt;GetWidth(), y2 + spr2-&gt;GetHeight());

    <span class="comment">/** Test for the intersect of rectangles */</span>
    <span class="keyword">if</span>(r1.Intersect(&r2))
    {
        <span class="keyword">int</span> x[] = { x1, x2, x1 + spr1-&gt;GetWidth(), x2 + spr2-&gt;GetWidth() };
        <span class="keyword">int</span> y[] = { y1, y2, y1 + spr1-&gt;GetHeight(), y2 + spr2-&gt;GetHeight() };
        <span class="built_in">std</span>::sort(x, x + <span class="number">4</span>);
        <span class="built_in">std</span>::sort(y, y + <span class="number">4</span>);
        hgeRect r;

        <span class="comment">/** Set the rectangle area where the two rectangles intersected. */</span>
        r.Set(x[<span class="number">1</span>], y[<span class="number">1</span>], x[<span class="number">2</span>], y[<span class="number">2</span>]);

        <span class="comment">/** The start point of sprite1 and sprite2. (From the intersected area) */</span>
        <span class="keyword">int</span> sx1, sy1, sx2, sy2;
        sx1 = x[<span class="number">1</span>] - x1;
        sy1 = y[<span class="number">1</span>] - y1;
        sx2 = x[<span class="number">1</span>] - x2;
        sy2 = y[<span class="number">1</span>] - y2;

        <span class="comment">/** Get the "hotspot" of texture */</span>
        HTEXTURE hTex1 = hot1;
        HTEXTURE hTex2 = hot2;
        <span class="keyword">if</span>(hTex1 == <span class="number">0</span>) hTex1 = spr1-&gt;GetTexture();
        <span class="keyword">if</span>(hTex2 == <span class="number">0</span>) hTex2 = spr2-&gt;GetTexture();

        <span class="keyword">float</span> tx1, ty1, tw1, th1, tx2, ty2, tw2, th2;
        <span class="keyword">int</span> w1 = hge-&gt;Texture_GetWidth(hTex1), w2 = hge-&gt;Texture_GetWidth(hTex2);
        spr1-&gt;GetTextureRect(&tx1, &ty1, &tw1, &th1);
        spr2-&gt;GetTextureRect(&tx2, &ty2, &tw2, &th2);

        DWORD* color1 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];
        DWORD* color2 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];
        DWORD* color;

        <span class="comment">/** Copy the effectivearea of texture 1 */</span>
        color = hge-&gt;Texture_Lock(hTex1, <span class="keyword">true</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)
            { 
                color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty1 + sy1) * w1 + (<span class="keyword">int</span>)tx1 + sx1 + i * w1 + j];
            } 
        } 
        hge-&gt;Texture_Unlock(hTex1);

        <span class="comment">/** Copy the effectivearea of texture 2 */</span>
        color = hge-&gt;Texture_Lock(hTex2, <span class="keyword">true</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++) 
            { 
                color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty2 + sy2) * w2 + (<span class="keyword">int</span>)tx2 + sx2 + i * w1 + j]; 
            } 
        } 
        hge-&gt;Texture_Unlock(hTex2);

        <span class="comment">/** Test for the collision */</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)
            {
                <span class="keyword">if</span>(color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor && color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor)
                {
                    <span class="keyword">delete</span> []color1;
                    <span class="keyword">delete</span> []color2;

                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }
            }
        }

        <span class="keyword">delete</span> []color1;
        <span class="keyword">delete</span> []color2;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;
}
</pre></td></tr></table></figure>

<p><a href="src.rar">点击下载</a></p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="HGE" scheme="http://xcoder.in/tags/HGE/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于HGE的透明背景处理]]></title>
    <link href="http://xcoder.in/2011/09/13/hge-transparent-color/"/>
    <id>http://xcoder.in/2011/09/13/hge-transparent-color/</id>
    <published>2011-09-13T03:12:32.000Z</published>
    <updated>2014-04-11T05:22:23.000Z</updated>
    <content type="html"><![CDATA[<p>嘛 = = 在做那个项目的动画预览器的时候，因为那引擎封装得太麻烦了，于是自己基于HGE再移植一遍，发现其中有一个SetTransparentColor函数，即设置透明色。</p>
<p>　　拿出来分享一下吧。</p>
<p>　　其实方法很简单，<code>HTEXTURE</code> 是纹理句柄，当你用 <code>Texture_Lock</code> 这个函数锁定这个纹理的时候，它的返回值就是这个纹理在内存中的首地址。也就是说接下来的 width * height 个地址中就是这个纹理的每一个像素了。既然要设置透明色，只要对于每个像素判断一下与运算一下就好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>HTEXTURE SetTransColor(HTEXTURE hTex, DWORD dwColor)
{
    <span class="comment">/** 注：上面的dwColor代表的是RGB，不是ARGB */</span>
    <span class="keyword">static</span> HGE* hge = hgeCreate(HGE_VERSION);

    <span class="keyword">int</span> size = hge-&gt;Texture_GetWidth(hTex) * hge-&gt;Texture_GetHeight(hTex);
    DWORD* dwTex = hge-&gt;Texture_Lock(hTex);
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)
    {
        <span class="keyword">if</span>((dwTex[i] & <span class="number">0x00FFFFFF</span>) == dwColor)
        {
            dwTex[i] &= <span class="number">0x00FFFFFF</span>;
        }
    }
    hge-&gt;Texture_Unlock(hTex);

    <span class="keyword">return</span> hTex;
}
</pre></td></tr></table></figure>

<p>　　嘛，这样一来，就透明了~</p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="HGE" scheme="http://xcoder.in/tags/HGE/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于游戏资源包的更新、删除]]></title>
    <link href="http://xcoder.in/2011/06/16/resource-pack/"/>
    <id>http://xcoder.in/2011/06/16/resource-pack/</id>
    <published>2011-06-15T16:20:31.000Z</published>
    <updated>2014-04-11T05:27:18.000Z</updated>
    <content type="html"><![CDATA[<p>最近除了忙各种各样的期末考试、去西班牙的签证，就是公司的那个韩国项目了。</p>
<p>　　我的任务基本完成——将原本单屏的游戏改成三屏，完善整个 GUI系统 以及“劫持”了原游戏中的一些逻辑，比如滚轴的排列可以任意控制等。由于原代码中的GUI系统没有文本编辑框，我还得自己写一个。然而我对于IME的操作、GDI和DX的结合不是非常熟悉，所以还是参照了一下 <strong>ShowLong</strong> 所修改的微妙的平衡给HGE写的中文解决方案。</p>
<p>　　完成了以上的任务之后，由于我的考试以及签证问题以及我本身的任务差不多了，就把这个摊子就扔回公司去了。在交接的时候，老大给我派了一个任务，让我来写这个游戏资源包的代码。</p>
<p>　　原版游戏代码中有资源包代码，但是写得非常乱，于是需要我来写一个新的文件结构、新的加密算法，然后仍然是“劫持”掉原代码中的资源包加载函数。</p>
<p>　　在此之前，我拜读了云风的《<a href="http://blog.codingnow.com/2010/08/resource_pack.html" target="_blank">游戏资源的压缩、打包与补丁更新</a>》，有了点灵感。</p>
<p>　　<strong>最主要的就是其删除这一块。为了让用户在更新的时候减少大量的文件IO操作，做法就是减少文件内容的大幅度移动。</strong></p>
<p>　　而我便是参考了云风大大的这个思想来写我的文件包。首先因为在游戏中需要实时读取，所以文件没有压缩，只是做了两层加密处理，密钥也是通过哈希得到的，所以每个文件的密钥是不同的。</p>
<p>　　然后在文件索引的时候，我这里是分了两种索引：<strong>文件索引</strong>以及<strong>空块索引</strong>。</p>
<p>　　所谓空块索引就是：在文件包中删除某一个文件的时候，不把后面的文件内容全部往前挪以覆盖这一块的内容、导致整个文件包在删除文件之后的信息全部往前挪而产生的大量IO操作，而是对这一块内容不作任何处理、把这一块内容的索引从文件索引中移除并附加到空块索引中以供以后新文件加入时所用，<strong>这样就只产生了一点对于索引的文件IO更新</strong>，不过索引的更新充其量也就那么点，相对于文件的操作来说只是九牛一毛，当然前提是这个索引是在整个文件包的最后。而在有新文件插入的时候，先在空块索引中找有比新文件大的空块，如果有的话就直接把这个文件插入到那个空块中，然后更新一下文件索引以及空块索引即可，这里又少掉了一些IO操作。</p>
<p>　　正如云风所说：</p>
<blockquote>
<p>如果新增加的文件较之小，就重复利用这个空间。如果利用不上，就浪费在那里。这有点像内存管理算法，<strong>时间久了，资源包内会有一些空洞，但也是可以接受的。</strong></p>
</blockquote>
<p>　　接着就是资源包在游戏中的使用了。在原先的游戏代码中是有判断重复加载的代码，也就是说把已加载的资源存到node里，在之后再次需要加载这个资源（通过文件名判断）就直接从node中去，这样就少了很多内存开销，尤其是当我把单屏改为三屏之后，这样的优化效果更为明显（否则相同的资源要加载三次，等于消耗了三倍的内存）。不得赞一下这05年开发的代码，虽然是棒子。不过原游戏代码中的高耦合度让我蛋疼。</p>
<p>　　想到以后这个资源包类要用到以后的一些项目，于是我自己也写了一个Cache机制。就是在一个包中，当加载某个资源的时候，顺便把这个资源的Buffer加到一个Cache中，当下次再需要用到这个资源的时候就直接从Cache中取就好了，实际上这就还是之前的代码实现的功能，只不过我自己在这基础上精简了一下。最后写一个ClearCache的函数能清除Cache，我这个资源包类就算完成了。</p>
<p>　　还有在获取资源的时候，为了防止内存突增，我的Buffer是一段一段获取的，类似于Socket中的获取消息一直到消息结束为止。当然，每一段Buffer的大小是可以自己传进去的。我这种以时间换空间的做法还没自己实际测试过效果如何，只不过是自己想想可能会比较优罢了，因为最近实在是太慢，这篇日志还是考完了概率然后摸着黑地写的。</p>
<p>　　我对文件系统本身不是非常了解，操作系统还没考呢。所以我现在仅仅做到的是云风九年前的一种设计，然后加上了原先代码有的Cache机制而已。不过写下这篇日志来记录我自己成长的足迹罢了。</p>
]]></content>
    
    
      <category term="二进制文件" scheme="http://xcoder.in/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
      <category term="游戏制作" scheme="http://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
      <category term="资源包" scheme="http://xcoder.in/tags/%E8%B5%84%E6%BA%90%E5%8C%85/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
</feed>
