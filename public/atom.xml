<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[艾克斯の編碼者]]></title>
  <subtitle><![CDATA[一個偽宅级别的蒟蒻碼畜。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xcoder.in//"/>
  <updated>2014-12-21T02:31:54.163Z</updated>
  <id>http://xcoder.in//</id>
  
  <author>
    <name><![CDATA[小鳥遊死月]]></name>
    <email><![CDATA[admin@xcoder.in]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在 C++ 中鏈接 C 的 文件]]></title>
    <link href="http://xcoder.in/2014/12/10/link-c-on-gpp/"/>
    <id>http://xcoder.in/2014/12/10/link-c-on-gpp/</id>
    <published>2014-12-10T07:30:32.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="原因">原因</h2>
<p>由於某些原因，我寫了個很搓的<a href="https://github.com/XadillaX/xmempool" target="_blank">內存池</a>（C 版本的）。</p>
<p>然後我想到了把之前寫的一個 Node.js 包 <a href="https://github.com/XadillaX/thmclrx" target="_blank">thmclrx</a> 的更挫的“僞·內存池”用新寫的內存池去替換掉。(❛◡❛✿)</p>
<p>然後問題就來了，我貌似不能控制 node-gyp 去用 G++ 編譯 <code>*.c</code> 文件，這樣的話所有文件編譯好之後鏈接 <code>*.o</code> 文件會出問題。雖然鏈接的時候沒報錯，但是使用的時候就會報這麼個錯 (;´༎ຶД༎ຶ`)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>➜ thmclrx git:(master) ✗ node test/test.js
dyld: lazy symbol binding failed: Symbol not found: __Z16xmem_create_poolj
  Referenced from: /Users/<span class="keyword">...</span>/code/huaban/thmclrx/build/Release/thmclrx.node
  Expected <span class="keyword">in</span>: dynamic lookup

dyld: Symbol not found: __Z16xmem_create_poolj
  Referenced from: /Users/<span class="keyword">...</span>/code/huaban/thmclrx/build/Release/thmclrx.node
  Expected <span class="keyword">in</span>: dynamic lookup

[<span class="number">1</span>]    <span class="number">52501</span> trace trap  node test/test.js
</pre></td></tr></table></figure>

<p>大致意思就是說在我編譯好鏈接好的 <code>thmclrx.node</code> 中找不到 <code>__Z16xmem_create_poolj</code> 這個符號，也就是說 <code>xmempool.o</code> 這個用 C 編譯出來的文件並沒有正確被鏈接。</p>
<h2 id="假想方案">假想方案</h2>
<h3 id="假想一">假想一</h3>
<p>一開始我想找的是“如何在 node-gyp 中手動選擇編譯器”，即不讓機器自動選擇 GCC 去編譯 <code>*.c</code> 文件。後來無果。ル||☛_☚|リ</p>
<h3 id="假想二">假想二</h3>
<p>再後來我想開了，於是決定讓編譯的時候去識別我在跟 C 說話還是跟 C++ 說話。(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</p>
<h2 id="解決方案">解決方案</h2>
<p>於是我找到了這麼個帖子：<a href="http://grokbase.com/t/gg/nodejs/14amregx72/linking-c-sources-files-in-cc-files" target="_blank">http://grokbase.com/t/gg/nodejs/14amregx72/linking-c-sources-files-in-cc-files</a></p>
<p>他貌似也遇到了跟我相似的問題。下面這個提問者自己提出了這樣的回答：</p>
<blockquote>
<p>Nevermind, found my own answer after finally hitting the right google search terms.</p>
<p>Added</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">#ifdef __cplusplus</span>
<span class="keyword">extern</span> <span class="string">"C"</span> {
<span class="preprocessor">#endif</span>

<span class="comment">//... source code here...</span>

<span class="preprocessor">#ifdef __cplusplus</span>
}
<span class="preprocessor">#endif</span>
</pre></td></tr></table></figure>

<p>So that the CPP compiler would know I was talking C and not CPP :)</p>
</blockquote>
<p>答案的大意就是在你的 C 頭文件中添加上面 blahblah 一大段宏，好讓 C++ 的編譯器知道它是在跟 C 的中間文件交流而不是 C++，這樣的話鏈接的時候就能正常接軌了。於是我在我的新版 <a href="https://github.com/XadillaX/xmempool/commit/b06351836c9b51952a3d98c438df6626dda8738c" target="_blank">xmempool</a> 的頭文件裏面就已經添加上了這兩段話了。</p>
<h2 id="事後煙">事後煙</h2>
<p>其實以前我也老在別的項目裏面看到這個 <code>#ifdef __cplusplus</code> 的宏定義，只不過以前不知道什麼意思。</p>
<p>今天通過這麼一件事情終於知道了它的用途了，新技能 get √。</p>
<p>ε(*´･∀･｀)зﾞ</p>
]]></content>
    
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何生成一個覆蓋廣的色板]]></title>
    <link href="http://xcoder.in/2014/10/16/generate-color-space/"/>
    <id>http://xcoder.in/2014/10/16/generate-color-space/</id>
    <published>2014-10-16T03:00:54.000Z</published>
    <updated>2014-12-10T07:49:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用途">用途</h2>
<p>　　在主題色提取的過程中，要把顏色加入搜索引擎。但是如果是真彩色任意值加進去的話，對於搜索的時候來說無疑是一個複雜的操作。搜索條件要各種計算距離什麼的。</p>
<p>　　於是一個妥協的做法就是提供一套調色板，保證所有顏色都被吸納到調色板中的某一色值當中。</p>
<p>　　那麼這個時候調色板的覆蓋率以及距離什麼的就比較重要了。本文就講如何生成一套看起來還不錯的自用“標準色板”。</p>
<h2 id="Windows_色板">Windows 色板</h2>
<p>　　一開始我用了一套 256 色的色板，不知道哪裏搞來的 Windows 色板。</p>
<p>　　由於顏色太多，不好貼代碼，我就直接把鏈接貼過來了：</p>
<blockquote>
<p><a href="https://github.com/XadillaX/thmclrx/blob/4a5bff429f25294af7111de800063ffd90cce1d8/src/common.cpp#L29" target="_blank">點我萌萌噠 ฅ(๑<em>д</em>๑)ฅ!!</a></p>
</blockquote>
<p>　　這一套色板大致的效果如下：</p>
<style>
#standard-256 {
    line-height: 10px;
    padding: 0;
    margin: 0;
}
#standard-256 span {
    width: 40px;
    height: 20px;
    display: inline-block;
}
</style>

<div class="well"><div id="standard-256"></div></div>

<script src="http://blog.xcoder.in/theme-color-slide/palette.js"></script>
<script>
$(function()
{
    for (var i = 0; i < palette.length; i++)
    {
        var block = "<span style=\"background: rgba(" +
            palette[i][0] + ", " + palette[i][1] + ", " +
            palette[i][2] + ", 1);\"></span>";
        $("#standard-256").append(block);
    }
});
</script>

<h2 id="生成更好的色板">生成更好的色板</h2>
<p>　　我指的更好並不一定真的比之前找到的 256 色要好，畢竟上面那個是人家智慧和勞動的結晶。我指的更好是顏色更多，但是偏差又不會太大。</p>
<p>　　理論上我們能按照那種規則生成比真彩色少的任意種數的色板。</p>
<h3 id="相關的色彩模式">相關的色彩模式</h3>
<p>　　這裏有必要重新普及下 N 多種色彩模式中的其中兩種，也就是我們今天生成一個色板所用到的兩種模式。</p>
<h4 id="RGB_色彩模式">RGB 色彩模式</h4>
<p>　　這個大家都已經耳熟能詳了，無非是 RGB 通道中的分量結合起來生成的一種顏色。</p>
<blockquote>
<p>RGB 色彩模式是工業界的一種顏色標準，是通過對紅 (R)、綠 (G)、藍 (B)三個顏色通道的變化以及它們相互之間的疊加來得到各式各樣的顏色的，RGB 即是代表紅、綠、藍三個通道的顏色，這個標準幾乎包括了人類視力所能感知的所有顏色，是目前運用最廣的顏色系統之一。</p>
<p>使用 RGB 模型爲圖像中每一個像素的 RGB 分量分配一個 0 ~ 255 範圍內的強度值。RGB 圖像只使用三種顏色，就可以使它們按照不同的比例混合，在屏幕上呈現 16777216 (<code>256 * 256 * 256</code>) 種顏色。</p>
</blockquote>
<h4 id="HSL_色彩模式">HSL 色彩模式</h4>
<blockquote>
<p>HSL 色彩模式是工業界的一種顏色標準，是通過對色相 (H)、飽和度 (S)、明度 (L) 三個顏色通道的變化以及它們相互之間的疊加來得到各式各樣的顏色的，HSL 即是代表色相，飽和度，明度三個通道的顏色，這個標準幾乎包括了人類視力所能感知的所有顏色，是目前運用最廣的顏色系統之一。</p>
</blockquote>
<p>　　HSL 色彩模式就是今天的主角了。我們將會用 HSL 生成一張類似下圖的色板，而色板的粒度將會與你決定色板的顏色數量相關：</p>
<p><img src="SqfinPalette-RealColorWheel-RGB-14inwide72dpi-1024x437.png" alt="HSL Color Space"></p>
<h3 id="代碼實現">代碼實現</h3>
<p>　　爲了簡化代碼，我們暫時不考慮飽和度，也就是說所有顏色讓它飽和度都爲 <strong>100%</strong>。</p>
<p>　　而且實際上色相是在一個圓裏面的 0° ~ 360°，那麼也就是說我們只需要做兩步就是了：</p>
<ol>
<li>色相 0° ~ 360° 循環；</li>
<li>以及明度 0% ~ 100% 循環。</li>
</ol>
<p>　　在這裏我定了一個步長：色相以 10° 爲一個步長，明度以 5% 爲一個步長。並且剔除 RGB 相等的黑白灰色。</p>
<blockquote>
<p>當然這裏步長完全可以按照自己的喜好來。</p>
</blockquote>
<p>　　我們以前端的 Javascript 爲例，能想到下面的一段代碼：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> count = <span class="number">0</span>;
$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) {
        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">36</span>; j++) {
            $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div class='color'&gt;&lt;/div&gt;"</span>);
            $(<span class="string">".color"</span>).eq(count++).css(<span class="string">"background-color"</span>, <span class="string">"hsl("</span> + (j * <span class="number">10</span>) + <span class="string">", "</span> + <span class="string">"100%, "</span> + <span class="built_in">parseInt</span>(((i + <span class="number">1</span>) / <span class="number">21</span>) * <span class="number">100</span>) + <span class="string">"%)"</span>);
        }
        $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div style='clear: both;'&gt;&lt;/div&gt;"</span>);
    }
});
</pre></td></tr></table></figure>

<p>　　這裏需要注意的是，實際上我明度的步長是 <code>(100 / 22)</code>。然後 <code>0</code> 和 <code>100</code> 這兩個明度我們另外拎出來，所以只取了 1 ~ 21 的明度。</p>
<p>　　剩下的就是跟剛纔說的一樣，各色相的各明度生成一個 HSL 顏色賦值給 <code>background-color</code>。</p>
<p>　　接下去我們生成一個灰色條的色板，專治灰黑白。這個時候實際上我們可以直接用 RGB 搞定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>$(<span class="string">"#palette"</span>).append(<span class="string">"&lt;br /&gt;"</span>);
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i++) {
    $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div class='color'&gt;&lt;/div&gt;"</span>);
    <span class="keyword">var</span> val = <span class="built_in">parseInt</span>(((<span class="number">19</span> - i) / <span class="number">19</span>) * <span class="number">255</span>);
    $(<span class="string">".color"</span>).eq(count++).css(<span class="string">"background-color"</span>, <span class="string">"rgb("</span> + val + <span class="string">", "</span> + val + <span class="string">", "</span> + val + <span class="string">")"</span>);
}
</pre></td></tr></table></figure>

<p>　　最後把顏色輸出到一個數組就好了。</p>
<blockquote>
<p>這裏有一點 happy 的是，就算你是用 HSL 來搞的背景色，用 <strong><em>jQuery</em></strong> 的 <code>$(foo).css(&quot;background-color&quot;)</code> 獲取到的仍然是 RGB 值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> colors = [];
$(<span class="string">".color"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> result = <span class="regexp">/rgb\((\d+), (\d+), (\d+)\)/</span>.exec($(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>));
    colors.push({ r: <span class="built_in">parseInt</span>(result[<span class="number">1</span>]), g: <span class="built_in">parseInt</span>(result[<span class="number">2</span>]), b: <span class="built_in">parseInt</span>(result[<span class="number">3</span>]) });
});

$(<span class="string">"textarea"</span>).val(<span class="built_in">JSON</span>.stringify(colors));
</pre></td></tr></table></figure>

<p>　　所以最後我們還需要初始的 HTML 了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">textarea</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"palette"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"clear: both;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p>　　效果的話這裏能看到：</p>
<ul>
<li><a href="http://blog.xcoder.in/hsl-color-space/" target="_blank">http://blog.xcoder.in/hsl-color-space/</a></li>
<li><a href="http://runjs.cn/code/spahru8w" target="_blank">http://runjs.cn/code/spahru8w</a></li>
</ul>
<h2 id="小結">小結</h2>
<p>　　用 HSL 生成的色彩空間（色板）一個是表現力好，相對於 RGB 來說，好像更好知道如何去生成分部比較 OK 的一個色彩空間。</p>
<p>　　但是也有一個缺點，當我們不去管飽和度的時候，實際上我們還是丟失了一部分的顏色。好在本身我們生成色板也只是爲了合併顏色，可以通過 k-D 樹來快速尋找某個顏色在色板中是屬於哪種色塊的。當然，目前我們就是這麼做的。</p>
<h2 id="參考資料">參考資料</h2>
<ul>
<li><a href="http://websafecolorcodes.com/colors-palette/color-wheel-palette/" target="_blank">Color Wheel Palette</a></li>
<li><a href="http://www.waldronconstructionllc.com/wp-content/uploads/2012/03/SqfinPalette-RealColorWheel-RGB-14inwide72dpi-1024x437.png" target="_blank">Refer Image</a></li>
<li><a href="http://codeforartists.com/samples/cfa-color-palette-hsl.php" target="_blank">Algorithm</a></li>
</ul>
]]></content>
    
    
      <category term="HSL" scheme="http://xcoder.in/tags/HSL/"/>
    
      <category term="RGB" scheme="http://xcoder.in/tags/RGB/"/>
    
      <category term="色板" scheme="http://xcoder.in/tags/%E8%89%B2%E6%9D%BF/"/>
    
      <category term="Palette" scheme="http://xcoder.in/tags/Palette/"/>
    
      <category term="Color Space" scheme="http://xcoder.in/tags/Color%20Space/"/>
    
      <category term="色彩空間" scheme="http://xcoder.in/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Javascript 實現一個簡易 BrainF**k 解釋器]]></title>
    <link href="http://xcoder.in/2014/10/08/brainf**k/"/>
    <id>http://xcoder.in/2014/10/08/brainf**k/</id>
    <published>2014-10-08T03:42:32.000Z</published>
    <updated>2014-12-10T07:49:31.000Z</updated>
    <content type="html"><![CDATA[<p>首先祝賀自己在 <a href="http://www.codewars.com/users/XadillaX" target="_blank">CodeWars</a> 升級到 3 Kyu，以及感謝 @<a href="http://www.html-js.com/card/473" target="_blank">Bolt_白衣蒼狗</a> 童鞋讓我知道有 CodeWars 這麼個好玩的東西。</p>
<p>　　雖然裏面水題居多，不過在上班比較空閒的檔口 #<strong>帶薪刷題</strong># 的感覺還是蠻不錯的。</p>
<h2 id="話嘮一下">話嘮一下</h2>
<p>　　高中的時候就跟 @<a href="http://www.lvchaoshuai.com/" target="_blank">MatRush</a> 發現了一個名字超級好玩的編程語言叫 <a href="http://en.wikipedia.org/wiki/Brainfuck" target="_blank">BrainF**k</a>，它比較搞腦筋，因爲所有的編程操作都是集合在操作符裏面，然後控制指針偏移和內存值的修改來進行一系列操作。</p>
<p>　　這與後面發現的 <a href="http://www.hacker.org/hvm/" target="_blank">HVM</a>（Hack Virtual Machine）有異曲同工之妙。其實之前也出過一個“<a href="http://acm.nbut.edu.cn/Problem/view.xhtml?id=1062" target="_blank">實現一個簡易 HVM 解釋器</a>”的題目，所以在 CodeWars 看到這個題目的時候還感覺蠻親切的。</p>
<h2 id="問題描述">問題描述</h2>
<p>　　問題很簡單，就是讓你實現一個函數來解釋一句 BrainF**k 的語句，並且根據輸入數據來輸出相應的內容。</p>
<p>　　至於這題所需的 BrainF**k 的語法，大致如下：</p>
<ul>
<li><code>&gt;</code>: 指針右移一位。</li>
<li><code>&lt;</code>: 指針左移一位。</li>
<li><code>+</code>: 當前指針所指的內存值加一，以 255 爲界，溢出爲 0，即 <code>255 + 1 = 0</code>。</li>
<li><code>-</code>: 當前指針所指的內存值減一，以 0 爲界，溢出爲 255，即 <code>0 - 1 = 255</code>。</li>
<li><code>.</code>: 輸出當前指針所指的值，即輸出該值 ASCII 碼所對應的字符。</li>
<li><code>,</code>: 從輸入取一個字符轉爲 ASCII 碼存入當前指針所指的內存。</li>
<li><code>[</code>: 若當前指針所指的值爲 0，則命令跳到該 <code>[</code> 匹配的結束 <code>]</code> 符號位置的下一位置的指令。</li>
<li><code>]</code>: 若當前指針所指的值不爲 0，則指令向前跳到該 <code>]</code> 匹配到的 <code>[</code> 符號位置的下一位置的指令。</li>
</ul>
<p>　　舉個例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="string">,</span><span class="literal">+</span><span class="title">[</span><span class="literal">-</span><span class="string">.</span><span class="string">,</span><span class="literal">+</span><span class="title">]</span>
</pre></td></tr></table></figure>

<p>　　上面的句子大致就是說：</p>
<ol>
<li>獲取輸入到當前指針。</li>
<li>當前指針值加一。</li>
<li>如果當前指針的值爲 0，那麼跳到結束位置；否則下一步。</li>
<li>當前指針值減一。</li>
<li>輸出當前指針的值（綜上所述，就是輸出輸入的值）。</li>
<li>獲取輸入到當前指針。</li>
<li>當前指針值加一。</li>
<li>若當前指針值不爲 0，那麼跳到 <code>[</code> 後面的位置——即第四步。</li>
</ol>
<p>　　說白了，就是不斷獲取輸入的值，如果輸入的值是 255，那麼就跳出循環，否則原樣輸出。</p>
<h2 id="開始實現">開始實現</h2>
<p>　　明白了上面的題意之後就可以開始實現了，步驟大致上就是逐位遍歷指令，然後一個 <code>switch</code> 來處理各種指令即可。</p>
<p>　　<strong>CodeWars</strong> 給了你一個函數原型，你在裏面實現代碼就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span><span class="params">(code, input)</span>{</span>
  <span class="keyword">return</span> output;
}
</pre></td></tr></table></figure>

<h3 id="前趨工作">前趨工作</h3>
<p>　　在開始之前，我們做一些初始化工作，比如申明幾個變量什麼的：</p>
<ul>
<li>輸入數據當前的位置，也就是說讀取幾個之後，這個位置要偏移幾位。</li>
<li>當前指令的位置。</li>
<li>當前指針的位置。</li>
<li>“僞內存塊”的值，用一個數組表示，默認一個 <code>[ 0 ]</code>。</li>
<li>需要 <code>return</code> 的字符串，即輸出的值。</li>
<li>某個括號匹配的括號的指令下標的這麼一個映射數組。</li>
</ul>
<p>　　所以接下去我們要把架子填成這樣：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span><span class="params">(code, input)</span> {</span>
    <span class="keyword">var</span> inputPos = <span class="number">0</span>;
    <span class="keyword">var</span> commandPos = <span class="number">0</span>;
    <span class="keyword">var</span> pointerPos = <span class="number">0</span>;
    <span class="keyword">var</span> bytes = [ <span class="number">0</span> ];
    <span class="keyword">var</span> output = <span class="string">""</span>;
    <span class="keyword">var</span> matching = getMatchingBra(code);    <span class="comment">///&lt; 人家纔不是罩罩呢，我是 Brackets 的縮寫</span>
}
</pre></td></tr></table></figure>

<h4 id="括號匹配函數">括號匹配函數</h4>
<p>　　上面的 <code>getMatchingBra</code> 就是我們要實現的一個括號匹配函數了，思想就是用棧。</p>
<p>　　碰到前括號就把這個前括號的下標入棧；碰到後括號，就把棧頂元素即前括號的下標推出，這個時候括號匹配數組的這個前括號下標的值就是當前後括號的下標，而後括號下標的值就是前括號的下標了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">/**
 * 你纔是 Bra ／/( ◕‿‿◕ )＼
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">getMatchingBra</span><span class="params">(code)</span> {</span>
    <span class="keyword">var</span> stack = [];
    <span class="keyword">var</span> bra = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) bra.push(-<span class="number">1</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) {
        <span class="keyword">if</span>(code[i] === <span class="string">'['</span>) {
            stack.push(i);
        } <span class="keyword">else</span> <span class="keyword">if</span>(code[i] === <span class="string">']'</span>) {
            bra[i] = stack.pop();
            bra[bra[i]] = i;
        }
    }
    <span class="keyword">return</span> bra;
}
</pre></td></tr></table></figure>

<p>　　有了這個數組就可以隨便跳了，如果指令第 <code>i</code> 位是一個括號（不管前括號還是後括號），那麼它的匹配括號下標就是 <code>matching[i]</code> 了。</p>
<h3 id="各種指令的處理">各種指令的處理</h3>
<p>　　要處理指令的話實際上就是一個 <code>while</code> 語句不斷循環指令，然後判斷當前指令是什麼然後做相應的事，最後指令位置加一就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">while</span>(commandPos &lt; code.length) {
    <span class="keyword">switch</span>(code[commandPos]) {
        <span class="keyword">case</span> <span class="string">'&gt;'</span>: {}
        <span class="keyword">case</span> <span class="string">'&lt;'</span>: {}
        <span class="keyword">case</span> <span class="string">'+'</span>: {}
        <span class="keyword">case</span> <span class="string">'-'</span>: {}
        <span class="keyword">case</span> <span class="string">'.'</span>: {}
        <span class="keyword">case</span> <span class="string">','</span>: {}
        <span class="keyword">case</span> <span class="string">'['</span>: {}
        <span class="keyword">case</span> <span class="string">']'</span>: {}
    }
    commandPos++;
}
</pre></td></tr></table></figure>

<h4 id="&gt;">&gt;</h4>
<p>　　指針右移的話就把指針位置加一，如果內存數組還沒當前指針位置的值的話 <code>push</code> 一個 <code>0</code> 就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'&gt;'</span>: {
    <span class="keyword">if</span>(<span class="literal">undefined</span> === bytes[++pointerPos]) bytes.push(<span class="number">0</span>);
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="&lt;">&lt;</h4>
<p>　　左移就是減一，如果位置小於 0，那麼內存數組從前推入一個值，並讓指針等於 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'&lt;'</span>: {
    <span class="keyword">if</span>(--pointerPos &lt; <span class="number">0</span>) {
        bytes.unshift(<span class="number">0</span>);
        pointerPos = <span class="number">0</span>;
    }
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="+">+</h4>
<p>　　沒什麼好說的，內存加一就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'+'</span>: {
    bytes[pointerPos] = (bytes[pointerPos] + <span class="number">1</span>) % <span class="number">256</span>;
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="-">-</h4>
<p>　　減一。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'-'</span>: {
    bytes[pointerPos]--;
    <span class="keyword">if</span>(bytes[pointerPos] &lt; <span class="number">0</span>) bytes[pointerPos] = <span class="number">0</span>;
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="--1">.</h4>
<p>　　輸出的話直接往 <code>output</code> 字符串裏面加上當前指針的值就好了，注意要 ASCII 轉變之後的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'.'</span>: {
    output += <span class="built_in">String</span>.fromCharCode(bytes[pointerPos]);
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id=",">,</h4>
<p>　　輸入的話就讓 <code>input</code> 當前位置的值變成 ASCII 存進當前指針，然後輸入位置加一就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">','</span>: {
    bytes[pointerPos] = input.charCodeAt(inputPos++);
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="[">[</h4>
<p>　　由於之前已經做好了匹配數組，所以我們只需要判斷當前指針是不是 0，然後如果是就跳到匹配括號處。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">'['</span>: {
    commandPos = !bytes[pointerPos] ? matching[commandPos] : commandPos;
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h4 id="]">]</h4>
<p>　　同上，只不過條件改一下而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="string">']'</span>: {
    commandPos = bytes[pointerPos] ? matching[commandPos] : commandPos;
    <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<h3 id="善後工作">善後工作</h3>
<p>　　上面的函數體完成之後，我們只需要在最後把 <code>output</code> 給返回就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">return</span> output;
</pre></td></tr></table></figure>

<h2 id="肢體組裝">肢體組裝</h2>
<p>　　完成了上面七零八落的肢體之後，我們要把五馬分屍的代碼給湊回去，所以最後就長這個樣子了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">getMatchingBra</span><span class="params">(code)</span> {</span>
    <span class="keyword">var</span> stack = [];
    <span class="keyword">var</span> bra = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) bra.push(-<span class="number">1</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) {
        <span class="keyword">if</span>(code[i] === <span class="string">'['</span>) {
            stack.push(i);
        } <span class="keyword">else</span> <span class="keyword">if</span>(code[i] === <span class="string">']'</span>) {
            bra[i] = stack.pop();
            bra[bra[i]] = i;
        }
    }
    <span class="keyword">return</span> bra;
}

<span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span><span class="params">(code, input)</span> {</span>
    <span class="keyword">var</span> inputPos = <span class="number">0</span>;
    <span class="keyword">var</span> commandPos = <span class="number">0</span>;
    <span class="keyword">var</span> pointerPos = <span class="number">0</span>;
    <span class="keyword">var</span> bytes = [ <span class="number">0</span> ];
    <span class="keyword">var</span> output = <span class="string">""</span>;
    <span class="keyword">var</span> matching = getMatchingBra(code);
    
    <span class="keyword">while</span>(commandPos &lt; code.length) {
        <span class="keyword">switch</span>(code[commandPos]) {
            <span class="keyword">case</span> <span class="string">'&gt;'</span>: {
                pointerPos++;
                <span class="keyword">if</span>(<span class="literal">undefined</span> === bytes[pointerPos]) {
                    bytes.push(<span class="number">0</span>);
                }
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">'&lt;'</span>: {
                pointerPos--;
                <span class="keyword">if</span>(<span class="number">0</span> &gt; pointerPos) {
                    bytes.unshift(<span class="number">0</span>);
                    pointerPos = <span class="number">0</span>;
                }
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">'+'</span>: {
                bytes[pointerPos] = (bytes[pointerPos] + <span class="number">1</span>) % <span class="number">256</span>;
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">'-'</span>: {
                bytes[pointerPos]--;
                <span class="keyword">if</span>(bytes[pointerPos] &lt; <span class="number">0</span>) bytes[pointerPos] = <span class="number">0</span>;
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">'.'</span>: {
                output += <span class="built_in">String</span>.fromCharCode(bytes[pointerPos]);
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">','</span>: {
                <span class="keyword">var</span> temp = input.charCodeAt(inputPos++);
                bytes[pointerPos] = temp;
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">'['</span>: {
                <span class="keyword">if</span>(!bytes[pointerPos]) {
                    commandPos = matching[commandPos];
                }
                <span class="keyword">break</span>;
            }
            <span class="keyword">case</span> <span class="string">']'</span>: {
                <span class="keyword">if</span>(bytes[pointerPos]) {
                    commandPos = matching[commandPos];
                }
                <span class="keyword">break</span>;
            }
        }
        commandPos++;
    }
    
    <span class="keyword">return</span> output;
}
</pre></td></tr></table></figure>

<h2 id="題後語">題後語</h2>
<p>　　艾瑪，忘了放題目鏈接了：<a href="http://www.codewars.com/kata/526156943dfe7ce06200063e" target="_blank">http://www.codewars.com/kata/526156943dfe7ce06200063e</a>。以及大家如果有興趣的話也可以去試試看寫個 <a href="http://acm.nbut.edu.cn/Problem/view.xhtml?id=1062" target="_blank">HVM</a> 看看。</p>
<p>　　實際上本文實現的東西實用性幾乎沒有，只不過是拋磚引玉，讓大家在做一些模擬題邏輯（或者說是簡單模擬邏輯）的時候理清思路、按部就班，切忌自己亂了思路和邏輯。</p>
]]></content>
    
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="解釋器" scheme="http://xcoder.in/tags/%E8%A7%A3%E9%87%8B%E5%99%A8/"/>
    
      <category term="BrainFuck" scheme="http://xcoder.in/tags/BrainFuck/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Node.js 實現一個 Singleton]]></title>
    <link href="http://xcoder.in/2014/09/30/javascript-singleton/"/>
    <id>http://xcoder.in/2014/09/30/javascript-singleton/</id>
    <published>2014-09-30T07:21:13.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>今天隨便玩了一道 <a href="http://www.codewars.com/kata/singleton-pattern/javascript" target="_blank">CodeWar 的題</a>。</p>
<p>　　題意大致就是你需要實現一個 <code>Singleton</code> 也就是單件模式的類，讓其下面代碼執行成功：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> obj1 = <span class="keyword">new</span> Singleton();
<span class="keyword">var</span> obj2 = <span class="keyword">new</span> Singleton();
obj1 === obj2; <span class="comment">// =&gt; true</span>
obj1.test = <span class="number">1</span>;
obj2.test; <span class="comment">// =&gt; 1</span>
</pre></td></tr></table></figure>

<p>　　並且還有很重要的一點就是 <code>Singleton</code> 的對象的 <code>instanceof</code> 也得的確是 <code>Singleton</code> 才行。</p>
<h2 id="開始試驗">開始試驗</h2>
<p>　　我們猜想 <code>new Singleton()</code> 的結果，如果 <code>Singleton</code> 函數也就是這個類的構造函數沒返回值的話，直接會返回 <code>this</code>，有返回值的話，那麼就是等於其返回值了。</p>
<p>　　我們碼下面的代碼看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> { foo: <span class="string">"bar"</span> };
};

console.log(<span class="keyword">new</span> Singleton());
</pre></td></tr></table></figure>

<p>　　跑一遍之後我們的確發現了輸出的值就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>{ foo: <span class="string">"bar"</span> }
</pre></td></tr></table></figure>

<h2 id="小作弊失敗">小作弊失敗</h2>
<p>　　於是我這麼做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = {};
<span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> foo;
};
</pre></td></tr></table></figure>

<p>　　結果上面的幾個條件都符合了，不信大家可以自己輸出一遍看看。</p>
<p>　　但是——</p>
<p>　　這東西不是一個 <code>Singleton</code> 的實例，它只是一個簡單的 <code>JSON</code> 對象，所以還是無法通過。</p>
<h2 id="死月の正解">死月の正解</h2>
<p>　　答案有很多，CodeWar 上面每個人的解法都不一樣，但是歸根結底本質還是大同小異的。</p>
<p>　　就是第一次的時候先直接返回 <code>this</code>，並且把 <code>this</code> 放在某個地方。以後每次來這裏創建的時候返回之前存好的 <code>this</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span>(Singleton.prototype.instance) <span class="keyword">return</span> Singleton.prototype.instance = <span class="keyword">this</span>;

    <span class="comment">// Do some initialize things</span>
    <span class="comment">// ...</span>

    Singleton.prototype.instance = <span class="keyword">this</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>

<h2 id="別的寫法">別的寫法</h2>
<p>　　寫法很多，我這裏隨意挑幾個別人的答案吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/**
 * By tjwudi
 */</span>
<span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  <span class="keyword">return</span> Singleton.ins = Singleton.ins ? Singleton.ins : <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">/**
 * By nonowarn
 */</span>
<span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> instance = <span class="literal">null</span>;

  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> instance || (instance = <span class="keyword">this</span>);
  };
})();
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="設計模式" scheme="http://xcoder.in/tags/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="Node.js" scheme="http://xcoder.in/categories/Node.js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[讓我們用 Node.js 寫自己的 DDNS 動態域名程序]]></title>
    <link href="http://xcoder.in/2014/09/20/lets-build-ourselves-ddns/"/>
    <id>http://xcoder.in/2014/09/20/lets-build-ourselves-ddns/</id>
    <published>2014-09-20T07:51:40.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>　　一開始我在移動的寬帶中。那個時候雖然還不是完全的局域網，但是電信網絡訪問不了我的外網 IP。又因爲我需要一個 DDNS 服務來維持我的 <a href="http://kacaka.ca/" target="_blank">kacaka.ca</a>（目前暫失效）。</p>
<p>　　爲了解決讓電信網絡也能訪問我的 Web，於是我想到了免費 CDN 當中比較有名的 <a href="http://cloudflare.com/" target="_blank">CloudFlare</a>。而且它也有提供 API 讓開發者自己開發通過他的服務解析域名的服務。</p>
<p>　　再然後，去年的九月份，我的早期 Node.js 作品 <strong><a href="https://github.com/XadillaX/dloucflare/tree/0.0.2" target="_blank">dloucflare</a></strong> 發佈了。所以就有了<a href="http://cnodejs.org/topic/522b64c3101e574521332451" target="_blank">這個帖子</a>。</p>
<p>　　現在，我已經搬到電信了，然後舊版的貌似不能用了，因爲 <strong>CloudFlare</strong> 貌似 API 都遷移到了 <code>https</code> 上面。然後我爲了我的小夥伴們能訪問我出租屋裏的舊電腦，又重構了一遍<a href="https://github.com/XadillaX/dloucflare" target="_blank">這個項目</a>。</p>
<h2 id="使用_dlouc-flare_構建">使用 dlouc-flare 構建</h2>
<p>　　首先安裝最新的 <code>dlouc-flare</code> 包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install dlouc-flare
</pre></td></tr></table></figure>

<p>　　然後去創建一個 <strong>DF</strong> 對象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> DloucFlare = <span class="built_in">require</span>(<span class="string">"dlouc-flare"</span>);
<span class="keyword">var</span> df = DloucFlare.create(<span class="string">"你的郵箱"</span>, <span class="string">"API KEY"</span>, <span class="string">"域名（不需要 www）"</span>);
</pre></td></tr></table></figure>

<p>　　<strong>CloudFlare</strong> 如何使用的話這裏就不多做解釋了，至於 <strong>API KEY</strong> 的話，可以在<a href="https://www.cloudflare.com/my-account" target="_blank">這裏</a>獲取到。</p>
<p>　　然後調用 <code>df.dynamicDomains</code> 函數去把你這個域名下面的一些子域名加入你這個腳本的動態域名範疇當中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>df.dynamicDomains([ <span class="string">"@"</span>, <span class="string">"www"</span>, <span class="string">"子域名3"</span>, <span class="string">"子域名4"</span>, ... ], 檢測時間間隔);
</pre></td></tr></table></figure>

<blockquote>
<p>其中 <code>&quot;@&quot;</code> 代表的是域名沒有 <code>www</code> 前綴的本身。檢測時間間隔以毫秒爲單位。</p>
</blockquote>
<p>　　事實上，你也可以自定義一個檢測你當前主機的 IP 地址的函數（如果你不喜歡用包內的默認檢測 IP 函數）。</p>
<p>　　只要你寫一個函數：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">checkIp</span><span class="params">(callback)</span> {</span>
    <span class="comment">// blahblah...</span>
    callback(<span class="literal">undefined</span>, IP地址);
}
</pre></td></tr></table></figure>

<p>　　然後覆蓋掉默認的 IP 檢測函數即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>df.getIpFunction = checkIp;
</pre></td></tr></table></figure>

<p>　　最後保存退出並用 <code>node</code> 執行你的程序就好了，程序就會開始歡快地跑了。</p>
<p><img src="preview.png" alt="Preview"></p>
<h2 id="如何自己寫？">如何自己寫？</h2>
<p>　　其實要完全自己寫也是很簡單的——無非就是調用一下 <strong>CloudFlare</strong> 的 API 而已。</p>
<p>　　我們定位明確就是要做 DDNS，所以沒必要關係其它很多不相關的 API，只需要最基礎的幾個就夠了。</p>
<h3 id="API_解析">API 解析</h3>
<p>　　所有 API 的基礎 URI 都爲：<a href="https://www.cloudflare.com/api_json.html" target="_blank">https://www.cloudflare.com/api_json.html</a>。</p>
<h4 id="驗證信息">驗證信息</h4>
<p>　　根據 <strong>CloudFlare</strong> 文檔所說，所有的提交都要黏上<a href="https://www.cloudflare.com/docs/client-api.html#s2.1" target="_blank">驗證信息</a>給 POST 過去。而驗證的字段如下：</p>
<ul>
<li><strong>tkn:</strong> 從你的個人頁面當中複製出來的 API KEY。</li>
<li><strong>email:</strong> 你的登錄郵箱。</li>
<li><strong>a:</strong> 操作名，每種操作都有其特有的操作名。</li>
</ul>
<h4 id="獲取域名下的子域名記錄">獲取域名下的子域名記錄</h4>
<p>　　其操作名爲 <code>rec_load_all</code>，我們不關心其它不重要的參數，只需要再傳一個 <code>z</code> 字段代表其域名就好了，舉個例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="keyword">var</span> self = <span class="keyword">this</span>;
<span class="keyword">var</span> param = {
    a       : <span class="string">"rec_load_all"</span>,
    tkn     : <span class="keyword">this</span>.apiKey,
    email   : <span class="keyword">this</span>.email,
    z       : <span class="keyword">this</span>.domain
};

<span class="keyword">var</span> url = <span class="string">"https://www.cloudflare.com/api_json.html"</span>;
spidex.post(url, <span class="function"><span class="keyword">function</span><span class="params">(html, status)</span> {</span>
    <span class="keyword">if</span>(status !== <span class="number">200</span>) {
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error status while fetching DNS records."</span>));
    }

    <span class="keyword">var</span> json;
    <span class="keyword">try</span> {
        json = <span class="built_in">JSON</span>.parse(html);
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error while parsing DNS records: "</span> + e.message));
    }

    <span class="keyword">if</span>(json.result === <span class="string">"error"</span>) {
        <span class="keyword">var</span> msg = json.msg;
        <span class="keyword">if</span>(<span class="literal">undefined</span> === msg) msg = <span class="string">"Unknown error."</span>;
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(msg));
    } <span class="keyword">else</span> <span class="keyword">if</span>(json.result === <span class="string">"success"</span>) {
        <span class="keyword">var</span> count = json.response.recs.count;
        <span class="keyword">var</span> objects = json.response.recs.objs;
        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) {
            self.records.push(<span class="keyword">new</span> DNSRecordObject(self, objects[i]));
        }

        callback(<span class="literal">undefined</span>, self.records);
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unknown error."</span>));
    }
}, param, <span class="string">"utf8"</span>).on(<span class="string">"error"</span>, callback);
</pre></td></tr></table></figure>

<p>　　上述代碼就是把 <code>param</code> 數據給 POST 到 API 的 RESTful 裏面去。然後根據返回值進行解析。</p>
<blockquote>
<p>關於 <code>DNSRecordObject</code> 的代碼可以自行翻閱<a href="https://github.com/XadillaX/dloucflare/blob/master/lib/dnsrecordobject.js" target="_blank">這裏</a>。</p>
<p>以及 <strong>spidex</strong> 的文檔在<a href="https://www.npmjs.org/package/spidex#readme" target="_blank">這裏</a>。</p>
</blockquote>
<h4 id="修改某記錄">修改某記錄</h4>
<p>　　其操作名爲 <code>rec_edit</code>，如<a href="https://www.cloudflare.com/docs/client-api.html#s5.2" target="_blank">文檔</a>所說，除了固有的幾個參數之外，我們還需要有如下參數：</p>
<ul>
<li><code>z:</code> 域名。</li>
<li><code>id:</code> 域名記錄編號，從 <code>rec_load_all</code> 中獲取。</li>
<li><code>type:</code> 記錄類型。如 <code>A</code> / <code>CNAME</code> 等等。</li>
<li><code>name:</code> 子域名名，如果無前綴子域名則與域名相同。</li>
<li><code>content:</code> 值。如果我們只是做動態域名的話，這裏的值就是 IP。</li>
<li><code>service_mode:</code> 服務類型，填原值即可。</li>
<li><code>ttl</code>: TTL，填原值即可。</li>
</ul>
<blockquote>
<p>上面參數的解說只是對於我們要做 DDNS 腳本而言的解釋。</p>
</blockquote>
<p>　　所以說在 <strong><a href="https://github.com/XadillaX/dloucflare/blob/master/lib/dnsrecordobject.js" target="_blank">dnsrecordobject.js</a></strong> 中我是這麼做的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="keyword">var</span> param = {
    a       : <span class="string">"rec_edit"</span>,
    tkn     : <span class="keyword">this</span>.dloucflare.apiKey,
    email   : <span class="keyword">this</span>.dloucflare.email,
    id      : <span class="keyword">this</span>.recordId(),

    z       : <span class="keyword">this</span>.domain,
    type    : <span class="keyword">this</span>.recordType(),
    name    : <span class="keyword">this</span>.name,
    content : ip,

    service_mode    : <span class="keyword">this</span>.object.service_mode,
    ttl     : <span class="keyword">this</span>.object.ttl
};

<span class="keyword">var</span> self = <span class="keyword">this</span>;
spidex.post(config.baseUrl, <span class="function"><span class="keyword">function</span><span class="params">(html, status, respHeader)</span> {</span>
    <span class="keyword">if</span>(status !== <span class="number">200</span>) {
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error status while editing "</span> + self.name + <span class="string">"."</span>));
    }

    <span class="keyword">var</span> json;
    <span class="keyword">try</span> {
        json = <span class="built_in">JSON</span>.parse(html);
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error while parsing editing result: "</span> + e.message));
    }

    <span class="keyword">if</span>(json.result === <span class="string">"success"</span>) {
        self.object.content = ip;
        <span class="keyword">return</span> callback();
    } <span class="keyword">else</span> {
        <span class="keyword">var</span> msg = json.msg || <span class="string">"Unknown error."</span>;
        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(msg));
    }
}, param, <span class="string">"utf8"</span>).on(<span class="string">"error"</span>, callback);
</pre></td></tr></table></figure>

<blockquote>
<p>上面的代碼就能將你某個域名（<code>this.domain</code>）下的子域名 <code>this.name</code> 的 IP 給修改成 <code>ip</code> 了。</p>
</blockquote>
<h4 id="探測_IP">探測 IP</h4>
<p>　　這種 API 網上就多了去了。</p>
<p>　　舉個簡單的例子，我的 <code>dlouc-flare</code> 的獲取 IP 的 API 就是從</p>
<blockquote>
<p><a href="http://www.telize.com/ip" target="_blank">http://www.telize.com/ip</a></p>
</blockquote>
<p>　　來的。</p>
<p>　　請求上面的地址之後，輸出的內容（注意有換行符）就是你當前機子所在的網絡的公網 IP 了。</p>
<p>　　類似的 API 還有很多：</p>
<ul>
<li><strong><a href="http://ip-api.com/json" target="_blank">http://ip-api.com/json</a></strong>: 這個 API 就會輸出一堆的 JSON，需要自行解析。</li>
<li><strong><a href="http://ip.taobao.com/service/getIpInfo2.php?ip=myip" target="_blank">http://ip.taobao.com/service/getIpInfo2.php?ip=myip</a></strong>: 這個是淘寶提供的 RESTful 獲取 IP 的 API。</li>
<li>…（其它的可以自己去發現）</li>
</ul>
<h3 id="流程">流程</h3>
<p>　　有了上面的仨 API，一切都好說了，流程很簡單：</p>
<ul>
<li>獲取自己某個使用 <code>CloudFlare</code> 解析的域名下的<a href="#獲取域名下的子域名記錄">子域名</a>。</li>
<li>自己設置幾個子域名名拿來做 DDNS。</li>
<li>設置一個定時器，每次定時器到時的時候都進行如下操作：<ol>
<li>通過 <a href="#探測_IP">IP 的 API</a> 獲取當前 IP。</li>
<li>循環遍歷每個自己設置的子域名名。</li>
<li>對於每個子域名，都判斷其當前記錄 IP 是否等於當前剛探測的 IP。<ul>
<li><strong>是</strong>：<a href="#修改某記錄">修改該子域名的記錄值</a>爲剛探測的 IP。</li>
<li><strong>否</strong>：不作任何操作。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>　　有了上面的幾個步驟，加上之前我們講的幾個 API，大家就能輕鬆加愉快地完成自己的 DDNS 腳本了。</p>
<p>　　當然，如果自己懶的話也可以用本文一開始的方法，使用 <code>dlouc-flare</code> 這個包，通過簡單的編碼就能實現自己的 DDNS 動態域名腳本了。</p>
<blockquote>
<p>這裏的定時器時間自己按需而定，就我自己而言，我是給設置了 <code>1000 * 60</code> 毫秒的間隔。</p>
</blockquote>
<h2 id="小結">小結</h2>
<p>　　最早與動態域名結緣的時候是初中的時候，大概七八年前了吧，那個時候花生殼什麼的，但是最終用的是 <code>3322.org</code>。</p>
<p>　　其實基本的動態域名的原理很簡單，無非就是本地開一個腳本，不停去探測本機 IP，一旦有變化就去解析服務器修改。</p>
<p>　　本人在這裏拋磚引玉。如果哪裏有別的解析商的 API，大家自己也可以舉一反三，寫什麼 DNSPod 的動態域名，寫什麼 jiasule 的動態域名等等等等。</p>
<p>　　喵~<em>ଘ(੭</em>ˊᵕˋ)੭* ੈ✩‧₊˚</p>
]]></content>
    
    
      <category term="DDNS" scheme="http://xcoder.in/tags/DDNS/"/>
    
      <category term="動態域名" scheme="http://xcoder.in/tags/%E5%8B%95%E6%85%8B%E5%9F%9F%E5%90%8D/"/>
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[圖片主題色提取算法小結]]></title>
    <link href="http://xcoder.in/2014/09/17/theme-color-extract/"/>
    <id>http://xcoder.in/2014/09/17/theme-color-extract/</id>
    <published>2014-09-17T03:34:54.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>所謂主題色提取，就是對於一張圖片，近似地提取出一個調色板，使得調色板裏面的顏色能組成這張圖片的主色調。</p>
</blockquote>
<p>　　以上定義爲我個人胡謅的。</p>
<p>　　大家不要太把我的東西當成嚴謹的文章來看，很多東西什麼的都是我用我自己的理解去做，並沒有做多少考證。</p>
<p>　　解析中都會以 Node.js 來寫一些小 Demo。</p>
<h2 id="引子">引子</h2>
<p>　　寫該文章主要是爲了對我這幾天對於『主題色提取』算法研究進行一個小結。</p>
<p>　　花瓣網需要做一件事，就是把圖片的主題色提取出來加入到花瓣網搜索引擎的索引當中，以供用戶搜索。</p>
<p>　　於是有了一個需求：提取出圖片中在某個規定調色板中的顏色，加入到搜索引擎。</p>
<p>　　接下去就開始解析兩種不同的算法以及在這種業務場景當中的應用。</p>
<h2 id="算法解析">算法解析</h2>
<h3 id="魔法數字法"><del>魔法數字法</del></h3>
<p>　　這個算法大家可以忽略，可能是我使用的姿勢不對，總之提取出來（也許它根本就不是這麼用的）的東西錯誤很大。</p>
<p>　　不過看一下也好開闊下眼界，尤其是我這種想做遊戲又不小心掉進互聯網的坑裏的蒟蒻來說。</p>
<p>　　首先該算法我是從<a href="http://dev.gameres.com/Program/Visual/Other/256color.htm" target="_blank">這裏</a>找到的。想當年我還是經常逛 <a href="http://www.gameres.com/" target="_blank">GameRes</a> 的。ヾ(;ﾟ;Д;ﾟ;)ﾉﾞ</p>
<p>　　然後輾轉反側最終發現這段代碼是提取自 <a href="https://github.com/liballeg/allegro5/blob/4.3/src/color.c#L268-L328" target="_blank">Allegro</a> 遊戲引擎。</p>
<p>　　具體我也就不講了，畢竟找不到資料，只是粗粗瞄了眼代碼裏面有幾個魔法數字（在遊戲和算法領域魔法數字倒是非常常見的），也沒時間深入解讀這段代碼。</p>
<p>　　我把它翻譯成了 Node.js，然後放在了 <a href="https://github.com/XadillaX/theme-color-test/blob/master/version1/magicnumber.js" target="_blank">Demo</a> 當中。大家有興趣可以自己去看看。</p>
<h3 id="八叉樹提取法">八叉樹提取法</h3>
<p>　　這個算法在顏色量化中比較常見的。</p>
<blockquote>
<p>該算法最早見於 1988 年，<strong><em>M. Gervautz</em></strong> 和 <strong><em>W. Purgathofer</em></strong> 發表的論文<strong><em>《A Simple Method for Color Quantization: Octree Quantization》</em></strong>當中。其時間複雜度和空間複雜度都有很大的優勢，並且保真度也是非常的高。</p>
</blockquote>
<p>　　大致的思路就是對於某一個像素點的顏色 <strong>R / G / B</strong> 分開來之後，用二進制逐行寫下。</p>
<p>　　如 <code>#FF7800</code>，其中 <strong>R</strong> 通道爲 <code>0xFF</code>，也就是 <code>255</code>，<strong>G</strong> 爲 <code>0x78</code> 也就是 <code>120</code>，<strong>B</strong> 爲 <code>0x00</code> 也就是 <code>0</code>。</p>
<p>　　接下去我們把它們寫成二進制逐行放下，那麼就是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">R</span>: <span class="string">1111 1111</span>
<span class="attribute">G</span>: <span class="string">0111 1000</span>
<span class="attribute">B</span>: <span class="string">0000 0000</span>
</pre></td></tr></table></figure>

<p>　　<strong>RGB</strong> 通道逐列黏合之後的值就是其在某一層節點的子節點編號了。每一列一共是三位，那麼取值範圍就是 <code>0 ~ 7</code> 也就是一共有八種情況。這就是爲什麼這種算法要開八叉樹來計算的原因了。</p>
<p>　　舉個例子，上述顏色的第一位黏合起來是 <code>100(2)</code>，轉化爲十進制就是 4，所以這個顏色在第一層是放在根節點的第五個子節點當中；第二位是 <code>110(2)</code> 也就是 6，那麼它就是根節點的第五個兒子的第七個兒子。</p>
<p>　　於是我們有了這樣的一個節點結構：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> OctreeNode = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.isLeaf = <span class="literal">false</span>;
    <span class="keyword">this</span>.pixelCount = <span class="number">0</span>;
    <span class="keyword">this</span>.red = <span class="number">0</span>;
    <span class="keyword">this</span>.green = <span class="number">0</span>;
    <span class="keyword">this</span>.blue = <span class="number">0</span>;

    <span class="keyword">this</span>.children = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.children.length; i++) <span class="keyword">this</span>.children[i] = <span class="literal">null</span>;

    <span class="comment">// 這裏的 next 不是指兄弟鏈中的 next 指針</span>
    <span class="comment">// 而是在 reducible 鏈表中的下一個節點</span>
    <span class="keyword">this</span>.next = <span class="literal">null</span>;
};
</pre></td></tr></table></figure>

<ul>
<li><code>isLeaf</code>: 表明該節點是否爲葉子節點。</li>
<li><code>pixelCount</code>: 在該節點的顏色一共插入了幾次。</li>
<li><code>red</code>: 該節點 <strong>R</strong> 通道累加值。</li>
<li><code>green</code>: <strong>G</strong> 累加值。</li>
<li><code>blue</code>: <strong>B</strong> 累加值。</li>
<li><code>children</code>: 八個子節點指針。</li>
<li><code>next</code>: <strong><em>reducible</em></strong> 鏈表的下一個節點指針，後面會作詳細解釋，目前可以先忽略。</li>
</ul>
<h4 id="插入顏色">插入顏色</h4>
<p>　　根據上面的理論，我們大致就知道了往八叉樹插入一個像素點顏色的步驟了。</p>
<p>　　就是每一位 <strong>RGB</strong> 通道黏合的值就是它在樹的那一層的子節點的編號。</p>
<p>　　大致可以看下圖：</p>
<p><img src="http://www.microsoft.com/msj/archive/wicked1.gif" alt="八叉樹插入"><br><small>圖片來源：<a href="http://www.microsoft.com/msj/archive/S3F1.aspx" target="_blank">http://www.microsoft.com/msj/archive/S3F1.aspx</a></small></p>
<p>　　由此可以推斷，在沒有任何顏色合併的情況下，插入一種顏色最壞的情況下是進行 64 次檢索。</p>
<blockquote>
<p><strong>注意：</strong>我們將會把該顏色的 RGB 分量分別累加到該節點的各分量值中，以便最終求平均數。</p>
</blockquote>
<p>　　大致的流程就是從根節點開始 DFS，如果到達的節點是葉子節點，那麼分量、顏色總數累加；否則就根據層數和該顏色的第層數位顏色黏合值得到其子節點序號。若該子節點不存在就創建一個子節點並與該父節點關聯，否則就直接搜下一層去。</p>
<p>　　創建的時候根據層數來確定它是不是葉子節點，如果是的話需要標記一下，並且全局的葉子節點數要加一。</p>
<p>　　還有一點需要注意的就是如果這個節點不是葉子節點，就將其丟到 <strong><em>reducible</em></strong> 相應層數的鏈表當中去，以供之後顏色合併的時候用。關於顏色合併的內容後面會進行解釋。</p>
<p>　　下面是創建節點的代碼：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createNode</span><span class="params">(idx, level)</span> {</span>
    <span class="keyword">var</span> node = <span class="keyword">new</span> OctreeNode();
    <span class="keyword">if</span>(level === <span class="number">7</span>) {
        node.isLeaf = <span class="literal">true</span>;
        leafNum++;
    } <span class="keyword">else</span> {
        <span class="comment">// 將其丟到第 level 層的 reducible 鏈表中</span>
        node.next = reducible[level];
        reducible[level] = node;
    }

    <span class="keyword">return</span> node;
}
</pre></td></tr></table></figure>

<p>　　以及下面是插入某種顏色的代碼：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">addColor</span><span class="params">(node, color, level)</span> {</span>
    <span class="keyword">if</span>(node.isLeaf) {
        node.pixelCount++;
        node.red += color.r;
        node.green += color.g;
        node.blue += color.b;
    } <span class="keyword">else</span> {
        <span class="comment">// 由於 js 內部都是以浮點型存儲數值，所以位運算並沒有那麼高效</span>
        <span class="comment">// 在此使用直接轉換字符串的方式提取某一位的值</span>
        <span class="comment">//</span>
        <span class="comment">// 實際上如果用位運算來做的話就是這樣子的：</span>
        <span class="comment">//   https://github.com/XadillaX/thmclrx/blob/7ab4de9fce583e88da6a41b0e256e91c45a10f67/src/octree.cpp#L91-L103</span>
        <span class="keyword">var</span> str = <span class="string">""</span>;
        <span class="keyword">var</span> r = color.r.toString(<span class="number">2</span>);
        <span class="keyword">var</span> g = color.g.toString(<span class="number">2</span>);
        <span class="keyword">var</span> b = color.b.toString(<span class="number">2</span>);
        <span class="keyword">while</span>(r.length &lt; <span class="number">8</span>) r = <span class="string">'0'</span> + r;
        <span class="keyword">while</span>(g.length &lt; <span class="number">8</span>) g = <span class="string">'0'</span> + g;
        <span class="keyword">while</span>(b.length &lt; <span class="number">8</span>) b = <span class="string">'0'</span> + b;

        str += r[level];
        str += g[level];
        str += b[level];
        <span class="keyword">var</span> idx = <span class="built_in">parseInt</span>(str, <span class="number">2</span>);

        <span class="keyword">if</span>(<span class="literal">null</span> === node.children[idx]) {
            node.children[idx] = createNode(node, idx, level + <span class="number">1</span>);
        }

        <span class="keyword">if</span>(<span class="literal">undefined</span> === node.children[idx]) {
            console.log(color.r.toString(<span class="number">2</span>));
        }

        addColor(node.children[idx], color, level + <span class="number">1</span>);
    }
}
</pre></td></tr></table></figure>

<h4 id="合併顏色">合併顏色</h4>
<p>　　這一步就是八叉樹的空間複雜度低和保真度高的另一個原因了。</p>
<blockquote>
<p>勿忘初心。</p>
</blockquote>
<p>　　我們用這個算法做的是顏色量化，或者說我要拿它提取主題色、調色板，所以肯定是提取幾個有代表性的顏色就夠了，否則茫茫世界中 <strong>RRGGBB</strong> 一共有 419430400 種顏色，怎麼歸納？</p>
<p>　　我們可以讓指定一棵八叉樹不超過多少多少葉子節點（也就是最後能歸納出來的主題色數），比如 8，比如 16、64 或者 256 等等。</p>
<p>　　所以當葉子節點數超過我們規定的葉子節點數的時候，我們就要合併其中一個節點，將其所有子節點的數據都合併到它身上去。</p>
<p>　　舉個例子，我們有一個節點有八個子節點，並且都是葉子節點，那麼我們把八個葉子節點的通道分量全累加到該節點中，顏色總數也累加到該節點中，然後刪除八個葉子節點並把該節點設置爲葉子節點。那麼一下子我們就合併了八個節點有木有！</p>
<p>　　爲什麼這些節點可以被合併呢？</p>
<p>　　我們來看看某個節點下的子節點顏色都有神馬相似點吧——它們的三個分量前七位（或者說如果已經不是最底層的節點的話那就是前幾位）是相同的，那麼比如說剛纔的 <code>FF7800</code>，跟它同級並且擁有相同父節點（也就是它的兄弟節點）的顏色都是什麼呢：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">R</span>: <span class="string">1111 111(0,1)</span>
<span class="attribute">G</span>: <span class="string">0111 100(0,1)</span>
<span class="attribute">B</span>: <span class="string">0000 000(0,1)</span>
</pre></td></tr></table></figure>

<p>　　整合出來一看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>FE7800
FE7801
FE7900
FE7901
FF7800
FF7801
FF7900
FF7901
</pre></td></tr></table></figure>

<p>　　怎麼樣？是不是確實很相近？這就是八叉樹的精髓了，所有的兄弟節點肯定是在一個相近的顏色範圍內。</p>
<p>　　所以說我們要合併就先去最底層的 <strong><em>reducible</em></strong> 鏈表中尋找一個可以合併的節點，把它從鏈表中刪除之後合併葉子節點並且刪除其葉子節點就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">reduceTree</span><span class="params">()</span> {</span>
    <span class="comment">// 找到最深層次的並且有可合併節點的鏈表</span>
    <span class="keyword">var</span> lv = <span class="number">6</span>;
    <span class="keyword">while</span>(<span class="literal">null</span> === reducible[lv]) lv--;

    <span class="comment">// 取出鏈表頭並將其從鏈表中移除</span>
    <span class="keyword">var</span> node = reducible[lv];
    reducible[lv] = node.next;

    <span class="comment">// 合併子節點</span>
    <span class="keyword">var</span> r = <span class="number">0</span>;
    <span class="keyword">var</span> g = <span class="number">0</span>;
    <span class="keyword">var</span> b = <span class="number">0</span>;
    <span class="keyword">var</span> count = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
        <span class="keyword">if</span>(<span class="literal">null</span> === node.children[i]) <span class="keyword">continue</span>;
        r += node.children[i].red;
        g += node.children[i].green;
        b += node.children[i].blue;
        count += node.children[i].pixelCount;
        leafNum--;
    }

    <span class="comment">// 賦值</span>
    node.isLeaf = <span class="literal">true</span>;
    node.red = r;
    node.green = g;
    node.blue = b;
    node.pixelCount = count;
    leafNum++;
}
</pre></td></tr></table></figure>

<p>　　這樣一來，就合併了一個最深層次的節點了，如果滿打滿算的話，一次合併最多會燒掉 7 個節點（我大 FFF 團壯哉）。</p>
<h4 id="建樹">建樹</h4>
<p>　　上面的函數都有了，我們可以開始建樹了。</p>
<p>　　實際上建樹的過程就是遍歷一遍傳入的像素顏色信息，對於每個顏色都插入到八叉樹當中；並且每一次插入之後都判斷下葉子節點數有沒有溢出，如果滿出來的話需要及時合併。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">buildOctree</span><span class="params">(pixels, maxColors)</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pixels.length; i++) {
        <span class="comment">// 添加顏色</span>
        addColor(root, pixels[i], <span class="number">0</span>);

        <span class="comment">// 合併葉子節點</span>
        <span class="keyword">while</span>(leafNum &gt; maxColors) reduceTree();
    }
}
</pre></td></tr></table></figure>

<p>　　整棵樹建好之後，我們應該得到了最多有 <code>maxColors</code> 個葉子節點的高保真八叉樹。其根節點爲 <code>root</code>。</p>
<h4 id="主題色提取">主題色提取</h4>
<p>　　有了這麼一棵八叉樹之後我們就可以從裏面提取我們想要的東西了。</p>
<p>　　主題色提取實際上就是把八叉樹當中剩下的葉子節點 <strong><em>RGB</em></strong> 通道分量求平均，求出來的就是近似的主題色了。（也許有更好的，不是求平均的方法能獲得更好的主題色結果，但是我沒有深入去研究，歡迎大家一起來指正 (❀╹◡╹)）</p>
<p>　　於是我們深度遍歷這棵樹，每遇到葉子節點，就求出顏色加入到我們所存結果的數組或者任意數據結構當中了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">colorsStats</span><span class="params">(node, object)</span> {</span>
    <span class="keyword">if</span>(node.isLeaf) {
        <span class="keyword">var</span> r = <span class="built_in">parseInt</span>(node.red / node.pixelCount).toString(<span class="number">16</span>);
        <span class="keyword">var</span> g = <span class="built_in">parseInt</span>(node.green / node.pixelCount).toString(<span class="number">16</span>);
        <span class="keyword">var</span> b = <span class="built_in">parseInt</span>(node.blue / node.pixelCount).toString(<span class="number">16</span>);
        <span class="keyword">if</span>(r.length === <span class="number">1</span>) r = <span class="string">'0'</span> + r;
        <span class="keyword">if</span>(g.length === <span class="number">1</span>) g = <span class="string">'0'</span> + g;
        <span class="keyword">if</span>(b.length === <span class="number">1</span>) b = <span class="string">'0'</span> + b;

        <span class="keyword">var</span> color = r + g + b;
        <span class="keyword">if</span>(object[color]) object[color] += node.pixelCount;
        <span class="keyword">else</span> object[color] = node.pixelCount;
        
        <span class="keyword">return</span>;
    }

    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
        <span class="keyword">if</span>(<span class="literal">null</span> !== node.children[i]) {
            colorsStats(node.children[i], object);
        }
    }
}
</pre></td></tr></table></figure>

<h4 id="算法小結">算法小結</h4>
<p>　　八叉樹主題色提取算法提取出來的主題色是一個無固定調色板（Non-palette）的顏色羣，它有着對原圖的儘量保真性，但是由於沒有固定的調色板，有時候對於搜索或者某種需要固定值來解釋的場景中還是欠了點火候。但是活靈活現非它莫屬了。比如某種圖片格式裏面預先存調色板然後存各像素的情況下，我們就可以用八叉樹提取出來的顏色作爲該圖片調色板，能很大程度上對這張圖片進行保真，並且圖片顏色也減到一定的量。</p>
<p>　　該算法的完整 Demo 大家可以在我的 <a href="https://github.com/XadillaX/theme-color-test/blob/master/version3/octree.js" target="_blank">Github</a> 當中找到。</p>
<h3 id="最小差值法">最小差值法</h3>
<p>　　這是一個非常簡單又實用的算法。</p>
<p>　　大致的思想就是給定一個調色板，過來一個顏色就跟調色板中的顏色一一對比，取最小差值的那個調色板裏的顏色作爲這個顏色的代表。</p>
<p>　　對比的過程就是分別將 <strong>R / G / B</strong> 通道的值兩兩相減取絕對值，將三個差相加，得到的這個值就是顏色差值了。</p>
<p>　　反正最後就是調色板中哪個顏色跟對比的顏色差值最小，就拿過來就是了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">var</span> best = <span class="number">0</span>;
<span class="keyword">var</span> bestv = pal[<span class="number">0</span>];
<span class="keyword">var</span> bestr = <span class="built_in">Math</span>.abs(r - bestv.r) + <span class="built_in">Math</span>.abs(g - bestv.g) + <span class="built_in">Math</span>.abs(b - bestv.b);

<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; pal.length; j++) {
    <span class="keyword">var</span> p = pal[j];
    <span class="keyword">var</span> res = <span class="built_in">Math</span>.abs(r - p.r) + <span class="built_in">Math</span>.abs(g - p.g) + <span class="built_in">Math</span>.abs(b - p.b);
    <span class="keyword">if</span>(res &lt; bestr) {
        best = j;
        bestv = pal[j];
        bestr = res;
    }
}

r = pal[best].r.toString(<span class="number">16</span>);
g = pal[best].g.toString(<span class="number">16</span>);
b = pal[best].b.toString(<span class="number">16</span>);

<span class="keyword">if</span>(r.length === <span class="number">1</span>) r = <span class="string">"0"</span> + r;
<span class="keyword">if</span>(g.length === <span class="number">1</span>) g = <span class="string">"0"</span> + g;
<span class="keyword">if</span>(b.length === <span class="number">1</span>) b = <span class="string">"0"</span> + b;

<span class="keyword">if</span>(colors[r + g + b] === <span class="literal">undefined</span>) colors[r + g + b] = -<span class="number">1</span>;
colors[r + g + b]++;
</pre></td></tr></table></figure>

<h2 id="我是怎麼做的">我是怎麼做的</h2>
<p>　　八叉樹的缺點我在之前的八叉樹小結中提到過了，就是顏色不固定。對於需要有一定固定值範圍的主題色提取需求來說不是那麼合人意。</p>
<p>　　而最小差值法的話又太古板了。</p>
<p>　　於是我的做法是將這兩種算法都過一遍。</p>
<p>　　比如我要將一張圖片提取出少於 256 種顏色，我會用八叉樹過濾一遍得出保證的兩百多種顏色，然後拿着這批顏色和其數量再扔到最小插值法裏面將顏色規範化一遍，得出的最終結果可能就是我想要的結果了。</p>
<p>　　這期間第二步的效率可以忽略不計，畢竟如果是上面的需求的話第一步的結果也就那麼兩百多種顏色。</p>
<p>　　這個方法我已經實現並且用在我自己的顏色提取包 <strong><em><a href="https://github.com/XadillaX/thmclrx" target="_blank">thmclrx</a></em></strong> 裏了。大致的代碼可以看<a href="https://github.com/XadillaX/thmclrx/blob/7ab4de9fce583e88da6a41b0e256e91c45a10f67/lib/x.js#L95-L145" target="_blank">這裏</a>。</p>
<h2 id="主題色提取_Node-js_包——thmclrx">主題色提取 Node.js 包——thmclrx</h2>
<p>　　在這幾天的辛勤勞作下，總算完成了某種意義上我的第一個 Node.js C++ Addon。</p>
<p>　　跟算法相關（八叉樹、最小差值）的計算全放在了 <a href="https://github.com/XadillaX/thmclrx/tree/master/src" target="_blank">C++ 層</a>進行計算。大家有興趣的可以去讀一下並且幫忙指出各種各樣的缺點，算是拋磚引玉了。</p>
<p>　　這個包的 Repo 在 Github 上面：</p>
<blockquote>
<p><a href="https://github.com/XadillaX/thmclrx" target="_blank">https://github.com/XadillaX/thmclrx</a></p>
</blockquote>
<p>　　文檔自認爲還算完整吧。並且也可以通過</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install thmclrx
</pre></td></tr></table></figure>

<p>　　進行安裝。</p>
<h2 id="本文小結">本文小結</h2>
<p>　　進花瓣兩個月了，這一次終於如願以償地碰觸到了一點點的『算法相關』的活。（我不會告訴你這不是我的任務，是我從別人手中搶來的 2333333 <em>ଘ(੭</em>ˊᵕˋ)੭* ੈ✩‧₊˚</p>
<p>　　總之幾種算法和實現在上方介紹了，具體需要怎麼用還是要看大家自己了。我反正大致找到了我使用的途徑，那你們呢。( ´･･)ﾉ(._.`)</p>
]]></content>
    
    
      <category term="Algorithm" scheme="http://xcoder.in/tags/Algorithm/"/>
    
      <category term="Theme Color" scheme="http://xcoder.in/tags/Theme%20Color/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我是如何實現簡單的隨機中文名生成器的（Node 版）]]></title>
    <link href="http://xcoder.in/2014/09/01/how-i-made-chinese-random-x/"/>
    <id>http://xcoder.in/2014/09/01/how-i-made-chinese-random-x/</id>
    <published>2014-09-01T12:36:33.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="序">序</h2>
<p>最近閒着蛋疼實現了兩個庫。</p>
<ul>
<li>隨機生成中文名字</li>
<li>隨機生成中文技能名</li>
</ul>
<p>我當然不會說去用各種人工智能去實現一個強大的的解析器然後生成，也不會說用一個非常龐大如搜狗拼音的姓名庫來隨機獲取——我只是偶然間知道蘑菇街小俠節一個混戰 PK 的 Demo 編寫比賽，閒來無聊隨便寫寫，然而這其中我需要隨機給 Bot 起名以及技能起名而用到的庫。</p>
<p>不需要有多少正確性——這兩個庫的結果經常出現非常奇葩的名字，讓人哭笑不得，但是我要的就是這種效果。</p>
<h2 id="結果示範">結果示範</h2>
<p>就兩個庫，我各生成一批名字以示效果。</p>
<h3 id="Chinese_Random_Name">Chinese Random Name</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>闕造
廣錫一
席寺
扶駕
鄭萱黃
林樊牽
孟登元
魚彰
皮憂暑
左稗
宦醇
糜弋招
席準
方抑
烏泔
苗魯
孟候依
龍珠餞
洪打鷹
繆負鐸
</pre></td></tr></table></figure>

<h3 id="Chinese_Random_SKill">Chinese Random SKill</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>地永心法
纓槍訣
冉腿
尼邏心法
奠拳譜
曲掌法
始刺
娘桶擷刀
璋瑾單養刀
銎刀
勵儉驛媛心訣
瞻馳刀訣
晏協驊腿
示嫩帳羽刀訣
賽勘神體刀訣
鑄愛指
施淨琮萍棍
泊臨惇槍訣
我道六分槍
殘亭求拳譜
</pre></td></tr></table></figure>

<h2 id="解析">解析</h2>
<p>實際上無論是起名還是技能名，都用了一個相同的起名字庫和一段差不多的複用代碼（雖然沒有真正意義上的複用，只是複製粘貼而已，誰讓他們是兩個庫呢，已經很簡單了，我總不能再給他們搞一個依賴出來吧？）</p>
<h3 id="起姓">起姓</h3>
<p>關於 <code>chinese-random-name</code> 中的姓氏，我找了一箇中國百家姓（包括複姓）比較全的詞庫。</p>
<blockquote>
<p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/dict/f.dict" target="_blank">詞庫鏈接</a></p>
</blockquote>
<p>比較幸運，我找到的時候已經是這麼分段分好了。我也沒有詳細做研究，隨便給了不同的段不同的權值，當然越前面的段權值越高，被隨機到的可能性越大。</p>
<p>首先用 <code>split</code> 來分割不同段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>dict = dict.split(<span class="string">"\n\n"</span>);
</pre></td></tr></table></figure>

<p>對於每一段來說通過 <code>Array.reduce</code> (詳見 <a href="https://github.com/andrewplummer/Sugar/blob/master/lib/es5.js#L287" target="_blank">SugarJs</a>) 來分割成行再成字。</p>
<p>看字典一共有 6 大段，每段的權值分別爲：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">const</span> weights = [ <span class="number">100</span>, <span class="number">70</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span> ];
</pre></td></tr></table></figure>

<p>然後每個字都有一個其權值區間，是累加上去的。</p>
<p>最後獲取姓的時候隨機生成一個在總區間內的數字，然後看看數字在哪個姓的區間內，就返回這個姓。</p>
<h3 id="技能後綴">技能後綴</h3>
<p>關於 <code>chinese-random-skill</code> 中的技能後綴，我偷懶了。因爲那個時候 Demo 就快 Deadline 了，所以隨便糊弄了一下——直接把印象裏面比較熟的後綴寫上去了事，也不給權值了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> suffix = [
    <span class="string">"劍"</span>, <span class="string">"劍法"</span>, <span class="string">"劍譜"</span>, <span class="string">"劍訣"</span>,
    <span class="string">"槍"</span>, <span class="string">"槍法"</span>, <span class="string">"槍訣"</span>,
    <span class="string">"拳"</span>, <span class="string">"拳法"</span>, <span class="string">"拳譜"</span>,
    <span class="string">"刀"</span>, <span class="string">"刀法"</span>, <span class="string">"刀譜"</span>, <span class="string">"刀訣"</span>,
    <span class="string">"斬"</span>, <span class="string">"刺"</span>, <span class="string">"大法"</span>, <span class="string">"心訣"</span>, <span class="string">"心法"</span>, <span class="string">"訣"</span>, <span class="string">"寶典"</span>,
    <span class="string">"棍"</span>, <span class="string">"棍法"</span>, <span class="string">"棍譜"</span>, <span class="string">"棍訣"</span>,
    <span class="string">"指"</span>, <span class="string">"掌"</span>, <span class="string">"掌法"</span>, <span class="string">"腿"</span>, <span class="string">"攻"</span>, <span class="string">"鉤"</span>
];
</pre></td></tr></table></figure>

<h3 id="共用部分">共用部分</h3>
<p>名字主體爲兩個包的共用部分。</p>
<p>實際上他們依賴於一個特定款式的字庫——我也就網上隨便那麼一搜。</p>
<blockquote>
<p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/dict/n.dict" target="_blank">字庫鏈接</a></p>
</blockquote>
<p>它每一行的結構一樣：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">Number</span> UniChar UniChar：<span class="built_in">String</span>
</pre></td></tr></table></figure>

<p>其中第一個數字我目測是繁體的筆畫數，比如 899 行的 <code>書</code> 繁體就是 <code>書</code>，數一下的確是 10 劃。</p>
<p>第二個就是字本體，第三個是該字的五行屬性，最後是這個字在什麼什麼命數（請不要迷信）描述。</p>
<p>爲了讓名字看起來稍微正常點（只是稍微而已），我儘可能讓同屬性的字在一塊兒，於是有了以下組合：</p>
<ul>
<li>金金</li>
<li>木木</li>
<li>水水</li>
<li>火火</li>
<li>土土</li>
</ul>
<p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/lib/name.js#L41" target="_blank">這些字</a>湊在一起的權值爲 100。</p>
<p>然後隔一個屬性的話是相剋的，我不懂什麼起名大法什麼的，只是用膝蓋想了下相剋的屬性不好起名吧（猜錯了不要怨我），於是給了 20 的權值。</p>
<p>至於隔壁屬性，是相生吧？於是給了 50 權值。</p>
<p>對於三個字的起名來說，也是用了類似的方法給權值，具體可以參考代碼。</p>
<p>總之就是根據其兩兩之間的五行關係來起名的，聽起來還是有那麼點道理的。</p>
<p>哈哈，權當玩的，認真你就輸了。</p>
<h3 id="綜合說明">綜合說明</h3>
<p>上面的分步做完了，然後真·生成名字的步驟是：</p>
<p>隨機生成一個姓（或者技能後綴），然後按照某個權值隨機生成一個數字代表剩下的名字的長度，然後隨機生成一串該長度的名字即可。</p>
<p>最後拼接上去就 OK 了。</p>
<h2 id="無節操小廣告">無節操小廣告</h2>
<p>最後還是貼一下兩個包的 repo 地址吧：</p>
<blockquote>
<ul>
<li><a href="https://github.com/XadillaX/chinese-random-name" target="_blank">Chinese Random Name</a></li>
<li><a href="https://github.com/XadillaX/chinese-random-skill" target="_blank">Chinese Random Skill</a></li>
</ul>
</blockquote>
<p>以及安裝的話照下去弄就好了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>$ npm install chinese<span class="attribute">-random</span><span class="attribute">-name</span>
$ npm install chinese<span class="attribute">-random</span><span class="attribute">-skill</span>
</pre></td></tr></table></figure>

<p><code>README</code> 文件兩個包都有。</p>
]]></content>
    
    
      <category term="NodeJS" scheme="http://xcoder.in/tags/NodeJS/"/>
    
      <category term="中文名" scheme="http://xcoder.in/tags/%E4%B8%AD%E6%96%87%E5%90%8D/"/>
    
      <category term="中文技能" scheme="http://xcoder.in/tags/%E4%B8%AD%E6%96%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storm 中 Clojure 的 Prepare Bolt 實現]]></title>
    <link href="http://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/"/>
    <id>http://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/</id>
    <published>2014-08-04T03:50:21.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>　　Storm 中的 Bolt 都是通過 Nimbus 這個服務將序列化好的 Bolt 斷章取義地發到各個 worker 中。所以，任何在 bolt 之外你自認爲加載期間初始化計算好的上下文環境並不會被打包上去，Java 我不懂也不知道，但是至少在 Clojure 這個類的概念被淡化的 LIST 方言中，你要做的就是把所有跟 bolt 初始化計算相關的代碼放到其 <code>prepare</code> 的代碼當中去。</p>
<p>　　你想一下，當你在文件加載的時候初始化了一個 MongoDB 鏈接，這個鏈接總不能被序列化到遠程去吧？所以說辦法就是把 bolt 搞上去之後，bolt 自動去初始化一個鏈接——這就是 <code>prepare</code> 的作用了。</p>
<p>　　說白了，這個還是我們在 <strong><em>Suwako</em></strong> 當中踩到的坑。</p>
<h2 id="做法">做法</h2>
<p>　　大致的骨架如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="list">(<span class="title">defbolt</span> bolt <span class="collection">[...]</span> <span class="collection">{<span class="attribute">:prepare</span> true}</span>
 <span class="collection">[...]</span>
 <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[...]</span>
  <span class="list">(<span class="title">bolt</span>
   <span class="list">(<span class="title">prepare</span> <span class="collection">[...]</span>
    <span class="list">(<span class="title">...</span>)</span>)</span>
   <span class="list">(<span class="title">execute</span> <span class="collection">[tuple]</span>
    <span class="list">(<span class="title">...</span>)</span>)</span>)</span>)</span></span>
</pre></td></tr></table></figure>

<p>　　首先就是 <code>{:prepare true}</code> 代表了它是一個需要初始化的 Bolt。</p>
<p>　　然後在 <code>(bolt)</code> 的作用域之內有兩個 form——<code>prepare</code> 和 <code>execute</code>。</p>
<p>　　其中 <code>prepare</code> 就是你要初始化的語句了。舉個例子，我們讓這裏面初始化一個 <a href="http://clojuremongodb.info/" target="_blank">Monger</a>，於是我們要在 <code>let</code> 裏面定義一個用於鏈接的 <code>atom {}</code>。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="list">(<span class="title">defbolt</span> bolt <span class="collection">[<span class="string">"..."</span>]</span> <span class="collection">{<span class="attribute">:prepare</span> true}</span>
 <span class="collection">[conf context collector]</span>
 <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[conn <span class="list">(<span class="title"><span class="built_in">atom</span></span> <span class="collection">{}</span>)</span>
       db <span class="list">(<span class="title"><span class="built_in">atom</span></span> <span class="collection">{}</span>)</span>]</span>
   <span class="list">(<span class="title">bolt</span>
    <span class="list">(<span class="title">prepare</span> <span class="collection">[conf context collector]</span>
     <span class="list">(<span class="title"><span class="built_in">reset!</span></span> conn <span class="list">(<span class="title">mg/connect</span> ...)</span>)</span>
     <span class="list">(<span class="title"><span class="built_in">reset!</span></span> db <span class="list">(<span class="title">mg/get-db</span> @conn ...)</span>)</span>)</span>
    <span class="list">(<span class="title">execute</span> <span class="collection">[tuple]</span>
     <span class="list">(<span class="title">...</span>)</span>)</span>)</span>)</span>)</span>
</pre></td></tr></table></figure>

<p>　　這樣一來，當 Bolt 被 Nimbus 打包傳到各個 worker 之後，Bolt 執行起來的時候會自動執行 <code>prepare</code> 當中的代碼，即初始化 MongoDB 的鏈接，並且將其賦值給 <code>conn</code> 和 <code>db</code> 兩個 atom。</p>
<p>　　那麼，我們就能在本體 <code>execute</code> 當中使用 <code>@conn</code> 和 <code>@db</code> 來使喚 MongoDB 了。</p>
<h2 id="思考">思考</h2>
<p>　　可能很多人不解，不是說儘量保持 LISP 語系當中值的不變性的麼？</p>
<p>　　其實不變性只是爲了提高程序在運行時的效率——而事實上是，上面那段代碼並沒有在運行時去做變量。</p>
<p>　　雖然說這麼說有點牽強，但是的確就是這個意思——因爲我們是在程序執行真正有用的好邏輯的時候沒有去改變一些值，相反只是在 Bolt 啓動的時候做一些變量的操作。</p>
<p>　　換句話說，雖然嚴謹的講那個時候是算運行時，但是在運行時裏面我們卻可以把它歸類爲預處理——這一類東西反正程序還沒真正開始跑有用的東西，效率慢一點無所謂，而且就初始化這麼屁大點事兒能有多少影響？</p>
<p>　　效率和效果之間權衡上面的還是要仁者見仁智者見智了。</p>
<h2 id="小結">小結</h2>
<p>　　本以爲 <code>Suwako</code> 終於可以暫時告一段落了，緊要關頭居然還是阻塞了。</p>
<p>　　說多都是淚，不說了，找 Bug 去了。</p>
<p><img src="suwako.jpg" alt="泄矢諏訪子"></p>
]]></content>
    
    
      <category term="Storm" scheme="http://xcoder.in/tags/Storm/"/>
    
      <category term="Clojure" scheme="http://xcoder.in/tags/Clojure/"/>
    
      <category term="Huaban" scheme="http://xcoder.in/tags/Huaban/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[開發測試時給 Kafka 發消息的 UI 發送器——Mikasa]]></title>
    <link href="http://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/"/>
    <id>http://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/</id>
    <published>2014-07-30T02:14:29.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起_(灬ºωº灬)">起 (灬ºωº灬)</h2>
<p>　　說來話長，自從入了花瓣，整個人就掉進連環坑了。</p>
<p>　　後端元數據採集是用 Storm 來走拓撲流程的，又因爲 @<a href="http://weibo.com/zolazhou" target="_blank">Zola</a> 不是很喜歡 Java，所以退而求其次選擇了 Clojure，所以正在苦逼地學習 Clojure 和 Storm 中。</p>
<p>　　目前來說外面的 Storm 拓撲的 Spout 是從 Kafka 中流入數據的。但是我們要給 Kafka 發送測試數據的時候，就需要跑到 Kafka 的測試服務器打開它的一個發送腳本進去發送，非常蛋疼；要麼就是直接通過特定的發送業務邏輯代碼測試，沒有一個稍微泛一點的測試用發數據工具，於是 Mikasa 誕生了。</p>
<h2 id="承_(ﾟ3ﾟ)～♪">承 (ﾟ3ﾟ)～♪</h2>
<p>　　講到 Mikasa 名字的來源，實際上看過『巨人』都知道，八塊腹肌的三爺。</p>
<p>　　這裏小爆料一下，又拍雲和花瓣（都是同宗）的項目名很大部分都是以海賊王的角色命名的——尤其是又拍雲更是喪心病狂。不過這讓我這個僞·二次元的小夥伴異常欣喜，因爲我也能用各種啪啪啪來命名我的角色了。比如我的第一個 Storm 相關的項目就叫 Suwako，即諏訪子大人，因爲腦子需要各種跳，於是就對諏訪子大人這位青蛙之神各種膜拜。</p>
<p>　　至於這個發射器爲什麼要用三爺呢？因爲三爺相當於先鋒軍哇！</p>
<p><img src="mikasa.jpeg" alt="Mikasa"></p>
<p>　　這裏的 Kafka 依賴用了搜狐小夥伴 @<a href="http://weibo.com/crzidea" target="_blank">Crzidea</a> 他們團隊寫的模塊。</p>
<h2 id="轉_(ㄏ￣▽￣)ㄏ_ㄟ(￣▽￣ㄟ)">轉 (ㄏ￣▽￣)ㄏ   ㄟ(￣▽￣ㄟ)</h2>
<p>　　於是，話也不多說，直接上 repo 吧。在公司內網的 gitlab 裏面有一份，還有一個 repo 在 <a href="https://github.com/" target="_blank">GitHub</a> 上。</p>
<blockquote>
<p><a href="https://github.com/XadillaX/mikasa" target="_blank">點我</a></p>
</blockquote>
<h3 id="Download_||_Clone">Download || Clone</h3>
<p>　　如果要直接下載的話就用這個鏈接：</p>
<blockquote>
<p><a href="https://github.com/XadillaX/mikasa/archive/master.zip" target="_blank">https://github.com/XadillaX/mikasa/archive/master.zip</a></p>
</blockquote>
<p>　　如果要克隆的話就：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="constant">XadillaX</span>/mikasa.git
</pre></td></tr></table></figure>

<h3 id="Setup">Setup</h3>
<p>　　直接安裝一下依賴：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install
</pre></td></tr></table></figure>

<h3 id="Configuration">Configuration</h3>
<p>　　接下去就是簡單的配置一下了，其實就是配置下配置文件。由於是快速開發，直接用了自己之前的 <a href="https://github.com/XadillaX/exframess" target="_blank">Exframess</a> 框架，所以很多無用代碼也懶得刪了。</p>
<h4 id="config/server-js">config/server.js</h4>
<p>　　這裏其實別的也不用動，主要是修改下端口即可。</p>
<h4 id="config/kafka-js">config/kafka.js</h4>
<p>　　這裏修改一下 Kafka 的 <code>Connection String</code> 就好了。</p>
<h3 id="Start_up">Start up</h3>
<p>　　最後啓動服務即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>node app.js
<span class="comment"># or</span>
<span class="variable">$ </span>pm2 app.js
<span class="comment"># or some other's</span>
</pre></td></tr></table></figure>

<h2 id="合_(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧">合 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</h2>
<p>　　最後的效果是這樣的：</p>
<p><img src="mikasa-preview.png" alt="Preview"></p>
<p>　　只要在 Topics 欄裏面輸入你要發送的 Topic，然後再下面的消息欄裏面輸入你要傳的消息（字符串），最後點擊 <code>Send</code> 即可將你的測試消息發進 Kafka 中去了。</p>
<blockquote>
<p>託大家的福，今天我的 Suwako 整個邏輯終於跑通了，撒花！ε٩(๑&gt; ₃ &lt;)۶з</p>
</blockquote>
]]></content>
    
    
      <category term="Kafka" scheme="http://xcoder.in/tags/Kafka/"/>
    
      <category term="Mikasa" scheme="http://xcoder.in/tags/Mikasa/"/>
    
      <category term="花瓣" scheme="http://xcoder.in/tags/%E8%8A%B1%E7%93%A3/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Untrusted - 遊戲題解]]></title>
    <link href="http://xcoder.in/2014/06/12/untrusted-solution/"/>
    <id>http://xcoder.in/2014/06/12/untrusted-solution/</id>
    <published>2014-06-12T03:08:34.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://alexnisnevich.github.io/untrusted/" target="_blank">Trusted</a> 是一個代碼解謎遊戲，用 Javascript 來過關的。</p>
<p>　　昨天凌晨花了仨小時通關了這個遊戲，在這裏就粗粗做一下題解吧，好幾題都是 Hack 過去的。（不要臉，( ﾟДﾟ)σ</p>
<h2 id="Ceil_Block_A">Ceil Block A</h2>
<p>　　這有點像教學關吧，總之先拿到那臺電腦你就能操作了。拿到電腦後你就能修改地圖內部黑色底色的代碼了。</p>
<p>　　這個時候你只需要把中間設置牆的代碼去掉就可以了，或者註釋掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">//for(y = 3; y &lt;= map.getHeight() - 10; y++) {</span>
<span class="comment">//    map.placeObject(5, y, 'block');</span>
<span class="comment">//    map.placeObject(map.getWidth() - 5, y, 'block');</span>
<span class="comment">//}</span>
<span class="comment">//</span>
<span class="comment">//for(x = 5; x &lt;= map.getWidth() - 5; x++) {</span>
<span class="comment">//    map.placeObject(x, 3, 'block');</span>
<span class="comment">//    map.placeObject(x, map.getHeight() - 10, 'block');</span>
<span class="comment">//}</span>
</pre></td></tr></table></figure>

<p>　　然後 <code>&lt;ctrl-5&gt;</code> 重新執行——噠噠～牆就消失了，趕緊到藍色的出口處吧。</p>
<h2 id="The_Long_Way_Out">The Long Way Out</h2>
<p>　　代碼大致是給你創建了一個迷宮，並且出口處四面用圍牆圍起來。</p>
<p>　　我用了一個比較 Hack 的方法，在第一個黑色區域的最上方把 <code>maze.create</code> 重定向到自己的一個空函數，這樣下面調用創建迷宮的函數就不會被執行，這個時候再執行的話迷宮就不見了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>maze.create = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>};
</pre></td></tr></table></figure>

<p>　　迷宮不見了還不靠譜，因爲還有一個出口四周有牆——那就自己再建一個出口唄，在第二個黑色區域寫上建立一個新出口的代碼即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.placeObject(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"exit"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>勇敢的少年啊，快去創造奇蹟！</p>
</blockquote>
<h2 id="Validation_Engaged">Validation Engaged</h2>
<p>　　這題的要求是在還存在着一定量『壁』的情況下你能到達出口，也就是說純粹地刪除它加『壁』的代碼是不行的，那我們做點改動就 OK 了。把『壁』往外移動，直到把人和出口都是在『壁』內。</p>
<blockquote>
<p>那一天，人類終於回想起曾經一度被他們所支配的恐怖，還有囚禁於鳥籠中的那份屈辱。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">for</span>(y = <span class="number">0</span>; y &lt;= map.getHeight() - <span class="number">3</span>; y++) {
    map.placeObject(<span class="number">5</span>, y, <span class="string">'block'</span>);
    map.placeObject(map.getWidth() - <span class="number">5</span>, y, <span class="string">'block'</span>);
}

<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt;= map.getWidth() - <span class="number">5</span>; x++) {
    map.placeObject(x, <span class="number">3</span>, <span class="string">'block'</span>);
    map.placeObject(x, map.getHeight() - <span class="number">3</span>, <span class="string">'block'</span>);
}
</pre></td></tr></table></figure>

<h2 id="Multiplicity">Multiplicity</h2>
<p>　　嘛嘛，這是第二關的簡化版——直接再搞一個出口就 OK 了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.placeObject(<span class="number">20</span>, <span class="number">10</span>, <span class="string">'exit'</span>);
</pre></td></tr></table></figure>

<h2 id="Minesweeper">Minesweeper</h2>
<p>　　這是一個雷區，你不碰雷就好。從代碼裏面看出來有個 <code>map.setSquareColor</code> 函數可以設置某個格子的顏色。那好辦，我們在設置一個地雷後把它用別的顏色標記出來就好了，然後重新執行只要你不是色盲都能安全通過。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.setSquareColor(x, y, <span class="string">"#ff7800"</span>);
</pre></td></tr></table></figure>

<h2 id="Drones_101">Drones 101</h2>
<p>　　這題大概就是說有個癡漢會跟你靠近，然後把你先奸後殺。</p>
<p>　　但是癡漢很笨，在他的必經之路用牆堵住他就不會繼續動了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>map.placeObject(<span class="number">30</span>, <span class="number">12</span>, <span class="string">'block'</span>);
map.placeObject(<span class="number">31</span>, <span class="number">11</span>, <span class="string">'block'</span>);
</pre></td></tr></table></figure>

<h2 id="Colors">Colors</h2>
<p>　　這個是那個賣相不錯的電話機的教學關卡。所以大致的意思是設置了打電話的回調函數即可。ε٩(๑&gt; ₃ &lt;)۶з</p>
<p>　　分析代碼可知，要通過那幾個長得跟菊花一樣的帶色兒的牆你就要跟那個菊花顏色一樣。所以電話機的回調函數大致是讓你自己變色就好了。</p>
<p>　　按照順序所見，如果人是綠色的通過之後要變成紅色，然後再變成黃色再綠色。於是寫以下的變色過程就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> player = map.getPlayer();

<span class="keyword">var</span> color = player.getColor();
<span class="keyword">switch</span>(color) {
    <span class="keyword">case</span> <span class="string">"#0f0"</span>:
        player.setColor(<span class="string">"#f00"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">"#f00"</span>:
        player.setColor(<span class="string">"#ff0"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">"#ff0"</span>:
        player.setColor(<span class="string">"#0f0"</span>);
        <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<p>　　重新執行撿起電話機，然後通過綠菊花之後按 <code>Q</code> 使用電話機讓自己變色兒就好了。</p>
<blockquote>
<p>“哎呀，天！他是惦記弟弟了。……可我還不知道呢！那麼這是他老人家的狗？很高興。……你把它帶去吧。……這條小狗怪不錯的。……挺伶俐。……一口就把這傢伙的手指咬破了！哈哈哈哈！……咦，你幹嗎發抖？嗚嗚，……嗚嗚。……它生氣了，小壞蛋，……好一條小狗……”</p>
</blockquote>
<h2 id="Into_the_Woods">Into the Woods</h2>
<p>　　森林裏面有樹和牆，我也懶得想或者寫代碼了。（明明是自己想不出來#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</p>
<p>　　總之我是儘可能向出口靠近，然後到死路了趕緊打電話讓森林重新生成一遍，如此循環往復直到出口。</p>
<h2 id="Fording_the_River">Fording the River</h2>
<p>　　23333333333333！做這題的時候差點沒把自己瀏覽器卡死。</p>
<p>　　大致的意思是河的上面有一條船，你直接遇水會死，要上船。但是船貌似不跟你走啊 QAQ。</p>
<p>　　而且設定寫着只能有一條 <code>raft</code>。</p>
<p>　　咱就來個偷天換日，自己造諾亞方舟鋪滿整條河（因爲懶得計算）。</p>
<p>　　首先定義諾亞方舟的類型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"noah"</span>, {
    <span class="string">'type'</span>: <span class="string">'dynamic'</span>,
    <span class="string">'symbol'</span>: <span class="string">'a'</span>,
    <span class="string">'color'</span>: <span class="string">'#420'</span>,
    <span class="string">'transport'</span>: <span class="literal">true</span>,
    <span class="string">'behavior'</span>: <span class="function"><span class="keyword">function</span><span class="params">(me)</span> {</span>
    }
});
</pre></td></tr></table></figure>

<p>　　然後呢把它鋪滿整條大河吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; map.getWidth(); x++) {
    <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">5</span>; y &lt; <span class="number">15</span>; y++) {
        map.placeObject(x, y, <span class="string">'noah'</span>);
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p>一條大河，兩岸寬，風吹稻花香兩岸。（喂喂喂，小心卡死<em>(┐「ε:)</em></p>
</blockquote>
<h2 id="Ambush">Ambush</h2>
<p>　　後來我去 <code>Untrusted</code> 的 repo 去看題解，發現他們都是去驅使這羣癡漢幹嘛幹嘛。我感覺我的最簡單暴力了——直接廢了他們。</p>
<p>　　其實呢只要把碰撞函數重寫一遍，這堆癡漢馬上就變得人畜無害，你走過去人家還行禮呢233333333333</p>
<p>　　仔細看一下我們要完成的部分在 <code>behavior</code> 裏面，所以在這裏面用 <code>this</code> 是妥妥生效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">this</span>.onCollision = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>};
</pre></td></tr></table></figure>

<blockquote>
<p>看我碎蛋大粉拳！（忽然覺得下身一陣疼痛  |Д`)ノ⌒●～*</p>
</blockquote>
<h2 id="Robot">Robot</h2>
<p>　　你走一步機器人走一步，也是教學關卡。</p>
<p>　　機器人能往下走就往下走，能往右走就往右走就拿到鑰匙了，最後你再追上機器人把鑰匙搶過來就好了。因爲機器人是可以穿過紫翔色的那扇門的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">if</span>(me.canMove(<span class="string">"down"</span>)) me.move(<span class="string">"down"</span>);
<span class="keyword">else</span> me.move(<span class="string">"right"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>站住，保護費。你不裝 X 我們還是好朋友。</p>
</blockquote>
<h2 id="Robot_Nav">Robot Nav</h2>
<p>　　我居然無聊到自己把路線數出來了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> road = <span class="string">"ddddrrrrrrrrrrrrrrrrrrrrrrrrrrrrrruurrrrrrrrrrrrrrrrrddddddd"</span>;
<span class="keyword">this</span>.cur = <span class="keyword">this</span>.cur === <span class="literal">undefined</span> ? <span class="number">0</span> : (<span class="keyword">this</span>.cur + <span class="number">1</span>);

<span class="keyword">if</span>(<span class="keyword">this</span>.cur &gt;= road.length) <span class="keyword">return</span>;

<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"d"</span>) me.move(<span class="string">"down"</span>);
<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"r"</span>) me.move(<span class="string">"right"</span>);
<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"u"</span>) me.move(<span class="string">"up"</span>);
</pre></td></tr></table></figure>

<h2 id="Robot_Maze">Robot Maze</h2>
<p>　　好吧作者早就想到了有人會無聊地去數。</p>
<p>　　嘛嘛，就如作者所願寫個最基礎的 DFS 了事吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="keyword">var</span> direct = {
    <span class="string">"d"</span>: <span class="string">"down"</span>,
    <span class="string">"u"</span>: <span class="string">"up"</span>,
    <span class="string">"l"</span>: <span class="string">"left"</span>,
    <span class="string">"r"</span>: <span class="string">"right"</span>
};

<span class="comment">// dfs...</span>
<span class="keyword">if</span>(<span class="literal">undefined</span> === <span class="keyword">this</span>.dfs) {
    <span class="keyword">this</span>.ans = <span class="string">""</span>;
    <span class="keyword">this</span>.step = <span class="number">0</span>;

    <span class="keyword">var</span> vis = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        vis.push([]);
        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) vis[i].push(<span class="literal">false</span>);
    }

    <span class="keyword">var</span> dir = [
        [ <span class="number">0</span>, -<span class="number">1</span>, <span class="string">"u"</span>, <span class="string">"#f00"</span> ],
        [ <span class="number">0</span>, <span class="number">1</span>, <span class="string">"d"</span>, <span class="string">"#0f0"</span> ],
        [ -<span class="number">1</span>, <span class="number">0</span>, <span class="string">"l"</span>, <span class="string">"#00f"</span> ],
        [ <span class="number">1</span>, <span class="number">0</span>, <span class="string">"r"</span>, <span class="string">"#fff"</span> ]
    ];

    <span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> {</span>
        <span class="keyword">if</span>(x === map.getWidth() - <span class="number">2</span> && y === <span class="number">8</span>) {
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
        vis[y][x] = <span class="literal">true</span>;

        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
            <span class="keyword">var</span> newx = x + dir[i][<span class="number">0</span>];
            <span class="keyword">var</span> newy = y + dir[i][<span class="number">1</span>];

            <span class="keyword">if</span>(newx &lt; <span class="number">0</span> || newy &lt; <span class="number">0</span> ||
                newx &gt;= map.getWidth() ||
                newy &gt;= map.getHeight() ||
                vis[newy][newx] ||
                map.getObjectTypeAt(newx, newy) === <span class="string">"block"</span>
                ) <span class="keyword">continue</span>;

            <span class="keyword">var</span> oldans = <span class="keyword">this</span>.ans;
            <span class="keyword">this</span>.ans += dir[i][<span class="number">2</span>];

            <span class="keyword">if</span>(!<span class="keyword">this</span>.dfs(newx, newy)) {
                <span class="keyword">this</span>.ans = oldans;
            } <span class="keyword">else</span> {
                map.setSquareColor(x, y, dir[i][<span class="number">3</span>]);

                <span class="keyword">return</span> <span class="literal">true</span>;
            }
        }

        <span class="keyword">return</span> <span class="literal">false</span>;
    };

    <span class="keyword">this</span>.dfs(<span class="number">1</span>, <span class="number">1</span>);
    <span class="keyword">this</span>.ans += <span class="string">"dd"</span>;
}

<span class="keyword">if</span>(<span class="keyword">this</span>.step &gt;= <span class="keyword">this</span>.ans.length) <span class="keyword">return</span>;
me.move(direct[<span class="keyword">this</span>.ans[<span class="keyword">this</span>.step++]]);
</pre></td></tr></table></figure>

<blockquote>
<p>紅魔館的地下室一樣呢。反正是機器人多走幾步路沒事，沒必要用 BFS 求最優解2333333333</p>
</blockquote>
<h2 id="Crisps_Contest">Crisps Contest</h2>
<p>　　剛纔那仨 2B 機器人引領你拿到了仨顏色的鑰匙在這邊派上用場了。</p>
<p>　　鑽紅菊花你需要有紅鑰匙，並且用了之後會少掉。其它顏色也一樣。最終你要拿到 <code>A</code> 所代表的 <code>theAlgorithm</code> 走到出口。</p>
<blockquote>
<p>等等！啊咧？綠鑰匙的通過判定有個地方可以修改？就是你通過綠菊花的時候需要有綠鑰匙並且你可以選擇你丟棄的東西。丟什麼好呢？電腦？不行不行，過關還靠它呢。電話機？以後肯定要用到。其它顏色鑰匙？那你肯定會被鎖在某個地方出不來。那就只有丟棄 <code>theAlgorithm</code> 了——反正只要拿到 <code>theAlgorithm</code> 之後不再通過綠菊花就沒事了。</p>
</blockquote>
<p>　　於是隻要把綠菊花的通過判斷函數裏面可修改的區域改成 <code>theAlgorithm</code> 就好了。</p>
<p>　　最後走的順序大概是：</p>
<blockquote>
<p>進左上角的門拿到<span style="color: yellow;">黃藥屎</span>和<span style="color: blue;">藍藥屎</span>出來。然後右上角把<span style="color: red;"><strong>紅</strong></span>和<span style="color: blue;"><strong>藍</strong></span>拿出來。然後向下直搗黃龍，左黃菊花進拿到 <code>theAlgorithm</code> 藍菊花通過拿到<span style="color: yellow;">黃藥屎</span>然後再黃菊花出。</p>
<p>大功告成！走向勝利的出口吧！</p>
<p><strong>自古紅藍出 CP！</strong></p>
</blockquote>
<h2 id="Exceptional_Crossing">Exceptional Crossing</h2>
<p>　　又是過河啊，這次你只能是死了，因爲你的編輯區域只有在 <code>player.killedBy()</code> 裏面。</p>
<blockquote>
<p>《訂製死神》：這個時候讓死神笑就可以了。</p>
</blockquote>
<p>　　讓我們一起來玩壞它吧！在裏面填上 <code>) = (0</code> 就好了。什麼什麼看不懂？你填進去看一下整句話就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>player.killedBy() = (<span class="number">0</span>);
</pre></td></tr></table></figure>

<p>　　然後死神就會被你玩壞了。你走過去的時候這句話執行出錯了2333333</p>
<h2 id="Lasers">Lasers</h2>
<p>　　有很多隱藏線，你人必須要跟隱藏線的顏色一致才能通過，然後目前所有線都用白色給畫出來。</p>
<p>　　目測作者的意思是讓你把硬編碼的白色改成隱藏線的顏色，這樣就能把線的顏色給標記出來，然後再給電話機寫個函數就是讓你自己的人變色。</p>
<p>　　不過我還是用了個 Hack 的方法——</p>
<p>　　第一條線他要畫就畫，咱不碰它就好了，只不過在第一條線畫完的後面我們把這個畫線函數給 Hack 掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// using canvas to draw the line</span>
<span class="keyword">var</span> ctx = map.getCanvasContext();
ctx.beginPath();
ctx.strokeStyle = <span class="string">'white'</span>;
ctx.lineWidth = <span class="number">5</span>;
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();

createLaser = abc;
</pre></td></tr></table></figure>

<p>　　接下去是在第二片區域寫下自己的畫線函數吧，這題最下方檢測了線的數量不能少於 25 條。麼事，爺高興畫 100 條都麼問題，因爲我都把它縮在左上角了 2333333</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">abc</span><span class="params">()</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) {
        map.createLine([<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span><span class="params">(player)</span> {</span>
            <span class="comment">//... Ahahaha</span>
        });

        <span class="keyword">var</span> ctx = map.getCanvasContext();
        ctx.beginPath();
        ctx.strokeStyle = <span class="string">'red'</span>;
        ctx.lineWidth = <span class="number">5</span>;
        ctx.moveTo(<span class="number">1</span>, <span class="number">1</span>);
        ctx.lineTo(<span class="number">2</span>, <span class="number">2</span>);
        ctx.stroke();
    }
}
</pre></td></tr></table></figure>

<h2 id="Pointers">Pointers</h2>
<p>　　有好多傳送門，每次執行隨機生成傳送位置，有些傳送門會把你傳到二小姐的地下室然後被吃掉。</p>
<p>　　我也懶得多動腦筋或者畫線什麼的，直接對兩個都是傳送門的 CP 標記一樣的隨機顏色就好了，最後跟着顏色走到出口去（有個坑就是有時候這個地圖本身就是死局，所以得多試幾次重新執行 இдஇ</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> dict = <span class="string">"0123456789ABCDEF"</span>;
<span class="keyword">if</span>(t1.getType() === <span class="string">"teleporter"</span> && t2.getType() === <span class="string">"teleporter"</span>) {
    <span class="keyword">var</span> color = <span class="string">"#"</span> + dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +
        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +
        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)];

    map.setSquareColor(t1.getX(), t1.getY(), color);
    map.setSquareColor(t2.getX(), t2.getY(), color);
}
</pre></td></tr></table></figure>

<h2 id="Super_Dr-_Eval_Bros">Super Dr. Eval Bros</h2>
<p>　　好吧本意是讓你設置一個 <code>timer</code> 然後一直跳啊跳的。</p>
<p>　　不過呢，定一個新方塊給自己搭一座橋就是了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"❤"</span>, {
    impassable: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="literal">true</span>;
    },
    symbol: <span class="string">"❤"</span>
});
map.placeObject(<span class="number">20</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">21</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">22</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">23</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">24</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">25</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">26</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">27</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">28</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">29</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>你只要打個電話橋就會出現的。</p>
</blockquote>
<h2 id="Document_Object_Madness">Document Object Madness</h2>
<p>　　好神奇！好奇葩！我鍵盤 <code>hjkl</code> 亂按一通就過了。</p>
<h2 id="Boss_Fight">Boss Fight</h2>
<p>　　打 Boss 了。</p>
<p>　　好吧我承認我 Cheat 了——原諒我用了 <code>console.log</code>。</p>
<blockquote>
<p>因爲當我打開控制檯的時候下面的語句出現在我的眼裏：</p>
<blockquote>
<p><strong><em>If you can read this, you are cheating!</em></strong></p>
<p><strong><em>But really, you don’t need this console to play the game. Walk around using arrow keys (or Vim keys), and pick up the computer (⌘). Then the fun begins!</em></strong></p>
</blockquote>
</blockquote>
<p>　　嘛嘛，無論如何，過關了就好。</p>
<p>　　這題呢是要讓所有的 <code>boss</code> 給毀滅掉即可—— 當所有的 <code>boss</code> 毀滅之後會爆出任務道具 <code>theAlgorithm</code> 然後就能通關了。</p>
<p>　　後來我發現可以讓子彈消滅 <code>boss</code>。但是我當時沒這麼做。</p>
<p>　　我先弄了堵牆把子彈擋住先：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"保命的"</span>, {
    impassable: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="literal">true</span>;
    },
    symbol: <span class="string">"❤"</span>,
    onCollision: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    }
});

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; map.getWidth(); i++) {
    map.placeObject(i, <span class="number">9</span>, <span class="string">"保命的"</span>);
}
</pre></td></tr></table></figure>

<p>　　這下你就能撿到電話機了——然後給電話機寫回調函數。</p>
<p>　　怎麼說呢，當你每用一次電話機，我就把當前存在於屏幕的 <code>boss</code> 和 <code>bullet</code> 給分開羅列，然後把 <code>boss</code> 的 <code>_destroy</code>（警察叔叔，就是這個函數是我 <code>console.log</code> 出來的）給嫁接到 <code>bullet</code> 的 <code>_destroy</code> 去。</p>
<p>　　這樣會出現什麼樣的結果呢？——當子彈碰到牆的時候就會銷燬，這個時候會觸發 <code>_destroy</code> 函數，但是這個時候的 <code>_destroy</code> 函數已經會變成了 <code>boss</code> 的了，也就是說這個時候子彈不會被銷燬反而是某一個 <code>boss</code> 的 <code>_destroy</code> 函數被調用然後被銷毀了。</p>
<p>　　再怎麼說這都是 Hack 的辦法，所以並不會觸發 <code>boss</code> 的 <code>onDestroy</code> 函數也就是說即使所有 <code>boss</code> 都沒了也不會出現 <code>theAlgorithm</code> 這玩意兒。</p>
<blockquote>
<p>自己動手豐衣足食！</p>
</blockquote>
<p>　　敵人不給我們我們就自己造唄！反正通關判定是——<code>boss</code> 數量爲 <code>0</code> 且你有 <code>theAlgorithm</code> 這個道具。</p>
<p>　　所以說當所有 <code>boss</code> 都被銷燬之後，我們自己去 <code>map.replaceObject</code> 一個 <code>theAlgorithm</code> 道具即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>map.getPlayer().setPhoneCallback(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> bosses = [];
    <span class="keyword">var</span> bullets = [];
    <span class="keyword">var</span> objects = map.getDynamicObjects();
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) {
        <span class="keyword">if</span>(objects[i].getType() == <span class="string">"boss"</span>) {
            bosses.push(objects[i]);
        } <span class="keyword">else</span> {
            bullets.push(objects[i]);
        }
    }
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(bosses.length, bullets.length); i++) {
        bullets[i]._destroy = bosses[i]._destroy;
    }

    <span class="keyword">if</span>(bosses.length === <span class="number">0</span>) {
        map.placeObject(map.getPlayer().getX(), map.getPlayer().getY() + <span class="number">1</span>,
            <span class="string">'theAlgorithm'</span>);
    }
});
</pre></td></tr></table></figure>

<p>　　以上代碼寫完後就開始打 <code>boss</code> 吧！趕緊去拿到電話機，然後你會發現打一個電話 <code>boss</code> 就少一堆，那感覺倍爽兒！</p>
<h2 id="End_of_the_Line">End of the Line</h2>
<p>　　馬上要通關了。這裏是個坑，開始我還以爲這裏就是真·通關了 QAQ。</p>
<p>　　隨後看看後面還是有關卡啊。但是我突然發現 <code>&lt;ctrl+0&gt;</code> 跳出來的 menu 左邊多出了文件夾！然後進去隨意翻看了。</p>
<p>　　最後發現原來是要修改 <code>scripts/objects.js</code> 文件→＿→。</p>
<p>　　好吧，分析通關驗證來看，這一關的 <code>map.finalLevel</code> 爲 <code>true</code>。所以我們只需要把 <code>scripts/objects.js</code> 文件裏面的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span>(!game.map.finalLevel) {
    game._moveToNextLevel();
}
</pre></td></tr></table></figure>

<p>給改成如果是 <code>finalLevel</code> 就跑到下一關去就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span>(game.map.finalLevel) {
    game._moveToNextLevel();
}
</pre></td></tr></table></figure>

<h2 id="Credits">Credits</h2>
<p>　　由於事先文章結構沒有寫好，就接這關的坑位來小結吧 0. 0。（反正人家只是序幕章了</p>
<p>　　好的，其實也什麼總結的，但是總覺得得有這麼個小結纔對。</p>
<p>　　找工作啊找工作——有想要我的請聯繫我 2333333333</p>
<p>　　聯繫資料在 <a href="http://xcoder.in/curriculumvitae/">CV</a> 裏面。</p>
]]></content>
    
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="untrusted" scheme="http://xcoder.in/tags/untrusted/"/>
    
      <category term="遊戲" scheme="http://xcoder.in/tags/%E9%81%8A%E6%88%B2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos2d-x 3.1.1 開發環境搭建（Win篇）]]></title>
    <link href="http://xcoder.in/2014/06/07/cocos2d-311-setup/"/>
    <id>http://xcoder.in/2014/06/07/cocos2d-311-setup/</id>
    <published>2014-06-07T11:34:02.000Z</published>
    <updated>2014-12-10T07:49:31.000Z</updated>
    <content type="html"><![CDATA[<p>由於偷懶，所以在此感謝 Etond 的指導（喂喂喂，明明是自己懶得看文檔，明明 <a href="README"><code>READEME.md</code></a> 裏面就有！(´≖◞౪◟≖)</p>
<p>　　另，在搭建環境的時候，最好保證你在<span style="background: #222;">牆外</span>。以及我默認覺得大家已經有了 <code>Python</code> 環境和 <code>JDK</code>。</p>
<h2 id="前驅工作">前驅工作</h2>
<p>　　先去 <a href="http://www.cocos2d-x.org/download" target="_blank">cocos2d-x 官網</a>下壓縮包，放到一個只有神知道的世界裏面。</p>
<p>　　接下去需要安裝仨東西：</p>
<h3 id="Android_SDK">Android SDK</h3>
<p>　　<a href="http://developer.android.com/sdk/index.html#download" target="_blank">這東西</a>真尼瑪大啊！我家的小水管真吃不起。</p>
<p>　　然後把 <strong>adt-bundle-…zip</strong> 這個包壓縮到任意木有中文和空格的路徑下面。</p>
<h3 id="NDK">NDK</h3>
<p>　　<a href="http://developer.android.com/tools/sdk/ndk/index.html#download" target="_blank">這小夥伴</a>也不小啊。都是 500M 的主兒啊（٩(ŏ﹏ŏ、)۶</p>
<p>　　也解壓到一個地方不用管它。</p>
<h3 id="Ant">Ant</h3>
<p>　　據說這貨是阿帕奇出的？總之下載地址在<a href="http://ant.apache.org/bindownload.cgi" target="_blank">這裏</a>。</p>
<h2 id="安裝">安裝</h2>
<p>　　哦對了你還得有個 Python 路徑，這裏就不累述了。接下去在命令行裏面執行 Cocos2d 的 <code>setup.py</code> 文件即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>/&gt; py setup<span class="preprocessor">.py</span>
</pre></td></tr></table></figure>

<p>　　接下去終端會停在下面一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> NDK_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　在後面輸入你放好的 NDK 目錄即可。</p>
<p>　　如果下面又出現了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> ANDROID_SDK_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　你只需在裏面輸入你剛放好的 Android SDK 的目錄即可。（注意是要剛纔的 SDK 壓縮包解壓出來的 sdk 路徑）</p>
<p>　　再如果下面還出現：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> ANT_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　那麼再把 Ant 的路徑搞上去就好了。（又得注意這裏得是 Ant 的 bin 目錄）</p>
<p>　　最後確保終端（或者說命令行）裏面出現如下字樣：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please restart <span class="operator">the</span> terminal <span class="operator">or</span> restart computer <span class="built_in">to</span> make added <span class="keyword">system</span> variables take effect
</pre></td></tr></table></figure>

<p>　　然後你把終端關了再開一個就好了。至此，大致就安裝完畢了。</p>
<h2 id="新建一個_Demo_項目">新建一個 Demo 項目</h2>
<p>　　隨意跑到一個目錄下面執行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> cocos <span class="literal">new</span> FirstGame <span class="attribute">-p</span> <span class="keyword">in</span><span class="built_in">.</span>xcoder<span class="built_in">.</span>firstgame <span class="attribute">-l</span> cpp <span class="attribute">-d</span> FirstGame
</pre></td></tr></table></figure>

<blockquote>
<p>大致意思就是說創建一個新的項目路徑，叫 <code>FirstGame</code>，其包名叫 <code>in.xcoder.firstgame</code>，然後語言是 <code>cpp</code>，最後 <code>-d</code> 是路徑。</p>
</blockquote>
<p>　　命令詳情幫助可以看 <code>cocos --help</code>。</p>
<h3 id="編譯_Demo">編譯 Demo</h3>
<p>　　讀標題，是 Win 篇。所以我們跑到項目路徑下面的 <code>proj.win32</code> 目錄下面用 M$ VS 打開 <code>FirstGame.sln</code> 就可以打開剛創建的模板項目了。</p>
<p>　　無論如何先編譯看看吧！～</p>
<p>　　如何？跑起來了吧？</p>
<h3 id="打包_Demo">打包 Demo</h3>
<p>　　這裏就講講如何打包安卓的版本吧：</p>
<h4 id="Debug_版本">Debug 版本</h4>
<p>　　跑到你的項目目錄下面（即有 <code>.cocos-project.json</code> 文件的目錄），然後執行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>/&gt; cocos <span class="command">run</span> -p android
</pre></td></tr></table></figure>

<p>　　等工具編譯打包完成就 OK 了。（記得要查安卓手機並且調試模式哦～）</p>
<h4 id="Release_版本">Release 版本</h4>
<p>　　如果要上傳到 Google Play 之類的地方，需要有簽名。所以發佈 Release 版本之前，你先得搞好自己的簽名。</p>
<h5 id="Keytool">Keytool</h5>
<p>　　在終端跑到你的項目路徑下面，然後執行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> keytool <span class="attribute">-genkey</span> <span class="attribute">-v</span> <span class="attribute">-keystore</span> FirstGame<span class="built_in">.</span>keystore <span class="attribute">-alias</span> FirstGame <span class="attribute">-keyalg</span> RSA <span class="attribute">-keysize</span> <span class="number">2048</span> <span class="attribute">-validaty</span> <span class="number">10000</span>
</pre></td></tr></table></figure>

<p>　　照着命令行給的提示完成創建密鑰即可。</p>
<h5 id="編譯">編譯</h5>
<p>　　生成之後啊就直接執行編譯命令了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> cocos run <span class="attribute">-p</span> android <span class="attribute">-m</span> release
</pre></td></tr></table></figure>

<p>　　在裏面呢最後會讓你輸入 <code>.keystore</code> 文件的路徑。</p>
<p>　　我們輸入相對路徑，由於我們剛纔把這個文件搞在項目根目錄，所以我們只需要輸入 <code>../FirstGame.keystore</code> 即可。接下去他會讓你輸入密碼、別名和別名信息的密碼。你都正確輸入一遍他就會安安分分跑在你的手機裏面了。</p>
<h4 id="仨版本的文件路徑">仨版本的文件路徑</h4>
<p>　　上面都弄好之後，你的仨版本 <code>*.apk</code> 文件也就生成了。很多人可能很困惑，爲什麼是仨版本。因爲其中 Release 版本還分帶簽名和沒簽名版本。</p>
<p>　　總之那個路徑在 <code>publish/android</code> 下面，裏面有仨 <code>*.apk</code> 文件，你拿出來發佈就可以了。</p>
<h2 id="小結">小結</h2>
<p>　　其實也沒什麼結不結的，這些東西你們自己去看看官方文檔就好了。總之就這樣了吧，以上。</p>
]]></content>
    
    
      <category term="cocos2d" scheme="http://xcoder.in/tags/cocos2d/"/>
    
      <category term="遊戲開發" scheme="http://xcoder.in/categories/%E9%81%8A%E6%88%B2%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【轉】TCP 的那些事兒（上）]]></title>
    <link href="http://xcoder.in/2014/06/07/tcp-those-things-1/"/>
    <id>http://xcoder.in/2014/06/07/tcp-those-things-1/</id>
    <published>2014-06-06T17:47:10.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>TCP是一個巨複雜的協議，因爲他要解決很多問題，而這些問題又帶出了很多子問題和陰暗面。所以學習 TCP 本身是個比較痛苦的過程，但對於學習的過程卻能讓人有很多收穫。關於 TCP 這個協議的細節，我還是推薦你去看 <a href="http://www.kohala.com/start/" target="_blank">W.Richard Stevens</a> 的《<a href="http://book.douban.com/subject/1088054/" target="_blank">TCP/IP 詳解 卷1：協議</a>》（當然，你也可以去讀一下 <a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC793</a> 以及後面 N 多的 RFC）。另外，本文我會使用英文術語，這樣方便你通過這些英文關鍵詞來查找相關的技術文檔。</p>
<p>　　之所以想寫這篇文章，目的有三個，</p>
<ul>
<li>一個是想鍛鍊一下自己是否可以用簡單的篇幅把這麼複雜的TCP協議描清楚的能力。</li>
<li>另一個是覺得現在的好多程序員基本上不會認認真真地讀本書，喜歡快餐文化，所以，希望這篇快餐文章可以讓你對TCP這個古典技術有所瞭解，並能體會到軟件設計中的種種難處。並且你可以從中有一些軟件設計上的收穫。</li>
<li>最重要的希望這些基礎知識可以讓你搞清很多以前一些似是而非的東西，並且你能意識到基礎的重要。</li>
</ul>
<p>　　所以，本文不會面面俱到，只是對 TCP 協議、算法和原理的科普。</p>
<p>　　我本來只想寫一個篇幅的文章的，但是 TCP 真 TMD 的複雜，比 C++ 複雜多了，這 30 多年來，各種優化變種爭論和修改。所以，寫着寫着就發現只有砍成兩篇。</p>
<ul>
<li>上篇中，主要向你介紹TCP協議的定義和丟包時的重傳機制。</li>
<li>下篇中，重點介紹TCP的流迭、擁塞處理。</li>
</ul>
<p>　　廢話少說，首先，我們需要知道 TCP 在網絡 OSI 的七層模型中的第四層 —— 傳輸層(Transport)，IP 在第三層 —— 網絡層(Network)，ARP 在第二層 —— 數據鏈路層(Data Link)，在第二層上的數據，我們叫 Frame，在第三層上的數據叫 Packet，第四層的數據叫 Segment。</p>
<p>　　首先，我們需要知道，我們程序的數據首先會打到 TCP 的 Segment 中，然後 TCP 的 Segment 會打到 IP 的 Packet 中，然後再打到以太網 Ethernet 的 Frame 中，傳到對端後，各個層解析自己的協議，然後把數據交給更高層的協議處理。</p>
<h2 id="TCP頭格式">TCP頭格式</h2>
<p>　　接下來，我們來看一下 TCP 頭的格式</p>
<p><img src="TCP-Header-01.jpg" alt="TCP 頭格式 1"></p>
<center>TCP 頭格式 1（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank">圖片來源</a>）</center>

<p>　　你需要注意這麼幾點：</p>
<ul>
<li>TCP 的包是沒有 IP 地址的，那是 IP 層上的事。但是有源端口和目標端口。</li>
<li>一個 TCP 連接需要四個元組來表示是同一個連接（<code>src_ip</code>, <code>src_port</code>, <code>dst_ip</code>, <code>dst_port</code>）準確說是五元組，還有一個是協議。但因爲這裏只是說TCP協議，所以，這裏我只說四元組。</li>
<li>注意上圖中的四個非常重要的東西：<ul>
<li><strong><em>Sequence Number</em></strong> 是包的序號，用來<strong>解決網絡包亂序（reordering）問題</strong>。</li>
<li><strong><em>Acknowledgement Number</em></strong> 就是 ACK —— 用於確認收到，<strong>用來解決不丟包的問題</strong>。</li>
<li><strong><em>Window</em></strong> 又叫 <strong><em>Advertised-Window</em></strong>，也就是著名的滑動窗口（Sliding Window），<strong>用於解決流控的</strong>。</li>
<li><strong><em>TCP Flag</em></strong> ，也就是包的類型，主要是<strong>用於操控 TCP 的狀態機的</strong>。</li>
</ul>
</li>
</ul>
<p>　　關於其它的東西，可以參看下面的圖示</p>
<p><img src="TCP-Header-02.jpg" alt="TCP 頭格式 2"></p>
<center>TCP 頭格式 2（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank">圖片來源</a>）</center>

<h2 id="TCP的狀態機">TCP的狀態機</h2>
<p>　　其實，<strong>網絡上的傳輸是沒有連接的，包括 TCP 也是一樣的</strong>。而 TCP 所謂的“連接”，其實只不過是在通訊的雙方維護一個“連接狀態”，讓它看上去好像有連接一樣。所以，TCP 的狀態變換是非常重要的。</p>
<p>　　下面是：“<strong>TCP 協議的狀態機</strong>”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank">圖片來源</a>） 和 “<strong>TCP 建鏈接</strong>”、“<strong>TCP 斷鏈接</strong>”、“<strong>傳數據</strong>” 的對照圖，我把兩個圖並排放在一起，這樣方便在你對照着看。另外，下面這兩個圖非常非常的重要，你一定要記牢。（吐個槽：看到這樣複雜的狀態機，就知道這個協議有多複雜，複雜的東西總是有很多坑爹的事情，所以 TCP 協議其實也挺坑爹的）</p>
<p><img src="tcpfsm.png" alt="TCP 協議的狀態機"> <img src="tcp_open_close.jpg" alt="握手次數"></p>
<p>　　很多人會問，爲什麼建鏈接要 3 次握手，斷鏈接需要 4 次揮手？</p>
<ul>
<li><strong>對於建鏈接的 3 次握手</strong>，主要是要初始化 Sequence Number 的初始值。通信的雙方要互相通知對方自己的初始化的 Sequence Number（縮寫爲 ISN：Inital Sequence Number） —— 所以叫 SYN，全稱 Synchronize Sequence Numbers。也就上圖中的 x 和 y。這個號要作爲以後的數據通信的序號，以保證應用層接收到的數據不會因爲網絡上的傳輸的問題而亂序（TCP 會用這個序號來拼接數據）。</li>
<li><strong>對於 4 次揮手</strong>，其實你仔細看是 2 次，因爲 TCP 是全雙工的，所以，發送方和接收方都需要 Fin 和 Ack。只不過，有一方是被動的，所以看上去就成了所謂的 4 次揮手。如果兩邊同時斷連接，那就會就進入到 CLOSING 狀態，然後到達T IME_WAIT 狀態。下圖是雙方同時斷連接的示意圖（你同樣可以對照着 TCP 狀態機看）：</li>
</ul>
<p><img src="tcpclosesimul.png" alt="兩端同時斷開鏈接"></p>
<center>兩端同時斷開鏈接（<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm" target="_blank">圖片來源</a>）</center>

<p>　　另外，有幾個事情需要注意一下：</p>
<ul>
<li><strong>關於建連接時 SYN 超時</strong>。試想一下，如果 server 端接到了 client 發的 SYN 後回了 SYN-ACK 後 client 掉線了，server 端沒有收到 client 回來的 ACK，那麼，這個連接處於一箇中間狀態，即沒成功，也沒失敗。於是，server 端如果在一定時間內沒有收到的 TCP 會重發 SYN-ACK。在 Linux 下，默認重試次數爲 5 次，重試的間隔時間從 1s 開始每次都翻售，5 次的重試時間間隔爲 1s, 2s, 4s, 8s, 16s，總共 31s，第 5 次發出後還要等 32s 都知道第 5 次也超時了，所以，總共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 - 1 = 63s，TCP 纔會把斷開這個連接。</li>
<li><strong>關於 SYN Flood 攻擊</strong>。一些惡意的人就爲此製造了 SYN Flood 攻擊 —— 給服務器發了一個 SYN 後，就下線了，於是服務器需要默認等 63s 纔會斷開連接，這樣，攻擊者就可以把服務器的 syn 連接的隊列耗盡，讓正常的連接請求不能處理。於是，Linux 下給了一個叫 <code>tcp_syncookies</code> 的參數來應對這個事 —— 當 SYN 隊列滿了後，TCP 會通過源地址端口、目標地址端口和時間戳打造出一個特別的 Sequence Number 發回去（又叫 cookie），如果是攻擊者則不會有響應，如果是正常連接，則會把這個 SYN Cookie 發回來，然後服務端可以通過 cookie 建連接（即使你不在 SYN 隊列中）。請注意，請先千萬別用 <code>tcp_syncookies</code> 來處理正常的大負載的連接的情況。因爲，<code>synccookies</code> 是妥協版的 TCP 協議，並不嚴謹。對於正常的請求，你應該調整三個 TCP 參數可供你選擇，第一個是：<code>tcp_synack_retries</code> 可以用他來減少重試次數；第二個是：<code>tcp_max_syn_backlog</code>，可以增大 SYN 連接數；第三個是：<code>tcp_abort_on_overflow</code> 處理不過來乾脆就直接拒絕連接了。</li>
<li><strong>關於 ISN 的初始化</strong>。ISN 是不能 hard code 的，不然會出問題的 —— 比如：如果連接建好後始終用 1 來做 ISN，如果 client 發了 30 個 segment 過去，但是網絡斷了，於是 client 重連，又用了 1 做 ISN，但是之前連接的那些包到了，於是就被當成了新連接的包，此時，client 的 Sequence Number 可能是 3，而 Server 端認爲 client 端的這個號是 30 了。全亂了。RFC793 中說，ISN 會和一個假的時鐘綁在一起，這個時鐘會在每4微秒對 ISN 做加一操作，直到超過 2^32，又從 0 開始。這樣，一個ISN的週期大約是 4.55 個小時。因爲，我們假設我們的 TCP Segment 在網絡上的存活時間不會超過 Maximum Segment Lifetime（縮寫爲 MSL - Wikipedia 語條），所以，只要 MSL 的值小於 4.55 小時，那麼，我們就不會重用到 ISN。</li>
<li><strong>關於 MSL 和 TIME_WAIT</strong>。通過上面的 ISN 的描述，相信你也知道 MSL 是怎麼來的了。我們注意到，在 TCP 的狀態圖中，從 TIME_WAIT 狀態到 CLOSED 狀態，有一個超時設置，這個超時設置是 2 * MSL（RFC793 定義了 MSL 爲 2 分鐘，Linux 設置成了 30s）爲什麼要這有 TIME_WAIT？爲什麼不直接給轉成 CLOSED 狀態呢？主要有兩個原因：<ol>
<li>TIME_WAIT 確保有足夠的時間讓對端收到了 ACK，如果被動關閉的那方沒有收到 Ack，就會觸發被動端重發 Fin，一來一去正好 2 個MSL；</li>
<li>有足夠的時間讓這個連接不會跟後面的連接混在一起（你要知道，有些自做主張的路由器會緩存IP數據包，如果連接被重用了，那麼這些延遲收到的包就有可能會跟新連接混在一起）。你可以看看這篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
</ol>
</li>
<li><strong>關於 TIME_WAIT 數量太多</strong>。從上面的描述我們可以知道，TIME_WAIT 是個很重要的狀態，但是如果在大並發的短鏈接下，TIME_WAIT 就會太多，這也會消耗很多系統資源。只要搜一下，你就會發現，十有八九的處理方式都是教你設置兩個參數，一個叫 <code>tcp_tw_reuse</code>，另一個叫 <code>tcp_tw_recycle</code> 的參數，這兩個參數默認值都是被關閉的，後者 recyle 比前者 resue 更爲激進，resue 要溫柔一些。另外，如果使用 <code>tcp_tw_reuse</code>，必需設置 <code>tcp_timestamps = 1</code>，否則無效。這裏，你一定要注意，<strong>打開這兩個參數會有比較大的坑 —— 可能會讓 TCP 連接出一些詭異的問題</strong>（因爲如上述一樣，如果不等待超時重用連接的話，新的連接可能會建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank">官方文檔</a>上說的一樣“<strong><em>It should not be changed without advice/request of technical experts</em></strong>”）。<ol>
<li><strong>關於 <code>tcp_tw_reuse</code></strong>。官方文檔上說 <code>tcp_tw_reuse</code> 加上 <code>tcp_timestamps</code>（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保證協議的角度上的安全，但是你需要 <code>tcp_timestamps</code> 在兩邊都被打開（你可以讀一下 <code>tcp_twsk_unique</code> 的源碼 ）。我個人估計還是有一些場景會有問題。</li>
<li><strong>關於 <code>tcp_tw_recycle</code></strong>。如果是 <code>tcp_tw_recycle</code> 被打開了話，會假設對端開啓了 <code>tcp_timestamps</code>，然後會去比較時間戳，如果時間戳變大了，就可以重用。但是，如果對端是一個 NAT 網絡的話（如：一個公司只用一個 IP 出公網）或是對端的 IP 被另一臺重用了，這個事就複雜了。建鏈接的 SYN 可能就被直接丟掉了（你可能會看到 connection time out 的錯誤）（如果你想觀摩一下 Linux 的內核代碼，請參看源碼 <code>tcp_timewait_state_process</code>）。</li>
<li><strong>關於 <code>tcp_max_tw_buckets</code></strong>。這個是控制並發的 TIME_WAIT 的數量，默認值是 180000，如果超限，那麼，系統會把多的給 destory 掉，然後在日誌裏打一個警告（如：time wait bucket table overflow），官網文檔說這個參數是用來對抗 DDoS 攻擊的。也說的默認值 180000 並不小。這個還是需要根據實際情況考慮。</li>
</ol>
</li>
</ul>
<blockquote>
<p>Again，使用 <code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 來解決 TIME_WAIT 的問題是非常非常危險的，因爲這兩個參數違反了TCP協議（<a href="http://tools.ietf.org/html/rfc1122" target="_blank">RFC 1122</a>） 。</p>
</blockquote>
<h2 id="數據傳輸中的_Sequence_Number">數據傳輸中的 Sequence Number</h2>
<p>　　下圖是我從 Wireshark 中截了個我在訪問 coolshell.cn 時的有數據傳輸的圖給你看一下，SeqNum 是怎麼變的。（使用 Wireshark 菜單中的 <code>Statistics -&gt; Flow Graph…</code>）</p>
<p><img src="tcp_data_seq_num.jpg" alt="數據傳輸圖"></p>
<p>　　你可以看到，SeqNum 的增加是和傳輸的字節數相關的。上圖中，三次握手後，來了兩個 Len:1440 的包，而第二個包的 SeqNum 就成了 1441。然後第一個 ACK 回的是 1441，表示第一個 1440 收到了。</p>
<blockquote>
<p><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你會發現 SeqNum 總是爲0，不是這樣的，Wireshark 爲了顯示更友好，使用了 Relative SeqNum —— 相對序號，你只要在右鍵菜單中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了。</p>
</blockquote>
<h2 id="TCP重傳機制">TCP重傳機制</h2>
<p>　　TCP 要保證所有的數據包都可以到達，所以，必需要有重傳機制。</p>
<p>　　注意，接收端給發送端的 Ack 確認只會確認最後一個連續的包，比如，發送端發了 1,2,3,4,5 一共五份數據，接收端收到了 1，2，於是回 ack 3，然後收到了 4（注意此時 3 沒收到），此時的 TCP 會怎麼辦？我們要知道，因爲正如前面所說的，SeqNum 和 Ack 是以字節數爲單位，所以 ack 的時候，不能跳着確認，只能確認最大的連續收到的包，不然，發送端就以爲之前的都收到了。</p>
<h3 id="超時重傳機制">超時重傳機制</h3>
<p>　　一種是不回 ack，死等 3，當發送方發現收不到 3 的 ack 超時後，會重傳 3。一旦接收方收到 3 後，會 ack 回 4 —— 意味着 3 和 4 都收到了。</p>
<p>　　但是，這種方式會有比較嚴重的問題，那就是因爲要死等 3，所以會導致 4 和 5 即便已經收到了，而發送方也完全不知道發生了什麼事，因爲沒有收到 Ack，所以，發送方可能會悲觀地認爲也丟了，所以有可能也會導致 4 和 5 的重傳。</p>
<p>　　對此有兩種選擇：</p>
<ul>
<li>一種是僅重傳 timeout 的包。也就是第 3 份數據。</li>
<li>另一種是重傳 timeout 後所有的數據，也就是第 3，4，5 這三份數據。</li>
</ul>
<p>　　這兩種方式有好也有不好。第一種會節省帶寬，但是慢，第二種會快一點，但是會浪費帶寬，也可能會有無用功。但總體來說都不好。因爲都在等 timeout，timeout 可能會很長（在下篇會說 TCP 是怎麼動態地計算出 timeout 的）</p>
<h3 id="快速重傳機制">快速重傳機制</h3>
<p>　　於是，TCP 引入了一種叫 <strong><em>Fast Retransmit</em></strong> 的算法，不以時間驅動，而以數據驅動重傳。也就是說，如果，包沒有連續到達，就 ack 最後那個可能被丟了的包，如果發送方連續收到 3 次相同的 ack，就重傳。<strong><em>Fast Retransmit</em></strong> 的好處是不用等 timeout 了再重傳。</p>
<p>　　比如：如果發送方發出了 1，2，3，4，5 份數據，第一份先到送了，於是就 ack 回 2，結果 2 因爲某些原因沒收到，3 到達了，於是還是 ack 回 2，後面的 4 和 5 都到了，但是還是 ack 回 2，因爲 2 還是沒有收到，於是發送端收到了三個 ack = 2 的確認，知道了 2 還沒有到，於是就馬上重轉 2。然後，接收端收到了 2，此時因爲 3，4，5 都收到了，於是 ack 回 6。示意圖如下：</p>
<p><img src="FASTIncast021.png" alt="快速重傳"></p>
<p>　　Fast Retransmit 只解決了一個問題，就是 timeout 的問題，它依然面臨一個艱難的選擇，就是重轉之前的一個還是重裝所有的問題。對於上面的示例來說，是重傳 #2 呢還是重傳 #2，#3，#4，#5 呢？因爲發送端並不清楚這連續的 3 個 ack(2) 是誰傳回來的？也許發送端發了 20 份數據，是 #6，#10，#20 傳來的呢。這樣，發送端很有可能要重傳從 2 到 20 的這堆數據（這就是某些 TCP 的實際的實現）。可見，這是一把雙刃劍。</p>
<h3 id="SACK_方法">SACK 方法</h3>
<p>　　另外一種更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（參看 <a href="http://tools.ietf.org/html/rfc2018" target="_blank">RFC 2018</a>），這種方式需要在 TCP 頭里加一個 SACK 的東西，ACK 還是 Fast Retransmit 的 ACK，SACK 則是彙報收到的數據碎版。參看下圖：</p>
<p><img src="tcp_sack_example-1024x577.jpg" alt="SACK方法"></p>
<p>　　這樣，在發送端就可以根據回傳的 SACK 來知道哪些數據到了，哪些沒有到。於是就優化了 Fast Retransmit 的算法。當然，這個協議需要兩邊都支持。在 Linux 下，可以通過 <code>tcp_sack</code> 參數打開這個功能（Linux 2.4 後默認打開）。</p>
<p>　　這裏還需要注意一個問題 —— 接收方 Reneging，所謂 Reneging 的意思就是接收方有權把已經報給發送端 SACK 裏的數據給丟了。這樣幹是不被鼓勵的，因爲這個事會把問題複雜化了，但是，接收方這麼做可能會有些極端情況，比如要把內存給別的更重要的東西。所以，發送方也不能完全依賴 SACK，還是要依賴 ACK，並維護 Time-Out，如果後續的 ACK 沒有增長，那麼還是要把 SACK 的東西重傳，另外，接收端這邊永遠不能把 SACK 的包標記爲 Ack。</p>
<blockquote>
<p><strong>注意</strong>：SACK 會消費發送方的資源，試想，如果一個攻擊者給數據發送方發一堆 SACK 的選項，這會導致發送方開始要重傳甚至遍歷已經發出的數據，這會消耗很多發送端的資源。詳細的東西請參看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank">TCP SACK的性能權衡</a>》</p>
</blockquote>
<h3 id="Duplicate_SACK_–_重複收到數據的問題">Duplicate SACK – 重複收到數據的問題</h3>
<p>　　Duplicate SACK 又稱 D-SACK，其主要使用了 SACK 來告訴發送方有哪些數據被重複接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a> 裏有詳細描述和示例。下面舉幾個例子（來源於 <a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a>）</p>
<p>　　D-SACK使用了SACK的第一個段來做標誌，</p>
<ul>
<li>如果 SACK 的第一個段的範圍被 ACK 所覆蓋，那麼就是 D-SACK</li>
<li>如果 SACK 的第一個段的範圍被 SACK 的第二個段覆蓋，那麼就是 D-SACK</li>
</ul>
<h4 id="示例一：ACK_丟包">示例一：ACK 丟包</h4>
<p>　　下面的示例中，丟了兩個 ACK，所以，發送端重傳了第一個數據包（3000 - 3499），於是接收端發現重複收到，於是回了一個 SACK = 3000 - 3500，因爲 ACK 都到了 4000 意味着收到了 4000 之前的所有數據，所以這個 SACK 就是 D-SACK —— 旨在告訴發送端我收到了重複的數據，而且我們的發送端還知道，數據包沒有丟，丟的是 ACK 包。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="attribute">Transmitted  Received    ACK Sent
Segment      Segment     (Including SACK Blocks)

3000-3499    3000-3499   3500 (ACK dropped)
3500-3999    3500-3999   4000 (ACK dropped)
3000-3499    3000-3499   4000, SACK</span>=<span class="string">3000-3500
                                    ---------</span>
</pre></td></tr></table></figure>

<h4 id="示例二：網絡延誤">示例二：網絡延誤</h4>
<p>　　下面的示例中，網絡包（1000 - 1499）被網絡給延誤了，導致發送方沒有收到 ACK，而後面到達的三個包觸發了“Fast Retransmit 算法”，所以重傳，但重傳時，被延誤的包又到了，所以，回了一個 SACK = 1000 - 1500，因爲 ACK 已到了 3000，所以，這個 SACK 是 D-SACK —— 標識收到了重複的包。</p>
<p>　　這個案例下，發送端知道之前因爲“Fast Retransmit 算法”觸發的重傳不是因爲發出去的包丟了，也不是因爲迴應的 ACK 包丟了，而是因爲網絡延時了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="xml"><span class="tag"><span class="attribute">Transmitted</span>    <span class="attribute">Received</span>    <span class="attribute">ACK</span> <span class="attribute">Sent</span>
<span class="attribute">Segment</span>        <span class="attribute">Segment</span>     (<span class="attribute">Including</span> <span class="attribute">SACK</span> <span class="attribute">Blocks</span>)
 
<span class="attribute">500-999</span>        <span class="attribute">500-999</span>     <span class="attribute">1000</span>
<span class="attribute">1000-1499</span>      (<span class="attribute">delayed</span>)
<span class="attribute">1500-1999</span>      <span class="attribute">1500-1999</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-2000</span>
<span class="attribute">2000-2499</span>      <span class="attribute">2000-2499</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-2500</span>
<span class="attribute">2500-2999</span>      <span class="attribute">2500-2999</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-3000</span>
<span class="attribute">1000-1499</span>      <span class="attribute">1000-1499</span>   <span class="attribute">3000</span>
               <span class="attribute">1000-1499</span>   <span class="attribute">3000</span>, <span class="attribute">SACK</span>=<span class="value">1000-1500</span>
                                      <span class="attribute">---------</span></span></span>
</pre></td></tr></table></figure>

<p>　　可見，引入了 D-SACK，有這麼幾個好處：</p>
<ol>
<li>可以讓發送方知道，是發出去的包丟了，還是回來的 ACK 包丟了。</li>
<li>是不是自己的 timeout 太小了，導致重傳。</li>
<li>網絡上出現了先發的包後到的情況（又稱 reordering）</li>
<li>網絡上是不是把我的數據包給複製了。</li>
</ol>
<p>　　<strong>知道這些東西可以很好得幫助TCP瞭解網絡情況，從而可以更好的做網絡上的流控。</strong></p>
<p>　　Linux 下的 <code>tcp_dsack</code> 參數用於開啓這個功能（Linux 2.4 後默認打開）</p>
<p>　　好了，上篇就到這裏結束了。如果你覺得我寫得還比較淺顯易懂，那麼，歡迎移步看下篇《<a href="http://coolshell.cn/articles/11609.html" target="_blank">TCP的那些事（下）</a>》</p>
<p>　　[原文鏈接：<a href="http://coolshell.cn/articles/11564.html" target="_blank">http://coolshell.cn/articles/11564.html</a>]</p>
]]></content>
    
    
      <category term="TCP" scheme="http://xcoder.in/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一個任務隊列的 module]]></title>
    <link href="http://xcoder.in/2014/06/03/scartlet-task/"/>
    <id>http://xcoder.in/2014/06/03/scartlet-task/</id>
    <published>2014-06-02T16:17:38.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>事情很曲折，我某天在萌否收音機裏面聽到了一首歌，很好聽，叫 <code>hypnotized</code>，於是紅心了。</p>
<p>　　過了幾天我再去聽——發現這首歌變了。</p>
<p>　　最後經過多方面求證，我大概得出結果就是應該有人傳錯了歌，然後後來有人重新傳了一遍，導致我聽的不是原來那首歌了。那我那天聽的那首歌到底叫什麼名字呢？</p>
<p>　　然後大致看了一下，雖然歌被重新傳了，但是<a href="http://moe.fm/music/9600" target="_blank">這裏</a>顯示的這首歌的時間沒變！還是11分鐘，目測是數據庫沒更新。</p>
<p>　　於是我就想了個笨辦法，去爬收音機裏面所有 tag 爲 <code>東方project</code> 的專輯，然後跑到專輯頁看歌曲的長度。</p>
<p>　　問題來了，如果我直接爬，然後爬完 <code>callback</code> 之後又直接爬，沒有任何間隔，就相當於我在 <code>DDOS</code> 它的站子。或者即使沒那麼嚴重——反正最後到一定程度併發太大我就訪問不了了。</p>
<p>　　於是我就想到了做一個任務隊列的 module。該 module 的作用就是把一堆任務扔到隊列中，完成一個纔開始下一個。</p>
<p>　　然後如果同時執行一個也太慢，module 還允許你開多幾個子隊列同時執行。</p>
<p>　　模塊的 repo 在 <a href="https://github.com/XadillaX/scarlet-task" target="_blank">GitHub</a> 上面。名字叫 <code>Scarlet Task</code> 的原因一是我本身就喜歡二小姐，二是爲了紀念這次事件我是爲了找有關二小姐的歌。</p>
<p>　　要安裝也很簡單：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install scarlet-task
</pre></td></tr></table></figure>

<p>　　然後 repo 的 <code>README.md</code> 裏面有使用方法的——大致就是實例化一個對象，然後定義好某個任務的任務標識（可以是字符串，可以是 json 對象，可以是任何類型的數據），然後再定義好處理這個任務的函數，將這個數據推倒隊列中即可。然後在處理函數中任務處理完的時候執行以下任務完成的函數即可。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="任務隊列" scheme="http://xcoder.in/tags/%E4%BB%BB%E5%8B%99%E9%9A%8A%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建 VIM 下的 Hexo 編輯環境]]></title>
    <link href="http://xcoder.in/2014/06/02/vim-hexo-environment/"/>
    <id>http://xcoder.in/2014/06/02/vim-hexo-environment/</id>
    <published>2014-06-01T20:52:30.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>本文只講兩個函數，對於 <code>markdown</code> 如何高亮之類的問題還請自行谷歌。</p>
<p>　　然後請打開你自己的 <code>.vimrc</code> 文件。</p>
<h2 id="預備工作">預備工作</h2>
<p>　　首先定義一個變量——你自己的 <code>hexo</code> 目錄，如果要跨平臺可以做個判斷之類的，如下：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> has(<span class="string">"win32"</span>)
    <span class="built_in">let</span> g:hexoProjectPath=<span class="string">"E:\\cygwin\\home\\XadillaX\\hexo"</span>
<span class="keyword">else</span>
    <span class="built_in">let</span> g:hexoProjectPath=<span class="string">"~/hexo/"</span>
endif
</pre></td></tr></table></figure>

<h2 id="幾個函數">幾個函數</h2>
<h3 id="進入_Hexo_目錄">進入 Hexo 目錄</h3>
<p>　　這個函數大致就是讓你進入你自己的 <code>Hexo</code> 路徑：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">fun</span>! <span class="variable">OpenHexoProjPath</span>()
    execute <span class="string">"cd "</span> . g:hexo<span class="variable">ProjectPath</span>
endfun
</pre></td></tr></table></figure>

<h3 id="打開一篇_Post">打開一篇 Post</h3>
<p>　　接下去就是一個打開 <code>Post</code> 的函數了：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span>! <span class="title">OpenHexoPost</span><span class="params">(...)</span></span>
    call OpenHexoProjPath()

    let filename = <span class="string">"source/_posts/"</span> . a:<span class="number">1</span> . <span class="string">".md"</span>
    execute <span class="string">"e "</span> . filename
<span class="function"><span class="keyword">endfunction</span></span>
</pre></td></tr></table></figure>

<blockquote>
<p>解析：上面的代碼大意就是進入 Hexo 路徑，然後設定好文件名，最後執行 <code>:e filename</code> 即可打開文件了。</p>
</blockquote>
<h3 id="新建一篇_Post">新建一篇 Post</h3>
<p>　　新建的流程跟打開相似，只不過首先要在 <code>Hexo</code> 目錄下執行一遍 <code>hexo new FOO</code> 的命令而已，命令執行完畢之後再打開即可。</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span>! <span class="title">NewHexoPost</span><span class="params">(...)</span></span>
    call OpenHexoProjPath()

    let filename = a:<span class="number">1</span>
    execute <span class="string">"!hexo new "</span> . filename

    call OpenHexoPost(a:<span class="number">1</span>)
<span class="function"><span class="keyword">endfunction</span></span>
</pre></td></tr></table></figure>

<h2 id="指令映射">指令映射</h2>
<p>　　函數寫好後我們最後把函數映射成類似於 <code>:e</code>, <code>:w</code> 之類的後面能跟着參數的指令即可。</p>
<p>　　以前木有接觸過的同學可以參考一下<a href="http://vimdoc.sourceforge.net/htmldoc/usr_40.html#40.2" target="_blank">這裏</a>的文檔。</p>
<h3 id="打開指令">打開指令</h3>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command"><span class="keyword">command</span> -<span class="title">nargs</span>=+ <span class="title">HexoOpen</span> :<span class="title">call</span> <span class="title">OpenHexoPost</span>(<span class="string">"&lt;args&gt;"</span>)</span>
</pre></td></tr></table></figure>

<h3 id="新建指令">新建指令</h3>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command"><span class="keyword">command</span> -<span class="title">nargs</span>=+ <span class="title">HexoNew</span> :<span class="title">call</span> <span class="title">NewHexoPost</span>(<span class="string">"&lt;args&gt;"</span>)</span>
</pre></td></tr></table></figure>

<h2 id="使用方法">使用方法</h2>
<p>　　當你做完以上步驟的時候，你就可以無論在什麼目錄下在 VIM 裏面通過下面的指令進行新建一篇日誌了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">:HexoNew</span> artical-name
</pre></td></tr></table></figure>

<p>　　以及下面的指令來打開一篇已存在的日誌：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">:HexoOpen</span> artical-name
</pre></td></tr></table></figure>

<h2 id="遺留問題">遺留問題</h2>
<p>　　相信看到這裏之後，大家也能自己寫出一個生成的指令了，這裏就不累述了，無非就是：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>:!hexo <span class="keyword">generate</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="vim" scheme="http://xcoder.in/tags/vim/"/>
    
      <category term="hexo" scheme="http://xcoder.in/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「NBUT 2014 校賽·網絡同步賽」題解 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/"/>
    <id>http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/</id>
    <published>2014-05-05T07:08:39.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>這次比賽由 <a href="http://blog.163.com/surgy_han/" target="_blank">Hungar</a>，<a href="http://www.cnblogs.com/Wine93/" target="_blank">8Mao</a> 以及我負責的。明明都讀研了，還詐屍回來出題——歸結起來大概是因爲各種面試不順吧，想來虐虐學弟妹們怒刷存在感。結果網絡賽還是被虐得死去活來。（果然我是蒟蒻 (◓Д◒)✄╰⋃╯</p>
<p>　　好了廢話不多說，還是直接上題解吧。</p>
<h2 id="Minecraft_Server_Bug">Minecraft Server Bug</h2>
<p>　　題意大概就是說一排巖漿和水，你要拿一桶水和巖漿，並且水的下標小於巖漿。</p>
<p>　　爲了更便於理解，我們從後往前做。首先將序列讀進來之後從後往前遍歷——若是巖漿，那麼巖漿數加一，如果是水，那麼這桶水能選擇後面巖漿的任意一桶，也就是說答案加上當前的巖漿數即可。</p>
<blockquote>
<p>注意用 <code>__int64</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n;
    <span class="keyword">char</span> ch[<span class="number">1000005</span>];
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &n))
    {
        <span class="keyword">char</span> tmp;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        {
            <span class="built_in">scanf</span>(<span class="string">"%c%c"</span>, ch + i, &tmp);
        }
        
        __int64 ans = <span class="number">0</span>;
        <span class="keyword">int</span> cnt = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)
        {
            <span class="keyword">if</span>(ch[i] == <span class="string">'L'</span>) cnt++;
            <span class="keyword">else</span> ans += (__int64)cnt;
        }
        
        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);
    }
    
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h2 id="Beautiful_Walls">Beautiful Walls</h2>
<p>　　一堵牆，每單位高度不定。你需要選擇其中任意連續的牆，使得你選擇的牆每單位的高度都是唯一的——問有多少種選法。</p>
<p>　　先求出總的種數，然後求不滿足的數量，最後用總數減去不滿足數即爲答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="preprocessor">#define lint long long</span>
<span class="preprocessor">#define N 100005</span>
<span class="keyword">int</span> p[N], A[N];
lint solution(lint n)
{
    <span class="built_in">memset</span>(p, -<span class="number">1</span>, <span class="keyword">sizeof</span>(p));
    lint ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>, Max = <span class="number">0</span>;
    <span class="keyword">for</span>(lint i=<span class="number">0</span>; i &lt; n; ++i)
    {
        <span class="keyword">if</span>(~p[A[i]])
        {
            <span class="keyword">if</span>(Max &lt; p[A[i]]) Max = p[A[i]];
            p[A[i]] = i + <span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            p[A[i]] = i + <span class="number">1</span>;
        }
        ans -= Max;
    }
    <span class="keyword">return</span> ans;
}

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n, x;
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &n))
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)
        {
            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);
        }
        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solution(n));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="ACM" scheme="http://xcoder.in/tags/ACM/"/>
    
      <category term="算法" scheme="http://xcoder.in/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://xcoder.in/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[死月出品：Hero Snake 英雄蛇]]></title>
    <link href="http://xcoder.in/2014/04/11/hero-snake/"/>
    <id>http://xcoder.in/2014/04/11/hero-snake/</id>
    <published>2014-04-11T05:53:35.000Z</published>
    <updated>2014-12-10T07:49:31.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注：備份到這篇日誌的時候，感覺眼睛進了什麼奇怪的東西。（才……纔不是眼淚呢，那一定是沙子！(;´༎ຶД༎ຶ`)</p>
<p>主要引起感傷的還是這首軒轅劍的 BGM 吧。因爲 Hero Snake 的BGM就是這個。</p>
<p>這篇文章原文是在 2011年5月1日 發的。遊戲是跟 <strong>MatRush</strong> 在2011年寒假一起寫的，雖然是我邊教邊寫的。呵呵，轉眼間三年過去了。</p>
<p>想當年我還是那麼執着於遊戲行業，現在糾結於到底要從事遊戲行業還是互聯網呢？半年真的能改變很多，要是我當時沒有去汽族網實習，也許現在並不會有那麼大的改變吧。</p>
<p>自從被 <a href="http://weibo.com/shyvo" target="_blank">@樸大</a> 刷了之後，我又開始着重考慮了。是不是我玩互聯網只是覺得新鮮好玩而已呢？畢竟我是半路出家的，雖然有着十來年的 <code>Web經歷</code>，但那都是小打小鬧哇。還記得小學的時候買的第一本電腦書——<a href="http://www.amazon.cn/%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6-%E6%9C%B1%E6%83%A0%E5%BC%BA/dp/B0011A9QSA/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1397196202&amp;sr=1-1&amp;keywords=%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6" target="_blank">《在網上安個家》</a>，到現在還記得那個時候捧着書的激動心情。</p>
<p>我是不是有點偏離了自己本身的軌道呢？總之還是在這兩塊領域猶豫不決。</p>
<p>廢話有點扯遠了，還是把文章從 Capture 備份回來再說吧。</p>
</blockquote>
<p>　　這是一款正宗基於HGE的小遊戲，算是我做的遊戲中自己比較滿意的小遊戲吧。</p>
<p>　　幕後故事是這樣的：MatRush寒假找我一起做遊戲，因爲他們學校弄了一個蛋疼的遊戲製作比賽。然後命題是貪吃蛇，於是我們加了一點自己的小創意，給他講解了一些HGE的基礎之後，就寫了這個遊戲了。然後因爲我們都比較喜歡軒轅劍，於是BGM就是軒轅劍的《永遠的三個人的快樂時光》，由於MatRush比較喜歡MapleStory，便有了素材是那些像素畫面。</p>
<p>　　首先這個遊戲有兩種模式：單人模式和雙人模式。</p>
<p>　　關於單人模式，這是一個闖關型模式，大家在每一關必須通過吃道具獲得一定的分數以及吃圈圈獲得一定圈圈數才能開啓通往下一關的門，默認一共20關，可以自己編輯關卡，這是後話。下面是幾種道具的解說：</p>
<blockquote>
<p><img src="treasure0.png" alt="開山斧"></p>
<p>開山斧：撿到這貨隨機獲得1~3個斧頭並且附贈100分數。斧頭的作用是能破開木桶，安全通過，一個斧頭用一次。斧頭數在左下角的Axe(s)後面。</p>
<p><img src="treasure1.png" alt="命運之剪"></p>
<p>命運之剪：撿到這個之後獲得100分並且給你斷掉一個尾巴以降低難度。</p>
<p><img src="treasure2.png" alt="降速器"></p>
<p>降速器：因爲你每吃一個圈圈會增加一定速度，而這個降速器是降低你的速度讓你容易些。並且附贈100分。</p>
<p><img src="treasure8.png" alt="藥水"></p>
<p>藥水：藥水是裝飾變色用的，其實是送分的。前四種藥水100分，紫色的300分。</p>
<p><img src="treasure3.png" alt="降速器"></p>
<p>骷髏頭：想死的話就碰碰它試試。</p>
<p><img src="door.png" alt="傳送門"></p>
<p>傳送門：遇到這貨就說明你功德圓滿了。恭喜，可以通過它前往下一關。</p>
</blockquote>
<p>　　接下去是雙人模式。雙人模式因爲當初設想有些問題，所以實現起來僅僅是簡單的雙人走啊走，看誰碰到誰誰就輸。在雙人模式中，先要選擇一張對戰地圖，然後開始雙人走啊走啊走。</p>
<p>　　然後Rank是排行榜，Option是遊戲的一些選項，Introduction是遊戲介紹，這個介紹有些蛋疼，最後不用說Exit就是退出了。</p>
<p>　　下面是關於地圖編輯器的說明：</p>
<p>　　首先在遊戲目錄小有一個config.ini文件，是一些遊戲設置。其中levelnum是遊戲關卡數。注意這個數字必須要跟地圖數量一致或者小於它，否則會因爲找不到之後的地圖而出錯。地圖就存在data裏，命名方式是mapX.txt，從0開始。地圖編輯器則在MapEditor文件夾下。操作很簡單，說明都在編輯器下方的文字上，就幾個快捷鍵。可以用鼠標操作也可以用上下左右控制方向。</p>
<p>　　最後，預祝大家玩得愉快。附上下載地址和幾張預覽圖吧：</p>
<p>　　<a href="bin.7z">點擊下載</a></p>
<p>　　<a href="https://github.com/XadillaX/hero-snake" target="_blank">代碼地址</a></p>
<p><img src="1.png" alt="標題畫面"><br><img src="2.png" alt="玩的畫面"><br><img src="4.png" alt="雙人模式"></p>
]]></content>
    
    
      <category term="老博客備份歸檔" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%82%99%E4%BB%BD%E6%AD%B8%E6%AA%94/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="HGE" scheme="http://xcoder.in/tags/HGE/"/>
    
      <category term="遊戲開發" scheme="http://xcoder.in/tags/%E9%81%8A%E6%88%B2%E9%96%8B%E7%99%BC/"/>
    
      <category term="老博客備份歸檔" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%82%99%E4%BB%BD%E6%AD%B8%E6%AA%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[讓Node.js和C++一起搞基 —— 3 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/"/>
    <id>http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/</id>
    <published>2014-04-06T08:15:39.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2014/04/03/nodejs-cpp-addons-2/">上一章</a>我們偷偷學習瞭如何在 <code>C++</code> 中實現 <code>Node.js</code> 調用時傳參數和調用回調函數，並且我自己也心血來潮寫了個<a href="/2014/04/05/cpp-class-inline-keng/#simpleini">小 Demo</a> 供大家參考。</p>
<p>　　今天我們就不複習了，直搗黃龍吧。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中類成員函數 inline 的坑]]></title>
    <link href="http://xcoder.in/2014/04/05/cpp-class-inline-keng/"/>
    <id>http://xcoder.in/2014/04/05/cpp-class-inline-keng/</id>
    <published>2014-04-05T08:55:57.000Z</published>
    <updated>2014-12-10T07:49:31.000Z</updated>
    <content type="html"><![CDATA[<p>今天我來講一講 <code>C++</code> 中類成員函數 <code>inline</code> 修飾符的一個坑。</p>
<p>　　這個坑是我在嘗試着寫我的第一個 <code>Node.js</code> 擴展 <code>simpleini</code> 時候遇到的。</p>
<h2 id="坑描述">坑描述</h2>
<p>　　因爲只是嘗試着寫，所以懶得自己實現，於是網上找了個開源的 <code>C++</code> 閱讀 ini 文件的項目，名不見經傳，叫 <a href="http://miniini.tuxfamily.org/" target="_blank">miniini</a>。</p>
<p>　　好了，問題來了，當我寫好我的源文件的時候，然後寫好了我的 <code>binding.gyp</code> ，總之一切大功告成開始編譯的時候—— <code>Windows</code> 下沒問題，<code>MacOS</code> 下也可以正常運行，但是在 <code>Linux</code> 下就出問題了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>node: symbol lookup err: <span class="keyword">...</span>/simpleIni.node: undefined symbol: _ZNK10INISection10ReadStringEPKcRS1_
</pre></td></tr></table></figure>

<p>　　大致的意思呢就是說找不到 <code>INISection</code> 的 <code>ReadString</code> 函數符號。</p>
<h2 id="問題分析">問題分析</h2>
<p>　　又是懷着崇敬的心情去 <a href="http://stackoverflow.com/questions/22868307/undefined-symbol-in-node-js-c-addon-under-linux-why" target="_blank">SO</a> 求解了。</p>
<p>　　最後的解答大概<a href="http://isocpp.org/wiki/faq/inline-functions#inline-member-fns" target="_blank">如下</a>：</p>
<blockquote>
<p>內聯成員函數的聲明看起來像一個非內聯函數的聲明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">class</span> Fred {
<span class="keyword">public</span>:
    <span class="keyword">void</span> f(<span class="keyword">int</span> i, <span class="keyword">char</span> c);
};
</pre></td></tr></table></figure>

<p>但是你的內斂成員函數定義前面又加了 <code>inline</code> 這個關鍵字時，你必須把這個定義放到頭文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">inline</span>
<span class="keyword">void</span> Fred::f(<span class="keyword">int</span> i, <span class="keyword">char</span> c)
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>這麼做的原因就是爲了避免鏈接器 <code>unresolved external</code> 的發生。如果你不這麼做，這個錯誤就將會在你從另外一個 <code>.cpp</code> 文件中調用它時出現。</p>
</blockquote>
<p>　　好嘛，原來是原作者自己寫的代碼有問題啊。但是不得不說一下又漲姿勢了。C++還真是有千奇百怪的坑和錯誤啊。</p>
<h2 id="解決方案">解決方案</h2>
<p>　　最後的解決方案大致就是把函數定義放到頭文件中去，或者在函數聲明前面也加上 <code>inline</code> 關鍵字。</p>
<h2 id="simpleini">simpleini</h2>
<p>　　我的第一個 <code>C++</code> 模塊，叫 <code>simpleini</code> ，其實只是抱着試試看 <code>Node.j</code> 的 <code>C++</code> 模塊是不是這麼寫的而已，並沒有多大實際用處。Repo 在 <a href="https://github.com/XadillaX/node-simple-ini" target="_blank">Github</a> 上。</p>
<p>　　然後用法很簡單，先安裝：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install simpleini
</pre></td></tr></table></figure>

<p>　　然後下面的代碼就是例子了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> simpleIni = <span class="built_in">require</span>(<span class="string">"simpleini"</span>);

console.log(simpleIni.open(<span class="string">"./node_modules/simpleini/src/miniini-0.9/test/test.ini"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>));
console.log(simpleIni.read(<span class="string">"SETTINGS"</span>, <span class="string">"sections"</span>));
console.log(simpleIni.read(<span class="string">"vals"</span>, <span class="string">"float"</span>));
</pre></td></tr></table></figure>

<p>　　讀取配置的時候第一個參數是 <code>Section</code>，第二個參數是 <code>Key</code>，第三個參數是取不到該值時的默認值。</p>
]]></content>
    
    
      <category term="Programming" scheme="http://xcoder.in/tags/Programming/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[讓Node.js和C++一起搞基 —— 2]]></title>
    <link href="http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/"/>
    <id>http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/</id>
    <published>2014-04-03T14:37:15.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>好，今天讓我們更深入地搞基吧！</p>
<h2 id="溫故而知新，可以爲溼矣">溫故而知新，可以爲溼矣</h2>
<p>　　首先請大家記住這個 V8 的在線手冊——<a href="http://izs.me/v8-docs/main.html" target="_blank">http://izs.me/v8-docs/main.html</a>。</p>
<p>　　還記得上次的 <code>building.gyp</code> 文件嗎？</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"addon"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"addon.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>

<p>　　就像這樣，舉一反三，如果多幾個 <code>*.cc</code> 文件的話就是這樣的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>"sources": [ "addon.cc", "myexample.cc" ]
</pre></td></tr></table></figure>

<p>　　上次我們把倆步驟分開了，實際上配置和編譯可以放在一起的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure build
</pre></td></tr></table></figure>

<p>　　複習完了嗎？沒？！</p>
<p><img src="mama.jpg" alt="啪"></p>
<p>　　好的，那我們繼續吧。</p>
<h2 id="表番">表番</h2>
<h3 id="函數參數">函數參數</h3>
<p>　　現在我們終於要講參數了呢。</p>
<p>　　讓我們設想有這樣一個函數 <code>add(a, b)</code> 代表把 <code>a</code> 和 <code>b</code> 相加返回結果，所以先把函數外框寫好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;

    <span class="comment">//... 又來！</span>
}
</pre></td></tr></table></figure>

<h4 id="Arguments">Arguments</h4>
<p>　　這個就是函數的參數了。我們不妨先看看 v8 的<a href="http://izs.me/v8-docs/classv8_1_1Arguments.html" target="_blank">官方手冊參考</a>。</p>
<ul>
<li><code>int Length() const</code></li>
<li><code>Local&lt;Value&gt; operator[](int i) const</code></li>
</ul>
<p>　　其它的我們咱不關心，這兩個可重要了！一個代表傳入函數的參數個數，另一箇中括號就是通過下標索引來訪問第 <code>n</code> 個參數的。</p>
<p>　　所以如上的需求，我們大致就可以理解爲 <code>args.Length()</code> 爲 <code>2</code>，<code>args[0]</code> 代表 <code>a</code> 以及 <code>args[1]</code> 代表 <code>b</code> 了。並且我們要判斷這兩個數的類型必須得是 <code>Number</code>。</p>
<p>　　注意到沒，中括號的索引操作符返回結果是一個 <code>Local&lt;Value&gt;</code> 也就是 <code>Node.js</code> 的所有類型基類。所以傳進來的參數類型不定的，我們必須得自己判斷是什麼參數。這就關係到了這個 <code>Value</code> 類型的一些<a href="http://izs.me/v8-docs/classv8_1_1Value.html" target="_blank">函數</a>了。</p>
<ul>
<li><code>IsArray()</code></li>
<li><code>IsBoolean()</code></li>
<li><code>IsDate()</code></li>
<li><code>IsFunction()</code></li>
<li><code>IsInt32()</code></li>
<li><code>IsNativeError()</code></li>
<li><code>IsNull()</code></li>
<li><code>IsNumber()</code></li>
<li><code>IsRegExp()</code></li>
<li><code>IsString()</code></li>
<li>…</li>
</ul>
<p>　　我就不一一列舉了，剩下的自己看文檔。｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡</p>
<h4 id="ThrowException">ThrowException</h4>
<p>　　這個是我們等下要用到的一個函數。具體在 <a href="http://izs.me/v8-docs/namespacev8.html#a2469af0ac719d39f77f20cf68dd9200e" target="_blank">v8 文檔</a>中可以找到。</p>
<p>　　顧名思義，就是拋出錯誤啦。執行這個語句之後，相當於在 <code>Node.js</code> 本地文件中執行了一條 <code>throw()</code> 語句一樣。比如說：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
</pre></td></tr></table></figure>

<p>　　就相當於執行了一條 <code>Node.js</code> 的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong number of arguments"</span>);
</pre></td></tr></table></figure>

<h4 id="Undefined()">Undefined()</h4>
<p>　　這個函數呢也在<a href="http://izs.me/v8-docs/namespacev8.html#ad39cfade81e77137fc11ff3a24284340" target="_blank">文檔</a>裏面。</p>
<p>　　具體就是一個空值，因爲有些函數並不需要返回什麼具體的值，或者說沒有返回值，這個時候就需要用 <code>Undefined()</code> 來代替了。</p>
<h4 id="動手吧騷年！">動手吧騷年！</h4>
<p>　　在理解了以上的幾個要點之後，我相信你們很快就能寫出 <code>a + b</code> 的邏輯了，我就把 <code>Node.js</code> 官方手冊的代碼抄過來給你們過一遍就算完事了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    
    <span class="comment">// 代表了可以傳入 2 個以上的參數，但實際上我們只用前兩個</span>
    <span class="keyword">if</span>(args.Length() &lt; <span class="number">2</span>)
    {
        <span class="comment">// 拋出錯誤</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
        
        <span class="comment">// 返回空值</span>
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 若前兩個參數其中一個不是數字的話</span>
    <span class="keyword">if</span>(!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber())
    {
        <span class="comment">// 拋出錯誤並返回空值</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong arguments"</span>)));
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 具體參考 v8 文檔</span>
    <span class="comment">//     http://izs.me/v8-docs/classv8_1_1Value.html#a6eac2b07dced58f1761bbfd53bf0e366)</span>
    <span class="comment">// 的 `NumberValue` 函數</span>
    Local&lt;Number&gt; num = Number::New(args[<span class="number">0</span>]-&gt;NumberValue() + args[<span class="number">1</span>]-&gt;NumberValue());
    
    <span class="keyword">return</span> scope.Close(num);
}
</pre></td></tr></table></figure>

<p>　　函數大功告成！</p>
<p>　　最後把尾部的導出函數給寫好就 OK 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> Init(Handle&lt;Object&gt; exports)
{
    exports-&gt;Set(String::NewSymbol(<span class="string">"add"</span>),
        FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　等你編譯好之後，我們就能這樣用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> addon = <span class="built_in">require</span>(<span class="string">'./build/Release/addon'</span>);
console.log(addon.add(<span class="number">1</span>, <span class="number">1</span>) + <span class="string">"b"</span>);
</pre></td></tr></table></figure>

<p>　　你會看到一個 <code>2b</code> ！✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p>
<h3 id="回調函數">回調函數</h3>
<p>　　上一章我們只講了個 <code>Hello world</code>，這一章阿婆主就良心發現一下，再來個回調函數的寫法。</p>
<p>　　慣例我們先寫好框架：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
  HandleScope scope;

  <span class="comment">// ... 噼裏啪啦噼裏啪啦</span>

  <span class="keyword">return</span> scope.Close(Undefined());
}
</pre></td></tr></table></figure>

<p>　　然後我們決定它的用法是這樣的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>func(<span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
    console.log(msg);
});
</pre></td></tr></table></figure>

<p>　　即它會給回調函數傳入一個參數，我們設想它是一個字符串，然後我們可以 <code>console.log()</code> 出來看。</p>
<h4 id="首先你要有一個字符串系列">首先你要有一個字符串系列</h4>
<p>　　廢話不多說，先給它一個字符串餵飽了再說吧。<em>(√ ζ ε:)</em></p>
<p>　　不過我們得讓這個字符串是通用類型的，因爲 <code>Node.js</code> 代碼是弱類型的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>));
</pre></td></tr></table></figure>

<p>　　什麼？你問我什麼是 <code>Local&lt;Value&gt;</code>？</p>
<p>　　那我稍稍講一下吧，參考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">這裏</a>和<a href="http://izs.me/v8-docs/classv8_1_1Local.html" target="_blank">V8參考文檔</a>。</p>
<p>　　如文檔所示，<code>Local&lt;T&gt;</code> 實際上繼承自 <code>Handle&lt;T&gt;</code>，我記得<a href="/2014/04/02/nodejs-cpp-addons-1/#Handle&lt;Value">上一章</a>已經講過 <code>Handle&lt;T&gt;</code> 這個東西了。</p>
<p>　　然後下面就是講 Local 了。</p>
<blockquote>
<p>Handle 有兩種類型， Local Handle 和 Persistent Handle ，類型分別是 <code>Local&lt;T&gt; : Handle&lt;T&gt;</code> 和 <code>Persistent&lt;T&gt; : Handle&lt;T&gt;</code> ，前者和 <code>Handle&lt;T&gt;</code> 沒有區別生存週期都在 scope 內。而後者的生命週期脫離 scope ，你需要手動調用 <code>Persistent::Dispose</code> 結束其生命週期。也就是說 Local Handle 相當於在 C++`在棧上分配對象而 Persistent Handle 相當於 C++ 在堆上分配對象。</p>
</blockquote>
<h4 id="然後你要有個參數表系列">然後你要有個參數表系列</h4>
<p>　　終端命令行調用 C/C++ 之後怎麼取命令行參數？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>　　對了，這裏的 <code>argc</code> 就是命令行參數個數，<code>argv[]</code> 就是各個參數了。那麼調用 <code>Node.js</code> 的回調函數，<code>v8</code> 也採用了類似的<a href="http://izs.me/v8-docs/classv8_1_1Function.html#ac61877494d2d8bb81fcef96003ec4059" target="_blank">方法</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>V8EXPORT Local&lt;Value&gt; v8::Function::Call(Handle&lt;Object&gt;recv,
    <span class="keyword">int</span> argc,
    Handle&lt;Value&gt; argv[]
);
</pre></td></tr></table></figure>

<blockquote>
<p><del>QAQ 卡在了 <code>Handle&lt;Object&gt; recv</code> 了！！！明天繼續寫。</del></p>
</blockquote>
<p>　　好吧，新的一天開始了我感覺我充滿了力量。(∩^o^)⊃━☆ﾟ.*･｡</p>
<p>　　經過我多方面求證（<a href="http://segmentfault.com/q/1010000000456217" target="_blank">SegmentFault</a>和<a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a>以及一個扣扣羣），終於解決了上面這個函數仨參數的意思。</p>
<p>　　後面兩個參數就不多說了，一個是參數個數，另一個就是一個參數的數組了。至於第一個參數 <code>Handle&lt;Object&gt; recv</code>，StackOverflow 仁兄的解釋是這樣的：</p>
<blockquote>
<p>It is the same as apply in JS. In JS, you do</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> context = ...;
cb.apply(context, [ ...args...]);
</pre></td></tr></table></figure>

<p>The object passed as the first argument becomes this within the function scope. More documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank">MDN</a>. If you don’t know JS well, you can read more about JS’s this here: <a href="http://unschooled.org/2012/03/understanding-javascript-this/" target="_blank">http://unschooled.org/2012/03/understanding-javascript-this/</a></p>
<p style="text-align: right;">—— 摘自 <a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a></p>

</blockquote>
<p>　　總之其作用就是指定了被調用函數的 <code>this</code> 指針。這個 <code>Call</code> 的用法就跟 JavaScript 中的 <code>bind()</code>、<code>call()</code>、<code>apply()</code> 類似。</p>
<p>　　所以我們要做的事情就是先把參數表建好，然後傳入這個 <code>Call</code> 函數供其執行。</p>
<p>　　第一步，顯示轉換函數，因爲本來是 <code>Object</code> 類型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
</pre></td></tr></table></figure>

<p>　　第二步，建立參數表（數組）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
</pre></td></tr></table></figure>

<h4 id="最後調用函數系列">最後調用函數系列</h4>
<p>　　調用 <code>cb</code> ，把參數傳進去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>cb-&gt;Call(Context::GetCurrent()-&gt;Global(), <span class="number">1</span>, argv);
</pre></td></tr></table></figure>

<p>　　這裏第一個參數 <code>Context::GetCurrent()-&gt;Global()</code> 所代表的意思就是獲取全局上下文作爲函數的 <code>this</code>；第二個參數就是參數表中的個數（畢竟雖然 <code>Node.js</code> 的數組是有長度屬性的，但是 <code>C++</code> 裏面數組的長度實際上系統是不知道的，還得你自己傳進一個數來說明數組長度）；最後一個參數就是剛纔我們建立好的參數表了。</p>
<h4 id="終章之結束文件系列">終章之結束文件系列</h4>
<p>　　相信這一步大家已經輕車熟路了吧，就是把函數寫好，然後放進導出函數裏面，最後申明一下。</p>
<p>　　我就直接放出代碼吧，或者直接跑去 <code>Node.js</code> 的<a href="http://nodejs.org/api/addons.html#addons_callbacks" target="_blank">文檔</a>看也行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">1</span>;
    Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
    cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);
    
    <span class="keyword">return</span> scope.Close(Undefined());
}

<span class="keyword">void</span> Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module)
{
    module-&gt;Set(String::NewSymbol(<span class="string">"exports"</span>),
        FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　Well done! 最後剩下的步驟就自己去吧。至於 <code>Js</code> 裏面這麼調用這個函數，我在<a href="#回調函數">之前</a>已經提到過了。</p>
<h2 id="番外">番外</h2>
<p>　　嘛嘛，我感覺我的學習筆記寫得越來越奔放了求破～</p>
<p>　　今天就先寫到這裏吧，寫學習筆記的過程中我又漲姿勢了，比如說那個 <code>Call</code> 函數的參數意義。</p>
<p>　　如果你們覺得本系列學習筆記對你們還有幫助的話，就來和我一起搞基吧麼麼噠～Σ&gt;―(〃°ω°〃)♡→</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[讓Node.js和C++一起搞基 —— 1]]></title>
    <link href="http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/"/>
    <id>http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/</id>
    <published>2014-04-01T16:53:22.000Z</published>
    <updated>2014-12-10T07:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>N久之前的一個坑——用 <strong>Node.js</strong> 來重構 NBUT 的 <strong>Online Judge</strong>，包括評測端也得重構一遍。（至於什麼時候完成大家就不要關心了，(／‵Д′)／~ ╧╧</p>
<p>　　總之我們現在要做的其實簡而言之就是——用C/C++來實現 <strong>Node.js</strong> 的模塊。</p>
<h2 id="準備工作">準備工作</h2>
<p>　　工欲善其事，必先<del>耍流氓</del>利其器。</p>
<h3 id="node-gyp">node-gyp</h3>
<p>　　首先你需要一個 <code>node-gyp</code> 模塊。</p>
<p>　　在任意角落，執行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install node<span class="attribute">-gyp</span> <span class="attribute">-g</span>
</pre></td></tr></table></figure>


<p>　　在進行一系列的 <code>blahblah</code> 之後，你就安裝好了。</p>
<h3 id="Python">Python</h3>
<p>　　然後你需要有個 <code>python</code> 環境。</p>
<p>　　自己去<a href="http://python.org/" target="_blank">官網</a>搞一個來。</p>
<blockquote>
<p><strong>注意：</strong> 根據 <code>node-gyp</code> 的<a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">GitHub</a>顯示，請務必保證你的 <code>python</code> 版本介於 <code>2.5.0</code> 和 <code>3.0.0</code> 之間。</p>
</blockquote>
<h3 id="編譯環境">編譯環境</h3>
<p>　　嘛嘛，我就偷懶點不細寫了，還請自己移步到 <a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">node-gyp</a> 去看編譯器的需求。並且倒騰好。</p>
<h2 id="入門">入門</h2>
<p>　　我就拿<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官網的入門 Hello World</a>說事兒了。</p>
<h3 id="Hello_World">Hello World</h3>
<p>　　請準備一個 <code>C++</code> 文件，比如就叫 <del>sb.cc</del> hello.cc。</p>
<p>　　然後我們一步步來，先往裏面搞出頭文件和定義好命名空間：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="preprocessor">#include &lt;v8.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;
</pre></td></tr></table></figure>


<h4 id="主要函數">主要函數</h4>
<p>　　接下去我們寫一個函數，其返回值是 <code>Handle&lt;Value&gt;</code>。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(const Arguments&amp; args)
{
    //<span class="keyword">...</span> 嗷嗷待寫
}
</pre></td></tr></table></figure>


<p>　　然後我來粗粗解析一下這些東西：</p>
<h5 id="Handle&lt;Value&gt;">Handle&lt;Value&gt;</h5>
<p>　　做人要有節操，我事先申明我是從<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">這裏</a>(<a href="http://cnodejs.org/user/fool" target="_blank">@fool</a>)參考的。</p>
<blockquote>
<p>V8 裏使用 Handle 類型來託管 JavaScript 對象，與 C++ 的 std::sharedpointer 類似，Handle 類型間的賦值均是直接傳遞對象引用，但不同的是，V8 使用自己的 GC 來管理對象生命週期，而不是智能指針常用的引用計數。</p>
<p>JavaScript 類型在 C++ 中均有對應的自定義類型，如 String 、 Integer 、 Object 、 Date 、 Array 等，嚴格遵守在 JavaScript 中的繼承關係。 C++ 中使用這些類型時，必須使用 Handle 託管，以使用 GC 來管理它們的生命週期，而不使用原生棧和堆。</p>
</blockquote>
<p>　　而這個所謂的 <strong>Value</strong> ，從 V8 引擎的頭文件 <a href="http://code.google.com/p/v8/source/browse/trunk/include/v8.h#1417" target="_blank">v8.h</a> 中的各種繼承關係中可以看出來，其實就是 JavaScript 中各種對象的基類。</p>
<p>　　在瞭解了這件事之後，我們大致能明白上面那段函數的申明的意思就是說，我們寫一個 <code>Hello</code> 函數，其返回的是一個不定類型的值。</p>
<blockquote>
<p><strong>注意：</strong> 我們只能返回特定的類型，即在 Handle 託管下的 String 啊 Integer 啊等等等等。</p>
</blockquote>
<h5 id="Arguments">Arguments</h5>
<p>　　這個就是傳入這個函數的參數了。我們都知道在 <code>Node.js</code> 中，參數個數是亂來的。而這些參數傳進去到 <code>C++</code> 中的時候，就轉變成了這個 <code>Arguments</code> 類型的對象了。</p>
<p>　　具體的用法我們在後面再說，在這裏只需要明白這個是個什麼東西就好。（爲毛要賣關子？因爲 <code>Node.js</code> 官方文檔中的<a href="https://github.com/rvagg/node-addon-examples" target="_blank">例子</a>就是分開來講的，我現在只是講第一個 <code>Hello World</code> 的例子而已( ´థ౪థ）σ</p>
<h4 id="添磚加瓦">添磚加瓦</h4>
<p>　　接下去我們就開始添磚加瓦了。就最簡單的兩句話：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(<span class="keyword">const</span> Arguments&amp; args)
{
    HandleScope <span class="keyword">scope</span>;
    <span class="keyword">return</span> <span class="keyword">scope</span>.Close(String::New(<span class="string">"world"</span>));
}
</pre></td></tr></table></figure>


<p>　　這兩句話是什麼意思呢？大致的意思就是返回一個 <code>Node.js</code> 中的字符串 <code>&quot;world&quot;</code>。</p>
<h5 id="HandleScope">HandleScope</h5>
<p>　　同參考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">這裏</a>。</p>
<blockquote>
<p>Handle 的生命週期和 C++ 智能指針不同，並不是在 C++ 語義的 scope 內生存（即{} 包圍的部分），而需要通過 HandleScope 手動指定。HandleScope 只能分配在棧上，HandleScope 對象聲明後，其後建立的 Handle 都由 HandleScope 來管理生命週期，HandleScope 對象析構後，其管理的 Handle 將由 GC 判斷是否回收。</p>
</blockquote>
<p>　　所以呢，我們得在需要管理他的生命週期的時候申明這個 <code>Scope</code> 。好的，那麼爲什麼我們的代碼不這麼寫呢？</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Handle</span><span class="subst">&lt;</span>Value<span class="subst">&gt;</span> Hello(const Arguments<span class="subst">&amp;</span> args)
{
    HandleScope scope;
    <span class="keyword">return</span> <span class="built_in">String</span><span class="tag">::New</span>(<span class="string">"world"</span>);
}
</pre></td></tr></table></figure>


<p>　　因爲當函數返回時，<code>scope</code> 會被析構，其管理的Handle也都將被回收，所以這個 <code>String</code> 就會變得沒有意義。</p>
<p>　　所以呢 V8 就想出了個神奇的點子——<code>HandleScope::Close(Handle&lt;T&gt; Value)</code> 函數！這個函數的用處就是關閉這個 Scope 並且把裏面的參數轉交給上一個 Scope 管理，也就是進入這個函數前的 Scope。</p>
<p>　　於是就有了我們之前的代碼 <code>scope.Close(String::New(&quot;world&quot;));</code>。</p>
<h5 id="String::New">String::New</h5>
<p>　　這個 <code>String</code> 類所對應的就是 <code>Node.js</code> 中原生的字符串類。繼承自 <code>Value</code> 類。與此類似，還有：</p>
<ul>
<li>Array</li>
<li>Integer</li>
<li>Boolean</li>
<li>Object</li>
<li>Date</li>
<li>Number</li>
<li>Function</li>
<li>…</li>
</ul>
<p>　　這些東西有些是繼承自 <code>Value</code>，有些是二次繼承。我們這裏就不多做研究，自己可以看看 V8 的代碼（至少是頭文件）研究研究或者看看這個<a href="http://bespin.cz/~ondras/html/classv8_1_1Value.html#a70d4afaccc7903e6a01f40a46ad04188" target="_blank">手冊</a>。</p>
<p>　　而這個 <code>New</code> 呢？<a href="http://bespin.cz/~ondras/html/classv8_1_1String.html" target="_blank">這裏</a>可以看的。就是新建一個 <code>String</code> 對象。</p>
<p>　　至此，這個主要函數我們就解析完畢了。</p>
<h4 id="導出對象">導出對象</h4>
<p>　　我們來溫習一下，如果是在 <code>Node.js</code> 裏面寫的話，我們怎麼導出函數或者對象什麼的呢？</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>exports.hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
</pre></td></tr></table></figure>


<p>　　那麼，在 <code>C++</code> 中我們該如何做到這一步呢？</p>
<h5 id="初始化函數">初始化函數</h5>
<p>　　首先，我們寫個初始化函數：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>void init(Handle&lt;Object&gt; exports)
{
    //<span class="keyword">...</span> 嗷嗷待寫你妹啊！<span class="comment">#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</span>
}
</pre></td></tr></table></figure>


<p>　　這是龜腚！函數名什麼的無所謂，但是傳入的參數一定是一個 <code>Handle&amp;lt;Object&gt;</code>，代表我們下面將要在這貨上導出東西。</p>
<p>　　然後，我們就在這裏面寫上導出的東西了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="literal">void</span> init(<span class="keyword">Handle</span><span class="subst">&lt;</span>Object<span class="subst">&gt;</span> exports)
{
    exports<span class="subst">-&gt;</span><span class="built_in">Set</span>(<span class="built_in">String</span><span class="tag">::NewSymbol</span>(<span class="string">"hello"</span>),
        FunctionTemplate<span class="tag">::New</span>(Hello)<span class="subst">-&gt;</span>GetFunction());
}
</pre></td></tr></table></figure>


<p>　　大致的意思就是說，爲這個 <code>exports</code> 對象添加一個字段叫 <code>hello</code>，所對應的東西是一個<a href="http://bespin.cz/~ondras/html/classv8_1_1FunctionTemplate.html" target="_blank">函數</a>，而這個函數就是我們親愛的 <code>Hello</code> 函數了。</p>
<p>　　用僞代碼寫直白點就是：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">void</span> init(Handle&lt;Object&gt; <span class="built_in">exports</span>)
{
    <span class="built_in">exports</span>.Set(<span class="string">"hello"</span>, <span class="reserved">function</span> hello);
}
</pre></td></tr></table></figure>


<p>　　大功告成！</p>
<p>　　（大功告成你妹啊！閉嘴( ‘д‘⊂彡☆))Д´)</p>
<h5 id="真·導出">真·導出</h5>
<p>　　這纔是最後一步，我們最後要申明，這個就是導出的入口，所以我們在代碼的末尾加上這一行：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">NODE_MODULE(hello, init)</span>
</pre></td></tr></table></figure>


<p>　　納了個尼？！這又是什麼東西？</p>
<p>　　彆着急，這個 <code>NODE_MODULE</code> 是一個宏，它的意思呢就是說我們採用 <code>init</code> 這個初始化函數來把要導出的東西導出到 <code>hello</code> 中。那麼這個 <code>hello</code> 哪來呢？</p>
<p>　　<strong>它來自文件名！</strong>對，沒錯，它來自文件名。你並不需要事先申明它，你也不必擔心不能用，總之你的這個最終編譯好的二進制文件名叫什麼，這裏的 <code>hello</code> 你就填什麼，當然要除去後綴名了。</p>
<p>　　詳見<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官方文檔</a>。</p>
<blockquote>
<p>Note that all Node addons must export an initialization function:</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> Initialize (Handle&lt;<span class="built_in">Object</span>&gt; exports);
NODE_MODULE(module_name, Initialize)
</pre></td></tr></table></figure>

<p>There is no semi-colon after NODE_MODULE as it’s not a function (see node.h).</p>
<p>The module_name needs to match the filename of the final binary (minus the .node suffix).</p>
</blockquote>
<h3 id="編譯_(๑•́_₃_•̀๑)">編譯 (๑•́ ₃ •̀๑)</h3>
<p>　　來吧，讓我們一起編譯吧！</p>
<p>　　我們再新建一個類似於 <code>Makefile</code> 的歸檔文件吧——<code>binding.gyp</code>。</p>
<p>　　並且在裏面添加這樣的<a href="https://github.com/TooTallNate/node-gyp#the-bindinggyp-file" target="_blank">代碼</a>：</p>
<figure class="highlight"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"hello"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"hello.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>


<p>　　爲什麼這麼寫呢？可以參考 <code>node-gyp</code> 的<a href="http://code.google.com/p/gyp/wiki/GypUserDocumentation#Skeleton_of_a_typical_Chromium_.gyp_file" target="_blank">官方文檔</a>。</p>
<h4 id="configure">configure</h4>
<p>　　在文件搞好之後，我們要在這個目錄下面執行這個命令了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure
</pre></td></tr></table></figure>


<p>　　如果一切正常的話，應該會生成一個 <code>build</code> 的目錄，然後裏面有相關文件，也許是 <strong>M$ Visual Studio</strong> 的 <code>vcxproj</code> 文件等，也許是 <code>Makefile</code> ，視平臺而定。</p>
<h4 id="build">build</h4>
<p>　　<code>Makefile</code> 也生成好之後，我們就開始構造編譯了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp build
</pre></td></tr></table></figure>


<p>　　等到一切編譯完成，纔算是真正的大功告成了！不信你去看看 <code>build/Release</code> 目錄，下面是不是有一個 <code>hello.node</code> 文件了？沒錯，這個就是 C++ 等下要給 Node.js 撿的肥皂！</p>
<h3 id="搞基吧！Node_ヽ(✿ﾟ▽ﾟ)ノ_C++">搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</h3>
<p>　　我們在剛纔那個目錄下新建一個文件 <code>jianfeizao.js</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> addon = <span class="built_in">require</span>(<span class="string">"./build/Release/hello"</span>);
<span class="built_in">console</span>.log(addon.hello());
</pre></td></tr></table></figure>


<p>　　看到沒！看到沒！出來了出來了！Node.js 和 C++ 搞基的結果！這個 <code>addon.hello()</code> 就是我們之前在 C++ 代碼中寫的 <code>Handle&lt;Value&gt; Hello(const Arguments&amp; args)</code> 了，我們現在就已經把它返回的值給輸出了。</p>
<h2 id="洗洗睡吧，下節更深入">洗洗睡吧，下節更深入</h2>
<p>　　時間不早了，今天就寫到這裏了，至此爲止大家都能搞出最基礎的 <strong>Hello world</strong> 的 C++ 擴展了吧。下一次寫的應該會更深入一點，至於下一次是什麼時候，我也不知道啦其實。<br>　　（喂喂喂，擼主怎麼可以這麼不負責！(ｏﾟﾛﾟ)┌┛Σ(ﾉ´<em>ω</em>`)ﾉ</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
</feed>
