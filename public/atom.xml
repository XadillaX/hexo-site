<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾克斯の编码者</title>
  
  <subtitle>一个伪宅级别的码畜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xcoder.in/"/>
  <updated>2018-12-29T18:47:24.537Z</updated>
  <id>https://xcoder.in/</id>
  
  <author>
    <name>死月·吃圡蕾特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死月的二零一八总结</title>
    <link href="https://xcoder.in/2018/12/30/my-2018/"/>
    <id>https://xcoder.in/2018/12/30/my-2018/</id>
    <published>2018-12-29T18:31:08.000Z</published>
    <updated>2018-12-29T18:47:24.537Z</updated>
    
    <content type="html"><![CDATA[<p>是时候总结一发了，今年经历了人生的大事，心态也多次变化，开心、焦虑、压力等等等等。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h3><ul><li>泰国·清迈；</li><li>成都·FCC 前端大会；</li><li>上海·马克西姆演奏会。</li></ul><p>今年的足迹比去年还少，更别提前年了。就在将近年末的时候听了一场马克西姆的演奏会，Live 效果就是好；以及在双十一的时候去成都参加了 <a href="https://web-conf.tk/2018/" target="_blank" rel="external">FreeCodeCamp 的 Web 前端交流大会</a>，充当了一次讲师提供了一场《<a href="https://github.com/FreeCodeCamp-Chengdu/Activity_PPT/blob/master/20181110/%E7%BB%99%20Node.js%20%E6%8F%92%E4%B8%8A%20C%2B%2B%20%E7%9A%84%E7%BF%85%E8%86%80-%E6%AD%BB%E6%9C%88.pdf" target="_blank" rel="external">给 Node.js 插上 C++ 的翅膀</a>》的演讲；再往前推就是年中的时候团建 Outing 去了清迈玩，很险的是差点选了去普吉岛，如果去普吉岛的话肯定会选择去皇帝岛的路线，而今年沉船就是在那几天，感觉也是捡回了一条命。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/qingmai1.jpeg_/fh/600/unsharp/true" alt="清迈"></p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/13770261.jpeg_/fw/600/unsharp/true" alt="成都 FCC"></p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/maksim.jpg_/fw/600/unsharp/true" alt="马克西姆"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>正式拥有了人生中第一套房子，很用心地去装修了它，100 寸激光电视 + 家庭影院玩 PS4 和 Switch 真香；</li><li>上了浙 A 牌照；</li><li>一不小心办了个婚礼；</li><li>塞尔达、地平线等真香、PS VR 真香；</li><li>在家招待了 N 次同学、同事、朋友……</li><li>健身减脂 10 斤，然后虽然到瓶颈了，好歹也是能看出一丢丢肌肉了，至少心肺比以前好太多了，主要不太想太管住嘴；</li><li>买了一小柜子的手办。</li></ul><p>体重今年曾一度到了 80 公斤，感觉自己不能再这么下去了，于是开始减脂。由于不想太管住嘴，所以还算比较佛系。但好在小有成效，心肺明显好了很多，并且也“慢慢”掉回到了 75 左右，不过体脂比以前的 75 还是要低的。然后由于有了自己的小窝，所以今年基本上都是宅在家里，100 寸的屏幕加上家庭影院玩游戏真的很爽。每每家里来客人，总要 PSVR 一番。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/psb%20%282%29.jpeg_/fw/600/unsharp/true" alt="手办"></p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/psb%20%283%29.jpeg_/fw/600/unsharp/true" alt="手办"></p><p>（猜猜上面两个都是谁 (๑•̀ㅂ•́)و✧）</p><p>另外，别的不说，推荐一个最近玩的路亚钓鱼游戏，<a href="https://finalfantasyxv.square-enix-games.com/en/playstation-vr" target="_blank" rel="external">Monster of the Deep</a>，近距离的席德妮妹子赛高。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/psb%20%284%29.jpeg_/fw/600/unsharp/true" alt="席德妮"></p><p>以及，多次招待了朋友和同事们。下图是大学时候集训队有爱的同学们。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/1546103297301%281%29.jpeg_/fh/600/unsharp/true" alt="集训队"></p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年的工作依然是比较坎坷。刚进蚂蚁有点水土不服，工作的方式跟以前大有不同，年中的时候特别焦虑，好在慢慢熬了过来，慢慢开始接受了现在的习惯。</p><p>目前在蚂蚁做的事情还是底层框架、基础设施相关的，在做一些应用、框架质量和治理相关的事情。相较以前更多地去关注技术和研发，现在更需要的是自己把控好整件事情，要 Hold 住整个产品的方向。真的是应了大家的话，进了阿里系之后，写代码反而是最简单的事情，大家需要努力提升自己的软技能。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/mmexport1546103866825.jpg_/fw/600/unsharp/true" alt="一年香的币"></p><p>在蚂蚁也一年了，周年那天也拿到了自己“一年香”的币，还是感慨万分的。团队的小伙伴们真的是又牛又棒，很喜欢融洽的氛围。大家如果不嫌弃有兴趣一起共事的话，也可以投简历过来哇，我们现在需要各种前端、Node.js 开发、3D 开发（Unreal 等），以及设计师、PD 等等等等。</p><p>唯一有点遗憾的是，对于某一特定技术钻研的时间变少了，技术输出也变少了，例如今年对于 Node.js 的贡献少之又少，文章等也变少了，今年一次 NodeParty 都没参加以及组织，感觉明年要更努力了。</p><h2 id="技术-amp-社区"><a href="#技术-amp-社区" class="headerlink" title="技术 &amp; 社区"></a>技术 &amp; 社区</h2><ul><li>《<a href="https://book.douban.com/subject/30247892/" target="_blank" rel="external">Node.js：来一打 C++ 扩展</a>》终于出版，以后也能说自己是出过书的人了；</li><li>接手了《Modern Vim: Craft Your Development Environment with Vim 8 and Neovim》一书的翻译，目前翻了几十页，可惜下半年太忙了，明年继续努力；</li><li><a href="https://www.zhihu.com/people/xadillax/" target="_blank" rel="external">知乎</a>莫名其妙有了 3600+ 的粉丝，求关注；</li><li>参与成都 FCC Web 前端交流大会并提供了《<a href="https://github.com/FreeCodeCamp-Chengdu/Activity_PPT/blob/master/20181110/%E7%BB%99%20Node.js%20%E6%8F%92%E4%B8%8A%20C%2B%2B%20%E7%9A%84%E7%BF%85%E8%86%80-%E6%AD%BB%E6%9C%88.pdf" target="_blank" rel="external">给 Node.js 插上 C++ 的翅膀</a>》一 Topic；</li><li>共建 <a href="https://github.com/apache/rocketmq-client-nodejs/" target="_blank" rel="external">RocketMQ Node.js Client</a> 社区，以后也能说自己是 Apache 社区的贡献者了；</li><li>由于团队的性质，也少量地贡献了 <a href="https://github.com/eggjs/egg" target="_blank" rel="external">Egg.js</a> 社区，不多，基本上都是与自身需求相关的；</li><li>输出了屈指可数的三篇文章。<ul><li>《<a href="https://xcoder.in/2018/04/01/random-connected-area/">随机生成指定面积单连通区域</a>》</li><li>《<a href="https://zhuanlan.zhihu.com/p/44809689" target="_blank" rel="external">【译】你所要知道关于 Node.js Streams 的一切</a>》</li><li>《<a href="https://xcoder.in/2018/12/07/a-macos-stl-keng/">一次 macOS 下 C++ 的 STL 踩坑记录</a>》</li></ul></li></ul><p>正如上一节所说，今年对于社区的输出变少了。什么“太忙了”什么的都是借口，就是自己的时间管理并没有达到自己想要的水准。</p><h3 id="出、译书"><a href="#出、译书" class="headerlink" title="出、译书"></a>出、译书</h3><p>正如去年的总结里面所说，这是去年的目标，而今年《Node.js：来一打 C++ 扩展》终于出版了。而自己出书有一点很爽的就是，可以自己埋下各种彩蛋，大家都去找找看吧。</p><p>可惜 Node.js 发展太快，去年书中的内容还是 Node.js v6，而现在已经到 10.x 了。不过好在底层都是相通的，大家还是可以一读。</p><p>此外，由于跟负责之前这本书的编辑熟了，于是又揽下了一本 Vim8 和 Neovim 相关的书的翻译。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/mmexport1546107015247.jpg_/fh/600/unsharp/true" alt="来一打"></p><p>（发现封面是二小姐的翅膀了吗？）</p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>去年年底和今年输出了几篇技术文章，托了团队专栏的福，涨了一波粉。以及知乎日报也收录了我的一个答案（<a href="https://www.zhihu.com/question/268793862/answer/341730200" target="_blank" rel="external">对 BAT、TMD 这类公司而言，1-3 年的工程师在技术面时面试官最看重的有哪些？</a>），所以又涨了一波。也算是今年的一个意外收获吧。</p><h3 id="FCC-成都"><a href="#FCC-成都" class="headerlink" title="FCC 成都"></a>FCC 成都</h3><p>托了前几项的福，今年受邀参加了 Web 前端交流大会。并不擅长提供 Topic 的我，居然被大家冠上了“幽默”文风的特性，也许是因为我的一句“老夫撸起袖子就是干”吧。</p><p>然后就是得到了一张证书。</p><p><img src="http://dm.nbut.ac.cn/xcoder/2018/12/30/mmexport1546106814751.jpg_/fh/600/unsharp/true" alt="证书"></p><p>可惜今年成都太匆忙了，由于是双十一，当天还要半夜去接某人天猫双十一归来，所以分享完毕都没来得及跟大家交流就马上上了飞机回了杭州。下次再来成都一定要好好玩玩。</p><h3 id="共建-RocketMQ-Node-js-Client-社区"><a href="#共建-RocketMQ-Node-js-Client-社区" class="headerlink" title="共建 RocketMQ Node.js Client 社区"></a>共建 RocketMQ Node.js Client 社区</h3><p>下半年的时候，RocketMQ 社区负责 SDK 的同学（阿里 RocketMQ 团队的）通过我之前写的 Aliyun ONS SDK 找到了我，说他们正在建设多语言 SDK，都是基于 RocketMQ C SDK 来的。由于我们这边恰好有一个业务用到 RocketMQ，而且 Egg.js 针对 SOFA 开源也有可能需要一个 RocketMQ 的插件，于是我也就应了下来。</p><p>由于之前写过 ONS，所以这里在技术实现上还算是轻车熟路的，成本基本上在于社区的基础建设上。</p><p>大家有兴趣也可以一起来共建哇。</p><h2 id="二〇一七的-Checklist"><a href="#二〇一七的-Checklist" class="headerlink" title="二〇一七的 Checklist"></a>二〇一七的 Checklist</h2><ul><li><del>去</del>欧美<del>国家游玩一次；</del></li><li><del>书出版；</del></li><li><del>买家具什么的装饰自己的家；</del></li><li>晋升；</li><li><del>弄一个类似家庭影院的东西；</del></li><li><del>精进厨艺；</del>（算是吧，至少某人嘴里是这么认为的）</li><li>赚更多钱，不要像现在一样花得憋屈。</li></ul><p>唉，去年的 Checklist 只完成了四项半。第一项由于也是出境游但不是欧美，所以只能算是完成了一半吧。感觉今年过得迷迷糊糊的很大一部分原因还是在于对于工作上的迷茫和焦虑，导致没有太多时间去想别的事情。感觉工作以来第一次有这种感觉吧，果然阿里系对于自身的提升还是非常有挑战性的。</p><h2 id="展望二〇一八"><a href="#展望二〇一八" class="headerlink" title="展望二〇一八"></a>展望二〇一八</h2><ul><li>去欧美国家游玩一次；</li><li>带父母们去玩一次；</li><li>翻译的书一定要翻译完并出版，不能拖延了；</li><li>晋升；</li><li>对于社区有更多的输出，今年不是一个好榜样；</li><li>坚持锻炼；</li><li>学习一门新的技术。</li></ul><p>Ask me anything: <a href="https://github.com/xadillax/ama" target="_blank" rel="external">https://github.com/xadillax/ama</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是时候总结一发了，今年经历了人生的大事，心态也多次变化，开心、焦虑、压力等等等等。&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;h3 id=&quot;足迹&quot;&gt;&lt;a href=&quot;#足迹
      
    
    </summary>
    
    
      <category term="总结" scheme="https://xcoder.in/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2018" scheme="https://xcoder.in/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>一次 macOS 下 C++ 的 STL 踩坑记录</title>
    <link href="https://xcoder.in/2018/12/07/a-macos-stl-keng/"/>
    <id>https://xcoder.in/2018/12/07/a-macos-stl-keng/</id>
    <published>2018-12-07T10:51:27.000Z</published>
    <updated>2018-12-07T11:00:41.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有在做 RocketMQ 社区的 Node.js SDK，是基于 RocketMQ 的 C SDK 封装的 Addon，而 C 的 SDK 则是基于 C++ SDK 进行的封装。</p><p>然而，却出现了一个诡异的问题，就是当我在消费信息的时候，发现在 macOS 下得到的消息居然是乱码，也就是说 Linux 下居然是正常的。</p><h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><blockquote><p>首先我们要知道一个函数是 <code>const char* GetMessageTopic(CMessageExt* msg)</code>，用于从一个 <code>msg</code> 指针中获取它的 Topic 信息。</p></blockquote><p>乱码的代码可以有好几个版本，是我在排查的时候做的各种改变：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往 JavaScript 的 `object` 对象中插入键名为 `topic` 的值为 `GetMessageTopic`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法：乱码</span></span><br><span class="line">Nan::Set(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::New(<span class="string">"topic"</span>).ToLocalChecked(),</span><br><span class="line">  Nan::New(GetMessageTopic(msg)).ToLocalChecked()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法：乱码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* temp = GetMessageTopic(msg);</span><br><span class="line">Nan::Set(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::New(<span class="string">"topic"</span>).ToLocalChecked(),</span><br><span class="line">  Nan::New(temp).ToLocalChecked()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法：乱码</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetMessageColumn</span><span class="params">(CMessageExt* msg, <span class="keyword">char</span>* name)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* orig = GetMessageTopic(msg);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(orig);</span><br><span class="line">  <span class="keyword">char</span> temp[len + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp, orig, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* temp = GetMessageColumn(msg, <span class="string">"topic"</span>);</span><br><span class="line">Nan::Set(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::New(<span class="string">"topic"</span>).ToLocalChecked(),</span><br><span class="line">  Nan::New(temp).ToLocalChecked()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>并且很诡异的是，当我在调试第三种写法的时候，我发现在 <code>const char* orig = GetMessageTopic(msg);</code> 这一部的时候 <code>orig</code> 的值是正确的。而一步步单步运行下去，一直到 <code>memcpy</code> 执行结束的时候，<code>orig</code> 内存块里面的字符串居然被莫名其妙修改成乱码了。</p><p>参考如下：</p><p><img src="https://s1.ax1x.com/2018/12/07/F3KN59.gif" alt=""></p><p>这就不能忍了。</p><p>当我锲而不舍的时候，发现当我改成这样之后，返回的值就对了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetMessageColumn</span><span class="params">(CMessageExt* msg, <span class="keyword">char</span>* name)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* orig = GetMessageTopic(msg);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(orig);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> temp[len + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[i] = orig[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做一些其它操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* temp = GetMessageColumn(msg, <span class="string">"topic"</span>);</span><br><span class="line">Nan::Set(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::New(<span class="string">"topic"</span>).ToLocalChecked(),</span><br><span class="line">  Nan::New(temp).ToLocalChecked()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但问题在于，在“其它操作”中，<code>orig</code> 还是会变成一堆乱码。当前返回能正确的原因是因为我在它变成乱码之前，用可以“不触发”变成乱码的操作先把 <code>orig</code> 的字符串给赋值到另一个字符数组中，最后返回那个新的数组。</p><p>问题看似解决了，但是这种诡异、危险的行为始终是我心中的一颗丧门钉，不处理总之是慌的。</p><h2 id="RocketMQ-C-SDK-源码查看"><a href="#RocketMQ-C-SDK-源码查看" class="headerlink" title="RocketMQ C++ SDK 源码查看"></a>RocketMQ C++ SDK 源码查看</h2><p>在排查的过程中，我去看了 RocketMQ 的 C++ 和 C SDK 的实现，我把重要的内容摘出来：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MQMessage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">string</span>::<span class="function"><span class="built_in">string</span> <span class="title">getTopic</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_topic;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> m_topic;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MQMessageExt 是继承自 MQMessage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetMessageTopic</span><span class="params">(CMessageExt *msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ((MQMessageExt *) msg)-&gt;getTopic().c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们阅读一下这段代码，在 <code>GetMessageTopic</code> 中，先得到了一个 <code>getTopic</code> 的 STL 字符串，然后调用它的 <code>c_str()</code> 返回 <code>const char*</code>。一切看起来是那么美好，没有问题。</p><p>但我后来在多次调试的时候发现，对于同一个 <code>msg</code> 进行调用 <code>GetMessageTopic</code> 得到的指针居然不一样！我是不是发现了什么新大陆？</p><p>诚然，<code>msg-&gt;getTopic()</code> 返回了一个字符串对象，并且是通过拷贝构造从 <code>m_topic</code> 那边来的。依稀记得大学时候看的 STL 源码解析，根据 STL 字符串的 Copy-On-Write 来说，我没做任何改变的情况下，它们不应该是同源的吗？</p><p><strong>事实证明，我当时的这个“想当然”就差点让我查不出问题来了。</strong></p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>在我捉鸡了好久之后一直毫无头绪之后，在参考资料 1 中获得了灵感，我开始打开脑洞（请原谅我这个坑还找了很久，毕竟我主手武器还是 Node.js），会不会现在的 String 都不是 Copy-On-Write 了？但是 Linux 下又是正常的哇。</p><p>后来我在网上找是不是有人跟我遇到一样的问题，最后还是找到了端倪。</p><blockquote><p>不同的 stl 标准库实现不同， 比如 CentOS 6.5 默认的 stl::string 实现就是 『Copy-On-Write』， 而 macOS（10.10.5）实现就是『Eager-Copy』。</p></blockquote><p>说得白话一点就是，不同库实现不一样。Linux 用的是 libstdc++，而 macOS 则是 libc++。而 libc++ 的 String 实现中，是不写时拷贝的，一开始赋值就采用深拷贝。也就是说就算是两个一样的字符串，在不同的两个 String 对象中也不会是同源。</p><p>其实深挖的话内容还有很多的，例如《Effective STL》中的第 15 条也有提及 String 实现有多样性；以及大多数的现代编译器中 String 也都有了 Short String Optimization 的特性；等等。</p><h2 id="回到乱码-Bug"><a href="#回到乱码-Bug" class="headerlink" title="回到乱码 Bug"></a>回到乱码 Bug</h2><p>得到了上面的结论之后，这个 Bug 的原因就知道了。</p><p><code>((MQMessageExt *) msg)-&gt;getTopic()</code> 得到了一个函数中的栈内存字符串变量。</p><ul><li>在 Linux 中，就算是栈内存变量，但是它的 <code>c_str()</code> 还是源字符串指向的指针，所以函数声明周期结束，这个栈内存中的字符串被释放，<code>c_str()</code> 指向的内存还坚挺着；</li><li>在 macOS 下，由于字符串是栈内存分配的，字符串又是深拷贝，所以 <code>c_str()</code> 的生命周期是跟着字符串本身来的，一旦函数调用结束，该字符串就被释放了，相应地 <code>c_str()</code> 对应内存中的内容也被释放。</li></ul><p>综上所述，在 macOS 下，我通过 <code>GetMessageTopic()</code> 得到的内容其实是一个已经被释放内存的地址。虽然通过 <code>for</code> 可以趁它的内存块被复制之前赶紧抢救出来，但是这种操作一块已经被释放的内存行为总归是危险的，因为它的内存块随时可能被覆盖，这也就是之前乱码的本质了。</p><h2 id="更小-Demo-验证"><a href="#更小-Demo-验证" class="headerlink" title="更小 Demo 验证"></a>更小 Demo 验证</h2><p>对于 STL 在这两个平台上不同的行为，我也抽出了一个最小化的 Demo，各位看官可以在自己的电脑上试试看：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">func1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%.8X 0x%.8X\n"</span>, a.c_str(), func1().c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在 Linux 下（如 Ubuntu 14.04）运行会输出两个一样的指针地址，而在 macOS 下执行则输出的是两个不一样的指针。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在语言、库的使用中，我们不能去使用一个没有明确在文档中定义的行为的“特性”。例如文档中没跟你说它用的是 Copy-On-Write 技术，也就说明它可能在未来任何时候不通知你就去改掉，而你也不容易去发现它。你就去用已经定义好的行为即可，就是说 <code>c_str()</code> 返回的是字符串的一个真实内容，我们就要认为它是跟随着 String 的生命周期，哪怕它其中有黑科技。</p><p>毕竟，下面这个才是 C++ reference 中提到的定义，我们不能臆想人家一定是 COW 行为：</p><blockquote><p>Returns a pointer to a null-terminated character array with data equivalent to those stored in the string.</p><p>The pointer is such that the range <code>[c_str(); c_str() + size()]</code> is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</p></blockquote><p>这一样可以引申到 JavaScript 上来，例如较早的 ECMAScript 262 第三版对于一个对象的定义中，键名在对象中的顺序也是未定义的，当时就不能讨巧地看哪个浏览器是怎么样一个顺序来进行输出，毕竟对于未定义的行为，浏览器随时改了你也不能声讨它什么。</p><p>好久没写文了，码字能力变弱了。</p><p>以上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《<a href="https://stackoverflow.com/questions/27627413/why-does-calling-c-str-on-a-function-that-returns-a-string-not-work/50490703#50490703" target="_blank" rel="external">Why does calling c_str() on a function that returns a string not work?</a>》</li><li>《<a href="https://libcxx.llvm.org/#why" target="_blank" rel="external">Why a new C++ Standard Library for C++11?</a>》</li><li>《Effective STL》第 15 条：注意 String 实现的多样性</li><li>《<a href="https://yanyiwu.com/work/2016/01/30/copy-on-write-stl.html" target="_blank" rel="external">C++ 之 stl::string 写时拷贝导致的问题</a>》</li><li>《<a href="https://www.cnblogs.com/cthon/p/9181979.html" target="_blank" rel="external">C++ 再探 String 之eager-copy、COW 和 SSO 方案</a>》</li><li>《<a href="https://www.jianshu.com/p/10e6564536ed" target="_blank" rel="external">C++ Short String Optimization stackoverflow 回答集锦以及我的思考</a>》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近有在做 RocketMQ 社区的 Node.js SDK，是基于 RocketMQ 的 C SDK 封装的 Addon，而 C 的 SD
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="macOS" scheme="https://xcoder.in/tags/macOS/"/>
    
      <category term="STL" scheme="https://xcoder.in/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js：来一打 C++ 扩展》已出版，求支持</title>
    <link href="https://xcoder.in/2018/06/14/node-cpp-advanced-sale/"/>
    <id>https://xcoder.in/2018/06/14/node-cpp-advanced-sale/</id>
    <published>2018-06-14T10:29:51.000Z</published>
    <updated>2018-06-14T10:31:10.240Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//dn-cnode.qbox.me/FggqZHIE8va72-RguIC8WKGgyzVn" alt="封面"></p><blockquote><p>千呼万唤始出来，犹抱琵琶生哪吒。</p><p>真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。</p></blockquote><p>Node.js 作为近几年新兴的一种编程运行时，托 V8 引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++ 开发 Node.js 原生扩展的口子，让开发者进行项目开发时有了更多的选择。</p><p>《Node.js：来一打 C++ 扩展》以 Chrome V8 的知识作为基础，配合 GYP 的一些内容，将教会大家如何使用 Node.js提供的一些 API 来编写其 C++ 的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN 以及与异步相关的 libuv 知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的 Node.js 以及 C++ 基础。</p><p>阅读《Node.js：来一打 C++ 扩展》，相当于同时学习Chrome V8 开发、libuv 开发以及 Node.js 的原生 C++ 扩展开发知识，非常值得！</p><p><strong>最后十分感谢包括 Node.js TSC 之一的 Anna、几位 Collaborator 以及各位业界的大佬帮忙写推荐语，感谢 @yorkie 大佬和 @justjavac 大佬帮忙作序。</strong></p><h2 id="编辑推荐"><a href="#编辑推荐" class="headerlink" title="编辑推荐"></a>编辑推荐</h2><p>《Node.js：来一打 C++ 扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍 Node.js 的包和模块规范开始，深入解析（包括但不限于剖析 Node.js 自身的源码） Node.js 的模块是如何在运行时被引入的，尤其是如何引入 C++ 模块的；接下来详细讲解了在什么时候、为何要编写 C++ 模块；借此契机，深入介绍了 Node.js 的基石 Chrome V8 和 libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以 Node.js 的 C++ 扩展为中心，衍生出对 Node.js 底层风光的层层剖析，最后再回归到如何编写 Node.js 的 C++ 扩展，一气呵成。读来酣畅淋漓，痛快不已！</p><p>买这一本书相当于买了“Node.js 的底层风光、C++ 扩展编写”、“Chrome V8”和“libuv”三本书！</p><p>读完本书后，你甚至能为 Node.js 自身的添砖加瓦做出非凡贡献。</p><h2 id="购书链接"><a href="#购书链接" class="headerlink" title="购书链接"></a>购书链接</h2><p><strong>目前在预售阶段，顺便蹭 618 活动。</strong></p><ul><li><a href="https://item.jd.com/12380404.html" target="_blank" rel="external">京东</a></li><li><a href="https://detail.tmall.com/item.htm?id=571628730908&amp;cat_id=2" target="_blank" rel="external">天猫</a></li><li><a href="http://product.dangdang.com/25291814.html" target="_blank" rel="external">当当</a></li><li><a href="https://www.amazon.cn/dp/B07DL8GHQC/ie=UTF8&amp;qid=1528969734" target="_blank" rel="external">亚马逊</a></li><li><a href="https://book.douban.com/subject/30247892/" target="_blank" rel="external">豆瓣</a>（不算购书链接）</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 Node.js 的 C++ 扩展前驱知识储备 1</span><br><span class="line">1.1 Node.js 的模块机制 2</span><br><span class="line">1.1.1 CommonJS 的模块规范 2</span><br><span class="line">1.1.2 Node.js 的模块 4</span><br><span class="line">1.1.3 小结 9</span><br><span class="line">1.1.4 参考资料 9</span><br><span class="line">1.2 Node.js 的包机制 9</span><br><span class="line">1.2.1 CommonJS 的包规范 9</span><br><span class="line">1.2.2 Node.js / NPM 下的包 13</span><br><span class="line">1.2.3 NPM 与 CNPM 16</span><br><span class="line">1.2.4 小结 19</span><br><span class="line">1.2.5 参考资料 19</span><br><span class="line">1.3 Node.js 依赖简介 20</span><br><span class="line">1.3.1 Chrome V8 20</span><br><span class="line">1.3.2 libuv 25</span><br><span class="line">1.3.3 其他依赖 28</span><br><span class="line">1.3.4 小结 30</span><br><span class="line">1.3.5 参考资料 30</span><br><span class="line">1.4 C++ 扩展开发的准备工作 31</span><br><span class="line">1.4.1 编辑器 / IDE 31</span><br><span class="line">1.4.2 node-gyp 36</span><br><span class="line">1.4.3 其他构建工具 54</span><br><span class="line">1.4.4 小结 56</span><br><span class="line">1.4.5 参考资料 56</span><br><span class="line">2 C++ 模块原理简析 57</span><br><span class="line">2.1 为什么要写 C++ 模块 57</span><br><span class="line">2.1.1 C++ 比 JavaScript 解释器高效 57</span><br><span class="line">2.1.2 已有的 C++ 轮子 72</span><br><span class="line">2.1.3 小结 77</span><br><span class="line">2.1.4 参考资料 77</span><br><span class="line">2.2 什么是 C++ 扩展 78</span><br><span class="line">2.2.1 C++ 模块本质 78</span><br><span class="line">2.2.2 Node.js 模块加载原理 80</span><br><span class="line">2.2.3 小结 102</span><br><span class="line">2.2.4 参考资料 103</span><br><span class="line">3 Chrome V8 基础 104</span><br><span class="line">3.1 Node.js 与 Chrome V8 104</span><br><span class="line">3.2 基本概念 105</span><br><span class="line">3.2.1 内存机制 105</span><br><span class="line">3.2.2 隔离实例（Isolate） 108</span><br><span class="line">3.2.3 上下文（Context） 109</span><br><span class="line">3.2.4 脚本（Script） 110</span><br><span class="line">3.2.5 小结 110</span><br><span class="line">3.2.6 参考资料 111</span><br><span class="line">3.3 句柄（Handle） 111</span><br><span class="line">3.3.1 本地句柄（Local） 112</span><br><span class="line">3.3.2 持久句柄（Persistent） 115</span><br><span class="line">3.3.3 永生句柄（Eternal） 119</span><br><span class="line">3.3.4 待实本地句柄（Maybe Local） 119</span><br><span class="line">3.3.5 小结 121</span><br><span class="line">3.3.6 参考资料 121</span><br><span class="line">3.4 句柄作用域 121</span><br><span class="line">3.4.1 一般句柄作用域（Handle Scope） 122</span><br><span class="line">3.4.2 可逃句柄作用域（Escapable Handle Scope） 125</span><br><span class="line">3.4.3 小结 129</span><br><span class="line">3.4.4 参考资料 129</span><br><span class="line">3.5 上下文（Context） 129</span><br><span class="line">3.6 模板（Template） 133</span><br><span class="line">3.6.1 函数模板（Function Template） 133</span><br><span class="line">3.6.2 对象模板（Object Template） 138</span><br><span class="line">3.6.3 对象模板的访问器（Accessor）与拦截器（Interceptor） 144</span><br><span class="line">3.6.4 对象模板的内置字段（Internal Field） 175</span><br><span class="line">3.6.5 函数模板的继承（Inherit） 183</span><br><span class="line">3.6.6 小结 188</span><br><span class="line">3.6.7 参考资料 189</span><br><span class="line">3.7 常用数据类型 189</span><br><span class="line">3.7.1 基值（Value） 189</span><br><span class="line">3.7.2 字符串（String） 194</span><br><span class="line">3.7.3 数值类型 196</span><br><span class="line">3.7.4 布尔类型（Boolean） 196</span><br><span class="line">3.7.5 对象（Object） 196</span><br><span class="line">3.7.6 函数（Function） 200</span><br><span class="line">3.7.7 数组（Array） 202</span><br><span class="line">3.7.8 JSON 解析器 203</span><br><span class="line">3.7.9 函数回调信息（Function Callback Info） 203</span><br><span class="line">3.7.10 函数返回值（Return Value） 204</span><br><span class="line">3.7.11 隔离实例（Isolate） 204</span><br><span class="line">3.7.12 小结 205</span><br><span class="line">3.7.13 参考资料 206</span><br><span class="line">3.8 异常机制 206</span><br><span class="line">3.8.1 try-catch 206</span><br><span class="line">3.8.2 抛出异常 209</span><br><span class="line">3.8.3 异常生成类（Exception） 211</span><br><span class="line">3.8.4 小结 211</span><br><span class="line">3.8.5 参考资料 211</span><br><span class="line">4 C++ 扩展实战初探 212</span><br><span class="line">4.1 binding.gyp 212</span><br><span class="line">4.1.1 惊鸿一瞥 213</span><br><span class="line">4.1.2 binding.gyp 基础结构 213</span><br><span class="line">4.1.3 GYP 文件 214</span><br><span class="line">4.1.4 常用字段 221</span><br><span class="line">4.1.5 小结 228</span><br><span class="line">4.1.6 参考资料 228</span><br><span class="line">4.2 牛刀小试 229</span><br><span class="line">4.2.1 又是 Hello World 229</span><br><span class="line">4.2.2 函数参数 232</span><br><span class="line">4.2.3 回调函数 234</span><br><span class="line">4.2.4 函数返回 238</span><br><span class="line">4.2.5 小结 239</span><br><span class="line">4.2.6 参考资料 240</span><br><span class="line">4.3 循序渐进 240</span><br><span class="line">4.3.1 C++ 与 JavaScript 类封装 240</span><br><span class="line">4.3.2 实例化 C++ 类封装对象的函数 250</span><br><span class="line">4.3.3 将 C++ 类封装对象传来传去 253</span><br><span class="line">4.3.4 进程退出钩子 255</span><br><span class="line">4.3.5 小结 259</span><br><span class="line">4.3.6 参考资料 259</span><br><span class="line">5 Node.js 原生抽象——NAN 260</span><br><span class="line">5.1 Node.js 原生模块开发方式的变迁 260</span><br><span class="line">5.1.1 以不变应万变 260</span><br><span class="line">5.1.2 时代在召唤 261</span><br><span class="line">5.1.3 小结 267</span><br><span class="line">5.1.4 参考资料 267</span><br><span class="line">5.2 基础开发 267</span><br><span class="line">5.2.1 什么是 NAN 267</span><br><span class="line">5.2.2 安装和配置 269</span><br><span class="line">5.2.3 先睹为快——搭上NAN 的快车 270</span><br><span class="line">5.2.4 基础帮助函数和宏 276</span><br><span class="line">5.2.5 忽略 node_modules 279</span><br><span class="line">5.2.6 小结 279</span><br><span class="line">5.2.7 参考资料 280</span><br><span class="line">5.3 JavaScript 函数 280</span><br><span class="line">5.3.1 函数参数类型 280</span><br><span class="line">5.3.2 函数声明 282</span><br><span class="line">5.3.3 函数设置 288</span><br><span class="line">5.3.4 小结 296</span><br><span class="line">5.3.5 参考资料 296</span><br><span class="line">5.4 常用帮助类与函数 296</span><br><span class="line">5.4.1 句柄相关 296</span><br><span class="line">5.4.2 创建数据对象 298</span><br><span class="line">5.4.3 与数据对象“玩耍” 300</span><br><span class="line">5.4.4 封装一个类 314</span><br><span class="line">5.4.5 异常处理 315</span><br><span class="line">5.4.6 小结 315</span><br><span class="line">5.4.7 参考资料 316</span><br><span class="line">5.5 NAN 中的异步机制 316</span><br><span class="line">5.5.1 Nan::AsyncQueueWorker 316</span><br><span class="line">5.5.2 Nan::Callback 317</span><br><span class="line">5.5.3 Nan::AsyncWorker 317</span><br><span class="line">5.5.4 Nan::AsyncProgressWorker 323</span><br><span class="line">5.5.5 小结 327</span><br><span class="line">5.5.6 参考资料 327</span><br><span class="line">6 异步之旅——libuv 328</span><br><span class="line">6.1 基础概念 329</span><br><span class="line">6.1.1 事件循环 330</span><br><span class="line">6.1.2 句柄（Handle）与请求（Request） 333</span><br><span class="line">6.1.3 尝尝甜头 335</span><br><span class="line">6.1.4 小结 340</span><br><span class="line">6.1.5 参考资料 340</span><br><span class="line">6.2 libuv 的跨线程编程基础 341</span><br><span class="line">6.2.1 libuv 的线程 342</span><br><span class="line">6.2.2 同步原语（Synchronization Primitive） 347</span><br><span class="line">6.2.3 工作队列 355</span><br><span class="line">6.2.4 小结 356</span><br><span class="line">6.2.5 参考资料 357</span><br><span class="line">6.3 跨线程通信 357</span><br><span class="line">6.3.1 uv_async_t 句柄 357</span><br><span class="line">6.3.2 Watchdog 半成品实战解析 358</span><br><span class="line">6.3.3 Watchdog 试运行 367</span><br><span class="line">6.3.4 小结 368</span><br><span class="line">6.3.5 参考资料 369</span><br><span class="line">7 实战——文件监视器 370</span><br><span class="line">7.1 准备工作 370</span><br><span class="line">7.1.1 功能规划 370</span><br><span class="line">7.1.2 文件系统监听库——efsw 373</span><br><span class="line">7.1.3 小结 376</span><br><span class="line">7.1.4 参考资料 376</span><br><span class="line">7.2 核心设计 376</span><br><span class="line">7.2.1 API 设计 377</span><br><span class="line">7.2.2 EFSWCore 的血肉之躯 377</span><br><span class="line">7.2.3 EFSWCore 的灵魂 381</span><br><span class="line">7.2.4 小结 385</span><br><span class="line">7.3 编写JavaScript 类 386</span><br><span class="line">7.3.1 类的设计 386</span><br><span class="line">7.3.2 核心逻辑 388</span><br><span class="line">7.3.3 简单容错 391</span><br><span class="line">7.3.4 小结 393</span><br><span class="line">7.4 进一步完善 393</span><br><span class="line">7.4.1 C++ 代码的完善 393</span><br><span class="line">7.4.2 JavaScript 代码的完善 398</span><br><span class="line">7.4.3 小结 400</span><br><span class="line">8 实战——现有包剖析 401</span><br><span class="line">8.1 字符串哈希模块——Bling Hashes 401</span><br><span class="line">8.1.1 文件设定 402</span><br><span class="line">8.1.2 C++ 源码剖析 403</span><br><span class="line">8.1.3 JavaScript 源码剖析 408</span><br><span class="line">8.1.4 小结 409</span><br><span class="line">8.1.5 参考资料 410</span><br><span class="line">8.2 类 Proxy 包——Auto Object 410</span><br><span class="line">8.2.1 Proxy 410</span><br><span class="line">8.2.2 Auto Object 使用范例 412</span><br><span class="line">8.2.3 代码剖析 415</span><br><span class="line">8.2.4 小结 424</span><br><span class="line">8.2.5 参考资料 424</span><br><span class="line">9 N-API——下一代 Node.js C++ 扩展开发方式 425</span><br><span class="line">9.1 浅尝辄止 426</span><br><span class="line">9.1.1 实现一个 Echo 函数 426</span><br><span class="line">9.1.2 尝试运行 N-API 扩展 430</span><br><span class="line">9.1.3 向下兼容 431</span><br><span class="line">9.1.4 N-API Package——C++ 封装 433</span><br><span class="line">9.1.5 小结 433</span><br><span class="line">9.1.6 参考资料 433</span><br><span class="line">9.2 基本数据类型与错误处理 433</span><br><span class="line">9.2.1 基本数据类型 433</span><br><span class="line">9.2.2 与作用域及生命周期相关的数据类型 435</span><br><span class="line">9.2.3 回调数据类型 438</span><br><span class="line">9.2.4 错误处理 439</span><br><span class="line">9.2.5 模块注册 441</span><br><span class="line">9.2.6 小结 442</span><br><span class="line">9.2.7 参考资料 442</span><br><span class="line">9.3 对象与函数 442</span><br><span class="line">9.3.1 对象 442</span><br><span class="line">9.3.2 函数 448</span><br><span class="line">9.3.3 类的封装 453</span><br><span class="line">9.3.4 小结 455</span><br><span class="line">9.3.5 参考资料 455</span><br></pre></td></tr></table></figure><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><blockquote><p>This book contains absolutely everything you need to know about how all the pieces of Node.js’ C++ code work and interact, explaining the necessary concepts without needing prior knowledge about the internals of V8, libuv or other pieces of Node.js. It shows well how Node.js’ own built-in modules are constructed using the APIs provided by V8, so that they are usable from JavaScript, and how you can create the same kind of modules from scratch.</p><p>After having read this book, you will be able to write a production-quality, future-proof C++ extension for Node.js if you need to do that, or maybe even make changes Node.js itself if you’re interested in that!</p><p>这本书包含了所有你需要了解的有关于 Node.js C++ 代码是如何运行和交互的知识，解释了一些你不需要知道 V8 的内部机制就能理解的必要概念，另外该书还介绍了 libuv 以及其他一些内容的方方面面。这本书还展示了 Node.js 的内置模块是如何使用 V8 的 API 进行构建并在 JavaScript 层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。</p><p>读完这本书，你将学到如何写出产品级质量的、面向未来的 Node.js C++ 扩展。感兴趣的话，你甚至可以对 Node.js 自身进行修改！</p><p>——安娜·亨宁森（Anna Henningsen, addaleax），Node.js 技术指导委员会成员（Node.js TSC）</p></blockquote><hr><blockquote><p>Node.js 不是第一个将 JavaScript 带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于 Node.js 适逢后端高并发潮流，巧妙结合 Reactor 模型和 JavaScript 所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合 JavaScript 和前端工程师的一套生态和工具链，Node.js 刚好成为前端 JavaScript 最易上手掌握的命令行环境。在 Node.js 发展这么火热之后，Node.js 的开发体验在不断提升，上手门槛也在不断降低。</p><p>然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解 Node.js 的底层机制，去学习写一些 Node.js 的扩展。从 Node.js 的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。</p><p>死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用 C++ 写一个扩展很有意思也很简单。作为 Node.js 工程师/爱好者的你，值得拥有本书。</p><p>——曹力（ShiningRay），酷链科技 CEO，前暴走漫画 CTO，前糗事百科联合创始人，高级 Node.js 技术专家，《JavaScript 高级程序设计》译者</p></blockquote><hr><blockquote><p>Native module is one of the most underappreciated features of Node.js. But even in the age of asm.js and WebAssembly, it is an irreplaceable part of the Node.js ecosystem due to its versatility and performance. XadillaX’s book provides a refreshing introduction (or reintroduction), and is a must-read for all low-level Node.js engineers.</p><p>原生模块是 Node.js 中最被低估的功能之一。因为它的性能和多样性，使其即使是在 asm.js 和 WebAssembly 时代，仍旧能作为 Node.js 生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js 工程师必读之物。</p><p>——顾天骋（Timothy Gu），pug、ejs 前 Maintainer，Node.js Core Collaborator 之一</p></blockquote><hr><blockquote><p>本书全面讲解了 V8、libuv 的原理并且手把手教你编写一打 Node.js 的 C++ 扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解 Node.js 的实现原理，除了熟读内置 API 文档之外，阅读这本书会是一个很好的选择。</p><p>——雷宗民（老雷），《Node.js 实战》作者之一</p></blockquote><hr><blockquote><p>这是一本角度刁钻的 Node.js 相关书籍，与市面上大多数的 Node.js 书籍定位不同。它借为 Node.js 开发 C++ 扩展为基石，顺带介绍了 Chrome V8 和 libuv 的内容，填补了市场上这一类书籍的空白，值得一读。</p><p>——李启雷博士，趣链科技 CTO</p></blockquote><hr><blockquote><p>死月一直把实战贯穿在整本书之内，无论是基础部分的 V8 练习，还是使用 Node.js 经典的 Addon 开发、用 NAN 来改写，或是 libuv 里的 WatchDog 案例、EFSW 的封装，甚至在第八章里还特意剖析了两个 C++ 模块，把之前讲解的基础知识部分综合起来，可以边学边练。</p><p>这本《Node.js：来一打 C++ 扩展》，在如今追求大而全的时代，单纯的讲 Node.js 的某一个方面，而且讲的特别棒的书，真的难得。</p><p>——刘琥（响马），西祠胡同创始人，fibjs 作者</p></blockquote><hr><blockquote><p>当你掌握了 Node.js 的上层使用，下一步进阶的方向就是研究 Node.js 的底层原理。本书为学习 Node.js 的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（Handle Scope）等概念直接来自于源码，对于阅读 Node.js 及 V8 的源码具有极高的参考价值。</p><p>——潘旻琦（pmq20），Node.js 技术专家，Node.js Collaborator 之一，RubyConf 讲师之一</p></blockquote><hr><blockquote><p>国内 Node.js 偏向于原理的书目前只有朴灵的《深入浅出 Node.js》一本，至今 4 年过去了，Node.js 已经从 v0.10 发展到 v9 版本，中间再没有这样的系统的有深度的书籍。</p><p>很高兴死月的新书弥补了这一遗憾。本书以 C++ 为主线，涵盖 Node.js 最核心的 libuv 和 V8，对理解 Node.js 原理有极大的好处。当然最大的好处在于使用 C++ 编写 Node.js Addon 可以让 Node.js 有更广阔的应用空间。我们都知道 Node.js 擅长的是 I/O 密集型任务，对于 CPU 密集型运算这是极好的弥补。</p><p>特别推荐大家阅读此书，Node.js 应用极其广泛的今天，使用 C++ 编写 Node.js Addon 是更出彩的部分，你值得拥有。</p><p>——桑世龙（狼叔），StuQ 明星讲师，Node.js 技术布道者，《更了不起的 Node.js》作者</p></blockquote><hr><blockquote><p>死月对 Node.js 底层机制有非常深入的了解。阅读本书，除了学习 C++ 扩展开发，还会跟随死月了解 V8、libuv，相信读后大家对于 Node.js 的理解会更上一层楼。</p><p>——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长</p></blockquote><hr><blockquote><p>C++ 扩展其实是从外在，用 C++ 的角度去观察 Node.js 内在的形式。因为 Node.js 整个系统自身几乎就是构建在 C/C++ 之上的，只是内部称之为 built-in，在 user-land 则称之 Addon，它们本质上其实没有区别。死月凭借他在 C/C++ 的深厚积累，选择从 C++ 扩展作为突破口，带大家领略 Node.js 底层的风光，在书里，你能看到真正发挥巨大价值的 V8、libuv 亦是精彩纷呈。</p><p>死月将 C++ 扩展写得这么透，我是服的。</p><p>——田永强（朴灵），高级 Node.js 技术专家，《深入浅出 Node.js》作者</p></blockquote><hr><blockquote><p>开发 C++ 扩展，可以扩充 Node.js 平台的本地 API，扩充 Node.js 应用的能力。这本书详细介绍了包括 libuv、V8 在内的各种必要知识，是该领域不可多得的好书。对 C++ 开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。</p><p>——王文睿博士（Roger Wang），node-webkit 和 NW.js 项目创始人和维护者，因特尔软件架构师</p></blockquote><hr><blockquote><p>清晰记得手写的第一个 Node.js C++ 扩展模块，在 Node.js 0.6.9 跑通的那种愉悦感。随着应用升级到 Node.js 0.8，依赖的 C++ 扩展模块无法安装编译成功，最后发现是 V8 的 API 变化导致不兼容，从此对 C++ 扩展模块产生抗拒。后来看到《Node.js：来一打 C++ 扩展》，从实现原理，到 V8 基础概念的一系列介绍，让我重新对 C++ 扩展模块产生兴趣。参考书里的实战例子，以及 NAN 的辅助下，现在编写一个跨 Node.js 版本的 C++ 扩展已经不是什么困难的事情。通过最后一章节，可以了解到 Node.js 官方的 N-API 计划，让 C++ 扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。</p><p>——袁锋（fengmk2），Node.js 技术专家</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//dn-cnode.qbox.me/FggqZHIE8va72-RguIC8WKGgyzVn&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;千呼万唤始出来，犹抱琵琶生哪吒。&lt;/p&gt;
&lt;p&gt;真的不好意思自卖自夸，所以索性直接把编辑推荐语、
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="《Node.js：来一打 C++ 扩展》" scheme="https://xcoder.in/tags/%E3%80%8ANode-js%EF%BC%9A%E6%9D%A5%E4%B8%80%E6%89%93-C-%E6%89%A9%E5%B1%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>随机生成指定面积单连通区域</title>
    <link href="https://xcoder.in/2018/04/01/random-connected-area/"/>
    <id>https://xcoder.in/2018/04/01/random-connected-area/</id>
    <published>2018-04-01T09:14:45.000Z</published>
    <updated>2018-04-11T07:24:51.690Z</updated>
    
    <content type="html"><![CDATA[<p>最近在知乎上看到一个问题，「<a href="https://www.zhihu.com/question/269483551/answer/354477009" target="_blank" rel="external">随机生成指定面积单连通区域？</a>」，感觉还挺有意思的，于是整理一下写一篇新文章。</p><h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>如下图所示，在 10x10 的区域中，随机生成面积为 6 的单连通区域，该「随机」包括「位置随机」以及「形状随机」。</p><p><img src="example.jpg" alt="示意图"></p><p>注意：</p><ol><li>单连通区域定义是该区域每一个区块上下左右至少连着另一个区块；</li><li>采用周期性结构，超出右边移到最左边，以此类推。</li></ol><blockquote><p>其中点 2 可以分采用和不采用周期性结构分别讨论。</p></blockquote><h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><p>这个问题，我不知道原题提问者想要做什么事。但是就这题本身而言，我们可以拿它去生成一个随机地图，例如：</p><blockquote><p>建造、等待的沙盒类手游，游戏中有一个空岛，玩家能在上面建造自己的建筑然后等待各种事件完成。<strong>空岛形状随机生成，并且都联通且面积一定，这样每个玩家进去的时候就能得到不同地形</strong>。</p></blockquote><h2 id="解决一下"><a href="#解决一下" class="headerlink" title="解决一下"></a>解决一下</h2><p>在得知了问题原题之后，我们就可以照着题目的意思开始解决了。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>其实这么一个问题一出现，脑子里面就瞬间涌出几个词汇：<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="external">DFS</a>、<a href="https://en.wikipedia.org/wiki/Flood_fill" target="_blank" rel="external">Flood fill</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="external">并查集</a>等等。</p><p>那么其实这最粗暴的办法相当于你假想有一个连通区域，然后你去 Flood fill 它——至于墙在哪，在递归的每一个节点的时候<strong>随机一下搜索方向的顺序就可以了</strong>。</p><h4 id="实现外壳"><a href="#实现外壳" class="headerlink" title="实现外壳"></a>实现外壳</h4><p>我们先实现一个类的框架吧（我是 Node.js 开发者，自然用 JavaScript 进行 Demo 的输出）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT = <span class="built_in">Symbol</span>(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Filler 构造函数</span><br><span class="line">     * @constructor</span><br><span class="line">     * @param &#123;Number&#125; length 地图总宽高</span><br><span class="line">     * @param &#123;Number&#125; needArea 需要填充的区域面积</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(length, needArea) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.needArea = needArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 初始化地图</span><br><span class="line">     */</span></span><br><span class="line">    [INIT]() &#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 为了方便，地图就用一个二维字符数组表示</span><br><span class="line">         *</span><br><span class="line">         *   + . 代表空地</span><br><span class="line">         *   + x 代表填充</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">this</span>.map = [];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> row = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length; j++) row.push(<span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">this</span>.map.push(row);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span><br><span class="line">      * 填充递归函数</span><br><span class="line">      * @param &#123;Number&#125; x 坐标 X 轴的值</span><br><span class="line">      * @param &#123;Number&#125; y 坐标 Y 轴的值</span><br><span class="line">      * @return 填充好的地图二维数组</span><br><span class="line">      */</span></span><br><span class="line">     fill(x, y) &#123;</span><br><span class="line">        <span class="comment">// 待实现</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非周期性实现"><a href="#非周期性实现" class="headerlink" title="非周期性实现"></a>非周期性实现</h4><p>有了架子之后，我们就可以实现递归函数 <code>fill</code> 了，整理一下流程如下：</p><ol><li>随机一个起点位置，并以此开始递归搜索；</li><li><code>fill(x, y)</code> 进入递归搜索：<ol><li>如果需要初始化地图就调用 <code>this[INIT]()</code>；</li><li><code>this.count++</code>，表示填充区域面积加了 <code>1</code>，并在数组中将该位置填充为 <code>x</code>；</li><li><code>this.count</code> 是否等于所需要的面积：<ol><li>若等于，则返回当前的地图状态；</li><li>若不等于，则继续 2.4；</li></ol></li><li>随机四个方向的顺序；</li><li>对四个方向进行循环：<ol><li><code>x</code>、<code>y</code> 轴的值按当前方向走一个算出新的坐标值 <code>newX</code> 和 <code>newY</code>；</li><li>判断坐标是否合法（越界算非法）：<ol><li>若非法则回 2.5 继续下一个方向；</li><li>若合法则继续 2.5.3；</li></ol></li><li>递归 <code>fill(newX, newY)</code> 得到结果，若有结果则返回；</li></ol></li><li>若循环完四个方向都还没返回结果则会跳到这一步来，这个时候进行状态还原，递归跳回上一层进行下一个状态的搜索。</li></ol></li></ol><blockquote><p>在这里「状态还原」表示把 <code>this.count--</code> 还原回当前坐标填充前的状态，并且把当前填充的 <code>&#39;x&#39;</code> 给还原回 <code>&#39;.&#39;</code>。</p></blockquote><p>照着上面的流程很快就能得出代码结论：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">"lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    fill(x, y) &#123;</span><br><span class="line">        <span class="comment">// 初始化地图</span></span><br><span class="line">        <span class="keyword">const</span> needInit = !<span class="built_in">arguments</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(needInit) <span class="keyword">this</span>[INIT]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前坐标已被填充，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] === <span class="string">"x"</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充当前坐标</span></span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.map[x][y] = <span class="string">"x"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充满了则返回当前地图</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count === <span class="keyword">this</span>.needArea) <span class="keyword">return</span> <span class="built_in">Object</span>.assign([], <span class="keyword">this</span>.map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机四个方向的顺序</span></span><br><span class="line">        <span class="keyword">const</span> dirs = _.shuffle([ [ <span class="number">0</span>, <span class="number">1</span> ], [ <span class="number">0</span>, <span class="number">-1</span> ], [ <span class="number">1</span>, <span class="number">0</span> ], [ <span class="number">-1</span>, <span class="number">0</span> ] ]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环四个方向</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> dir = dirs[i];</span><br><span class="line">            <span class="keyword">let</span> newX = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> newY = y + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(newX &lt; <span class="number">0</span> || newX &gt;= <span class="keyword">this</span>.length || newY &lt; <span class="number">0</span> || newY &gt;= <span class="keyword">this</span>.length) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一层递归并得到结果</span></span><br><span class="line">            <span class="keyword">const</span> ret = <span class="keyword">this</span>.fill(newX, newY, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若结果非空则返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态还原</span></span><br><span class="line">        <span class="keyword">this</span>.count--;</span><br><span class="line">        <span class="keyword">this</span>.map[x][y] = <span class="string">"."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一来，类就写好了。接下去我们只要实现一些交互的代码，就可以看效果了。</p><blockquote><p><a href="https://jsfiddle.net/XadillaX/x2ur8kvj/" target="_blank" rel="external">点我</a>进入 JSFiddle 看效果。</p></blockquote><p>如果懒得进入 JSFiddle 看，也可以看看下面的几个截图：</p><p><img src="10x10-1.png" alt=""><br><small>10x10 填 50 效果图</small></p><p><img src="10x10-2.png" alt=""><br><small>10x10 填 6 效果图</small></p><p><img src="50x50-1.png" alt=""><br><small>50x50 填 50 效果图</small></p><h4 id="周期性实现"><a href="#周期性实现" class="headerlink" title="周期性实现"></a>周期性实现</h4><p>其实原题说了一个条件，那就是<strong>采用周期性结构，超出右边移到最左边，以此类推</strong>。</p><p>而我们前文的代码其实是照着非周期性结构来实现的。不过如果我们要将其改成周期性实现也很简单，只需要把前文代码中边界判断的那一句代码改为周期性计算的代码即可，也就是说要把这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断边界</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(newX &lt; <span class="number">0</span> || newX &gt;= <span class="keyword">this</span>.length || newY &lt; <span class="number">0</span> || newY &gt;= <span class="keyword">this</span>.length) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 周期性计算</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(newX &lt; <span class="number">0</span>) newX = <span class="keyword">this</span>.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newX &gt;= <span class="keyword">this</span>.length) newX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(newY &lt; <span class="number">0</span>) newY = <span class="keyword">this</span>.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newY &gt;= <span class="keyword">this</span>.length) newY = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候出来的效果就是这样的了：</p><p><img src="10x10-zqx-1.png" alt=""><br><small>10x10 填 50 周期性效果图</small></p><h4 id="抛弃状态还原"><a href="#抛弃状态还原" class="headerlink" title="抛弃状态还原"></a>抛弃状态还原</h4><p>至此为止 DFS 的代码基本上完成了。不过目前来说，当然这个算法的一个缺陷就是，当需要面积与总面积比例比较大的时候，有可能陷入搜索的死循环（或者说效率特别低），因为要不断复盘。</p><p>所以我们可以做点改造——由于我们不是真的为了搜索到某个状态，而只是为了填充我们的小点点，那么 DFS 中比较经典的「状态还原」就不需要了，也就是说：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.count--;</span><br><span class="line"><span class="keyword">this</span>.mat[x][y] = <span class="string">"."</span>;</span><br></pre></td></tr></table></figure><p>这两行代码可以删掉了，用删掉上面两行代码的代码跑一下，我用 50x50 填充 800 格子的效果：</p><table><thead><tr><th><img src="800-1.png" alt=""></th><th><img src="800-2.png" alt=""></th><th><img src="800-3.png" alt=""></th><th><img src="800-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>继续之前的 50x50 填充 50：</p><table><thead><tr><th><img src="50-1.png" alt=""></th><th><img src="50-2.png" alt=""></th><th><img src="50-3.png" alt=""></th><th><img src="50-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><h3 id="生成「胖胖的」区域"><a href="#生成「胖胖的」区域" class="headerlink" title="生成「胖胖的」区域"></a>生成「胖胖的」区域</h3><p>上面 DFS 的方法，由于每次都要走完一条路，虽然会转弯导致黏连，但在填充区域很小的情况下，很容易生成“瘦瘦的区域”。</p><p>这里再给出另一个方法，一个 <code>for</code> 搞定的，思路如下：</p><ol><li>先随机一个起始点，并将该点加入边界池；</li><li>循环 N - 1 次（N 为所需要填充的面积）：<ol><li>从边界池中随机取出一个边界；</li><li>算出与其接壤的四个点，取出还未被填充的点；</li><li>在取出的点中随机一个将其填充；</li><li>填充后计算改点接壤的四个点是否有全都是已经填充了的，若不是，则将该坐标加入边界池；</li><li>拿着刚才计算的接壤的四个点，分别判断其是否周边四个点都已被填充，若是且该点在边界池中，则从边界池拿走；</li><li>回到第二大步继续循环；</li></ol></li><li>返回填充好的结果。</li></ol><p>给出代码 Demo：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filler2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, needArea) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.needArea = needArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _getContiguous(frontier) &#123;</span><br><span class="line">        <span class="keyword">return</span> Filler2.DIRS.map(<span class="function"><span class="params">dir</span> =&gt;</span> (&#123;</span><br><span class="line">            <span class="attr">x</span>: frontier.x + dir[<span class="number">0</span>],</span><br><span class="line">            <span class="attr">y</span>: frontier.y + dir[<span class="number">1</span>]</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fill() &#123;</span><br><span class="line">        <span class="keyword">const</span> mat = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> row = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length; j++) row.push(<span class="string">"."</span>);</span><br><span class="line">            mat.push(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> start = &#123;</span><br><span class="line">            <span class="attr">x</span>: random(<span class="keyword">this</span>.length - <span class="number">1</span>),</span><br><span class="line">            <span class="attr">y</span>: random(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        mat[start.x][start.y] = <span class="string">"x"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> frontierCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> frontiers = &#123;</span><br><span class="line">            [<span class="string">`<span class="subst">$&#123;start.x&#125;</span>:<span class="subst">$&#123;start.y&#125;</span>`</span>]: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.needArea; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出一个边界</span></span><br><span class="line">            <span class="keyword">const</span> randIdx = random(frontierCount - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> frontier = <span class="built_in">Object</span>.keys(frontiers)[randIdx].split(<span class="string">":"</span>).map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// _getContiguous 算出接壤坐标，filter 去除无用坐标</span></span><br><span class="line">            <span class="keyword">const</span> newCoors = <span class="keyword">this</span>._getContiguous(&#123;</span><br><span class="line">                <span class="attr">x</span>: frontier[<span class="number">0</span>],</span><br><span class="line">                <span class="attr">y</span>: frontier[<span class="number">1</span>]</span><br><span class="line">            &#125;).filter(<span class="function"><span class="params">coor</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (coor.x &lt; <span class="number">0</span> || coor.y &lt; <span class="number">0</span> || coor.x &gt;= <span class="keyword">this</span>.length || coor.y &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mat[coor.x][coor.y] === <span class="string">"x"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 随机取一个坐标</span></span><br><span class="line">            <span class="keyword">const</span> newCoor = newCoors[random(<span class="number">0</span>, newCoors.length - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充进去</span></span><br><span class="line">            mat[newCoor.x][newCoor.y] = <span class="string">"x"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取接壤坐标</span></span><br><span class="line">            <span class="keyword">const</span> contiguousOfNewCoor = <span class="keyword">this</span>._getContiguous(newCoor).filter(<span class="function"><span class="params">coor</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (coor.x &lt; <span class="number">0</span> || coor.y &lt; <span class="number">0</span> || coor.x &gt;= <span class="keyword">this</span>.length || coor.y &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若有一个接壤点为空，就认为当前坐标是边界，若是边界则把当前坐标加入对象</span></span><br><span class="line">            <span class="keyword">if</span> (contiguousOfNewCoor.reduce(<span class="function">(<span class="params">ret, coor</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mat[coor.x][coor.y] === <span class="string">"x"</span>) <span class="keyword">return</span> ret;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;, <span class="literal">false</span>)) &#123;</span><br><span class="line">                frontiers[<span class="string">`<span class="subst">$&#123;newCoor.x&#125;</span>:<span class="subst">$&#123;newCoor.y&#125;</span>`</span>] = <span class="literal">true</span>;</span><br><span class="line">                frontierCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再检查接壤的坐标是否继续为边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contiguousOfNewCoor.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> cur = contiguousOfNewCoor[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> isFrontier = <span class="keyword">this</span>._getContiguous(cur).filter(<span class="function"><span class="params">coor</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (coor.x &lt; <span class="number">0</span> || coor.y &lt; <span class="number">0</span> || coor.x &gt;= <span class="keyword">this</span>.length || coor.y &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;).reduce(<span class="function">(<span class="params">ret, coor</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mat[coor.x][coor.y] === <span class="string">"x"</span>) <span class="keyword">return</span> ret;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若不是边界的话，只管删除</span></span><br><span class="line">                <span class="keyword">if</span> (!isFrontier &amp;&amp; frontiers[<span class="string">`<span class="subst">$&#123;cur.x&#125;</span>:<span class="subst">$&#123;cur.y&#125;</span>`</span>]) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> frontiers[<span class="string">`<span class="subst">$&#123;cur.x&#125;</span>:<span class="subst">$&#123;cur.y&#125;</span>`</span>];</span><br><span class="line">                    frontierCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一圈下来，就出结果了</span></span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Filler2.DIRS = [ [ <span class="number">0</span>, <span class="number">1</span> ], [ <span class="number">0</span>, <span class="number">-1</span> ], [ <span class="number">1</span>, <span class="number">0</span> ], [ <span class="number">-1</span>, <span class="number">0</span> ] ];</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>上面的代码是我一溜烟写出来的，所以并没有后续优化代码简洁度，其实很多地方的代码可以抽象并复用的，懒得改了，能看就好了。用的时候就跟之前 DFS 代码一样 <code>new</code> 一个 <code>Filler2</code> 出来并 <code>fill</code> 就好了。</p><p>效果依然可以去 <a href="https://jsfiddle.net/XadillaX/36f6obca/" target="_blank" rel="external">JSFiddle</a> 看。</p></blockquote><p>或者也可以直接看效果图：</p><table><thead><tr><th><img src="fat-800-1.png" alt=""></th><th><img src="fat-800-2.png" alt=""></th><th><img src="fat-800-3.png" alt=""></th><th><img src="fat-800-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 800 胖胖的区域</small></center><table><thead><tr><th><img src="fat-50-1.png" alt=""></th><th><img src="fat-50-2.png" alt=""></th><th><img src="fat-50-3.png" alt=""></th><th><img src="fat-50-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 50 胖胖的区域</small></center><p>显而易见，跟之前 DFS 生成出来的奇形怪状相比，这种算法生成的连通区域更像是一块 Mainland，而前者则更像是一个洼地沼泽或者丛林。</p><h3 id="结合一下？"><a href="#结合一下？" class="headerlink" title="结合一下？"></a>结合一下？</h3><p>前面两种算法，一个是生成瘦瘦的稀奇古怪的面积，一个是生成胖胖的区域。有没有办法说在生成胖胖的区域的情况下允许一定的稀奇古怪的形状呢？</p><p>其实将两种算法结合一下就好了。结合的做法有很多，这里举一个例子，大家可以自己再去想一些出来。</p><ol><li>首先将需要的区域对半分（即配比 1 : 1），例如如果需要 800，就分为 400 跟 400。（为了长得好看，其实这个比例可以自行调配）</li><li>将前一半的区域用 <code>for</code> 生成胖胖的区域；</li><li>将剩下的区域随机几次，每次随机一个剩下所需要的面积以内的数，将这个数字作为 DFS 所需要生成的面积量，并从边界数组中随机取一个边界坐标并计算其合法接壤坐标开始进行 DFS 得到结果；</li><li>循环第 3 步知道所需区域面积符合要求为止。</li></ol><blockquote><p><strong>注意：</strong>为了保证每次 DFS 一开始的时候都能取到最新的边界坐标，在 DFS 流程中的时候每标一个区域填充也必须走一遍边界坐标更新的逻辑。</p></blockquote><p>具体代码就不放文章里面解析了，大家也可以到 <a href="https://jsfiddle.net/XadillaX/0bnzpw8d/" target="_blank" rel="external">JSFiddle</a> 中去观看。</p><p>或者也可以直接看效果图：</p><table><thead><tr><th><img src="mix-800-1.png" alt=""></th><th><img src="mix-800-2.png" alt=""></th><th><img src="mix-800-3.png" alt=""></th><th><img src="mix-800-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 800 混合区域（配比 3 : 1）</small></center><table><thead><tr><th><img src="mix-50-1.png" alt=""></th><th><img src="mix-50-2.png" alt=""></th><th><img src="mix-50-3.png" alt=""></th><th><img src="mix-50-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 50 胖胖的区域（配比 4 : 1）</small></center><h3 id="还能更丧心病狂吗？"><a href="#还能更丧心病狂吗？" class="headerlink" title="还能更丧心病狂吗？"></a>还能更丧心病狂吗？</h3><p>结合了两种算法，我们得到了一个我认为可能会更好看一点的区域。</p><p>此外，我们还能继续「丧心病狂」一点，例如两种方式交替出现，流程如下：</p><ol><li>指定特定方法和面积，奇数次用 <code>for</code>，偶数次用 DFS；<ol><li>如果是 <code>for</code> 则随机一个 <code>Math.min(剩余面积, 总面积 / 4)</code> 的数字；</li><li>如果是 DFS 则随机一个 <code>Math.min(剩余面积, 总面积 / 10)</code> 的数字；</li></ol></li><li>从边界数组中取一个坐标，并从合法接壤坐标中取一个坐标出来；</li><li>以第 2 步取出的坐标为起点，使用第 1 步指定的方法生成第 1 步指定的面积的单连通区域；</li><li>如果生成面积仍小于指定面积，则回到第 1 步继续循环，否则返回当前结果。</li></ol><p>依旧是给出 <a href="https://jsfiddle.net/XadillaX/5rx7vdzL/" target="_blank" rel="external">JSFiddle 的预览</a>。</p><p>或者也可以直接看效果图：</p><table><thead><tr><th><img src="frenzied-800-1.png" alt=""></th><th><img src="frenzied-800-2.png" alt=""></th><th><img src="frenzied-800-3.png" alt=""></th><th><img src="frenzied-800-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 800 丧病区域</small></center><table><thead><tr><th><img src="frenzied-50-1.png" alt=""></th><th><img src="frenzied-50-2.png" alt=""></th><th><img src="frenzied-50-3.png" alt=""></th><th><img src="frenzied-50-4.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><center><small>50x50 填充 800 丧病区域</small></center><blockquote><p><strong>注意：</strong>这里只给出思路，具体配比和详细流程大家可以继续优化。</p></blockquote><h2 id="几张效果对比图"><a href="#几张效果对比图" class="headerlink" title="几张效果对比图"></a>几张效果对比图</h2><p>最后，这里给出几张 10x10 填 50 的效果图放一起对比一下。</p><table><thead><tr><th><img src="f-50-dfs.png" alt=""></th><th><img src="f-50-cycle.png" alt=""></th><th><img src="f-50-dfs-without-back.png" alt=""></th><th><img src="f-50-cycle-without-back.png" alt=""></th><th><img src="f-50-fat.png" alt=""></th><th><img src="f-50-mix.png" alt=""></th><th><img src="f-50-frenzied.png" alt=""></th></tr></thead><tbody><tr><td><center><small>DFS</small></center></td><td><center><small>周期性 DFS</small></center></td><td><center><small>非还原 DFS</small></center></td><td><center><small>非还原周期性 DFS</small></center></td><td><center><small>胖胖的</small></center></td><td><center><small>结合</small></center></td><td><center><small>更丧病</small></center></td></tr></tbody></table><p>以及，几张 50x50 填充 800 面积的效果图对比。</p><table><thead><tr><th><img src="too-slow.png" alt=""></th><th><img src="too-slow.png" alt=""></th><th><img src="f-800-dfs-without-back.png" alt=""></th><th><img src="f-800-cycle-without-back.png" alt=""></th><th><img src="f-800-fat.png" alt=""></th><th><img src="f-800-mix.png" alt=""></th><th><img src="f-800-frenzied.png" alt=""></th></tr></thead><tbody><tr><td><center><small>DFS</small></center></td><td><center><small>周期性 DFS</small></center></td><td><center><small>非还原 DFS</small></center></td><td><center><small>非还原周期性 DFS</small></center></td><td><center><small>胖胖的</small></center></td><td><center><small>结合</small></center></td><td><center><small>更丧病</small></center></td></tr></tbody></table><h2 id="我错了之『真·单连通区域』"><a href="#我错了之『真·单连通区域』" class="headerlink" title="我错了之『真·单连通区域』"></a>我错了之『真·单连通区域』</h2><p><strong>之所以多出一节来，是因为我在写回答以及这篇文章的时候脑抽了一下，迷迷糊糊想成了连通区域，感谢评论区童鞋的提醒。实际上单连通区域要稍微复杂一些。</strong></p><blockquote><p>在拓扑学中，单连通是拓扑空间的一种性质。直观地说，单连通空间中所有闭曲线都能连续地搜索至一点。此性质可以由空间的基本群刻画。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Runge_theorem.svg/440px-Runge_theorem.svg.png" alt="连通区域"></p><center><small>这个空间不是单连通的，它有三个洞</small></center><p>——<a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E9%80%A3%E9%80%9A" target="_blank" rel="external">单连通@Wikipedia</a></p></blockquote><p><strong>对于非周期性的区域来说</strong>，生成一个单连通区域只要在上面的方法里面加点料就可以了。即在一个位置填充的时候，判断一下将它填充进去之后是否会出现所谓的「洞」。而这一点在非周期性区域中，由于在填充当前坐标前，已存在的区域已经是一个单连通区域，所以枚举一下几种情况即可排除非单连通区域的情况：</p><ol><li>新加的坐标其上下都有填充，但其左右为空；或者左右都有填充，但其上下为空；</li><li>新加的坐标只有一面相邻有填充，但该面对面的边所对应的两个角对过去至少有一个角与其它坐标共享顶点；</li><li>新加的坐标同一个顶点的两条边有接壤，且其对角顶点对过去的坐标与其共享顶点。</li></ol><blockquote><p>而对于周期性的区域来说，暂时我还没想到很好的办法。</p></blockquote><p>对于情况一而言，如果处于对面的两接壤坐标都有填充，且再多一个接壤面的话，原小区域内只有可能是「<strong>匚</strong>」型，那么填充进去只会形成一个 2x3 的实心区域，而如果只有处于对面的两个接壤坐标有填充的话，说明原小区域有两个面对面隔空的区域，它们形成单连通区域的大前提就是从其它地方绕出去将它们连起来，若这个时候将它们闭合的话，势必会形成一个空洞，如下图所示：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq7nxajherj306c05s75s" alt="情况一"></p><p>对于情况二而言，如果只有一面有填充，但是对面的顶点有共享的话，可以类比为情况一，举例如下：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq7nzv46v1j305w075dhp" alt="情况二"></p><p>对于情况三而言，其实就是情况二加一条边有填充，如果在情况二的情况下，在上图“原”的区域下方的空若已有填充，那么在“新”的位置填充进去，就形不成空洞了。毕竟如果“空”的位置已有填充的话，若先前状态生成没有洞的连通区域，则“空”下方也必定不是一个空洞的区域。</p><p>在解析完三种情况后，算法就明朗起来——在上面的 DFS 算法每次执行填充操作的时候，都判断一下当前填充是否符合刚才列举的三种情况，若符合，则不填充该点。</p><p>所以只需对 DFS 的那个代码做一下修改就好了，首先把状态还原两行代码删掉，然后在之前</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= <span class="keyword">this</span>.length || newY &lt; <span class="number">0</span> || newY &gt;= <span class="keyword">this</span>.length) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这句代码之下加一个条件判断就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.willBreak(newX, newY)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是去实现 <code>this.willBreak()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    willBreak(x, y) &#123;</span><br><span class="line">        <span class="comment">// 九宫格除自己以外的其它格状态</span></span><br><span class="line">        <span class="keyword">let</span> u = <span class="literal">false</span>, d = <span class="literal">false</span>, l = <span class="literal">false</span>, r = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> lu = <span class="literal">false</span>, ld = <span class="literal">false</span>, ru = <span class="literal">false</span>, rd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[x - <span class="number">1</span>][y] === <span class="string">'x'</span>) u = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; <span class="keyword">this</span>.map[x + <span class="number">1</span>][y] === <span class="string">'x'</span>) d = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[x][y - <span class="number">1</span>] === <span class="string">'x'</span>) l = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; <span class="keyword">this</span>.map[x][y + <span class="number">1</span>] === <span class="string">'x'</span>) r = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[x - <span class="number">1</span>][y - <span class="number">1</span>] === <span class="string">'x'</span>) lu = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; y + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; <span class="keyword">this</span>.map[x - <span class="number">1</span>][y + <span class="number">1</span>] === <span class="string">'x'</span>) ru = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[x + <span class="number">1</span>][y - <span class="number">1</span>] === <span class="string">'x'</span>) ld = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; y + <span class="number">1</span> &lt; <span class="keyword">this</span>.length &amp;&amp; <span class="keyword">this</span>.map[x + <span class="number">1</span>][y + <span class="number">1</span>] === <span class="string">'x'</span>) rd = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 1</span></span><br><span class="line">        <span class="keyword">if</span>((l &amp; r) ^ (u &amp; d)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 2</span></span><br><span class="line">        <span class="keyword">if</span>(l + r + u + d === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l &amp;&amp; (ru || rd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &amp;&amp; (lu || ld)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(u &amp;&amp; (ld || rd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(d &amp;&amp; (lu || ru)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 3</span></span><br><span class="line">        <span class="keyword">if</span>(l + r + u + d === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况 1 已经被 return 了，所以相加为 2 的肯定是共享顶点</span></span><br><span class="line">            <span class="keyword">if</span>(l &amp;&amp; u &amp;&amp; rd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &amp;&amp; d &amp;&amp; ru) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &amp;&amp; u &amp;&amp; ld) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &amp;&amp; d &amp;&amp; lu) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进 <a href="https://jsfiddle.net/XadillaX/yxjmdvh7/" target="_blank" rel="external">JSFiddle</a> 看完整代码。</p></blockquote><p>然后是 50x50 填充 800 的效果：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq7oygxbowj30m80m80ul" alt=""></p><p>以及 10x10 填充 50：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq7ozzqqhhj304g04gt8j" alt=""></p><blockquote><p><strong>注意：</strong>左下角的洞看起来是洞，实际上是处于边界了，而填充区域无法与边界合成闭合区域，实际上将地图往外想想空一格就可以知道它并不是一个洞了。当然如果读者执意不允许这种情况发生，那么只需要在 <code>willBreak()</code> 函数判断的时候做点手脚就可以了，至于怎么做手脚大家自己想吧。</p></blockquote><p>这种情况生成的地图比较像迷宫，哪怕是针对「胖胖的区域」做这个改进，<a href="https://jsfiddle.net/XadillaX/qswaevtL/" target="_blank" rel="external">JSFiddle</a> 出来的也是下面的效果：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq7rudhiixj30m80m8wfy" alt=""></p><p>所以呢，继续优化——我们知道有三种情况是会生成非单连通区域的，所以当我们探测到这种情况的时候，去 BFS 它内外区域，看看究竟是哪个区域被封闭出一个空洞来，探测出来之后再看看我们目前还需要填充的区域面积跟这个空洞的面积是否够用，若够用则将空洞补起来，不够用则当前一步重新来过——即再随机一个坐标看看行不行。</p><p>思想说出来了，具体的实现还是看看我写在 <a href="https://jsfiddle.net/XadillaX/2mkce52a/" target="_blank" rel="external">JSFiddle</a> 里面的代码吧。</p><p>50x50 填充 800 的效果如下：</p><p><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq8lhurxufj30m80m8jsj" alt=""></p><p>这么一来，我们很容易能跟 DFS 的算法结合起来，即之前说过的更丧病的算法。结合方法很简单，分别把改进过的 DFS 和胖胖区域的算法一起融合进之前丧病算法的代码中就好了。老样子我还是把代码更新到了 <a href="https://jsfiddle.net/XadillaX/5rx7vdzL/" target="_blank" rel="external">JSFiddle</a> 里面。大家看看 50x50 填充 800 的效果吧： </p><table><thead><tr><th style="text-align:center"><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq8qtl7yapj30m80m875m" alt=""></th><th style="text-align:center"><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq8nlpp42kj30m80m875i" alt=""></th><th style="text-align:center"><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq8nlrfbgpj30m80m8t9u" alt=""></th><th style="text-align:center"><img src="http://ww2.sinaimg.cn/large/005zWjpngy1fq8nltk6ycj30m80m8wfo" alt=""></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>最后，由于一开始文章写的概念性错误给大家带来的不变表示非常抱歉，好在最后我还是补全了一下文章。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要还是讲了，如何随机生成一个指定面积的单连通区域。从一开始拍脑袋就能想到 DFS 开始，延伸到胖胖的区域，然后从个人认为「图不好看」开始，想办法如何结合一下两种算法使其变得更自然。</p><p>针对同一件事的算法们并非一成不变或者不可结合的。不是说该 DFS 就只能 DFS，该 <code>for</code> 就只能 <code>for</code>，稍微结合一下也许食用效果更佳哦。</p><p>哦对了，在这之前还有一个例子就是我在三年多前写的主题色提取的文章《<a href="https://xcoder.in/2014/09/17/theme-color-extract/#%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">图片主题色提取算法小结</a>》，其中就讲到我最后的方法就是结合了八叉树算法和最小差值法，使其在提取比较贴近的颜色同时又能够规范化提取出来的颜色。</p><p>总之就是多想想，与诸君共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在知乎上看到一个问题，「&lt;a href=&quot;https://www.zhihu.com/question/269483551/answer/354477009&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机生成指定面积单连通区域？&lt;/a&gt;」，感觉还挺
      
    
    </summary>
    
      <category term="算法" scheme="https://xcoder.in/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://xcoder.in/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="https://xcoder.in/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>死月的二零一七总结</title>
    <link href="https://xcoder.in/2017/12/31/my-2017/"/>
    <id>https://xcoder.in/2017/12/31/my-2017/</id>
    <published>2017-12-31T11:25:47.000Z</published>
    <updated>2017-12-30T01:42:21.457Z</updated>
    
    <content type="html"><![CDATA[<p>是时候总结一发了，今年经历了职场的几番大变动吧，总之比较坎坷。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h3><ul><li>塞班岛</li><li>杭州·极地海洋世界</li><li>上海·天猫 88 会员节演唱会</li><li>上海·沪 JSConf</li><li>上海 QCon</li><li>台州·周杰伦演唱会</li></ul><p>今年的足迹并没有去年多，大多都是杭州周边随便游玩，没有什么特别的地方。值得一提的是以度假的形式终于出境游了一次，以后也能说是去过美帝的人了。其次就是参加了两场演唱会，其中终于是还了欠了十五六年的两张周董的演唱会门票。</p><p>周末么大多都是在商圈逛，感觉去最多的就是西溪印象城了，同以往一样，依旧抓了好多娃娃。平均每次去不抓个十几只就不收手的感觉。最近西溪银泰城也开了，也去抓了一次，感觉手感依旧。</p><p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fn0e8koraij21400u01di" alt="抓娃娃"></p><p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fn0ecwdhfoj20qo0zkton" alt="抓娃娃"></p><p><strong>这次的沪 JSConf 是一个契机，促成了我为了去 <a href="https://github.com/nodejs/code-and-learn/issues/68" target="_blank" rel="external">Code + Learn Workshop</a> 而刷 <a href="https://github.com/nodejs/node/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+author%3AXadillaX+" target="_blank" rel="external">PR</a>，从而成为了 <a href="https://github.com/nodejs/node/pull/14388" target="_blank" rel="external">Node.js Collaborator</a> 这件事。</strong></p><p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fn0emjtokcj20go0m8q3t" alt="JSConf"></p><center><small>图为 JSConf Code+Learn Workshop 与一群大佬的合影</small></center><p>还有一件感觉特对不起老东家的一件事，就是公费参加 QCon 没多久，我就离职了，至今觉得愧疚。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>入了人生中的第一辆车，我的宋，并为它摇到了人生中的第一个号；</li><li>薅了「分期乐」一把羊毛，以 3999 人民币入了宾得 KP；</li><li>开始跟风玩农药，并曾上到星耀；</li><li>又通关几款 PS4 游戏，其中我通的是大鹫；</li><li>练了一段时间的字，直到入职蚂蚁金服为止；</li><li>双十一被入了一架电钢，目前为止学会了小星星和天空之城；</li><li>拍了婚纱；</li><li>开始挑家具和定制家具，预计 2018 年 1 月或者 2 月交房。</li></ul><p>买车是去年年终总结时候对于今年的一个 TODO 项，结果还真做了；农药主要还是在跟前同事在玩，当时疯狂到基本上中午都要结队出去吃饭，然后在饭桌上都要开个一两局；而练字基本上就是吃完饭后的午休时间随便写几下的——没有午睡习惯的我；Pentax 是一个偶然机会发现分期乐上面可以薅，于是有了二话不说下单的一幕，最终在快递被召回之前开车赶往快递站勇夺快递——真市井；双十一的时候纠结了好久是要买吉他还是买电钢，最终媳妇还是选择了电钢，然后就偶尔下班回家学一会儿——由于没有老师只能自己野路子乱学；</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年的工作比较坎坷。</p><h3 id="大搜车"><a href="#大搜车" class="headerlink" title="大搜车"></a>大搜车</h3><p>年初的时候大搜车的研发发生了比较大的一个组织架构调整。空降而来的怀叔重整了研发部门，车牛业务交出，Node.js 团队开始做 BFF 的基础建设。</p><p>很高兴怀叔和头哥信任我，将 Node.js 团队交给我来带，如果没在将近年底的时候离职，我现在也是一个 9 人团队的负责人了。</p><p>在组织架构调整后，团队开始了一轮新的定位摸索，我们先后推出、负责、整理了一些项目，如大搜车的网关，这是一个基于 OpenResty + Node.js 进行开发的<strong>动态网关</strong>系统，被我命名为帕秋丽（Patchouli）。</p><p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fn0fp64i7cj20zk0qowpe" alt="Patchouli"></p><center><small>Patchouli 一开始讨论的时候在白板上留下的笔迹</small></center><p>现在已经在公司几个比较大流量的项目中应用起来了，也算是我留给公司的一份礼物吧——非常感谢小伙伴们一起努力把它最终给造了出来。Patchouli 的项目介绍和简单的技术分享我曾在沪 JSConf 的 After Party 中分享过，可以参考一下我在知乎上的回答「<a href="https://www.zhihu.com/question/62154473/answer/200104919" target="_blank" rel="external">参加 JSConf CN 2017 是个什么样的体验？</a>」。</p><p>另一个在公司中比较重要的项目就是新版的<strong>开放平台</strong>，分为对内的开放平台（Izayoi-Coffee）和对外的开放平台（Izayoi-Darts）。该项目是在公司宣布将要平台化的时候立项进行的，主要作为 API Hub 对内对外进行接洽，例如与各资金方、银行进行对接等。</p><p>感觉在进行这些开发的时候，也开始履行了去年总结时候的一句话——<strong>不再像以前一样只无脑关心技术本身，而是更多地去思考技术之外的事，对待旧的代码更宽容了</strong>。</p><p>剩下的就是继续迭代我以前负责和主导的一些项目，如短链接平台（Hata no Kokoro）、计算密集型任务集中处理系统（Youmu）和大搜车商学院（Yuuka）等。</p><p>本来坐拥十人左右的小团队，加上能主导整个团队的技术方向，十分开心。但是在年底的时候，还是决定再出去看一看——并不是因为大搜车不好，毕竟我在它最困难的 2015 年底 2016 年初都没有走，相反我认为它离上市已经不远了，我只不过是觉得年轻，有机会还是得尝试下。大家若是对大搜车有什么兴趣的话，也可以找我私聊。</p><p>最后在这里非常感谢大搜车的小伙伴们一年来的陪伴，有你们才有团队今天做到的成绩。</p><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><p>记得是八九月份的时候苏千来找的我，他挥动了他的小锄头跟我说有 HC 了，可以去试试看。我抱着去试试看的心理——反正面了也不亏，经过了几个月的心理挣扎，于今年 11 月 13 日正式入职蚂蚁，告别了伴我成长两年的大搜车。</p><p>进来之后其实感觉还是比较迷的，前驱体系太庞大了，现在还处于摸索阶段。总之我进来之后是做 Node.js 基础中间件和基础平台相关的一些事。</p><p>由于入职的时间不是很长，所以也没有太多的东西可以总结。总之在新的环境中遇到了很多大佬，包括团队中的小伙伴们也都是各种大佬——反而我是团队中最水的，这也是我从大搜车离职的原因之一，毕竟目前为止在那边我是我们团队的天花板了。</p><h2 id="技术-amp-社区"><a href="#技术-amp-社区" class="headerlink" title="技术 &amp; 社区"></a>技术 &amp; 社区</h2><ul><li>成为 Node.js Collaborator；</li><li>与头哥一起举办了几场 <a href="https://github.com/hangzhou-node-party" target="_blank" rel="external">Hangzhou Node Party</a>；</li><li>主办了一场 <a href="http://www.huodongxing.com/event/6415208651800" target="_blank" rel="external">Hangzhou OpenResty Meetup</a>（<a href="http://www.itdks.com/eventlist/detail/1767" target="_blank" rel="external">视频回放</a>）；</li><li>去上海参加了沪 JSConf 2017、QCon 上海；</li><li>写了一本书《Node.js：来一打 C++ 扩展》；</li><li>成为阿里云 MVP；</li><li>开了两场知乎 Live；</li><li>开了两场 GitChat；</li><li>客串了一场 Girls Coding Day 教练；</li><li>贡献了多个开源项目。</li></ul><h3 id="Node-js-Core-Collaborator"><a href="#Node-js-Core-Collaborator" class="headerlink" title="Node.js Core Collaborator"></a>Node.js Core Collaborator</h3><p>今年在成长方面也发生了挺多事。正如上面说的，曾经都已经开始带领九人小团队了。除了负责公司的几个项目架构之外，转折点还是在于沪 JSConf。</p><p>怎么说呢，就是一开始只是为了成为沪 JSConf 的 Code+Learn Workshop Mentor，开始刷各种 Node.js 的陈年老 Bug。最后无心插柳柳成荫，成为 Node.js Core Collaborator 之一，算是本年度最值得吹逼的事情了吧。</p><p>也正是这个事情，让我有动力去深入解读和剖析 Node.js 源码，以了解更底层相关的东西。</p><h3 id="阿里云-MVP"><a href="#阿里云-MVP" class="headerlink" title="阿里云 MVP"></a>阿里云 MVP</h3><p>其余的，就是参加了几场圈子里面的会议，面了个基。还有一件觉得挺对不起五花肉的事的，那个时候我成为了她负责的阿里云 MVP，并且去分享了一场关于阿里云 ONS（现 MQ）Node.js SDK 的 <a href="http://www.itdks.com/eventlist/detail/1283" target="_blank" rel="external">Topic</a>，但是最终由于我入职了蚂蚁金服，从而无法再继续以阿里云 MVP 的身份活跃在社区了，算是辜负了一番她当时做的工作。</p><h3 id="Hangzhou-Node-Party"><a href="#Hangzhou-Node-Party" class="headerlink" title="Hangzhou Node Party"></a>Hangzhou Node Party</h3><p>与头哥一起举办了几场 Node Party，其中认识了好多杭州 Node.js 圈子里面的大佬，以及杭州周边的大佬们——包括贺老也来参加了几次。头哥还搞了一个 Node Open-Source Foundation，募集了有小几万吧，用于每次 Node Party 的开销，包括非杭州讲师的食宿等等。</p><h3 id="Hangzhou-OpenResty-Meetup"><a href="#Hangzhou-OpenResty-Meetup" class="headerlink" title="Hangzhou OpenResty Meetup"></a>Hangzhou OpenResty Meetup</h3><p>在将近年底的时候，偶然一次机会看到了一场 <a href="http://www.itdks.com/dakashuo/play/6001" target="_blank" rel="external">OpenResty Con 2017</a>。由于我今年的网关就是基于 OpenResty + Node.js 完成的，心血来潮召集了学长学弟（都是又拍云的中流砥柱）主办了一趴 Hangzhou OpenResty Meetup，还请了女装大佬闪总过来帮忙主持，本来《OpenResty &amp; Node.js 开发网关》这个 Topic 是由我提供的，不过由于最终的开办日期是在我离职后，所以不方便继续提供，转而由我在大搜车的小伙伴 <a href="https://github.com/duanpengfei" target="_blank" rel="external">@duanpengfei</a> 呈现，而我从台前走到了幕后。</p><h3 id="Girls-Coding-Day"><a href="#Girls-Coding-Day" class="headerlink" title="Girls Coding Day"></a>Girls Coding Day</h3><p>在此之前，我也应闪总之邀，去参加了一次 <a href="https://girlscodingday.org/" target="_blank" rel="external">Girls Coding Day</a>，客串了一次教练。</p><blockquote><p>Girls Coding Day 是由社会企业 Coding Girls Club 联合众多性别友好的公司和程序员为促进性别平等而举办的公益编程工作坊。</p></blockquote><h3 id="几场付费知识分享"><a href="#几场付费知识分享" class="headerlink" title="几场付费知识分享"></a>几场付费知识分享</h3><p>去年这种形式的知识分享非常火热，我也开了几场，分别在知乎和 GitChat。</p><ul><li>知乎<ul><li>「<a href="https://www.zhihu.com/lives/842742839304667136" target="_blank" rel="external">深入了解 Node.js 包与模块机制</a>」</li><li>「<a href="https://www.zhihu.com/lives/907210790807949312" target="_blank" rel="external">当我们在学 Node.js 时，我们在学什么？</a>」</li></ul></li><li>GitChat<ul><li>《<a href="http://gitbook.cn/gitchat/activity/593763494ec5fa29296acea0" target="_blank" rel="external">从暴力到 NAN 到 NAPI——Node.js 原生模块开发方式变迁</a>》</li></ul></li></ul><h3 id="写书"><a href="#写书" class="headerlink" title="写书"></a>写书</h3><p>这件事是 2016 年年终总结时候留下的一个新年愿望，居然真的达成了。</p><p>由于市面上 Node.js 相关的书已经够多了，而且这个 Runtime 本身也没有什么太多很深的东西，所以我最后找了一个比较刁钻的角度开始写。</p><p>这里要感谢头哥帮我牵头博文视点的编辑，让我有机会能与出版社接触。书大概从 2 月份开始写，为时半年，终于在 8 月份将书稿交予出版社。截止写总结的目前，出版社第一次排版结束，我跟编辑一起做一次审校。</p><p>哦，对了，书名是《Node.js：来一打 C++ 扩展》。</p><blockquote><p>Node.js作为近几年新兴的一门编程运行时，托V8引擎的福，在作为后端服务时有比较高的运行效率，很多场景下在我们日常开发的时候足够用了。不过，它还为开发者开了个使用C++开发Node.js原生扩展的口子，让开发者有了更多的可能性来对其项目进行开发。</p><p>本书以Chrome V8的知识作为基础，配合上GYP的一些内容，将教会大家如何使用Node.js提供的一些API来编写其C++的原生扩展。此外，在后续的提高章节中，还会介绍原生抽象NAN，以及异步相关的libuv相关知识，最后辅以几个实例来进阶学习。不过，在学习本书内容之前，笔者推荐读者已经有了初步的Node.js以及C++基础。</p><p>总之，买了这一本书，相当于读者拥有了Chrome V8开发、libuv开发以及Node.js的原生C++扩展开发三本书，非常值当。</p></blockquote><h2 id="二〇一六的-Checklist"><a href="#二〇一六的-Checklist" class="headerlink" title="二〇一六的 Checklist"></a>二〇一六的 Checklist</h2><p>这里列出 2016 年总结中对 2017 年的一些希冀。</p><ul><li><del>至少出境游玩一次；</del></li><li><del>改变周末的习惯，对生活更积极一些；</del></li><li><del>买车；</del></li><li><del>想写一本书，并付诸实践；</del></li><li><del>通关更多的游戏；</del></li><li><del>再还一部分首付；</del></li><li>苦练摄影技术；</li><li>赚更多钱，不要像现在一样花得憋屈。</li></ul><p>基本上都完成了。去了塞班、周末经常开车出去、车子也买了、书也写了，游戏也通了些许，薅了个相机，技术还要继续努力，正在赚钱的路上——换了个新的工作环境。</p><h2 id="展望二〇一八"><a href="#展望二〇一八" class="headerlink" title="展望二〇一八"></a>展望二〇一八</h2><p>最后列出一些明年想做的事情。</p><ul><li>去欧美国家游玩一次；</li><li>书出版；</li><li>买家具什么的装饰自己的家；</li><li>晋升；</li><li>弄一个类似家庭影院的东西；</li><li>精进厨艺；</li><li>赚更多钱，不要像现在一样花得憋屈。</li></ul><p>Ask me anything: <a href="https://github.com/xadillax/ama" target="_blank" rel="external">https://github.com/xadillax/ama</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是时候总结一发了，今年经历了职场的几番大变动吧，总之比较坎坷。&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;h3 id=&quot;足迹&quot;&gt;&lt;a href=&quot;#足迹&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="年终总结" scheme="https://xcoder.in/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="2017" scheme="https://xcoder.in/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中遇到含空格 URL 的神奇“Bug”——小范围深入 HTTP 协议</title>
    <link href="https://xcoder.in/2017/12/13/node-http-parser-spaces-in-url/"/>
    <id>https://xcoder.in/2017/12/13/node-http-parser-spaces-in-url/</id>
    <published>2017-12-13T01:16:45.000Z</published>
    <updated>2017-12-13T06:41:55.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/31966196" target="_blank" rel="external">本文</a>首发于知乎专栏<a href="https://zhuanlan.zhihu.com/xtech" target="_blank" rel="external">蚂蚁金服体验科技</a>。</p></blockquote><p>首先声明，我在“Bug”字眼上加了引号，自然是为了说明它并非一个真 Bug。</p><h2 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h2><p>昨天有个童鞋在看后台监控的时候，突然发现了一个错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[error] 000001#0: ... upstream prematurely closed connection while reading response header from upstream.</span><br><span class="line">  client: 10.10.10.10</span><br><span class="line">  server: foo.com</span><br><span class="line">  request: &quot;GET /foo/bar?rmicmd,begin run clean docker images job HTTP/1.1&quot;</span><br><span class="line">  upstream: &quot;http://...&quot;</span><br></pre></td></tr></table></figure><p>大概意思就是说：一台服务器通过 HTTP 协议去请求另一台服务器的时候，单方面被对方服务器断开了连接——并且并没有任何返回。</p><h2 id="开始重现"><a href="#开始重现" class="headerlink" title="开始重现"></a>开始重现</h2><h3 id="客户端-CURL-指令"><a href="#客户端-CURL-指令" class="headerlink" title="客户端 CURL 指令"></a>客户端 CURL 指令</h3><p>其实这次请求的一些猫腻很容易就能发现——在 URL 中有空格。所以我们能简化出一条最简单的 CURL 指令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">"http://foo/bar baz"</span> -v</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>不带任何转义。</p></blockquote><h3 id="最小-Node-js-源码"><a href="#最小-Node-js-源码" class="headerlink" title="最小 Node.js 源码"></a>最小 Node.js 源码</h3><p>好的，那么接下去开始写相应的最简单的 Node.js HTTP 服务端源码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, resp</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'🌚'</span>);</span><br><span class="line">    resp.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">5555</span>);</span><br></pre></td></tr></table></figure><p>大功告成，启动这段 Node.js 代码，开始试试看上面的指令吧。</p><p>如果你也正在跟着尝试这件事情的话，你就会发现 Node.js 的命令行没有输出任何信息，尤其是嘲讽的 <code>&#39;🌚&#39;</code>，而在 CURL 的结果中，你将会看见：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &apos;http://127.0.0.1:5555/d d&apos; -v</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)</span><br><span class="line">&gt; GET /d d HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:5555</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Empty reply from server</span><br><span class="line">* Connection #0 to host 127.0.0.1 left intact</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure><p>瞧，<strong>Empty reply from server</strong>。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>发现了问题之后，就有另一个问题值得思考了：就 Node.js 会出现这种情况呢，还是其它一些 HTTP 服务器也会有这种情况呢。</p><p>于是拿小白鼠 Nginx 做了个实验。我写了这么一个配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">5555</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着也执行一遍 CURL，得到了如下的结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &apos;http://127.0.0.1:5555/d d&apos; -v</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)</span><br><span class="line">&gt; GET /d d HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:5555</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: openresty/1.11.2.1</span><br><span class="line">&lt; Date: Tue, 12 Dec 2017 09:07:56 GMT</span><br><span class="line">&lt; Content-Type: application/octet-stream</span><br><span class="line">&lt; Content-Length: 4</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt;</span><br><span class="line">* Connection #0 to host xcoder.in left intact</span><br><span class="line">/d d</span><br></pre></td></tr></table></figure><center><img src="word_bro.png"><br><small>厉害了，我的 Nginx</small></center><p>于是乎，理所当然，我<strong>暂时</strong>将这个事件定性为 Node.js 的一个 Bug。</p><h2 id="Node-js-源码排查"><a href="#Node-js-源码排查" class="headerlink" title="Node.js 源码排查"></a>Node.js 源码排查</h2><p>认定了它是个 Bug 之后，我就开始了一贯的看源码环节——由于这个 Bug 的复现条件比较明显，我暂时将其定性为“Node.js HTTP 服务端模块在接到请求后解析 HTTP 数据包的时候解析 URI 时出了问题”。</p><h3 id="http-js-gt-http-server-js-gt-http-common-js"><a href="#http-js-gt-http-server-js-gt-http-common-js" class="headerlink" title="http.js -&gt; _http_server.js -&gt; _http_common.js"></a>http.js -&gt; _http_server.js -&gt; _http_common.js</h3><blockquote><p>源码以 <a href="https://github.com/nodejs/node/tree/v8.9.2" target="_blank" rel="external">Node.js 8.9.2</a> 为准。</p></blockquote><p>这里先预留一下我们能马上想到的 <strong>node_http_parser.cc</strong>，而先讲这几个文件，是有原因的——这涉及到最后的一个应对方式。</p><p>首先看看 <a href="https://github.com/nodejs/node/blob/v8.9.2/lib/http.js#L33-L35" target="_blank" rel="external"><strong>lib/http.js</strong></a> 的相应源码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const server = <span class="built_in">require</span>(<span class="string">'_http_server'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Server &#125; = server;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(requestListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，马上进入 <strong>lib/_http_server.js</strong> 看吧。</p><p>首先是创建一个 HttpParser 并绑上监听获取到 HTTP 数据包后解析结果的回调函数的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  parsers,</span><br><span class="line">  ...</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">'_http_common'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectionListener</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  var parser = parsers.alloc();</span><br><span class="line">  parser.reinitialize(HTTPParser.REQUEST);</span><br><span class="line">  parser.socket = socket;</span><br><span class="line">  socket.parser = parser;</span><br><span class="line">  parser.incoming = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  state.onData = socketOnData.bind(<span class="literal">undefined</span>, <span class="keyword">this</span>, socket, parser, state);</span><br><span class="line">  ...</span><br><span class="line">  socket.on(<span class="string">'data'</span>, state.onData);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">socketOnData</span>(<span class="params">server, socket, parser, state, d</span>) </span>&#123;</span><br><span class="line">  assert(!socket._paused);</span><br><span class="line">  debug(<span class="string">'SERVER socketOnData %d'</span>, d.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret = parser.execute(d);</span><br><span class="line">  onParserExecuteCommon(server, socket, parser, state, ret, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中文我们能看到，当一个 HTTP 请求过来的时候，监听函数 <code>connectionListener()</code> 会拿着 Socket 对象加上一个 <code>data</code> 事件监听——一旦有请求连接过来，就去执行 <code>socketOnData()</code> 函数。</p><p>而在 <code>socketOnData()</code> 函数中，做的主要事情就是 <code>parser.execute(d)</code> 来解析 HTTP 数据包，在解析完成后执行一下回调函数 <code>onParserExecuteCommon()</code>。</p><p>至于这个 <code>parser</code>，我们能看到它是从 <a href="https://github.com/nodejs/node/blob/v8.9.2/lib/_http_common.js#L170-L193" target="_blank" rel="external"><strong>lib/_http_common.js</strong></a> 中来的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parsers = <span class="keyword">new</span> FreeList(<span class="string">'parsers'</span>, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parser = <span class="keyword">new</span> HTTPParser(HTTPParser.REQUEST);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  parser[kOnHeaders] = parserOnHeaders;</span><br><span class="line">  parser[kOnHeadersComplete] = parserOnHeadersComplete;</span><br><span class="line">  parser[kOnBody] = parserOnBody;</span><br><span class="line">  parser[kOnMessageComplete] = parserOnMessageComplete;</span><br><span class="line">  parser[kOnExecute] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>能看出来 <code>parsers</code> 是 <code>HTTPParser</code> 的一条 Free List（效果类似于最简易的动态内存池），每个 Parser 在初始化的时候绑定上了各种回调函数。具体的一些回调函数就不细讲了，有兴趣的童鞋可自行翻阅。</p><p>这么一来，链路就比较明晰了：</p><p><strong>请求进来的时候，Server 对象会为该次请求的 Socket 分配一个 <code>HttpParser</code> 对象，并调用其 <code>execute()</code> 函数进行解析，在解析完成后调用 <code>onParserExecuteCommon()</code> 函数。</strong></p><h3 id="node-http-parser-cc"><a href="#node-http-parser-cc" class="headerlink" title="node_http_parser.cc"></a>node_http_parser.cc</h3><p>我们在 <strong>lib/_http_common.js</strong> 中能发现，<code>HTTPParser</code> 的实现存在于 <strong>src/node_http_parser.cc</strong> 中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binding = process.binding(<span class="string">'http_parser'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; methods, HTTPParser &#125; = binding;</span><br></pre></td></tr></table></figure><blockquote><p>至于为什么 <code>const binding = process.binding(&#39;http_parser&#39;)</code> 就是对应到 <strong>src/node_http_parser.cc</strong> 文件，以及这一小节中下面的一些 C++ 源码相关分析，不明白且有兴趣的童鞋可自行去阅读更深一层的源码，或者网上搜索答案，或者我提前无耻硬广一下我快要上市的书《Node.js：来一打 C++ 扩展》——里面也有说明，以及我的有一场知乎 Live《深入理解 Node.js 包与模块机制》。</p></blockquote><p>总而言之，我们接下去要看的就是 <a href="https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L796-L804" target="_blank" rel="external"><strong>src/node_http_parser.cc</strong></a> 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"close"</span>, Parser::Close);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"execute"</span>, Parser::Execute);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"finish"</span>, Parser::Finish);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"reinitialize"</span>, Parser::Reinitialize);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"pause"</span>, Parser::Pause&lt;<span class="literal">true</span>&gt;);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"resume"</span>, Parser::Pause&lt;<span class="literal">false</span>&gt;);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"consume"</span>, Parser::Consume);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"unconsume"</span>, Parser::Unconsume);</span><br><span class="line">env-&gt;SetProtoMethod(t, <span class="string">"getCurrentBuffer"</span>, Parser::GetCurrentBuffer);</span><br></pre></td></tr></table></figure><p>如代码片段所示，前文中 <code>parser.execute()</code> 所对应的函数就是 <code>Parser::Execute()</code> 了。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">class Parser : public AsyncWrap &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  static void Execute(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">    Parser* parser;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Local&lt;Object&gt; buffer_obj = args[0].As&lt;Object&gt;();</span><br><span class="line">    char* buffer_data = Buffer::Data(buffer_obj);</span><br><span class="line">    size_t buffer_len = Buffer::Length(buffer_obj);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Local&lt;Value&gt; ret = parser-&gt;Execute(buffer_data, buffer_len);</span><br><span class="line"></span><br><span class="line">    if (!ret.IsEmpty())</span><br><span class="line">      args.GetReturnValue().Set(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Local&lt;Value&gt; Execute(char* data, size_t len) &#123;</span><br><span class="line">    EscapableHandleScope scope(env()-&gt;isolate());</span><br><span class="line"></span><br><span class="line">    current_buffer_len_ = len;</span><br><span class="line">    current_buffer_data_ = data;</span><br><span class="line">    got_exception_ = false;</span><br><span class="line"></span><br><span class="line">    size_t nparsed =</span><br><span class="line">      http_parser_execute(&amp;parser_, &amp;settings, data, len);</span><br><span class="line"></span><br><span class="line">    Save();</span><br><span class="line"></span><br><span class="line">    // Unassign the 'buffer_' variable</span><br><span class="line">    current_buffer_.Clear();</span><br><span class="line">    current_buffer_len_ = 0;</span><br><span class="line">    current_buffer_data_ = nullptr;</span><br><span class="line"></span><br><span class="line">    // If there was an exception in one of the callbacks</span><br><span class="line">    if (got_exception_)</span><br><span class="line">      return scope.Escape(Local&lt;Value&gt;());</span><br><span class="line"></span><br><span class="line">    Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);</span><br><span class="line">    // If there was a parse error in one of the callbacks</span><br><span class="line">    // TODO(bnoordhuis) What if there is an error on EOF?</span><br><span class="line">    if (!parser_.upgrade &amp;&amp; nparsed != len) &#123;</span><br><span class="line">      enum http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);</span><br><span class="line"></span><br><span class="line">      Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());</span><br><span class="line">      Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());</span><br><span class="line">      obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);</span><br><span class="line">      obj-&gt;Set(env()-&gt;code_string(),</span><br><span class="line">               OneByteString(env()-&gt;isolate(), http_errno_name(err)));</span><br><span class="line"></span><br><span class="line">      return scope.Escape(e);</span><br><span class="line">    &#125;</span><br><span class="line">    return scope.Escape(nparsed_obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进入 <code>Parser</code> 的静态 <code>Execute()</code> 函数，我们看到它把传进来的 <code>Buffer</code> 转化为 C++ 下的 <code>char*</code> 指针，并记录其数据长度，同时去执行当前调用的 <code>parser</code> 对象所对应的 <code>Execute()</code> 函数。</p><p>在这个 <code>Execute()</code> 函数中，有个最重要的代码，就是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> nparsed =</span><br><span class="line">    http_parser_execute(&amp;parser_, &amp;settings, data, len);</span><br></pre></td></tr></table></figure><p>这段代码是调用真正解析 HTTP 数据包的函数，它是 Node.js 这个项目的一个自研依赖，叫 <a href="https://github.com/nodejs/node/tree/v8.9.2/deps/http_parser" target="_blank" rel="external">http-parser</a>。它独立的项目地址在 <a href="https://github.com/nodejs/http-parser" target="_blank" rel="external">https://github.com/nodejs/http-parser</a>，我们本文中用的是 Node.js v8.9.2 中所依赖的源码，应该会有偏差。</p><h3 id="http-parser"><a href="#http-parser" class="headerlink" title="http-parser"></a>http-parser</h3><h4 id="HTTP-Request-数据包体"><a href="#HTTP-Request-数据包体" class="headerlink" title="HTTP Request 数据包体"></a>HTTP Request 数据包体</h4><blockquote><p>如果你已经对 HTTP 包体了解了，可以略过这一节。</p></blockquote><p>HTTP 的 Request 数据包其实是文本格式的，在 Raw 的状态下，大概是以这样的形式存在：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法 URI HTTP/版本</span><br><span class="line">头1: 我是头1</span><br><span class="line">头2: 我是头2</span><br></pre></td></tr></table></figure><blockquote><p>简单起见，这里就写出最基础的一些内容，至于 Body 什么的大家自己找资料看吧。</p></blockquote><p>上面的是什么意思呢？我们看看 CURL 的结果就知道了，实际上对应 <code>curl ... -v</code> 的中间输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /test HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:5555</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>所以实际上大家平时在文章中、浏览器调试工具中看到的什么请求头啊什么的，都是以文本形式存在的，以换行符分割。</p><p>而——重点来了，导致我们本文所述“Bug”出现的请求，它的请求包如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /foo bar HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:5555</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>重点在第一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /foo bar HTTP/1.1</span><br></pre></td></tr></table></figure><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>话不多少，我们之间前往 http-parser 的 <a href="https://github.com/nodejs/node/blob/v8.9.2/deps/http_parser/http_parser.c#L634" target="_blank" rel="external">http_parser.c</a> 看 <code>http_parser_execute ()</code> 函数中的状态机变化。</p><p>从源码中文我们能看到，http-parser 的流程是从头到尾以 O(n) 的时间复杂度对字符串逐字扫描，并且不后退也不往前跳。</p><p>那么扫描到每个字符的时候，都有属于当前的一个状态，如“正在扫描处理 uri”、“正在扫描处理 HTTP 协议并且处理到了 H”、“正在扫描处理 HTTP 协议并且处理到了 HT”、“正在扫描处理 HTTP 协议并且处理到了 HTT”、“正在扫描处理 HTTP 协议并且处理到了 HTTP”、……</p><center><img src="baoqingtian.png"></center><p>憋笑，这是真的，我们看看代码就知道了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> s_req_server:</span><br><span class="line"><span class="keyword">case</span> s_req_server_with_at:</span><br><span class="line"><span class="keyword">case</span> s_req_path:</span><br><span class="line"><span class="keyword">case</span> s_req_query_string_start:</span><br><span class="line"><span class="keyword">case</span> s_req_query_string:</span><br><span class="line"><span class="keyword">case</span> s_req_fragment_start:</span><br><span class="line"><span class="keyword">case</span> s_req_fragment:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">      UPDATE_STATE(s_req_http_start);</span><br><span class="line">      CALLBACK_DATA(url);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CR:</span><br><span class="line">    <span class="keyword">case</span> LF:</span><br><span class="line">      parser-&gt;http_major = <span class="number">0</span>;</span><br><span class="line">      parser-&gt;http_minor = <span class="number">9</span>;</span><br><span class="line">      UPDATE_STATE((ch == CR) ?</span><br><span class="line">        s_req_line_almost_done :</span><br><span class="line">        s_header_field_start);</span><br><span class="line">      CALLBACK_DATA(url);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(CURRENT_STATE() == s_dead)) &#123;</span><br><span class="line">        SET_ERRNO(HPE_INVALID_URL);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扫描的时候，如果当前状态是 URI 相关的（如 <code>s_req_path</code>、<code>s_req_query_string</code> 等），则执行一个子 <code>switch</code>，里面的处理如下：</p><ul><li>若当前字符是空格，则将状态改变为 <code>s_req_http_start</code> 并认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li><li>若当前字符是换行符，则说明还在解析 URI 的时候就被换行了，后面就不可能跟着 HTTP 协议版本的申明了，所以设置默认的 HTTP 版本为 <code>0.9</code>，并修改当前状态，最后认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li><li>其余情况（所有其它字符）下，通过调用 <code>parse_url_char()</code> 函数来解析一些东西并更新当前状态。（因为哪怕是在解析 URI 状态中，也还有各种不同的细分，如 <code>s_req_path</code>、<code>s_req_query_string</code> ）</li></ul><p>这里的重点还是当状态为解析 URI 的时候遇到了空格的处理，上面也解释过了，一旦遇到这种情况，则会认为 URI 已经解析好了，并且将状态修改为 <code>s_req_http_start</code>。也就是说，有“Bug”的那个数据包<br> <code>GET /foo bar HTTP/1.1</code> 在解析到 <code>foo</code> 后面的空格的时候它就将状态改为 <code>s_req_http_start</code> 并且认为 URI 已经解析结束了。</p><p>好的，接下来我们看看 <code>s_req_http_start</code> 怎么处理：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> s_req_http_start:</span><br><span class="line">  <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">      UPDATE_STATE(s_req_http_H);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      SET_ERRNO(HPE_INVALID_CONSTANT);</span><br><span class="line">      <span class="keyword">goto</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> s_req_http_H:</span><br><span class="line">  STRICT_CHECK(ch != <span class="string">'T'</span>);</span><br><span class="line">  UPDATE_STATE(s_req_http_HT);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> s_req_http_HT:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> s_req_http_HTT:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> s_req_http_HTTP:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> s_req_first_http_major:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如代码所见，若当前状态为 <code>s_req_http_start</code>，则先判断当前字符是不是合标。因为就 HTTP 请求包体的格式来看，如果 URI 解析结束的话，理应出现类似 <code>HTTP/1.1</code> 的这么一个版本申明。所以这个时候 http-parser 会直接判断当前字符是否为 <code>H</code>。</p><ul><li>若是 <code>H</code>，则将状态改为 <code>s_req_http_H</code> 并继续扫描循环的下一位，同理在 <code>s_req_http_H</code> 下若合法状态就会变成 <code>s_req_http_HT</code>，以此类推；<br>+若是空格，则认为是多余的空格，那么当前状态不做任何改变，并继续下一个扫描；</li><li>但如果当前字符既不是空格也不是 <code>H</code>，那么好了，http-parser 直接认为你的请求包不合法，将你本次的解析设置错误 <code>HPE_INVALID_CONSTANT</code> 并 <code>goto</code> 到 <code>error</code> 代码块。</li></ul><p>至此，我们基本上已经明白了原因了：</p><p><strong>http-parser 认为在 HTTP 请求包体中，第一行的 URI 解析阶段一旦出现了空格，就会认为 URI 解析完成，继而解析 HTTP 协议版本。但若此时紧跟着的不是 HTTP 协议版本的标准格式，http-parser 就会认为你这是一个 <code>HPE_INVALID_CONSTANT</code> 的数据包。</strong></p><p>不过，我们还是继续看看它的 <code>error</code> 代码块吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">error:</span><br><span class="line">  <span class="keyword">if</span> (HTTP_PARSER_ERRNO(parser) == HPE_OK) &#123;</span><br><span class="line">    SET_ERRNO(HPE_UNKNOWN);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RETURN(p - data);</span><br></pre></td></tr></table></figure><p>这段代码中首先判断一下当跳到这段代码的时候有没有设置错误，若没有设置错误则将错误设置为未知错误（<code>HPE_UNKNOWN</code>），然后返回已解析的数据包长度。</p><blockquote><p><code>p</code> 是当前解析字符指针，<code>data</code> 是这个数据包的起始指针，所以 <code>p - data</code> 就是已解析的数据长度。如果成功解析完，这个数据包理论上是等于这个数据包的完整长度，若不等则理论上说明肯定是中途出错提前返回。</p></blockquote><h3 id="回到-node-http-parser-cc"><a href="#回到-node-http-parser-cc" class="headerlink" title="回到 node_http_parser.cc"></a>回到 node_http_parser.cc</h3><p>看完了 http-parser 的原理后，很多地方茅塞顿开。现在我们回到它的调用地 <a href="https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L630-L666" target="_blank" rel="external"><strong>node_http_parser.cc</strong></a> 继续阅读吧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Local&lt;Value&gt; Execute(<span class="keyword">char</span>* data, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> nparsed =</span><br><span class="line">    http_parser_execute(&amp;parser_, &amp;settings, data, len);</span><br><span class="line"></span><br><span class="line">  Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);</span><br><span class="line">  <span class="keyword">if</span> (!parser_.upgrade &amp;&amp; nparsed != len) &#123;</span><br><span class="line">    <span class="keyword">enum</span> http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);</span><br><span class="line"></span><br><span class="line">    Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());</span><br><span class="line">    Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());</span><br><span class="line">    obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);</span><br><span class="line">    obj-&gt;Set(env()-&gt;code_string(),</span><br><span class="line">             OneByteString(env()-&gt;isolate(), http_errno_name(err)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scope.Escape(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scope.Escape(nparsed_obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从调用处我们能看见，在执行完 <code>http_parser_execute()</code> 后有一个判断，若当前请求不是 <code>upgrade</code> 请求（即请求头中有说明 <code>Upgrade</code>，通常用于 WebSocket），并且解析长度不等于原数据包长度（前文说了这种情况属于出错了）的话，那么进入中间的错误代码块。</p><p>在错误代码块中，先 <code>HTTP_PARSER_ERRNO(&amp;parser_)</code> 拿到错误码，然后通过 <code>Exception::Error()</code> 生成错误对象，将错误信息塞进错误对象中，最后返回错误对象。</p><p>如果没错，则返回解析长度（<code>nparsed_obj</code> 即 <code>nparsed</code>）。</p><blockquote><p>在这个文件中，眼尖的童鞋可能发现了，执行 <code>Execute()</code> 有好多处，这是因为实际上一个 HTTP 请求可能是流式的，所以有时候可能会只拿到部分数据包。所以最后有一个结束符需要被确认。<strong>这也是为什么 http-parser 在解析的时候只能逐字解析而不能跳跃或者后退了。</strong></p></blockquote><h3 id="回到-http-server-js"><a href="#回到-http-server-js" class="headerlink" title="回到 _http_server.js"></a>回到 _http_server.js</h3><p>我们把 <code>Parser::Execute()</code> 也就是 JavaScript 代码中的 <code>parser.execute()</code> 给搞清楚后，我们就能回到 <a href="https://github.com/nodejs/node/blob/v8.9.2/lib/_http_server.js#L462-L507" target="_blank" rel="external">_http_server.js</a> 看代码了。</p><p>前文说了，<code>socketOnData</code> 在解析完数据包后会执行 <code>onParserExecuteCommon</code> 函数，现在就来看看这个 <code>onParserExecuteCommon()</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onParserExecuteCommon</span>(<span class="params">server, socket, parser, state, ret, d</span>) </span>&#123;</span><br><span class="line">  resetSocketTimeout(server, socket, state);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">    debug(<span class="string">'parse error'</span>, ret);</span><br><span class="line">    socketOnError.call(socket, ret);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parser.incoming &amp;&amp; parser.incoming.upgrade) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长长的一个函数被我精简成这么几句话，重点很明显。<code>ret</code> 就是从 <code>socketOnData</code> 传进来已解析的数据长度，但是在 C++ 代码中我们也看到了它还有可能是一个错误对象。所以在这个函数中一开始就做了一个判断，判断解析的结果是不是一个错误对象，如果是错误对象则调用 <code>socketOnError()</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">socketOnError</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ignore further errors</span></span><br><span class="line">  <span class="keyword">this</span>.removeListener(<span class="string">'error'</span>, socketOnError);</span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'error'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.server.emit(<span class="string">'clientError'</span>, e, <span class="keyword">this</span>))</span><br><span class="line">    <span class="keyword">this</span>.destroy(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，如果真的不小心走到这一步的话，HTTP Server 对象会触发一个 <code>clientError</code> 事件。</p><p>整个事情串联起来了：</p><ul><li>收到请求后会通过 http-parser 解析数据包；</li><li><code>GET /foo bar HTTP/1.1</code> 会被解析出错并返回一个错误对象；</li><li>错误对象会进入 <code>if (ret instanceof Error)</code> 条件分支并调用 <code>socketOnError()</code> 函数；</li><li><code>socketOnError()</code> 函数中会对服务器触发一个 <code>clientError</code> 事件；（<code>this.server.emit(&#39;clientError&#39;, e, this)</code>）</li><li><strong>至此，HTTP Server 并不会走到你的那个 <code>function(req, resp)</code> 中去，所以不会有任何的数据被返回就结束了，也就解答了一开始的问题——收不到任何数据就请求结束。</strong></li></ul><p>这就是我要逐级进来看代码，而不是直达 http-parser 的原因了——<code>clientError</code> 是一个关键。</p><h2 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h2><p>要解决这个“Bug”其实不难，直接监听 <a href="https://nodejs.org/api/http.html#http_event_clienterror" target="_blank" rel="external"><code>clientError</code> 事件</a>并做一些处理即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, resp</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'🌚'</span>);</span><br><span class="line">    resp.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;).on(<span class="string">'clientError'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, sock</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'🐷'</span>);</span><br><span class="line">    sock.end(<span class="string">'HTTP/1.1 400 Bad Request\r\n\r\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">5555</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>由于运行到 <code>clientError</code> 事件时，并没有任何 Request 和 Response 的封装，你能拿到的是一个 Node.js 中原始的 Socket 对象，所以当你要返回数据的时候需要自己按照 HTTP 返回数据包的格式来输出。</p></blockquote><p>这个时候再挥起你的小手试一下 CURL 吧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &apos;http://127.0.0.1:5555/d d&apos; -v</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)</span><br><span class="line">&gt; GET /d d HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:5555</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 400 Bad Request</span><br><span class="line">* no chunk, no close, no size. Assume close to signal end</span><br><span class="line">&lt;</span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure><p>如愿以偿地输出了 400 状态码。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>接下来我们要引申讨论的一个点是，为什么这货不是一个真正意义上的 Bug。</p><p>首先我们看看 Nginx 这么实现这个黑科技的吧。</p><h3 id="Nginx-实现"><a href="#Nginx-实现" class="headerlink" title="Nginx 实现"></a>Nginx 实现</h3><p>打开 Nginx 源码的<a href="https://github.com/nginx/nginx/blob/release-1.13.7/src/http/ngx_http_parse.c#L104" target="_blank" rel="external">相应位置</a>。</p><p>我们能看到它的状态机对于 URI 和 HTTP 协议声明中间多了一个中间状态，叫 <code>sw_check_uri_http_09</code>，专门处理 URI 后面的空格。</p><p>在各种 URI 解析状态中，基本上都能找到这么一句话，表示若当前状态正则解析 URI 的各种状态并且遇到空格的话，则将状态改为 <code>sw_check_uri_http_09</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> sw_check_uri:</span><br><span class="line">  <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    r-&gt;uri_end = p;</span><br><span class="line">    state = sw_check_uri_http_09;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>然后在 <code>sw_check_uri_http_09</code> 状态时会做一些检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> sw_check_uri_http_09:</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CR:</span><br><span class="line">        r-&gt;http_minor = <span class="number">9</span>;</span><br><span class="line">        state = sw_almost_done;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LF:</span><br><span class="line">        r-&gt;http_minor = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'H'</span>:</span><br><span class="line">        r-&gt;http_protocol.data = p;</span><br><span class="line">        state = sw_http_H;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        r-&gt;space_in_uri = <span class="number">1</span>;</span><br><span class="line">        state = sw_check_uri;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><ul><li>遇到空格则继续保持当前状态开始扫描下一位；</li><li>如果是换行符则设置默认 HTTP 版本并继续扫描；</li><li>如果遇到的是 <code>H</code> 才修改状态为 <code>sw_http_H</code> 认为接下去开始 HTTP 版本扫描；</li><li>如果是其它字符，则标明一下 URI 中有空格，然后将状态改回 <code>sw_check_uri</code>，然后倒退回一格以 <code>sw_check_uri</code> 继续扫描当前的空格。</li></ul><p>在理解了这个“黑科技”后，我们很快能找到一个很好玩的点，开启你的 Nginx 并用 CURL 请求以下面的例子一下它看看吧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &apos;http://xcoder.in:5555/d H&apos; -v</span><br><span class="line">*   Trying 103.238.225.181...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to xcoder.in (103.238.225.181) port 5555 (#0)</span><br><span class="line">&gt; GET /d H HTTP/1.1</span><br><span class="line">&gt; Host: xcoder.in:5555</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 400 Bad Request</span><br><span class="line">&lt; Server: openresty/1.11.2.1</span><br><span class="line">&lt; Date: Tue, 12 Dec 2017 11:18:13 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 179</span><br><span class="line">&lt; Connection: close</span><br><span class="line">&lt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty/1.11.2.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure><p>怎么样？是不是发现结果跟之前的不一样了——它居然也返回了 400 Bad Request。</p><p>原因为何就交给童鞋们自己考虑吧。</p><h3 id="RFC-2616-与-RFC-2396"><a href="#RFC-2616-与-RFC-2396" class="headerlink" title="RFC 2616 与 RFC 2396"></a>RFC 2616 与 RFC 2396</h3><p>那么，为什么即使在 Nginx 支持空格 URI 的情况下，我还说 Node.js 这个不算 Bug，并且指明 Nginx 是“黑科技”呢？</p><p>后来我去看了 HTTP 协议 RFC。</p><p>原因在于 Network Working Group 的 <a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">RFC 2616</a>，关于 HTTP 协议的规范。</p><p>在 RFC 2616 的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.1" target="_blank" rel="external">3.2.1 节</a>中做了一些说明，它说了在 HTTP 协议中关于 URI 的文法和语义参照了 <a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">RFC 2396</a>。</p><blockquote><p>URIs in HTTP can be represented in absolute form or relative to some known base URI, depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon. For definitive information on URL syntax and semantics, see “Uniform Resource Identifiers (URI): Generic Syntax and Semantics,” RFC 2396 (which replaces RFCs 1738 and RFC 1808). This specification adopts the definitions of “URI-reference”, “absoluteURI”, “relativeURI”, “port”, “host”,”abs_path”, “rel_path”, and “authority” from that specification.</p></blockquote><p>而在 <a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">RFC 2396</a> 中，我们同样找到了它的 <a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">2.4.3 节</a>。里面对于 Disallow 的 US-ASCII 字符做了解释，其中有：</p><ul><li><p>控制符，指 ASCII 码在 0x00-0x1F 范围内以及 0x7F；</p><p>  控制符通常不可见；</p></li><li><p>空格，指 0x20；</p><p>  空格不可控，如经由一些排版软件转录后可能会有变化，<span style="color: #ccc;">而到了 HTTP 协议这层时，反正空格不推荐使用了，所以就索性用空格作为首行分隔符了；</span></p></li><li><p>分隔符，<code>&quot;&lt;&quot;</code>、<code>&quot;&gt;&quot;</code>、<code>&quot;#&quot;</code>、<code>&quot;%&quot;</code>、<code>&quot;\&quot;&quot;</code>。</p><p>  如 <code>#</code> 将用于浏览器地址栏的 Hash；而 <code>%</code> 则会与 URI 转义一同使用，所以不应单独出现在 URI 中。</p></li></ul><p><strong>于是乎，HTTP 请求中，包体的 URI 似乎本就不应该出现空格，而 Nginx 是一个黑魔法的姿势。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>嚯，写得累死了。本次的一个探索基于了一个有空格非正常的 URI 通过 CURL 或者其它一些客户端请求时，Node.js 出现的 Bug 状态。</p><blockquote><p>实际上发现这个 Bug 的时候，客户端请求似乎是因为那边的开发者手抖，不小心将不应该拼接进来的内容给拼接到了 URL 中，类似于 <code>$ rm -rf /</code>。</p></blockquote><p>一开始我以为这是 Node.js 的 Bug，在探寻之后发现是因为我们自己没用 Node.js HTTP Server 提供的 <code>clientError</code> 事件做正确的处理。而 Nginx 的正常请求则是它的黑科技。这些答案都能从 RFC 中寻找——<strong>再次体现了遇到问题看源码看规范的重要性。</strong></p><p>另，我本打算给 http-parser 也加上黑魔法，后来我快写好的时候发现它是流式的，很多状态没法在现有的体系中保留下来，最后放弃了，反正这也不算 Bug。不过在以后有时间的时候，感觉还是可以好好整理一下代码，好好修改一下给提个 PR 上去，以此自勉。</p><p>最后，求 fafa。</p><center><img src="http://ww2.sinaimg.cn/bmiddle/a15b4afely1fme81d41wpg206o06oabl"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31966196&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文&lt;/a&gt;首发于知乎专栏&lt;a href=&quot;https://zhuanlan.zhihu.
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="HTTP" scheme="https://xcoder.in/tags/HTTP/"/>
    
      <category term="Nginx" scheme="https://xcoder.in/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>从暴力到 NAN 再到 NAPI——Node.js 原生模块开发方式变迁</title>
    <link href="https://xcoder.in/2017/07/01/nodejs-addon-history/"/>
    <id>https://xcoder.in/2017/07/01/nodejs-addon-history/</id>
    <published>2017-07-01T07:55:08.000Z</published>
    <updated>2017-12-11T07:59:20.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由我首发于 <a href="http://gitbook.cn/books/5938f4ae8b55d47644b7a445/index.html" target="_blank" rel="external">GitChat</a> 中。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Node.js 开发领域中，原生 C++ 模块的开发一直是一个被人冷落的角落。但是实际上在必要的时候，用 C++ 进行 Node.js 的原生模块开发能有意想不到的好处。</p><ul><li>性能提升。很多情况下，使用 C++ 进行 Node.js 原生模块开发的性能会比纯 Node.js 开发要高，少数情况除外。</li><li>开发成本节约。在一些即有的 C++ 代码上做封装，开发成本远远低于从零开始写 Node.js 代码。</li><li>Node.js 无法完成的工作。个别情况，开发者只能得到一个库的静态连接库或者动态链接库以及一堆 C++ 头文件，其余都是黑盒的，这种情况就不得不使用 C++ 进行模块开发了。</li></ul><p>本文将从早期的 Node.js 开始，逐渐披露 Node.js 原生 C++ 模块开发方式的变迁。一直到最后，会比较详细地对 Node.js v8.x 新出的原生模块开发接口 N-API 做一次初步的尝试和解析，使得大家对 Node.js 原生 C++ 模块开发的固有印象（认为特别麻烦）有一个比较好的改观，让大家都来尝试一下 Node.js 原生 C++ 模块的开发。</p><h2 id="不变应万变"><a href="#不变应万变" class="headerlink" title="不变应万变"></a>不变应万变</h2><p>虽然 Node.js 原生 C++ 模块开发方式有了很大的改变，但是有一些内容是不变的，至少到现在来说都是基本上没什么 Breaking 的变化。</p><h3 id="原生模块本质"><a href="#原生模块本质" class="headerlink" title="原生模块本质"></a>原生模块本质</h3><p>这就要从 Node.js 最本质的 C++ 模块开发讲起了。举个例子，我们在 Linux 下有一个合法的原生模块 <strong>ons.node</strong>，它其实是一个二进制文件，使用文本编辑器无法正常地看出什么鬼，直到我们遇到了二进制文件查看器。</p><p><img src="http://images.gitbook.cn/81655b10-4cbe-11e7-920d-2570ff832158" alt="ons.node 二进制内容"></p><p>眼尖的同学会看到它的 Magic Number[^1] 是 <code>0x7F454C46</code>，其按位的 ASCII 码代表的字符串是 <code>ELF</code>。于是答案呼之欲出，这就是一个 Linux 下的动态链接库文件。</p><p>事实上，不只是在 Linux 中。当一个 Node.js 的 C++ 模块在 OSX 下编译会得到一个后缀是 <strong>*.node</strong> 本质上是 <strong>*.dylib</strong> 的动态链接库；而在 Windows 下则会得到一个后缀是 <strong>*.node</strong> 本质上是 <strong>*.dll</strong> 的动态链接库。</p><p>这么一个模块在 Node.js 中被 <code>require</code> 的时候，是通过 <code>process.dlopen()</code> 对其进行引入的。我们来看一下 Node.js v6.9.4 的 <code>DLOpen</code>[^2] 函数吧：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">void DLOpen(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">  Environment* env = Environment::GetCurrent(args);</span><br><span class="line">  uv_lib_t lib;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Local&lt;Object&gt; module = args[0]-&gt;ToObject(env-&gt;isolate());</span><br><span class="line">  node::Utf8Value filename(env-&gt;isolate(), args[1]);</span><br><span class="line"></span><br><span class="line">  // 使用 uv_dlopen 加载链接库</span><br><span class="line">  const bool is_dlopen_error = uv_dlopen(*filename, &amp;lib);</span><br><span class="line">  node_module* const mp = modpending;</span><br><span class="line">  modpending = nullptr;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // 将加载的链接库句柄转移到 mp 上</span><br><span class="line">  mp-&gt;nm_dso_handle = lib.handle;</span><br><span class="line">  mp-&gt;nm_link = modlist_addon;</span><br><span class="line">  modlist_addon = mp;</span><br><span class="line"></span><br><span class="line">  Local&lt;String&gt; exports_string = env-&gt;exports_string();</span><br><span class="line"></span><br><span class="line">  // exports_string 其实就是 `"exports"`</span><br><span class="line">  // 这句的意思是 `exports = module.exports`</span><br><span class="line">  Local&lt;Object&gt; exports = module-&gt;Get(exports_string)-&gt;ToObject(env-&gt;isolate());</span><br><span class="line"></span><br><span class="line">  if (mp-&gt;nm_context_register_func != nullptr) &#123;</span><br><span class="line">    mp-&gt;nm_context_register_func(exports, module, env-&gt;context(), mp-&gt;nm_priv);</span><br><span class="line">  &#125; else if (mp-&gt;nm_register_func != nullptr) &#123;</span><br><span class="line">    mp-&gt;nm_register_func(exports, module, mp-&gt;nm_priv);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    uv_dlclose(&amp;lib);</span><br><span class="line">    env-&gt;ThrowError("Module has no declared entry point.");</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照逻辑来讲，这个加载过程其实就是下面这样的。</p><ol><li>通过 <code>uv_dlopen</code> 加载链接库。</li><li>将加载的链接库挂到原生模块链表中去。</li><li>通过 <code>mp-&gt;nm_register_func()</code> 初始化这个模块，并得到该有的 <code>module</code> 和 <code>module.exports</code>。</li></ol><p>流程走下来就跟这个流程图差不多。</p><p><img src="http://images.gitbook.cn/4c391290-4cc0-11e7-be96-bb59812ba34f" alt="DLOpen 流程图"></p><h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><p>这货是 Node.js 中编译原生模块用的。自从 Node.js v0.8 之后，它就跟 Node.js 黏上了，在此之前它的默认编译帮助包是 node-waf[^3]，对于老 Noder 来说应该不会陌生的。</p><h4 id="GYP"><a href="#GYP" class="headerlink" title="GYP"></a>GYP</h4><p>node-gyp 是基于 GYP[^4] 的。它会识别包或者项目中的 <strong>binding.gyp</strong>[^5] 文件，然后根据该配置文件生成各系统下能进行编译的项目，如 Windows 下生成 Visual Studio 项目文件（<strong>*.sln</strong> 等），Unix 下生成 Makefile。在生成这些项目文件之后，node-gyp 还能调用各系统的编译工具（如 GCC）来将项目进行编译，得到最后的动态链接库 <strong>*.node</strong> 文件。</p><blockquote><p>从上面的描述中大家可以看到，Windows 下编译 C++ 原生模块是依赖 Visual Studio 的，这就是为什么大家在安装一些 Node.js 包的时候会需要你事先安装好 Vusual Studio 了。</p><p>事实上，对于并没有 Visual Studio 需求的同学们来说，它不是必须的，毕竟 node-gyp 只依赖它的编译器，而不是 IDE。想要精简化安装的同学可以直接访问 <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">http://landinghub.visualstudio.com/visual-cpp-build-tools</a> 下载 Visual CPP Build Tools 安装，或者通过 <code>$ npm install --global --production windows-build-tools</code> 命令行的方式安装，就能得到你该得到的编译工具了。</p></blockquote><p>说了那么多，让大家见识一下 <strong>binding.gyp</strong> 的基本结构吧。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># binding.gyp</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "targets": [&#123;</span><br><span class="line">    "target_name": "addon1",</span><br><span class="line">    "sources": [ "1/addon.cc", "1/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon2",</span><br><span class="line">    "sources": [ "2/addon.cc", "2/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon3",</span><br><span class="line">    "sources": [ "3/addon.cc", "3/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon4",</span><br><span class="line">    "sources": [ "4/addon.cc", "4/myobject.cc" ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置讲述了这么一个故事：</p><ul><li>定义了 4 个 C++ 原生模块。</li><li>每个模块的源码分别是 <strong>*/addon.cc</strong> 和 <strong>*/myobject.cc</strong>。</li><li>4 个模块名分别是 <strong>addon1</strong> 至 <strong>addon4</strong>。</li><li>隐藏故事：通过正规途径编译好后，这些模块存在于 <strong>build/Release/addon*.node</strong> 中。</li></ul><p>关于 GYP 配置文件的更多内容，大家可自行去官方文档观摩，在脚注中有 GYP 的链接。</p><h4 id="做的事情"><a href="#做的事情" class="headerlink" title="做的事情"></a>做的事情</h4><p>node-gyp 除了自身是基于 GYP 的之外，它还做了一些额外的事情。首先，在我们编译一个 C++ 原生扩展的时候，它会去指定目录下（通常是 <strong>~/.node-gyp</strong> 目录下）搜我们当前 Node.js 版本的头文件和静态连接库文件，若不存在，它就会火急火燎跑去 Node.js 官网下载。</p><p>这是一个 Windows 下 node-gyp 下载的指定版本 Node.js 头文件和库文件的目录结构。</p><p><img src="http://images.gitbook.cn/fca37040-4cc4-11e7-920d-2570ff832158" alt="Windows 下的 Node.js 头文件与库文件"></p><p>这个头文件目录会在 node-gyp 进行编译时，以 <code>&quot;include_dirs&quot;</code> 字段的形式合并进我们事先写好的 <strong>binding.gyp</strong> 中，总而言之，这里面的所有头文件能被直接 <code>#include &lt;&gt;</code>。</p><h4 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h4><p>node-gyp 是一个命令行的程序，在安装好后能通过 <code>$ node-gyp</code> 直接运行它。它有一些子命令供大家使用。</p><ul><li><code>$ node-gyp configure</code>：通过当前目录的 binding.gyp 生成项目文件，如 Makefile 等；</li><li><code>$ node-gyp build</code>：将当前项目进行构建编译，前置操作必须先 <code>configure</code>；</li><li><code>$ node-gyp clean</code>：清理生成的构建文件以及输出目录，说白了就是把目录清理了；</li><li><code>$ node-gyp rebuild</code>：相当于依次执行了 <code>clean</code>、<code>configure</code> 和 <code>build</code>；</li><li><code>$ node-gyp install</code>：手动下载当前版本的 Node.js 的头文件和库文件到对应目录。</li></ul><h2 id="时代在召唤"><a href="#时代在召唤" class="headerlink" title="时代在召唤"></a>时代在召唤</h2><blockquote><p>第 N 套国际 Node.js 开发者原生 C++ 模块开发方式，时代在召唤。</p></blockquote><p>除去前文中讲的一些不变的内容，还有很多内容是一直在变化的，虽然说用老旧的开发方式也是可以开发出能用的 C++ 原生模块，但是旧不如新。</p><p>而且，其实目前来说 node-gyp 的地位也有可能在未来进行变化。因为当年 Chromium 是通过 GYP 来管理它的构建配置的，现如今已经步入了 GN[^6] 的殿堂，是否也意味着 node-gyp 有一天也会被可能叫做 node-gn 的东西给取代呢？</p><p>话不多说，先来看看沧海桑田的故事吧。</p><h3 id="黑暗时代：node-waf"><a href="#黑暗时代：node-waf" class="headerlink" title="黑暗时代：node-waf"></a>黑暗时代：node-waf</h3><p>在 Node.js 0.8 之前，通常在开发 C++ 原生模块的时候，是通过 node-waf 构建的。当然彼 node-waf 不是现在在 NPM 仓库上能搜到的 node-waf 了，当年那个 node-waf 早就年久失修了。</p><p>这个东西使用一种叫 wscript 的文件来配置。自 Node.js 升上 0.8 之后，就自带了 node-gyp 的支持，从此就不再需要 wscript 了。</p><p>不过就是因为有这个青黄交接的时候，那段时间的各种使用 C++ 来开发 Node.js 原生扩展的包为了兼容 0.8 前后版本的 Node.js，通常都是 binding.gyp 和 wscript 共存的。</p><p>大家可以来看一下 <strong>node-mysql-libmysqlclient</strong> 这个包在当年相应时间段的时候的<a href="https://github.com/Sannis/node-mysql-libmysqlclient/tree/9545ea7485fcc8b07b7c56c5ec3575938bfd4e5f" target="_blank" rel="external">仓库文件</a>。为了支持 node-gyp，有一个 binding.gyp 文件，然后还存留着 wscript 配置文件。</p><h3 id="封建时代：暴力！暴力！暴力！"><a href="#封建时代：暴力！暴力！暴力！" class="headerlink" title="封建时代：暴力！暴力！暴力！"></a>封建时代：暴力！暴力！暴力！</h3><p>在早期的时候，Node.js 原生 C++ 模块开发方式是非常暴力的，直接使用其提供的原生模块开发头文件。</p><p>开发者直接深入到 Node.js 的各种 API，以及 Google V8 的 API。</p><p>举个最简单的例子，在几年前，你的 Node.js C++ 原生扩展代码可能是长这样的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowException(</span><br><span class="line">            Exception::TypeError(</span><br><span class="line">                String::New(<span class="string">"Wrong number of arguments."</span>)));</span><br><span class="line">        <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scope.Close(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Handle&lt;Object&gt; exports)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    exports-&gt;Set(String::NewSymbol(<span class="string">"echo"</span>),</span><br><span class="line">        FunctionTemplate::New(Echo)-&gt;GetFunction());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个最简单的 <code>echo</code> 函数，返回传进来的参数。写作 JavaScript 相当于是这样的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.echo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Wrong number of arguments."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遗憾的是，这样的代码如果发成一个包，你现在是无论如何无法安装的，除非你用的是 0.10.x 的 Node.js 版本。</p><p>为什么这么说呢，这段代码的确是在 Node.js 0.10.x 的时候可以用的。但是再往上升 Google V8 的大版本，这段代码就无法适用了，讲粗暴点就是没办法再编译通过了。</p><p>就拿 Node.js 6.x 版本的 Google V8 来说，函数声明的对比是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure><p>事实上，根本不需要等到 6.x。上面的代码到 0.12 就已经无法再编译通过了。不只是函数声明的变化，连句柄作用域[^7]的声明方式都变了。</p><p>如果要让它在 Node.js 6.x 下能编译，就需要改代码，就像这样。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="keyword">if</span>(args.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isolate-&gt;ThrowException(</span><br><span class="line">            Exception::TypeError(</span><br><span class="line">                String::NewFromUtf8(isolate, <span class="string">"Wrong number of arguments."</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    args.GetReturnValue().Set(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local&lt;Object&gt; exports)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"echo"</span>, Echo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，以黑暗时代的方式进行 Node.js 原生模块开发的时候，一个版本只能支持特定几个版本的 Node.js，一旦 Node.js 的底层 API 以及 Google V8 的 API 发生变化，而这些原生模块又依赖了变化了的 API 的话，包就作废了。除非包的维护者去支持新版的 API，不过这样依赖，老版 Node.js 下就又无法编译通过新版的包了。</p><p>这就很尴尬了。</p><h3 id="城堡时代：Native-Abstractions-for-Node-js"><a href="#城堡时代：Native-Abstractions-for-Node-js" class="headerlink" title="城堡时代：Native Abstractions for Node.js"></a>城堡时代：Native Abstractions for Node.js</h3><p>在经历了黑暗时代的尴尬局面之后，2013 年年中，一个救世主突然现世。</p><p>它的名字叫作 <a href="https://github.com/nodejs/nan" target="_blank" rel="external">NAN</a>，全称 Native Abstractions for Node.js，即 Node.js 原生模块抽象接口。</p><blockquote><p>NAN 由 <a href="https://github.com/rvagg" target="_blank" rel="external">Rod Vagg</a> 和 <a href="https://github.com/kkoopa" target="_blank" rel="external">Benjamin Byholm</a> 两手带大，记名在 GitHub 的 Rod Vagg 账号下。并且在 Node.js 与 io.js 黑历史的年代，这个在 GitHub 上面项目移到了 io.js 的组织下面；后来由于两家又重归于好，NAN 最终归属到了 <a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a> 这个组织下面。</p></blockquote><p>总之在 NAN 出现之后，Node.js 的原生开发方式进入了城堡时代，并且一直持续到现在，甚至可能会持续到好久之后。</p><p>说 NAN 是 Node.js 原生模块抽象接口可能还是有点抽象，那么讲明白点，它就是一堆宏判断。比如声明一个函数的时候，只需要通过下面的一个宏就可以了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAN_METHOD(Echo)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NAN 的宏会判断当前编译时候的 Node.js 版本，根据不同版本的 Node.js 来展开不同的结果。这会儿就又会提到先前的两个函数声明对比了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure><p><code>NAN_METHOD</code> 将会在不同版本的 Node.js 下被 NAN 展开成上面两个这样。</p><p>而且 NAN 可不只是提供了 <code>NAN_METHOD</code> 一个宏，它还有一坨一坨数不清的宏供开发者使用。</p><p>比如声明句柄作用域的 <code>Nan::HandleScope</code>、能黑盒调起 libuv[^8] 进行事件循环上的异步操作的 <code>Nan::AsyncWorker</code> 等。</p><p>于是，在城堡时代，大家的 C++ 原生模块代码都差不多长这样。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAN_METHOD(Echo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(info.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Nan::ThrowError(<span class="string">"Wrong number of arguments."</span>);</span><br><span class="line">        <span class="keyword">return</span> info.GetReturnValue().Set(Nan::Undefined());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.GetReturnValue().Set(info[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAN_MODULE_INIT(InitAll)</span><br><span class="line">&#123;</span><br><span class="line">    Nan::Set(</span><br><span class="line">        target,</span><br><span class="line">        Nan::New&lt;String&gt;(<span class="string">"echo"</span>).ToLocalChecked(),</span><br><span class="line">        Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Echo)).ToLocalChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处就是，代码只需要随着 NAN 的升级做改变就好，它会帮你兼容各不同 Node.js 版本，使其在任意版本都能被编译使用。</p><blockquote><p>即使是 NAN 这样的好物，也有自己的一个使命，使命之外的东西会被逐渐剥离。比如 0.10.x 和 0.12.x 等版本就应该要退出历史舞台了，NAN 会逐渐放弃对它们的兼容和支持。</p></blockquote><h3 id="帝国时代：符合-ABI-的-N-API"><a href="#帝国时代：符合-ABI-的-N-API" class="headerlink" title="帝国时代：符合 ABI 的 N-API"></a>帝国时代：符合 ABI 的 N-API</h3><p>自从前几天 Node.js v8.0.0 发布之后，Node.js 推出了全新的用于开发 C++ 原生模块的接口，N-API。</p><blockquote><p>据官方文档所述，它的发音就是一个单独的 <code>N</code>，加上 API，即四个英文字母单独发音。</p></blockquote><p>这东西相较于先前三个时代有什么不同呢？为什么会是更进一步的帝国时代呢？</p><p>首先，我们知道，即使是在 NAN 的开发方式下，一次编写好的代码在不同版本的 Node.js 下也需要重新编译，否则版本不符的话 Node.js 无法正常载入一个 C++ 扩展。即一次编写，到处编译。</p><p>而 N-API 相较于 NAPI 来说，它把 Node.js 的所有底层数据结构全部黑盒化，抽象成 N-API 当中的接口。</p><p>不同版本的 Node.js 使用同样的接口，这些接口是稳定地 ABI 化的，即应用二进制接口（Application Binary Interface）。这使得在不同 Node.js 下，只要 ABI 的版本号一致，编译好的 C++ 扩展就可以直接使用，而不需要重新编译。事实上，在支持 N-API 接口的 Node.js 中，的确就指定了当前 Node.js 所使用的 ABI 版本。</p><p>为了使得以后的 C++ 扩展开发、维护更方便，N-API 致力于以下的几个目标：</p><ul><li>以 C 的风格提供稳定 ABI 接口；</li><li>消除 Node.js 版本的差异；</li><li>消除 JavaScript 引擎的差异（如 Google V8、Microsoft ChakraCore 等）。</li></ul><p>而这些 API 主要就是用来创建和操作 JavaScript 的值了，我们就再也不用直接使用 Google V8 提供的数据类型了。毕竟在 NAN 中，就算我们有时候看不到 Google V8 的影子，实际上在宏展开后还是无数的 Google V8 数据结构。</p><p>为了达成上述隐藏的目标，N-API 的姿势就变成了这样：</p><ul><li>提供头文件 <strong>node_api.h</strong>；</li><li>任何 N-API 调用都返回一个 <code>napi_status</code> 枚举，来表示这次调用成功与否；</li><li>N-API 的返回值由于被 <code>napi_status</code> 占坑了，所以真实返回值由传入的参数来继承，如传入一个指针让函数操作；</li><li>所有 JavaScript 数据类型都被黑盒类型 <code>napi_value</code> 封装，不再是类似于 <code>v8::Object</code>、<code>v8::Number</code> 等类型；</li><li>如果函数调用不成功，可以通过 <code>napi_get_last_error_info</code> 函数来获取最后一次出错的信息。</li></ul><blockquote><p><strong>注意：</strong>哪怕是现在的 Node.js v8.x 版本，N-API 仍处于一个实验状态，个人认为还有非常长的一段路要走，所以大家在生产环境中还不必太过于激进，不过 N-API 依然是大势所趋；不过对于使用老版本的 Node.js 开发者来说，大家也不要着急，即使 N-API 是在 v8.x 才正式集成进 Node.js，在其它旧版本的 Node.js 中依然可以将 N-API 作为外挂式的头文件9中使用，只不过无法做到跨版本的特性，这只是它做的向后兼容的一个事情而已。</p></blockquote><p>关于 N-API 一系列的函数可以访问它的<a href="https://nodejs.org/docs/v8.0.0/api/n-api.html" target="_blank" rel="external">文档</a>了解更多详情，现在我们来点料儿让大家对 N-API 的印象不是那么抽象。</p><h4 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h4><p>在封建时代和 NAN 所处的，模块的初始化是交给 Node.js 提供的宏来实现的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NODE_MODULE(addon, Init)</span><br></pre></td></tr></table></figure><p>而到了当前的 N-API，它就变成了 N-API 的一个宏了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAPI_MODULE(addon, Init)</span><br></pre></td></tr></table></figure><p>相应地，这个初始化函数 <code>Init</code> 的写法也会有所改变。比如这是封建时代和 NAN 时代的两种不同写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"echo"</span>, Echo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NAN 写法</span></span><br><span class="line">NAN_MODULE_INIT(Init)</span><br><span class="line">&#123;</span><br><span class="line">    Nan::Set(</span><br><span class="line">        target,</span><br><span class="line">        Nan::New&lt;String&gt;(<span class="string">"echo"</span>).ToLocalChecked(),</span><br><span class="line">        Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Echo)).ToLocalChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而到了 N-API 的时候，这个 <code>Init</code> 函数就该是这样的了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(napi_env env, napi_value exports, napi_value <span class="keyword">module</span>, <span class="keyword">void</span>* priv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于设置 exports 对象的描述结构体</span></span><br><span class="line">    napi_property_descriptor desc =</span><br><span class="line">        &#123; <span class="string">"echo"</span>, <span class="number">0</span>, Echo, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, napi_default, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 "echo" 设置到 exports 去</span></span><br><span class="line">    status = napi_define_properties(env, exports, <span class="number">1</span>, &amp;desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>napi_property_descriptor</code> 是用于设置对象属性的描述结构体，它的声明如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* utf8name;</span><br><span class="line"></span><br><span class="line">  napi_callback method;</span><br><span class="line">  napi_callback getter;</span><br><span class="line">  napi_callback setter;</span><br><span class="line">  napi_value value;</span><br><span class="line"></span><br><span class="line">  napi_property_attributes attributes;</span><br><span class="line">  <span class="keyword">void</span>* data;</span><br><span class="line">&#125; napi_property_descriptor;</span><br></pre></td></tr></table></figure><p>那么上面 <code>Init</code> 函数中的 <code>desc</code> 意思就是，即将被挂在的对象下会挂一个叫 <code>&quot;echo&quot;</code> 的东西，它的函数是 <code>Echo</code>，其它的 <code>getter</code>、<code>setter</code> 等全是空指针，而属性则是 <code>napi_default</code>。</p><blockquote><p><code>napi_property_attributes</code> 除了 <code>napi_default</code> 之外，还有诸如只读、是否可枚举等属性。</p></blockquote></blockquote><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>还记得之前的两种函数声明吗？第三次再搬过来。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure><p>在 N-API 中，你不用再被告知需要有 C++ 基础，C 即可。因为在 N-API 里面，声明一个 <code>Echo</code> 是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">napi_value <span class="title">Echo</span><span class="params">(napi_env env, napi_callback_info info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    napi_value argv[<span class="number">1</span>];</span><br><span class="line">    status = napi_get_cb_info(env, info, &amp;argc, argv, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(status != napi_ok || argc &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        napi_throw_type_error(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// napi_value 实际上是一个指针，返回空指针表示无返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> argv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>重要：</strong>目前 8.0.0 和 8.1.0 版本的 Node.js 官方文档中，关于 N-API 的各种接口文档错误颇多，所以还是要以能使用的接口为准。</p><p>而且现在大家也有很多人正在帮忙一起修复文档。例如现在的 JavaScript 函数声明返回值其实是 <code>napi_value</code>，而官方文档上还是老旧的 <code>void</code>。又比如 <code>`napi_property_descriptor_desc</code> 结构体中，在 <code>utf8name</code> 之后还有一个 <code>napi_value</code> 的变量，而文档中却是没有的。</p><p>这也是为什么我前面强调目前来说 N-API 还处于试验阶段。毕竟 API 并没有完全稳定下来，还处于一个快速迭代的步伐中，文档的更新并未跟上代码的更新。至少在笔者写作的当前是这样的（现在日期 2017 年 6 月 9 日）。</p></blockquote><p>上面代码分步解析。</p><ul><li>通过 <code>napi_get_cb_info</code> 获取当次函数请求的参数信息，包括参数数量和参数体（参数体以 <code>napi_value</code> 的数组形式体现）；</li><li>看看解析有无出错（<code>status</code> 不等于 <code>napi_ok</code>）或者看看参数数量是否小于 1；<ul><li>若解析出错或者参数数量小于 1，通过 <code>napi_throw_type_error</code> 在 JavaScript 层抛出一个错误对象，并返回；</li><li>若无错则继续进行；</li></ul></li><li>返回 <code>argv[0]</code>，即第一个参数。</li></ul><h4 id="Demo-完整代码"><a href="#Demo-完整代码" class="headerlink" title="Demo 完整代码"></a>Demo 完整代码</h4><p>这里放上这个 Echo 样例的完整代码，大家可以拿回家试试看。</p><h5 id="binding-gyp"><a href="#binding-gyp" class="headerlink" title="binding.gyp"></a>binding.gyp</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [ <span class="string">"addon.cc"</span> ],</span><br><span class="line">    <span class="attr">"cflags!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"cflags_cc!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"xcode_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"GCC_ENABLE_CPP_EXCEPTIONS"</span>: <span class="string">"YES"</span>,</span><br><span class="line">      <span class="attr">"CLANG_CXX_LIBRARY"</span>: <span class="string">"libc++"</span>,</span><br><span class="line">      <span class="attr">"MACOSX_DEPLOYMENT_TARGET"</span>: <span class="string">"10.7"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"msvs_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"VCCLCompilerTool"</span>: &#123; <span class="attr">"ExceptionHandling"</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="addon-cc"><a href="#addon-cc" class="headerlink" title="addon.cc"></a>addon.cc</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">Echo</span><span class="params">(napi_env env, napi_callback_info info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    napi_value argv[<span class="number">1</span>];</span><br><span class="line">    status = napi_get_cb_info(env, info, &amp;argc, argv, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(status != napi_ok || argc &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        napi_throw_type_error(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line">        status = napi_get_undefined(env, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> argv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(napi_env env, napi_value exports, napi_value <span class="keyword">module</span>, <span class="keyword">void</span>* priv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line">    napi_property_descriptor desc =</span><br><span class="line">        &#123; <span class="string">"echo"</span>, <span class="number">0</span>, Echo, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, napi_default, <span class="number">0</span> &#125;;</span><br><span class="line">    status = napi_define_properties(env, exports, <span class="number">1</span>, &amp;desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAPI_MODULE(addon, Init)</span><br></pre></td></tr></table></figure><h4 id="乘风破浪"><a href="#乘风破浪" class="headerlink" title="乘风破浪"></a>乘风破浪</h4><p>在完成了代码之后，大家赶紧试一下代码吧。</p><p>首先在 Node.js v8.x 下进行试验，把这两段代码分别放到同一个目录下，命名好后，执行这样的终端命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node-gyp rebuild</span><br><span class="line">...</span><br><span class="line">$ node --napi-modules</span><br><span class="line">(node:52264) Warning: N-API is an experimental feature and could change at any time</span><br><span class="line">&gt; const addon = require(<span class="string">"./build/Release/addon"</span>);</span><br><span class="line">undefined</span><br><span class="line">&gt; addon.echo(<span class="string">"2333"</span>);</span><br><span class="line"><span class="string">'2333'</span></span><br><span class="line">&gt; addon.echo(<span class="string">"蛋花汤🐶"</span>, <span class="string">"南瓜饼🐱"</span>);</span><br><span class="line"><span class="string">'蛋花汤🐶'</span></span><br><span class="line">&gt; addon.echo();</span><br><span class="line">TypeError: Wrong number of arguments</span><br><span class="line">    at repl:1:7</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:44:33)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:239:29)</span><br><span class="line">    at bound (domain.js:301:14)</span><br><span class="line">    at REPLServer.runBound [as <span class="built_in">eval</span>] (domain.js:314:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:433:10)</span><br><span class="line">    at emitOne (events.js:120:20)</span><br><span class="line">    at REPLServer.emit (events.js:210:7)</span><br><span class="line">    at REPLServer.Interface._onLine (readline.js:278:10)</span><br><span class="line">    at REPLServer.Interface._line (readline.js:625:8)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>还是因为试验特性，目前在 Node.js v8.x 要加载和执行 N-API 的 C++ 扩展的话，在启动 <code>node</code> 的时候需要加上 <code>--napi-modules</code> 参数，表示这次执行要启用 N-API 特性。</p></blockquote><p>效果显而易见，在刚启动 Node.js REPL 的时候，你会得到一个警告。</p><blockquote><p>(node:52264) Warning: N-API is an experimental feature and could change at any time</p></blockquote><p>表示它目前还不是特别稳定，但是值得我们展望未来。然后在我们 <code>require()</code> 扩展的时候，我们就得到了一个拥有 <code>echo</code> 函数的对象了。</p><p>我们尝试了三种调用方式。第一次是规规矩矩传入一个参数，<code>echo</code> 如期返回我们传入的参数 <code>&quot;2333&quot;</code>；第二次传入两个参数，<code>echo</code> 返回了第一个参数 <code>&quot;蛋花汤🐶&quot;</code>；最后一次我们没传任何参数，这个时候就走到了 C++ 扩展中判断函数参数数量失败的条件分支，就抛出了一个 <code>Wrong number of arguments</code> 的错误对象。</p><p>总之，它按照我们的预期跑起来了。并且代码里面并没有任何 Node.js 非 N-API 所暴露出来的数据结构和 V8 的数据结构——版本差异消除了。</p><p>接下来激动人心的时刻到了，如果读者是使用 <code>nvm</code> 来管理自己的 Node.js 版本的话，可以尝试着安装一个 8.1.0 的 Node.js 版本。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nvm install 8.1.0</span><br></pre></td></tr></table></figure><p>在安装成功切换版本成功后，尝试着直接打开 Node.js RELP，忘掉再次编译刚才编译好的扩展这一步。（不过别忘了 <code>--napi-module</code> 参数）</p><p>把刚才用于测试的几句 JavaScript 代码再重复地输入——N-API 诚不我欺，居然还是能输出结果。这对于以前的暴力做法和 NAN 做法来说，无疑是非常大的一个进步。</p><h4 id="向下兼容"><a href="#向下兼容" class="headerlink" title="向下兼容"></a>向下兼容</h4><p>至此，我希望大家还没有忘记 N-API 是自 Node.js 8.0 之后出的特性。所以之前 Demo 的代码并不能在 Node.js 8.0 之前的版本如期编译和运行。</p><p>辛辛苦苦写好的包，居然不能在 Node.js 6.x 下面跑，搞什么。</p><p><img src="http://images.gitbook.cn/25ae5fa0-4cf6-11e7-92f5-09e07d17628a" alt="当时我就不乐意了"></p><p>先别急着摔。文中之前也说了，有一个外挂式头文件的包，其包名是 <code>node-addon-api</code>。</p><p>我们就试着通过它来进行向下兼容吧。首先在我们刚才的源码目录把这个包给安装上。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --save node-addon-api</span><br></pre></td></tr></table></figure><blockquote><p>还是由于快速迭代的原因，我不能保证这个包当前版本的时效性，不过我相信大家都有探索精神，在未来版本不符导致的 API 不符的问题应该都能解决。</p></blockquote><p>然后，给我们的 <strong>binding.gyp</strong> 函数加点料，加两个字段，里面是两个指令展开。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"include_dirs": [ "&lt;!@(node -p \"require('node-addon-api').include\")" ],</span><br><span class="line">"dependencies": [ "&lt;!(node -p \"require('node-addon-api').gyp\")" ]</span><br></pre></td></tr></table></figure><p><code>&lt;!@</code> 和 <code>&lt;!</code> 开头的字符串在 GYP 中代表指令，表示它的值是后面的指令的执行结果。上面两条指令的返回结果分别是外挂式头文件的头文件搜索路径，以及外挂式 N-API 这个包编译成静态连接库供我们自己的包使用的依赖声明。</p><p>有了这两个字段后，就表示我们依赖了外挂式 N-API 头文件。而且它内部自带判断，如果版本已经达到了有 N-API 的要求，它的依赖就会是一个空依赖，即不依赖外挂式 N-API 编译的静态连接库。</p><p><strong>也就是说，用了外挂式的 N-API，能自动适配 Node.js 8.x 和低版本。</strong></p><p>于是这个 <strong>binding.gyp</strong> 现在看起来是这样子的。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [ <span class="string">"addon.cc"</span> ],</span><br><span class="line">    <span class="attr">"cflags!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"cflags_cc!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"xcode_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"GCC_ENABLE_CPP_EXCEPTIONS"</span>: <span class="string">"YES"</span>,</span><br><span class="line">      <span class="attr">"CLANG_CXX_LIBRARY"</span>: <span class="string">"libc++"</span>,</span><br><span class="line">      <span class="attr">"MACOSX_DEPLOYMENT_TARGET"</span>: <span class="string">"10.7"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"msvs_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"VCCLCompilerTool"</span>: &#123; <span class="attr">"ExceptionHandling"</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"include_dirs"</span>: [ <span class="string">"&lt;!@(node -p \"require('node-addon-api').include\")"</span> ],</span><br><span class="line">    <span class="attr">"dependencies"</span>: [ <span class="string">"&lt;!(node -p \"require('node-addon-api').gyp\")"</span> ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于源码层面，我们就不需要作任何修改。在 Node.js v6.x 下面试试看吧。同样是使用 <strong>node-gyp rebuild</strong> 进行编译。然后通过 Node.js REPL 进去测试。</p><p>具体的终端输出这里就不放出来了，相信经过实验的大家都得到了自己想要的结果。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次内容主要讲解了在 Node.js 领域中原生 C++ 模块开发的方式变迁。</p><ul><li>从 node-waf 到 node-gyp，这是构建工具的一个变迁，未来说不定会是 GN 或者其它的构建工具。</li><li>从暴力写码，到 NAN 的出现，见证了 Node.js 社区的各种爱恨情仇，一直到现在的新生儿 N-API，为原生 C++ 模块的开发输送了新鲜的血液。</li></ul><p>目前的中坚力量仍然是 NAN 的开发方式，甚至我猜测是否未来有可能 NAN 会提供关于 N-API 的各种宏封装，使其彻底消除版本差异，包括 ABI 版本上的差异。当然这种 ABI 版本差异导致的需要多次编译问题应该还是存在的，这里指的是一次编码的差异。</p><p>在大家跟着本文对 N-API 进行了一次浅尝辄止的尝试之后，希望能对当下仍然处于实验状态的 N-API 充满了希冀，并对现在存在的各种坑处以包容的心态。</p><p>毕竟，Node.js loves you all。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>「Consider moving from gyp to gn」：<a href="https://github.com/nodejs/node/issues/6089" target="_blank" rel="external">https://github.com/nodejs/node/issues/6089</a></li><li>「Getting Started with Embedding · v8/v8 Wiki」：<a href="https://github.com/v8/v8/wiki/Getting-Started-with-Embedding" target="_blank" rel="external">https://github.com/v8/v8/wiki/Getting-Started-with-Embedding</a></li><li>「Drop support for v0.10 and v0.12?」：<a href="https://github.com/nodejs/nan/issues/676" target="_blank" rel="external">https://github.com/nodejs/nan/issues/676</a></li><li>「Node Loves Rust」：<a href="https://cnodejs.org/topic/593353775b07c1b24afa0638" target="_blank" rel="external">https://cnodejs.org/topic/593353775b07c1b24afa0638</a></li><li>「N-API | Node.js v8.0.0 Documentation」：<a href="https://nodejs.org/docs/v8.0.0/api/n-api.html" target="_blank" rel="external">https://nodejs.org/docs/v8.0.0/api/n-api.html</a></li><li>「doc: fix out of date sections in n-api doc」：<a href="https://github.com/nodejs/node/pull/13508" target="_blank" rel="external">https://github.com/nodejs/node/pull/13508</a></li></ul><p>[^1]: 用于定义某种文件类型的特殊标识，详见 <a href="https://en.wikipedia.org/wiki/Magic_number_(programming" target="_blank" rel="external">https://en.wikipedia.org/wiki/Magic_number_(programming</a>)<br>[^2]: 代码参见 <a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2427-L2502" target="_blank" rel="external">https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2427-L2502</a><br>[^3]: 年久失修，当前 NPM 上搜索到的 node-waf 已经不是当年的了，不过这个是 Waf 的官方仓库 <a href="https://github.com/waf-project/waf。" target="_blank" rel="external">https://github.com/waf-project/waf。</a><br>[^4]: 全称 Generate Your Projects，是谷歌开发的一套构建系统，未尽事宜详询 <a href="https://gyp.gsrc.io。" target="_blank" rel="external">https://gyp.gsrc.io。</a><br>[^5]: GYP 的配置文件的后缀就是 <em>.gyp 或者 </em>.gypi 等，是个类 JSON 文件。<br>[^6]: GN 是谷歌开发的相较于 GYP 更新更快的一套构建工具，可以参考 <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/HEAD/docs/quick_start.md" target="_blank" rel="external">https://chromium.googlesource.com/chromium/src/tools/gn/+/HEAD/docs/quick_start.md</a><br>[^7]: 让垃圾回收机制来管理 JavaScript 对象生命周期的一种类，即 HandleScope，在我的新书中将会有详解。<br>[^8]: Node.js 的异步事件循环支撑者，详询 <a href="http://www.libuv.org/" target="_blank" rel="external">http://www.libuv.org/</a><br>[^9]: 详情请查看 node-api 这个包，<a href="https://github.com/nodejs/node-api" target="_blank" rel="external">https://github.com/nodejs/node-api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文由我首发于 &lt;a href=&quot;http://gitbook.cn/books/5938f4ae8b55d47644b7a445/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitChat&lt;/a&gt; 中。&lt;
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="NAPI" scheme="https://xcoder.in/tags/NAPI/"/>
    
  </entry>
  
  <entry>
    <title>Byakuren：一个 C 实现的主题色提取库</title>
    <link href="https://xcoder.in/2017/03/03/byakuren/"/>
    <id>https://xcoder.in/2017/03/03/byakuren/</id>
    <published>2017-03-03T10:14:35.000Z</published>
    <updated>2017-12-11T07:59:20.462Z</updated>
    
    <content type="html"><![CDATA[<p>好久没发文章了，借着 Byakuren 开源的档口炒炒冷饭吧。</p><p>先上 Repo 地址：<a href="https://github.com/XadillaX/byakuren" target="_blank" rel="external">https://github.com/XadillaX/byakuren</a>。</p><h2 id="主题色"><a href="#主题色" class="headerlink" title="主题色"></a>主题色</h2><p>图像主题色是从一张图像中提取出来最能代表这张图片主色调的多种颜色。 也就是说在一幅色彩斑斓的图片里面，各种不同颜色的数量就对应着该颜色在图 片中的比例，程序可以通过计算图片中不同颜色的像素数来算出主题色。</p><h3 id="主题色提取算法"><a href="#主题色提取算法" class="headerlink" title="主题色提取算法"></a>主题色提取算法</h3><p>提取的算法在我之前的博客中有说明。在 Byakuren 中其实用的就是之前博客中讲的一些算法。</p><ul><li><a href="https://xcoder.in/2014/09/17/theme-color-extract/#八叉树提取法">八叉树提取法</a></li><li><a href="https://xcoder.in/2014/09/17/theme-color-extract/#最小差值法">最小差值法</a></li></ul><p>除去上面两种算法，Byakuren 还提供了将这两种算法结合起来的 Mix 算法。</p><h2 id="Byakuren"><a href="#Byakuren" class="headerlink" title="Byakuren"></a>Byakuren</h2><p>Byakuren 是我前两年写的一个主题色提取库，也是继 <a href="https://github.com/XadillaX/thmclrx/tree/e302b61b4cc70b24efa35c612899cc0b79d271f9" target="_blank" rel="external">thmclrx</a> 之后的 C 版实现，个人认为代码质量比旧版的 thmclrx 要高。并且它实际上经过了企业级的验证，在某相关的公司已经欢快跑了有些年头了。</p><blockquote><p>在经过相关人员的同意下，我也算把这雪藏了好久的代码给开源出来了。</p></blockquote><h3 id="伪·Byakuren-是什么？"><a href="#伪·Byakuren-是什么？" class="headerlink" title="伪·Byakuren 是什么？"></a>伪·Byakuren 是什么？</h3><p><img src="byakuren.png" alt="byakuren"></p><blockquote><p>聖 白蓮（ひじり びゃくれん，Hiziri Byakuren）是系列作品《东方 project》中的角色，首次登场于《东方星莲船》。</p><ul><li>种族：魔法使</li><li>能力：使用魔法程度的能力（酣畅增强身体能力的）</li><li>危险度：不明</li><li>人类友好度：中</li><li>主要活动场所：命莲寺之类</li><li>命莲寺的住持。虽然原本是人类，不过由于常年的修行已经完全超越了人类。现在已经属于人们常说的魔法使了。</li></ul><p>虽然已经入了佛门，但是不知道什么原因却被妖怪敬仰着。她从来没有像童话故事中的魔法使那样，念诵着咒语治退妖怪。使用的力量完全是邪恶的，一点都不像是圣人，虽然并没有人目击到她与人类为敌，但其实已彻底成为妖怪的同伴了。</p></blockquote><p>好吧，总之本人是个东方控，所以基本上项目名都跟东方有关。</p><h3 id="真·Byakuren-是什么？"><a href="#真·Byakuren-是什么？" class="headerlink" title="真·Byakuren 是什么？"></a>真·Byakuren 是什么？</h3><p>如文章题目所说，它是一个 C 实现的开源主题色提取的库，大家可以把它编译成链接库使用。</p><p>不过目前暂时只支持 Makefile 的形式来编译，大家如果有兴趣也可以自己建个 Windows 下的 Visual Studio 项目等，也欢迎提类似于 CMake 之类的 PR。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>其实详细的使用方法在<a href="https://github.com/XadillaX/byakuren#byakuren" target="_blank" rel="external">文档</a>中就有说明。</p><p>不过这里还是简单介绍一下吧。</p><h4 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h4><p>先把代码给下下来，你也可以把它 Clone 下来。总之仓库地址是：<a href="https://github.com/XadillaX/byakuren" target="_blank" rel="external">https://github.com/XadillaX/byakuren</a>。</p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>然后跑到目录下执行 <code>make</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make byakuren</span><br></pre></td></tr></table></figure><p>你将得到一个 <code>byakuren.a</code> 的静态链接库。</p><p>这个时候你只要拿着这个静态链接库，然后顺便在你的项目中把头文件引进来就可以了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"byakuren.h"</span></span></span><br></pre></td></tr></table></figure><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>我们假设你有 <code>bkr_rgb* rgb</code> 的图片像素信息，以及 <code>uint32_t color_count</code> 的图片像素总数两个变量，下面分别给出三个样例。具体的 API 解析还请去文档观摩。</p><h5 id="Octree"><a href="#Octree" class="headerlink" title="Octree"></a>Octree</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bkr_color_stats stats[<span class="number">256</span>];</span><br><span class="line">bkr_octree_node* root = bkr_build_octree(rgb, color_count, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">int</span> colors = bkr_octree_calculate_color_stats(root, stats);</span><br><span class="line">bkr_release_octree(root);</span><br></pre></td></tr></table></figure><blockquote><p><code>colors</code> 就是主题色数量了，传进去的 <code>stats</code> 就会接收到主题色的具体信息了。</p></blockquote><h5 id="Min-diff"><a href="#Min-diff" class="headerlink" title="Min-diff"></a>Min-diff</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bkr_color_stats stats[<span class="number">256</span>];</span><br><span class="line">bkr_mindiff_parameter param;</span><br><span class="line">param.gray_offset = <span class="number">5</span>;</span><br><span class="line">param.palette = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> colors = bkr_mindiff_calculate_color_stats(rgb, color_count, stats, &amp;param);</span><br></pre></td></tr></table></figure><blockquote><p><code>colors</code> 和 <code>stats</code> 如上所述。</p></blockquote><h5 id="Mix"><a href="#Mix" class="headerlink" title="Mix"></a>Mix</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bkr_color_stats stats[<span class="number">256</span>];</span><br><span class="line">bkr_mindiff_parameter param;</span><br><span class="line">param.gray_offset = <span class="number">-1</span>;</span><br><span class="line">param.palette = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> colors = bkr_mix_calculate_color_stats(rgb, color_count, <span class="number">256</span>, &amp;param, stats);</span><br></pre></td></tr></table></figure><blockquote><p><code>colors</code> 和 <code>stats</code> 如上所述。</p></blockquote><h3 id="预览一下"><a href="#预览一下" class="headerlink" title="预览一下"></a>预览一下</h3><p>可能有人想看看效果，我这里就放个效果图给大家看看吧。</p><p>其中 Octree 和 Mix 两个算法的主题色最大数量参数传的都是 16。</p><p><img src="result.png" alt="效果预览"></p><h3 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h3><p>你可以拿它来写一些主题色提取的东西。</p><p>你也可以拿它来完成其它语言的主题色提取库的封装，如 Python、Lua 等等。欢迎反馈给我。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>把一份自己觉得还不错的代码开源出来的感觉特爽，尤其是这种重见天日的感觉。ﾍ|･∀･|ﾉ*~●</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没发文章了，借着 Byakuren 开源的档口炒炒冷饭吧。&lt;/p&gt;
&lt;p&gt;先上 Repo 地址：&lt;a href=&quot;https://github.com/XadillaX/byakuren&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://g
      
    
    </summary>
    
    
      <category term="C" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="主题色" scheme="https://xcoder.in/tags/%E4%B8%BB%E9%A2%98%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>死月的二零一六总结</title>
    <link href="https://xcoder.in/2016/12/31/my-2016/"/>
    <id>https://xcoder.in/2016/12/31/my-2016/</id>
    <published>2016-12-31T07:43:08.000Z</published>
    <updated>2017-12-11T07:59:20.521Z</updated>
    
    <content type="html"><![CDATA[<p>看了那么多总结，自己也总结一回吧，回顾一下这个即将过去的二零一六。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h3><ul><li>千岛湖</li><li>上海迪士尼</li><li>良渚文化村</li><li>南京</li><li>湖州</li><li>黄山</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>拿老爸的车练手，并习得一定的实战驾车经验；</li><li>买了个房，欠下一笔巨款，并开始吃圡；</li><li>玩了一段时间的守望屁股；</li><li>被入手一个定焦人像头；</li><li>尝试了几次租车 App，也算尝试过了力帆电动车和别克；</li><li>拿了个本子；</li><li>被入手 PS4；</li><li>减肥失败；</li><li>被我妈影响，一段时间沉迷唱歌，在某 K 歌 App 上有好多难听的作品；</li><li>一段时间沉迷乌克丽丽，后来不了了之；</li><li>一段时间沉迷配音，在某 App 上也有难听的作品；</li><li>周末基本上就是<strong><em>出去吃饭 + 看电视</em></strong>，单调而重复；</li><li>失去了以前追番的热情，写文章也少了以前卖萌的动力——果然老了么。</li></ul><h2 id="工作-amp-技术"><a href="#工作-amp-技术" class="headerlink" title="工作 &amp; 技术"></a>工作 &amp; 技术</h2><p>从 2015 年 9 月入职现东家大搜车已经一年多了，经历了公司 C 轮亿级刀的融资和新产品的发布，在今年也有几件令自己比较自豪和挫败的事。</p><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>这一块是在年底借着公司新产品「<a href="https://tangeche.com" target="_blank" rel="external">弹个车</a>」的东风才开始真正落地开来。其实这一块已经落后大厂好多个年代了——2014 年淘宝的中途岛方案以及 2015 年死马分享的天猫 Wormhole 方案。</p><p>一是因为在未分离的阶段我们公司前端还是以传统的 <strong>Java</strong> 方式开发，二是在分离的阶段直接上了 <strong>Vue</strong> 等框架，所以直接就跳过那一步了。</p><p>但是其实很多情况下都是 <strong>Vue</strong> 力所不能及的——比如既要考虑到首屏就渲染好的展示页但是又不想继续在传统 Web 开发的阴影下进行工作的时候。我相信就算在阿里也是为了解决这个问题的——<strong><em>让前端更专注前端，让后端更专注后端，让浏览器得到的还是传统的结果。</em></strong></p><p>项目在内部唤作 <a href="http://finalfantasy.wikia.com/wiki/Oerba_Dia_Vanille" target="_blank" rel="external"><strong>Vanille</strong></a>，第一个上线版本花了两周的时间，目前已正常服役于第一个项目「弹个车」。这算是我今年在公司做的最自豪的一件事之一了，<strong><em>终于推动了一次内部技术的发展。</em></strong></p><h3 id="大搜车商学院"><a href="#大搜车商学院" class="headerlink" title="大搜车商学院"></a>大搜车商学院</h3><p>从去年以项目经理的身份接了这个项目，经历了从无到有到三不管再到现在的平稳状态。今年年初的时候该项目经历了一段时间研发，成为了公司内第一个接入内部支付平台的项目，只不过后来运营的头儿走了后 O2O 的支付功能一直被雪藏了——一股挫败感油然而生。</p><p>到了快年底的时候终于来了一波小需求，接入了内部的搜索引擎和加了一波小需求。不过这段时间在忙别的事情，主要的开发任务交给了同事开发，而我就做一些 Code Review 和部署的工作。</p><p>期间也想把商学院给升格成一个公司内部统一的 CMS，后来因为一直没有落地实施和一直被调遣做其它的任务，所以到后面不了了之了——那段时间公司的 Noder 着实不够用。</p><p><strong><em>一开始不要把所有事情都想得面面俱到，很有可能是浪费你的精力和感情，在迭代速度非常快的互联网时代，快速出产品才是最重要的事。还要练就强大的内心来拥抱各种变化。</em></strong></p><h3 id="车牛"><a href="#车牛" class="headerlink" title="车牛"></a>车牛</h3><p>这是今年做的一些业务相关的事，挑重要的总结一下感想。</p><p>做得最久的就是两大期的订阅相关的需求了，其实有点像花瓣网的瀑布流关注，稍加改造即可。不过由于做了接盘侠，接手代码的时候看到的是一坨比较晦涩的诡异实现方法，经历了三期的全盘复刻及 Promise 替换，四期从头开始再实现，还是没能将其迁移成我心目中的那一套方法——<strong><em>技术债的还债成本总是大的，以及在线上跑了那么久的代码至少是稳定的，实现方案的改造的开发成本远大于代码层面重构的开发成本。</em></strong>综上所述，除了得出不要轻易重构旧代码的结论，还得出了<strong><em>「宁可一开始花更多的时间和设计去搞定一套东西，也不要在代码稳定线上跑了好久之后再重构它的实现方式——哪怕旧的方式是一坨屎」的结论。</em></strong></p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><h4 id="Toshihiko"><a href="#Toshihiko" class="headerlink" title="Toshihiko"></a>Toshihiko</h4><p>今年对 Toshihiko 主要只是修修补补。但是在 Node Party 第一次 Speak 之后，下定决心重构了一次 Toshihiko 的代码并且使其理论上支持了多适配器层。</p><blockquote><p><a href="https://github.com/XadillaX/Toshihiko" target="_blank" rel="external">Repo 地址</a></p></blockquote><h4 id="Aliyun-ONS"><a href="#Aliyun-ONS" class="headerlink" title="Aliyun ONS"></a>Aliyun ONS</h4><p>这个项目源自于去年我们 Node.js 团队要接其他团队的消息队列，而他们使用的是阿里云的 ONS。他们没有 Node.js 的 SDK，我们只能自给自足。</p><p>一开始用了一个比较脏的办法，使用他们的 PHP SDK 然后在项目中启动子进程与主进程进行通讯，逻辑放在主进程处理，而收发消息的任务则交给 PHP。</p><p>后来我毛了，于是自给自足，基于他们的 C++ SDK 自己封装了一个 Node.js 版本的 SDK。经过了几个大版本的迭代和性能优化，目前该 SDK 已经稳稳当当服役于大搜车半年多了，一直很稳定。</p><p>虽然阿里云一直说在出 Node.js 的 SDK，但是迟迟未见产出，我姑且也自豪一番吧。</p><blockquote><p><a href="https://github.com/XadillaX/aliyun-ons" target="_blank" rel="external">Repo 地址</a></p></blockquote><h4 id="Hua"><a href="#Hua" class="headerlink" title="Hua"></a>Hua</h4><p>这个项目是为了当时即将去「蘑菇鸡」的小龙童鞋写的，虽然他由于身体原因最后没去成。</p><p>主要用法就是能根据你的一些设定（比如金木水火土）然后随机一堆花名，供你在阿里等厂用——面向各种起名困难户。</p><blockquote><p><a href="https://github.com/BoogeeDoo/hua" target="_blank" rel="external">Repo 地址</a></p></blockquote><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><ul><li>冒着冲撞头哥的风险，不厌其烦在团队推行规范化（Git 和 Eslint 等），终于出了一些成效；</li><li>去 <a href="http://2016.jsconf.cn/" target="_blank" rel="external">NingJS</a> 转了一圈；</li><li>推行并维护了公司内部的 NPM 仓库；</li><li>跟着头哥举办了几次 <a href="https://github.com/hangzhou-node-party" target="_blank" rel="external">Node Party</a>，并贡献了一个 Topic——「<a href="http://htmljs.b0.upaiyun.com/uploads/1470619563805-083e5543293c4da9f6c1d489d6010e60.pdf" target="_blank" rel="external">About Node.js ORM</a>」；</li><li>周末无聊写了点小外快，并 Get 了一些新技能，如 GIF 格式解析、Chrome 插件开发等；</li><li>给博客写了个新皮；</li><li>内推了几个新同事，虽然一个最后没算到我头上；</li><li>就 Vuex / MySQL /「callback 与 Promise 与 yield」等撕了好多场无意义的逼；</li><li>多次重启并弃坑新版 NOJ 的开发，最终都无果。</li></ul><p>除了上述的一些事情外，还收获了最重要的一点——<strong><em>不再像以前一样只无脑关心技术本身，而是更多地去思考技术之外的事，对待旧的代码更宽容了。</em></strong></p><p>不过纯技术方面来说，感觉还是到达一定瓶颈了。</p><h2 id="展望二〇一七"><a href="#展望二〇一七" class="headerlink" title="展望二〇一七"></a>展望二〇一七</h2><p>最后列出一些明年想做的事情。</p><ol><li>至少出境游玩一次；</li><li>改变周末的习惯，对生活更积极一些；</li><li>买车（感觉这点可以改变上点）；</li><li>想写一本书，并付诸实践；</li><li>通关更多的游戏；</li><li>再还一部分首付；</li><li>苦练摄影技术；</li><li>赚更多钱，不要像现在一样花得憋屈；</li></ol><p><img src="flandre.jpeg" alt="芙兰"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了那么多总结，自己也总结一回吧，回顾一下这个即将过去的二零一六。&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;h3 id=&quot;足迹&quot;&gt;&lt;a href=&quot;#足迹&quot; class=
      
    
    </summary>
    
    
      <category term="总结" scheme="https://xcoder.in/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2016" scheme="https://xcoder.in/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>跟我一起部署和定制 CNPM——自定义包存储层</title>
    <link href="https://xcoder.in/2016/07/22/lets-cnpm-storage/"/>
    <id>https://xcoder.in/2016/07/22/lets-cnpm-storage/</id>
    <published>2016-07-22T06:23:01.000Z</published>
    <updated>2017-12-11T07:59:20.519Z</updated>
    
    <content type="html"><![CDATA[<p>CNPM 的自定义包存储层文件系统简称 NFS，我猜是 NPM File System 的意思。</p><p>在之前《<a href="https://xcoder.in/2016/07/09/lets-cnpm-base-deploy/">跟我一起部署和定制 CNPM——基础部署</a>》中提到过，CNPM 配置项里面有一项配置 <code>nfs</code>，它所对应的是一个 NFS 对象。</p><p>在同步 package 的时候，CNPM 会把源站的包下载到本地，然后传给 NFS 对象相应的函数交予去处理，由 NFS 对象返回处理结束之后该包在我们自己部署的 CNPM 对应的包下载链接。</p><p>上面的这一套流程就给我们自定义包存储提供了可能，比如我们可以把包同步到又拍云存储、阿里云 OSS 等地方去，也可以以二进制的形式存入我们自己的数据库（不推荐），甚至可以什么都不用做直接放在本地，然后把本地文件对外网暴露即可。</p><h2 id="NFS-接口"><a href="#NFS-接口" class="headerlink" title="NFS 接口"></a>NFS 接口</h2><p>NFS 的接口是实现定义好的，我们如果要写一个自己的 NFS 类，只需要按照约定的接口实现他们的逻辑即可。</p><blockquote><p>虽然我自己不喜欢，但是 NFS 的所有函数需要在菊花函数中被实现。</p></blockquote><p>下面给出接口的定义：</p><ul><li><code>function* upload(filepath, options)</code><ul><li><code>filepath</code>：文件路径。</li><li><code>options</code><ul><li><code>key</code>：待上传文件的标识</li><li><code>size</code>：待上传文件大小</li></ul></li></ul></li><li><code>function* uploadBuffer(fileBuffer, options)</code><ul><li><code>fileBuffer</code>：待上传文件的 Buffer</li><li><code>options</code><ul><li><code>key</code>：待上传文件的标识</li><li><code>size</code>：待上传文件的大小</li></ul></li></ul></li><li><code>function* remove(key)</code><ul><li><code>key</code>: 文件标识</li></ul></li><li><code>function* download(key, savePath, options)</code>（可选实现）<ul><li><code>key</code>：文件标识</li><li><code>savePath</code>：保存路径</li><li><code>options</code><ul><li><code>timeout</code>：超时时间</li></ul></li></ul></li><li><code>function* createDownloadStream(key, options)</code>（可选实现）<ul><li><code>key</code>: 文件标识</li><li><code>options</code><ul><li><code>timeout</code>：超时时间</li></ul></li><li>返回一个 <code>ReadStream</code></li></ul></li><li><code>function[*] url(key)</code>（可选实现，可以不是菊花函数）<ul><li><code>key</code>: 文件标识</li></ul></li></ul><h2 id="OSS-CNPM-解析"><a href="#OSS-CNPM-解析" class="headerlink" title="OSS-CNPM 解析"></a>OSS-CNPM 解析</h2><p>这里拿出一个 NFS 的官方实现阿里云 OSS 版来作为解析。它的 Repo 是 <a href="https://github.com/cnpm/oss-cnpm" target="_blank" rel="external">https://github.com/cnpm/oss-cnpm</a>。</p><p>打开 <a href="https://github.com/cnpm/oss-cnpm/tree/2.1.0/index.js" target="_blank" rel="external">index.js</a> 我们能看到，的确 <code>OssWrapper</code> 实现了上面的一些接口。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 <code>function OssWrapper</code> 里面我们看到它 <code>new</code> 了 <a href="https://github.com/aliyun/oss-nodejs-sdk" target="_blank" rel="external">ali-oss</a> 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.cluster) &#123;</span><br><span class="line">  options.schedule = options.schedule || <span class="string">'masterSlave'</span>;</span><br><span class="line">  <span class="keyword">this</span>.client = <span class="keyword">new</span> oss.ClusterClient(options);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.client = oss(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说在各种上传等函数里面都是以这个 <code>client</code> 为主体做的事情的。</p><h3 id="upload-和-uploadBuffer"><a href="#upload-和-uploadBuffer" class="headerlink" title="upload 和 uploadBuffer"></a>upload 和 uploadBuffer</h3><p>首先我们看看 <code>upload</code> 函数，从外部传进来文件的 <code>key</code>，NFS 对象将该文件以 <code>key</code> 为名传到 OSS 去，并返回该文件上传之后在 OSS 上的地址。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proto.upload = <span class="function"><span class="keyword">function</span>* (<span class="params">filePath, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = trimKey(options.key);</span><br><span class="line">  <span class="comment">// https://github.com/ali-sdk/ali-oss#putname-file-options</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="keyword">this</span>.client.put(key, filePath, &#123;</span><br><span class="line">    <span class="attr">headers</span>: <span class="keyword">this</span>._defaultHeaders,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._mode === <span class="string">'public'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">url</span>: result.url &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">key</span>: key &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>uploadBuffer</code> 其实也一样，参数第一个 <code>fileBuffer</code> 是一个文件二进制 Buffer 对象，而 <code>ali-oss</code> 包的 <code>put</code> 函数第二个参数既可以传一个文件路径，也可以传一个 Buffer，所以相当于把 <code>upload</code> 这个函数直接拿过来就能用了，于是就有了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proto.uploadBuffer = proto.upload;</span><br></pre></td></tr></table></figure><h3 id="remove、download-和-createDownloadStream"><a href="#remove、download-和-createDownloadStream" class="headerlink" title="remove、download 和 createDownloadStream"></a>remove、download 和 createDownloadStream</h3><p>这两个函数实际上也是直接调用了 <code>ali-oss</code> 的函数，并没有什么好讲的，大家自己看看就好了。</p><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>这个函数无非就是判断下有没有自定义的 CDN 域名什么的，根据不同的返回不同的网址而已。</p><h3 id="trimKey"><a href="#trimKey" class="headerlink" title="trimKey"></a>trimKey</h3><p>把 <code>key</code> 里面带的最前面的斜杠去掉。</p><h2 id="我的-OSS-CNPM-随意改造"><a href="#我的-OSS-CNPM-随意改造" class="headerlink" title="我的 OSS-CNPM 随意改造"></a>我的 OSS-CNPM 随意改造</h2><p>上面一节解析了 <code>oss-cnpm</code> 这个包的代码，如果官方出的几个 NFS 包不能满足，大家也能自己去写一个 CNPM 存储层的包了。</p><p>我们公司的包是直接在 OSS 上面的，所以用 <code>oss-cnpm</code> 并没有什么不妥。</p><p>不过对于阿里系本身的公司门来说，OSS 并不是什么大事儿，对于我们来说，OSS 的 bucket 资源还是蛮稀缺的，上次就达到上限了。所以我们目前的 NPM 包跟公司别的测试业务用的是同一个 bucket。</p><p>那么问题来了：</p><p><strong><code>oss-cnpm</code> 直接把所有文件放在根目录下建文件夹，太乱了，而且的确是有小可能冲突的。而这个包又不能让人自定义前缀什么什么的。</strong></p><p>于是我就自己 Fork 小小改装了一下这个包，让它适合我们公司自己。</p><p>改装很简单，在上传的目录中加一个文件夹前缀。</p><p>动的是 <code>trimKey</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trimKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'_snpm_/'</span> + (key ? key.replace(<span class="regexp">/^\//</span>, <span class="string">''</span>) : <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下所有在我们内部 CNPM 里面的包的链接都多了个 <code>_snpm_/</code> 的前缀了。</p><h2 id="CNPM-调用解析"><a href="#CNPM-调用解析" class="headerlink" title="CNPM 调用解析"></a>CNPM 调用解析</h2><p>上面解析了接口之后，我们来扒一扒什么时候会调用上面实现的接口们吧，这样就知道 CNPM 对于 NFS 使用的工作原理了。</p><h3 id="controllers-registry-package-download-js"><a href="#controllers-registry-package-download-js" class="headerlink" title="controllers/registry/package/download.js"></a>controllers/registry/package/download.js</h3><blockquote><p><a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/registry/package/download.js" target="_blank" rel="external">源码参考</a></p></blockquote><p>对于包下载来说，它的路由是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;package&#125;/download/&#123;package&#125;-&#123;version&#125;.tgz</span><br></pre></td></tr></table></figure><p>然后在里面判断一下如果 NFS 对象有实现 <code>url()</code> 函数的话，先用 <code>url()</code> 函数生成对该包而言的真实下载链接。</p><p>读出这个包的 registry 信息，里面如果没有 <code>dist</code> 等参数的话直接 302 到刚生成的地址去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> nfs.url === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (is.generatorFunction(nfs.url)) &#123;</span><br><span class="line">    url = <span class="keyword">yield</span> nfs.url(common.getCDNKey(name, filename));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url = nfs.url(common.getCDNKey(name, filename));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!row || !row.package || !row.package.dist) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span>* next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="number">302</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'Location'</span>, url);</span><br><span class="line">  _downloads[name] = (_downloads[name] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下去是涉及到上一章没有提到过的一个配置参数，叫 <code>downloadRedirectToNFS</code>，默认为 <code>false</code>。如果该值为 <code>true</code> 的话并且刚才由 <code>url()</code> 函数生成了下载链接的话，也是直接 302 到真实下载链接去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.downloadRedirectToNFS &amp;&amp; url) &#123;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="number">302</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'Location'</span>, url);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过如果本身 registry 里面就没 <code>key</code> 这个选项的话也会直接用 <code>url()</code> 生成的链接给跳过去。如果没有 <code>url()</code> 的链接，那么直接用 registry 里面的 <code>tarball</code> 字段。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dist = row.package.dist;</span><br><span class="line"><span class="keyword">if</span> (!dist.key) &#123;</span><br><span class="line">  url = url || dist.tarball;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="number">302</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'Location'</span>, url);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面如果都跳过去了，那么说明要开始调用事先写好的 <code>download</code> 那两个函数了，把文件读到 Buffer 里面，然后把 Buffer 放到 Response 里面传回去。</p><h3 id="controllers-registry-package-remove-js"><a href="#controllers-registry-package-remove-js" class="headerlink" title="controllers/registry/package/remove.js"></a>controllers/registry/package/remove.js</h3><blockquote><p><a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/registry/package/remove.js" target="_blank" rel="external">源码参考</a></p></blockquote><p>对于删除包来说，除了把包从数据库删掉之外，还要循环遍历一遍这个包的所有版本，把所有版本的这个包都从 NFS 里面删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> keys.map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nfs.remove(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  logger.error(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就调用了你事先写好的 <code>remove</code> 了。当然你不实现也没关系，最多是包的压缩文件不删除而已。</p><h3 id="controllers-registry-package-remove-version-js"><a href="#controllers-registry-package-remove-version-js" class="headerlink" title="controllers/registry/package/remove_version.js"></a>controllers/registry/package/remove_version.js</h3><blockquote><p><a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/registry/package/remove_version.js" target="_blank" rel="external">源码参考</a></p></blockquote><p>这里跟上一小节差不多，之前是删除整个包，这里是删除包的某一个版本，所以就不用循环删除了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> nfs.remove(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  logger.error(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controllers-registry-package-save-js"><a href="#controllers-registry-package-save-js" class="headerlink" title="controllers/registry/package/save.js"></a>controllers/registry/package/save.js</h3><blockquote><p><a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/registry/package/save.js" target="_blank" rel="external">源码参考</a></p></blockquote><p>然后就是用户 <code>$ npm publish</code> 用的路由了，在一堆判断之后，发布传过来的包被放在二进制 Buffer 内存里面：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tarballBuffer;</span><br><span class="line">tarballBuffer = <span class="keyword">new</span> Buffer(attachment.data, <span class="string">'base64'</span>);</span><br></pre></td></tr></table></figure><p>接下去又判断来判断去，最后交由 NFS 的 <code>uploadBuffer</code> 来上传并得到结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadResult = <span class="keyword">yield</span> nfs.uploadBuffer(tarballBuffer, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dist = &#123;</span><br><span class="line">  <span class="attr">shasum</span>: shasum,</span><br><span class="line">  <span class="attr">size</span>: attachment.length</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uploadResult.url) &#123;</span><br><span class="line">  dist.tarball = uploadResult.url;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (uploadResult.key) &#123;</span><br><span class="line">  dist.key = uploadResult.key;</span><br><span class="line">  dist.tarball = uploadResult.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，就是这里记录的它到底是 <code>key</code> 还是 <code>tarball</code> 了。</p><p>如果你的 <code>upload</code> 函数返回的是 <code>{ url: &#39;FOO&#39; }</code>，那么就是 <code>tarball</code> 设置成该值，在下载的时候会直接 302 到 <code>tarball</code> 所指的地址去；如果返回的是 <code>{ key: &#39;key&#39; }</code> 的话，会在 <code>dist</code> 里面存个 <code>key</code>，下载的时候判断如果有 <code>key</code> 的话会把它传进你的 <code>createDownloadStream</code> 或者 <code>download</code> 函数去交由你的函数生成包 Buffer 并传回 Response。</p><h3 id="controller-sync-module-worker-js"><a href="#controller-sync-module-worker-js" class="headerlink" title="controller/sync_module_worker.js"></a>controller/sync_module_worker.js</h3><blockquote><p><a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/sync_module_worker.js" target="_blank" rel="external">源码参考</a></p></blockquote><p>这个文件是从源端同步相关的一些逻辑了，这里面有两个操作。</p><p>一个是 <code>unpublish</code>，调用的就是 NFS 的 <code>remove</code>，不作详谈了。</p><p>另一个就是同步了。同步包会被打散成同步一个版本，然后把每个版本同步过来。在同步版本的时候先把包文件<a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/sync_module_worker.js#L940" target="_blank" rel="external">下载</a>到本地文件 <code>filepath</code> 里面去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">yield</span> urllib.request(downurl, options);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/node-modules/urllib" target="_blank" rel="external">urllib</a> 是苏千死马他们自己写的比较方便和适合他们自己的一个 http 请求库。</p></blockquote><p>上面的代码 <code>options</code> 里面有一个文件流，链接到 <code>filepath</code> 目录的这个文件去，相当于这一步就是把源端的包下载到本地 <code>filepath</code> 去了。</p><p>经过一堆 blahblah 的判断（比如 SHASUM）之后，这个这个函数就会<a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/controllers/sync_module_worker.js#L995" target="_blank" rel="external">调用 NFS 的 <code>upload</code> 函数</a>将本地文件名对应的文件上传到你所需要的地方去了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = <span class="keyword">yield</span> nfs.upload(filepath, options);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  logger.syncInfo(<span class="string">'[sync_module_worker] upload %j to nfs error: %s'</span>, err);</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其结果到底是 <code>key</code> 还是 <code>url</code> 对于下载的影响跟前一小节一个道理。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章讲了如何使用和自己定制一个 CNPM 的 NFS 层，让包的走向跟着你的心走。在描述了开发规范和出示了样例代码和改造小例子之后，又解析了这个 NFS 是如何在 CNPM 里面工作的，上面已经提到了 2.12.2 版本中所有用到 NFS 的地方。</p><p>看了上面的解析之后会对 NFS 的工作流程有更深一层的了解，然后就不会有写 NFS 层的时候有种心慌慌摸不着底的情况了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CNPM 的自定义包存储层文件系统简称 NFS，我猜是 NPM File System 的意思。&lt;/p&gt;
&lt;p&gt;在之前《&lt;a href=&quot;https://xcoder.in/2016/07/09/lets-cnpm-base-deploy/&quot;&gt;跟我一起部署和定制 CNPM—
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="CNPM" scheme="https://xcoder.in/tags/CNPM/"/>
    
  </entry>
  
  <entry>
    <title>跟我一起部署和定制 CNPM——基础部署</title>
    <link href="https://xcoder.in/2016/07/09/lets-cnpm-base-deploy/"/>
    <id>https://xcoder.in/2016/07/09/lets-cnpm-base-deploy/</id>
    <published>2016-07-09T11:19:22.000Z</published>
    <updated>2017-12-11T07:59:20.518Z</updated>
    
    <content type="html"><![CDATA[<p>本章会介绍 CNPM 的基础部署方法。</p><blockquote><p>该文章所对应的 cnpm 目标版本为 <a href="https://github.com/cnpm/cnpmjs.org/tree/2.12.2" target="_blank" rel="external">v2.12.2</a>，上下浮动一些兼容的版本问题也都不是特别大。</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>想要部署 CNPM，你需要做以下的一些准备。</p><ol><li>部署的宿体，如服务器、云主机、自己的电脑等；</li><li>数据库，支持 MySQL、PostgreSQL、MariaDB，如果使用 SQLite 则无需准备；</li><li>Git 客户端（推荐）。</li></ol><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><h3 id="克隆-CNPM"><a href="#克隆-CNPM" class="headerlink" title="克隆 CNPM"></a>克隆 CNPM</h3><p>首先在本地选择一个目录，比如我将它选择在 <code>/usr/app</code>，然后预想 CNPM 的目录为 <code>/usr/app/cnpm</code>，那么需要在终端 <code>$ cd /usr/app</code>。</p><p>接下去执行 Git 指令将 CNPM 克隆到相应目录。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/cnpm/cnpmjs.org.git</span><br></pre></td></tr></table></figure><h4 id="Windows-用户"><a href="#Windows-用户" class="headerlink" title="Windows 用户"></a>Windows 用户</h4><p>Windows 用户也可以用类似 <a href="https://www.cygwin.com/" target="_blank" rel="external">Cygwin</a>、<a href="http://www.mingw.org/" target="_blank" rel="external">MinGW</a>、<a href="https://msdn.microsoft.com/en-us/powershell" target="_blank" rel="external">Powershell</a> 甚至直接是 Command 等来运行 <a href="https://git-scm.com/download/win" target="_blank" rel="external">Git</a>。</p><p>当然也可以直接下载一些 GUI 工具来克隆，如 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>。</p><h4 id="非-Git-用户"><a href="#非-Git-用户" class="headerlink" title="非 Git 用户"></a>非 Git 用户</h4><p>跑到 CNPM 的 Release 页面，选择相应的版本下载，比如这里会选择 <a href="https://github.com/cnpm/cnpmjs.org/releases/tag/2.12.2" target="_blank" rel="external">v2.12.2</a> 版。</p><p>下载完毕后将文件夹解压到相应目录即可。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>安装依赖其实就是一个 <code>npm install</code>，不过 CNPM 把该指令已经写到 Makefile 里面了，所以直接执行下面的命令就好了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>当然万一你是 Windows 用户或者不会 <code>make</code>，那么还是要用 <code>npm install</code>。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --build-from-source --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/mirrors/node</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>新建一份 <code>config/config.js</code> 文件，并且写入如下的骨架：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里面输入你需要的键值对。</p><p>这里将会列举一些常用的配置项，其余的一些配置项请自行参考 <a href="https://github.com/cnpm/cnpmjs.org/blob/2.12.2/config/index.js" target="_blank" rel="external">config/index.js</a> 文件。</p><h4 id="配置字段参考"><a href="#配置字段参考" class="headerlink" title="配置字段参考"></a>配置字段参考</h4><ul><li><code>enableCluster</code>：是否启用 <strong>cluster-worker</strong> 模式启动服务，默认 <code>false</code>，生产环节推荐为 <code>true</code>;</li><li><code>registryPort</code>：API 专用的 registry 服务端口，默认 <code>7001</code>；</li><li><code>webPort</code>：Web 服务端口，默认 <code>7002</code>；</li><li><code>bindingHost</code>：监听绑定的 Host，默认为 <code>127.0.0.1</code>，如果外面架了一层本地的 <strong>Nginx</strong> 反向代理或者 <strong>Apache</strong> 反向代理的话推荐不用改；</li><li><code>sessionSecret</code>：<strong>session</strong> 用的盐；</li><li><code>logdir</code>：日志目录；</li><li><code>uploadDir</code>：临时上传文件目录；</li><li><code>viewCache</code>：视图模板缓存是否开启，默认为 <code>false</code>；</li><li><code>enableCompress</code>：是否开启 <strong>gzip</strong> 压缩，默认为 <code>false</code>；</li><li><code>admins</code>：管理员们，这是一个 <code>JSON Object</code>，对应各键名为各管理员的用户名，键值为其邮箱，默认为 <code>{ fengmk2: &#39;fengmk2@gmail.com&#39;, admin: &#39;admin@cnpmjs.org&#39;, dead_horse: &#39;dead_horse@qq.com&#39; }</code>；</li><li><code>logoURL</code>：<strong>Logo</strong> 地址，不过对于我这个已经把 CNPM 前端改得面目全非的人来说已经忽略了这个配置了；</li><li><code>adBanner</code>：广告 Banner 的地址；</li><li><code>customReadmeFile</code>：实际上我们看到的 <a href="http://cnpmjs.org" target="_blank" rel="external">cnpmjs.org</a> 首页中间一大堆冗长的介绍是一个 Markdown 文件转化而成的，你可以设置该项来自行替换这个文件；</li><li><code>customFooter</code>：自定义页脚模板；</li><li><code>npmClientName</code>：默认为 <code>cnpm</code>，如果你有自己开发或者 fork 的 npm 客户端的话请改成自己的 CLI 命令，这个应该会在一些页面的说明处替换成你所写的；</li><li><code>backupFilePrefix</code>：备份目录；</li><li><code>database</code>：数据库相关配置，为一个对象，默认如果不配置将会是一个 <code>~/.cnpmjs.org/data.sqlite</code> 的 SQLite；<ul><li><code>db</code>：数据的库名；</li><li><code>username</code>：数据库用户名；</li><li><code>password</code>：数据库密码；</li><li><code>dialect</code>：数据库适配器，可选 <code>&quot;mysql&quot;</code>、<code>&quot;sqlite&quot;</code>、<code>&quot;postgres&quot;</code>、<code>&quot;mariadb&quot;</code>，默认为 <code>&quot;sqlite&quot;</code>；</li><li><code>hsot</code>：数据库地址；</li><li><code>port</code>：数据库端口；</li><li><code>pool</code>：数据库连接池相关配置，为一个对象；<ul><li><code>maxConnections</code>：最大连接数，默认为 <code>10</code>；</li><li><code>minConnections</code>：最小连接数，默认为 <code>0</code>；</li><li><code>maxIdleTime</code>：单条链接最大空闲时间，默认为 <code>30000</code> 毫秒；</li></ul></li><li><code>storege</code>：仅对 SQLite 配置有效，数据库地址，默认为 <code>~/.cnpmjs/data.sqlite</code>；</li></ul></li><li><code>nfs</code>：包文件系统处理对象，为一个 Node.js 对象，默认是 <a href="https://github.com/cnpm/fs-cnpm" target="_blank" rel="external">fs-cnpm</a> 这个包，并且配置在 <code>~/.cnpmjs/nfs</code> 目录下，也就是说默认所有同步的包都会被放在这个目录下；开发者可以使用别的一些文件系统插件（如上传到又拍云等）,又或者自己去按接口开发一个逻辑层，这些都是后话了；</li><li><code>registryHost</code>：暂时还未试过，我猜是用于 Web 页面显示用的，默认为 <code>r.cnpmjs.org</code>；</li><li><code>enablePrivate</code>：是否开启私有模式，默认为 <code>false</code>；<ul><li>如果是私有模式则只有管理员能发布包，其它人只能从源站同步包；</li><li>如果是非私有模式则所有登录用户都能发布包；</li></ul></li><li><code>scopes</code>：非管理员发布包的时候只能用以 <code>scopes</code> 里面列举的命名空间为前缀来发布，如果没设置则无法发布，也就是说这是一个必填项，默认为 <code>[ &#39;@cnpm&#39;, &#39;@cnpmtest&#39;, &#39;@cnpm-test&#39; ]</code>，据苏千大大解释是为了便于管理以及让公司的员工自觉按需发布；更多关于 NPM scope 的说明请参见 <a href="https://docs.npmjs.com/misc/scope" target="_blank" rel="external">npm-scope</a>；</li><li><code>privatePackages</code>：就如该配置项的注释所述，出于历史包袱的原因，有些已经存在的私有包（可能之前是用 Git 的方式安装的）并没有以命名空间的形式来命名，而这种包本来是无法上传到 CNPM 的，这个配置项数组就是用来加这些例外白名单的，默认为一个空数组；</li><li><code>sourceNpmRegistry</code>：更新源 NPM 的 registry 地址，默认为 <code>https://registry.npm.taobao.org</code>；</li><li><code>sourceNpmRegistryIsCNpm</code>：源 registry 是否为 CNPM，默认为 <code>true</code>，如果你使用的源是官方 NPM 源，请将其设为 <code>false</code>；</li><li><code>syncByInstall</code>：如果安装包的时候发现包不存在，则尝试从更新源同步，默认为 <code>true</code>；</li><li><code>syncModel</code>：更新模式（不过我觉得是个 <code>typo</code>），有下面几种模式可以选择，默认为 <code>&quot;none&quot;</code>;<ul><li><code>&quot;none&quot;</code>：永不同步，只管理私有用户上传的包，其它源包会直接从源站获取；</li><li><code>&quot;exist&quot;</code>：定时同步已经存在于数据库的包；</li><li><code>&quot;all&quot;</code>：定时同步所有源站的包；</li></ul></li><li><code>syncInterval</code>：同步间隔，默认为 <code>&quot;10m&quot;</code> 即十分钟；</li><li><code>syncDevDependencies</code>：是否同步每个包里面的 <code>devDependencies</code> 包们，默认为 <code>false</code>；</li><li><code>badgeSubject</code>：包的 <strong>badge</strong> 显示的名字，默认为 <code>cnpm</code>；</li><li><code>userService</code>：用户验证接口，默认为 <code>null</code>，即无用户相关功能也就是无法有用户去上传包，该部分需要自己实现接口功能并配置，如与公司的 <strong>Gitlab</strong> 相对接，这也是后话了；</li><li><code>alwaysAuth</code>：是否始终需要用户验证，即便是 <code>$ cnpm install</code> 等命令；</li><li><code>httpProxy</code>：代理地址设置，用于你在墙内源站在墙外的情况。</li></ul><h4 id="一个可能的配置"><a href="#一个可能的配置" class="headerlink" title="一个可能的配置"></a>一个可能的配置</h4><p>下面给出一个样例配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">enableCluster</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">database</span>: &#123;</span><br><span class="line">        <span class="attr">db</span>: <span class="string">"snpm"</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="string">"username"</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">"password"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">dialect</span>: <span class="string">"mysql"</span>,</span><br><span class="line">        <span class="attr">host</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">3306</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">enablePrivate</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">admins</span>: &#123;</span><br><span class="line">        <span class="attr">xadillax</span>: <span class="string">"i@2333.moe"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">syncModel</span>: <span class="string">"exist"</span>,</span><br><span class="line">    <span class="attr">nfs</span>: <span class="built_in">require</span>(<span class="string">'upyun-cnpm'</span>).create(&#123;</span><br><span class="line">        <span class="attr">bucket</span>: <span class="string">"your bucket"</span>,</span><br><span class="line">        <span class="attr">oprator</span>: <span class="string">"your id"</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">"your secret"</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">scopes</span>: [ <span class="string">'@cheniu'</span>, <span class="string">'@souche'</span>, <span class="string">'@souche-f2e'</span> ],</span><br><span class="line">    <span class="attr">badgeSubject</span>: <span class="string">'snpm'</span>,</span><br><span class="line">    <span class="attr">privatePackages</span>: [ <span class="string">'snpm'</span> ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的配置包文件系统层用的是 <a href="https://github.com/cnpm/upyun-cnpm" target="_blank" rel="external">upyun-cnpm</a> 插件，需要在 CNPM 源码根目录执行<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --save -d upyun-cnpm</span><br></pre></td></tr></table></figure></p><p>这个时候你的 <code>package.json</code> 就有更改与源 Repo 不一致了，如果是 Git 克隆的用户在以后升级更新系统的时候稍稍注意一下可能的冲突即可。</p></blockquote><h4 id="官方-NFS-插件"><a href="#官方-NFS-插件" class="headerlink" title="官方 NFS 插件"></a>官方 NFS 插件</h4><p>下面给出几个官方的 NFS 插件：</p><ul><li><a href="https://github.com/cnpm/upyun-cnpm" target="_blank" rel="external">upyun-cnpm</a>：包本体存在又拍云的插件；</li><li><a href="https://github.com/cnpm/fs-cnpm" target="_blank" rel="external">fs-cnpm</a>：包本体存在本地的插件；</li><li><a href="https://github.com/cnpm/sfs-client" target="_blank" rel="external">sfs-client</a>：包本体存在 <a href="https://github.com/cnpm/sfs" target="_blank" rel="external">SFS</a>（Simple FIle Store）插件；</li><li><a href="https://github.com/cnpm/qn-cnpm" target="_blank" rel="external">qn-cnpm</a>：包本体存在七牛的插件；</li><li><a href="https://github.com/cnpm/oss-cnpm" target="_blank" rel="external">oss-cnpm</a>：包本体存在阿里云 OSS 的插件。</li></ul><p>以后官方如果有一些新的插件进来，这里可能不会更新了，请自行去 <a href="https://github.com/cnpm/cnpmjs.org/wiki/NFS-Guide#present-storage-wrappers" target="_blank" rel="external">NFS Storage Wrappers</a> 获取最新的 NFS 插件们。</p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>如果你使用的是 SQLite 的话，数据库是自动就好了的，可以忽略该步。</p><p>其它数据库需要自行导入初始数据库结构。</p><p>初始数据库脚本在 <strong>docs/db.sql</strong> 里面，你可以用一些 GUI 工具将数据导入，也可以直接进入命令行导入。</p><p>比如你用的是 MySQL，就可以在本机操作 MySQL。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mysql -u yourname -p</span><br><span class="line">mysql&gt; use cnpmjs;</span><br><span class="line">mysql&gt; <span class="built_in">source</span> docs/db.sql</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>搞好配置之后就可以直接启动服务了。</p><h4 id="简单启动"><a href="#简单启动" class="headerlink" title="简单启动"></a>简单启动</h4><p>最简单的办法也是我现在正在用的方法就是直接用 <code>node</code> 执行一下入口文件就好了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node dispatch.js</span><br></pre></td></tr></table></figure><blockquote><p>其实我是在 <a href="https://tmux.github.io/" target="_blank" rel="external">tmux</a> 里面执行上面的指令的。</p></blockquote><h4 id="官方脚本启动"><a href="#官方脚本启动" class="headerlink" title="官方脚本启动"></a>官方脚本启动</h4><p>官方的其它一些指令，比如你可以用 NPM 的 script 来运行。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure><blockquote><p>在 CNPM 里面，npm script 还有下面几种指令</p><ul><li><code>npm run dev</code>：调试模式启动；</li><li><code>npm run test</code>：跑测试；</li><li><code>npm run start</code>：启动 CNPM；</li><li><code>npm run status</code>：查看 CNPM 启动状态；</li><li><code>npm run stop</code>：停止 CNPM。</li></ul></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文介绍了一些 CNPM 基础的部署方法，基本上能达到最小可用状态。</p><p>如果想要进阶定制一些 CNPM 的功能，请期待后续吧。ξ( ✿＞◡❛)</p><p>以及一些写得不好和不对的地方，请多多指正哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章会介绍 CNPM 的基础部署方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该文章所对应的 cnpm 目标版本为 &lt;a href=&quot;https://github.com/cnpm/cnpmjs.org/tree/2.12.2&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="CNPM" scheme="https://xcoder.in/tags/CNPM/"/>
    
  </entry>
  
  <entry>
    <title>跟我一起部署和定制 CNPM——索引</title>
    <link href="https://xcoder.in/2016/07/08/lets-cnpm-toc/"/>
    <id>https://xcoder.in/2016/07/08/lets-cnpm-toc/</id>
    <published>2016-07-08T11:14:58.000Z</published>
    <updated>2017-12-11T07:59:20.519Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章将会基于 <a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="external">cnpm</a> 部署搭建一套属于自己（或者公司）的内部私有 NPM 系统。</p><h2 id="什么是-CNPM"><a href="#什么是-CNPM" class="headerlink" title="什么是 CNPM"></a>什么是 CNPM</h2><p><a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="external">cnpm</a> 是 Node.js 中国社区成员主导的一个私有 NPM 开源项目，可以用于部署私有 NPM、公共 NPM 镜像等。</p><h2 id="阅读对象"><a href="#阅读对象" class="headerlink" title="阅读对象"></a>阅读对象</h2><ul><li>有一定 Node.js 后端基础</li><li>需要有一套私有 NPM</li><li>想要研究 CNPM 实现</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="https://xcoder.in/2016/07/09/lets-cnpm-base-deploy/">基础部署</a></li><li><a href="https://xcoder.in/2016/07/22/lets-cnpm-storage/">自定义包存储层</a></li><li>To be continued</li></ol><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>你可以对本系列文章进行勘误或者更新，直接提交 PR 或者在博客文章后方留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章将会基于 &lt;a href=&quot;https://github.com/cnpm/cnpmjs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cnpm&lt;/a&gt; 部署搭建一套属于自己（或者公司）的内部私有 NPM 系统。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="CNPM" scheme="https://xcoder.in/tags/CNPM/"/>
    
  </entry>
  
  <entry>
    <title>让我们一起来起花名吧</title>
    <link href="https://xcoder.in/2016/02/24/lets-hua/"/>
    <id>https://xcoder.in/2016/02/24/lets-hua/</id>
    <published>2016-02-24T05:40:36.000Z</published>
    <updated>2017-12-11T07:59:20.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因是我一个叫『小龙』的好基友由于某些原因离职去了一家跟阿里一样有着『花名文化』的公司，于是开始为花名犯愁。</p><p>结合之前妹纸『弍纾』在起花名的时候也遇到了同样的困扰，于是决定用 Node.js 写个『一本正经乱起花名』的程序。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="Chinese-Random-Name"><a href="#Chinese-Random-Name" class="headerlink" title="Chinese Random Name"></a>Chinese Random Name</h3><p>首先起花名的原理就是胡乱随机一串字出来胡乱拼。</p><p>于是准备应该有 <a href="https://github.com/XadillaX/chinese-random-name" target="_blank" rel="external">chinese-random-name</a>，一个随机生成中文名的包。</p><p>使用它很简单，先把它 <code>require</code> 进来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomName = <span class="built_in">require</span>(<span class="string">"chinese-random-name"</span>);</span><br></pre></td></tr></table></figure><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>如果你需要随机生成一个名字只需要 <code>randomName.generate()</code> 就可以了；如果你要随机一个姓那么就 <code>randomName.surnames.getOne()</code>；如果你只需要获得名字，这里面就有点门道了。</p><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p>你可以随机生成一个名（不带姓的） <code>randomName.names.get()</code>；你也可以指定名字的字数，一二三：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">randomName.names.get1();</span><br><span class="line">randomName.names.get2();</span><br><span class="line">randomName.names.get3();</span><br></pre></td></tr></table></figure><p>或者！</p><p>又或者！</p><p>然后或者！</p><p>你可以指定每个字的五行哦！</p><p>什么意思呢？比如你想给孩子起个名，然后孩子命里五行缺金，那么就可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">randomName.names.get2(<span class="string">"金金"</span>);</span><br></pre></td></tr></table></figure><p>然后你就可能得到一个『<strong>紫铨</strong>』，两个字都是属金的。那么如果你孩子姓李，就叫李紫铨；如果孩子姓王，就叫王紫铨；如果姓爱新觉罗，那么就叫爱新觉罗·紫铨。</p><p>有木有想给我装得这个逼打个 82 分呢？剩下的就交给 666 吧。(ง •̀_•́)ง</p><h3 id="Nomnom"><a href="#Nomnom" class="headerlink" title="Nomnom"></a>Nomnom</h3><p>这个包是用来解析命令行参数的。虽然市面上有挺多别的的，比如 <a href="https://www.npmjs.com/package/commander" target="_blank" rel="external">commander</a> 等，不过我还是最习惯 <a href="https://www.npmjs.com/package/nomnom" target="_blank" rel="external">nomnom</a>，用称手了就不想换了。</p><p>虽然它的 GitHub Repo 下面有这么一段话。</p><blockquote><p>Nomnom is deprecated. Check out <a href="https://github.com/tj/commander.js" target="_blank" rel="external">https://github.com/tj/commander.js</a>, which should have most, if not all of the capability that nomnom had. Thank you!</p></blockquote><p>不过再怎么说 nomnom 也是当年 <a href="https://github.com/substack/node-optimist" target="_blank" rel="external">substack</a> 大神推荐的啊。(ಡωಡ)</p><h3 id="Colorful"><a href="#Colorful" class="headerlink" title="Colorful"></a>Colorful</h3><p>这个包是用来上色的。</p><p>毕竟五行是有颜色的哇。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> color = <span class="built_in">require</span>(<span class="string">"colorful"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(color.red(<span class="string">"（*/∇＼*）"</span>));</span><br></pre></td></tr></table></figure><p>那么在你的终端就好看到一个红色的 <code>（*/∇＼*）</code>。</p><h3 id="Is-Chinese"><a href="#Is-Chinese" class="headerlink" title="Is Chinese"></a>Is Chinese</h3><p>用来判断是不是中文的包。</p><p>作为一个起名的命令行程序，你总得好好传参才行吧，总不能你随便传个咸鸭蛋🐣我也好好处理吧。</p><p>于是就用 <a href="https://www.npmjs.com/package/is-chinese" target="_blank" rel="external">is-chinese</a> 来判断某个字符串是不是纯中文。</p><p>这个包是由前阿里小伙伴，CNode 站长<a href="https://github.com/alsotang" target="_blank" rel="external">唐少</a>写的。</p><p>用起来也很简单，只要 <code>isChinese(&quot;什么你要判断什么&quot;)</code> 就可以了。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --save -d chinese-random-name</span><br><span class="line">$ npm install --save -d nomnom</span><br><span class="line">$ npm install --save -d colorful</span><br><span class="line">$ npm install --save -d is-chinese</span><br></pre></td></tr></table></figure><ul><li><strong>chinese-random-name</strong>: <a href="https://github.com/XadillaX/chinese-random-name" target="_blank" rel="external">https://github.com/XadillaX/chinese-random-name</a></li><li><strong>nomnom</strong>: <a href="https://github.com/harthur/nomnom" target="_blank" rel="external">https://github.com/harthur/nomnom</a></li><li><strong>colorful</strong>: <a href="https://github.com/lepture/colorful" target="_blank" rel="external">https://github.com/lepture/colorful</a></li><li><strong>is-chinese</strong>: <a href="https://github.com/alsotang/is-chinese" target="_blank" rel="external">https://github.com/alsotang/is-chinese</a></li></ul><h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><p>其结果在<a href="https://github.com/BoogeeDoo/hua" target="_blank" rel="external">这里</a>。</p><h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><p>首先效果是这样的：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hua --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: hua [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-p PREFIX, --prefix PREFIX          to specify a prefix.</span><br><span class="line">-s SUFFIX, --suffix SUFFIX          to specify a suffix.</span><br><span class="line">-5 WUXING, --five-elements WUXING   the file elements (Wuxing) of huaming.</span><br><span class="line">-c COUNT, --count COUNT             the count of huaming  [10]</span><br></pre></td></tr></table></figure><p>使用者可以自己想一个前缀或者后缀，然后自定义（或者也可以不指定）两个字的五行，以及指定一次性生成多少个花名。</p><p>比如想要生成以 <code>龙</code> 字为前缀的花名，就可以 <code>$ hua --prefix 龙</code>，得到结果可以是这样的：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 龙幼</span><br><span class="line">* 龙巡</span><br><span class="line">* 龙躬</span><br><span class="line">* 龙仇</span><br><span class="line">* 龙锤</span><br><span class="line">* 龙镒</span><br><span class="line">* 龙拾</span><br><span class="line">* 龙央</span><br><span class="line">* 龙些</span><br><span class="line">* 龙悠</span><br></pre></td></tr></table></figure><p>如果想两个字分别所属金和谁，就可以 <code>$ hua --five-elements 金水</code> 来起花名：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 倩娥</span><br><span class="line">* 雀效</span><br><span class="line">* 黍棓</span><br><span class="line">* 姹溶</span><br><span class="line">* 馨沙</span><br><span class="line">* 宫闲</span><br><span class="line">* 裕混</span><br><span class="line">* 俗封</span><br><span class="line">* 绸娥</span><br><span class="line">* 瑞淦</span><br></pre></td></tr></table></figure><p>想要得到这样一个命令行参数，我们可以用 <code>nomnom</code> 来解决。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> opts = <span class="built_in">require</span>(<span class="string">"nomnom"</span>)</span><br><span class="line">    .script(<span class="string">"hua"</span>)</span><br><span class="line">    .option(<span class="string">"prefix"</span>, &#123;</span><br><span class="line">        <span class="attr">abbr</span>: <span class="string">"p"</span>,</span><br><span class="line">        <span class="attr">help</span>: <span class="string">"to specify a prefix."</span>,</span><br><span class="line">        <span class="attr">metavar</span>: <span class="string">"PREFIX"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .option(<span class="string">"suffix"</span>, &#123;</span><br><span class="line">        <span class="attr">abbr</span>: <span class="string">"s"</span>,</span><br><span class="line">        <span class="attr">help</span>: <span class="string">"to specify a suffix."</span>,</span><br><span class="line">        <span class="attr">metavar</span>: <span class="string">"SUFFIX"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .option(<span class="string">"five-elements"</span>, &#123;</span><br><span class="line">        <span class="attr">abbr</span>: <span class="string">"5"</span>,</span><br><span class="line">        <span class="attr">help</span>: <span class="string">"the file elements (Wuxing) of huaming."</span>,</span><br><span class="line">        <span class="attr">metavar</span>: <span class="string">"WUXING"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .option(<span class="string">"count"</span>, &#123;</span><br><span class="line">        <span class="attr">abbr</span>: <span class="string">"c"</span>,</span><br><span class="line">        <span class="attr">help</span>: <span class="string">"the count of huaming"</span>,</span><br><span class="line">        <span class="attr">metavar</span>: <span class="string">"COUNT"</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .parse();</span><br></pre></td></tr></table></figure><p>上面的这段代码分别指定了脚本名为 <code>hua</code>，然后指定了 <code>prefix</code> / <code>suffix</code> / <code>five-elements</code> 和 <code>count</code> 四个参数，并把解析好的参数赋值给 <code>opts</code> 变量。</p><blockquote><p>由于我希望这个包在通常的 Node.js 下都可以跑，所以没有用 <code>let</code> 之类的东西。</p></blockquote><h3 id="花名类"><a href="#花名类" class="headerlink" title="花名类"></a>花名类</h3><p>接下去要写一个花名类，这个类不只是可以在 CLI 之中使用，也可以让别人作为一个包来引入。然后实际上这个类就是要对 <code>chinese-random-name</code> 进行一个封装。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Hua = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先这个 <code>options</code> 就是之前由 <code>nomnom</code> 解析出来的参数，当然有些参数是可选的。</p><p>接下去我们要在构造函数也就是 <code>Hua</code> 里面格式化前缀或者后缀（如果有的话），将他们弄成只有一个汉字的格式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(options.prefix) &#123;</span><br><span class="line">    options.prefix = options.prefix[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!isChinese(options.prefix)) <span class="keyword">delete</span> options.prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(options.suffix) &#123;</span><br><span class="line">    options.suffix = options.suffix[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!isChinese(options.suffix)) <span class="keyword">delete</span> options.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前后缀弄好之后要对五行进行分析了。</p><p>如果有前后缀那么忽略五行参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(options.prefix &amp;&amp; options.suffix) &#123;</span><br><span class="line">    <span class="keyword">delete</span> options[<span class="string">"file-elements"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有前缀，那么忽略传进来的五行的第一个五行；如果有后缀那么忽略第二个字的五行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wuxing = <span class="string">"金木水火土"</span>;</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(options.prefix) &#123;</span><br><span class="line">    options[<span class="string">"five-elements"</span>] = options[<span class="string">"five-elements"</span>].substr(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> === wuxing.indexOf(options[<span class="string">"five-elements"</span>])) &#123;</span><br><span class="line">        <span class="keyword">delete</span> options[<span class="string">"five-elements"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(options.suffix) &#123;</span><br><span class="line">    options[<span class="string">"five-elements"</span>] = options[<span class="string">"five-elements"</span>].substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> === wuxing.indexOf(options[<span class="string">"five-elements"</span>])) &#123;</span><br><span class="line">        <span class="keyword">delete</span> options[<span class="string">"five-elements"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果前后缀都没有，那么要格式化一下该参数，使其仅剩两个有效的五行汉字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    options[<span class="string">"five-elements"</span>] = options[<span class="string">"five-elements"</span>].substr(<span class="number">0</span>, <span class="number">2</span>).split(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; options[<span class="string">"five-elements"</span>].length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果是无效五行或者冰没有这个字的话，随机一个五行出来</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> === wuxing.indexOf(options[<span class="string">"five-elements"</span>][i])) &#123;</span><br><span class="line">            options[<span class="string">"five-elements"</span>][i] = wuxing[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字数不够，随机来凑</span></span><br><span class="line">    <span class="keyword">while</span>(options[<span class="string">"five-elements"</span>].length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        options[<span class="string">"five-elements"</span>].push(wuxing[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options[<span class="string">"five-elements"</span>] = options[<span class="string">"five-elements"</span>].join(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的这些逻辑都写在构造函数里面，如果想要完整的构造函数可以看 <code>hua</code> 的 <a href="https://github.com/BoogeeDoo/hua/blob/09f1bc7eae14faaa9e881392d3811a6073d94b1c/lib/hua.js#L14-L55" target="_blank" rel="external">hua.js</a> 文件。</p><h4 id="生成一个花名"><a href="#生成一个花名" class="headerlink" title="生成一个花名"></a>生成一个花名</h4><p>生成一个花名其实就是调用 <code>randomName.names.get</code> 系列函数们了。</p><ul><li><strong>有前后缀：</strong>直接返回前缀加后缀。</li><li><strong>有前缀：</strong>返回前缀加 <code>get1</code>。</li><li><strong>有后缀：</strong>返回 <code>get1</code> 加后缀。</li><li><strong>没有前后缀：</strong>直接返回 <code>get2</code>。</li></ul><blockquote><p><strong>注意：</strong>以上情况都会传进（哪怕是 <code>undefined</code>）五行参数。</p></blockquote><p>所以 <code>generateOne</code> 函数长<a href="https://github.com/BoogeeDoo/hua/blob/09f1bc7eae14faaa9e881392d3811a6073d94b1c/lib/hua.js#L67-L83" target="_blank" rel="external">这样</a>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hua.prototype.generateOne = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.options.prefix &amp;&amp; <span class="keyword">this</span>.options.suffix) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options.prefix + <span class="keyword">this</span>.options.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.options.prefix) &#123;</span><br><span class="line">        debug(<span class="keyword">this</span>.options[<span class="string">"five-elements"</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options.prefix + randomName.names.get1(<span class="keyword">this</span>.options[<span class="string">"five-elements"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.options.suffix) &#123;</span><br><span class="line">        debug(<span class="keyword">this</span>.options[<span class="string">"five-elements"</span>]);</span><br><span class="line">        <span class="keyword">return</span> randomName.names.get1(<span class="keyword">this</span>.options[<span class="string">"five-elements"</span>]) + <span class="keyword">this</span>.options.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> randomName.names.get2(<span class="keyword">this</span>.options[<span class="string">"five-elements"</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="生成-Count-个花名"><a href="#生成-Count-个花名" class="headerlink" title="生成 Count 个花名"></a>生成 Count 个花名</h4><p>还记得 CLI 的 <code>count</code> 参数么？因为为了方便，我们可以批量生成花名，所以就需要生成 Count 个花名的函数了。</p><p>实际上就是一个循环调用 <code>generateOne</code> 的函数而已。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hua.prototype.generate = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!count) count = <span class="keyword">this</span>.options.count || <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>.generateOne());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CLI-文件"><a href="#CLI-文件" class="headerlink" title="CLI 文件"></a>CLI 文件</h3><p>刚刚那个 <code>nomnom</code> 解析就在这个文件里面，然后接下去就是实例化一个 <code>Hua</code> 对象，然后生成 <code>count</code> 个花名。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hua = <span class="keyword">new</span> Hua(opts);</span><br><span class="line"><span class="keyword">var</span> result = hua.generate();</span><br></pre></td></tr></table></figure><p>最后把花名输出来就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" * "</span> + result[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桥豆麻袋！"><a href="#桥豆麻袋！" class="headerlink" title="桥豆麻袋！"></a>桥豆麻袋！</h4><blockquote><p>说好的五行颜色呢？！</p></blockquote><p>好像是的哦，我们要在输出之前给 <code>result</code> 上个色儿。</p><p>遍历 <code>result</code> 里面的花名每个字，获取它的五行属性，然后涮上色儿。</p><p><code>chinese-random-name</code> 暴露了字典中每个字的五行属性，只需要赋值一下就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="built_in">require</span>(<span class="string">"chinese-random-name"</span>).names.dict;</span><br></pre></td></tr></table></figure><p>然后逐一对比。最后对应金木水火土的颜色值分别为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> definedColors = [</span><br><span class="line">    <span class="number">220</span>, <span class="number">83</span>, <span class="number">26</span>, <span class="number">197</span>, <span class="number">59</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>220 为黄色，代表金；83 为绿色，代表木；26 蓝色代表水；197 红色代表火；59 灰色代表土。</p><p>如果那个字无法找到属性，则不上色，保持默认。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = result.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> withColor = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; wuxing.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> wx = wuxing[j];</span><br><span class="line">            <span class="keyword">if</span>(wx === <span class="string">" "</span>) &#123;</span><br><span class="line">                withColor += name[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dict[wx].indexOf(name[i]) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> color = <span class="keyword">new</span> Color(name[i]);</span><br><span class="line">                color.fgcolor = definedColors[j];</span><br><span class="line">                withColor += color.toString();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> withColor;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此我们的 CLI 就写好了，最后别忘了在 <a href="https://github.com/BoogeeDoo/hua/blob/09f1bc7eae14faaa9e881392d3811a6073d94b1c/bin/hua" target="_blank" rel="external">hua</a> 这个 CLI 文件顶部加上一句话。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure><p>这代表到时候如果要 <code>./hua</code> 的时候这个脚本是用 Node.js 来跑的。</p><h2 id="收拾"><a href="#收拾" class="headerlink" title="收拾"></a>收拾</h2><p>本来想好好写篇起花名的牢骚，结果不知不觉写成了给初心者看的初级教程了，泪目 ( •̥́ ˍ •̀ू )</p><p>不嫌弃的就这么看看吧。</p><p>最后这里给出我写好的这个 <code>hua</code> 程序。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ [sudo] npm install -g huaming</span><br></pre></td></tr></table></figure><p>然后就能在命令行下面跑了，跑法上面几章有介绍过。它的 Repo 在<a href="https://github.com/BoogeeDoo/hua" target="_blank" rel="external">这里</a>。</p><p>最后希望这个包在你们起花名的时候还真有那么一丢丢的用处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;起因是我一个叫『小龙』的好基友由于某些原因离职去了一家跟阿里一样有着『花名文化』的公司，于是开始为花名犯愁。&lt;/p&gt;
&lt;p&gt;结合之前妹纸『弍
      
    
    </summary>
    
    
      <category term="阿里巴巴" scheme="https://xcoder.in/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
      <category term="花名" scheme="https://xcoder.in/tags/%E8%8A%B1%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 启动方式：一道关于全局变量的题目引发的思考·续</title>
    <link href="https://xcoder.in/2015/11/27/a-js-problem-about-global-continued/"/>
    <id>https://xcoder.in/2015/11/27/a-js-problem-about-global-continued/</id>
    <published>2015-11-27T06:36:27.000Z</published>
    <updated>2017-12-11T07:59:20.458Z</updated>
    
    <content type="html"><![CDATA[<p>本文是上文《<a href="https://xcoder.in/2015/11/26/a-js-problem-about-global/">Node.js 启动方式：一道关于全局变量的题目引发的思考</a>》的续章。</p><h2 id="原题回顾"><a href="#原题回顾" class="headerlink" title="原题回顾"></a>原题回顾</h2><p>我们还是先回顾下原题吧。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>上题由我们亲爱的<a href="http://f2e.souche.com/blog/author/wang-xing-long/" target="_blank" rel="external">小龙</a>童鞋发现并在我们的 901 群里提问的。</p></blockquote><p>不过在上面一篇文章中，我们讲的是在 REPL 和 <code>vm</code> 中有什么事情，但是并没有解释为什么在文件模块的载入形式下，<code>var</code> 并不会挂载到全局变量去。</p><p>其实原因很简单，大家应该也都明白，在 Node.js 中，每个文件相当于是一个闭包，在 <code>require</code> 的时候被编译包了起来。</p><p>但是具体是怎么样的呢？虽然网上也有很多答案，我还是决定在这里按上一篇文章的尿性稍微解释一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们还是回到上一篇文章的《Node REPL 启动的沙箱》一节，里面说了当启动 Node.js 的时候是以 <a href="https://github.com/nodejs/node/blob/dfee4e3712ac4673b5fc472a8f77ac65bdc65f87/src/node.js" target="_blank" rel="external">src/node.js</a> 为入口的。</p><p>如果以 REPL 为途径启动的话是直接启动一个 <code>vm</code>，而此时的所有根级变量都在最顶级的作用域下，所以一个 <code>var</code> 自然会绑定到 <code>global</code> 下面了。</p><p>而如果是以文件，即 <code>$ node foo.js</code> 形式启动的话，它就会执行 src/node.js 里面的另一坨条件分支了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.argv[<span class="number">1</span>]) &#123;</span><br><span class="line">  <span class="comment">// make process.argv[1] into a full path</span></span><br><span class="line">  <span class="keyword">var</span> path = NativeModule.require(<span class="string">'path'</span>);</span><br><span class="line">  process.argv[<span class="number">1</span>] = path.resolve(process.argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  startup.preloadModules();</span><br><span class="line">  <span class="keyword">if</span> (global.v8debug &amp;&amp;</span><br><span class="line">      process.execArgv.some(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.match(<span class="regexp">/^--debug-brk(=[0-9]*)?$/</span>);</span><br><span class="line">      &#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || <span class="number">50</span>;</span><br><span class="line">    setTimeout(Module.runMain, debugTimeout);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Main entry point into most programs:</span></span><br><span class="line">    Module.runMain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>从上面的代码看出，只要是以 <code>$ node foo.js</code> 形式启动的，都会经历 <code>startup.preloadModules()</code> 和 <code>Module.runMain()</code> 两个函数。</p><h3 id="startup-preloadModules"><a href="#startup-preloadModules" class="headerlink" title="startup.preloadModules()"></a>startup.preloadModules()</h3><p>我们来看看<a href="https://github.com/nodejs/node/blob/dfee4e3712ac4673b5fc472a8f77ac65bdc65f87/src/node.js#L870" target="_blank" rel="external">这个函数</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">startup.preloadModules = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process._preload_modules) &#123;</span><br><span class="line">    NativeModule.require(<span class="string">'module'</span>)._preloadModules(process._preload_modules);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上就是执行的 lib/module.js 里面的 <code>_preloadModules</code> 函数，并且把这个 <code>process._preload_modules</code> 给传进去。当然，前提是有这个 <code>process._preload_modules</code>。</p><h4 id="process-preload-modules"><a href="#process-preload-modules" class="headerlink" title="process._preload_modules"></a>process._preload_modules</h4><p>这个 <code>process._preload_modules</code> 指的就是当你在使用 Node.js 的时候，命令行里面的 <code>--require</code> 参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r, --require         module to preload (option can be repeated)</span><br></pre></td></tr></table></figure><p>代码在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc#L3306" target="_blank" rel="external">src/node.cc</a> 里面可考。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--require"</span>) == <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">strcmp</span>(arg, <span class="string">"-r"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">module</span> = argv[index + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s requires an argument\n"</span>, argv[<span class="number">0</span>], arg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  args_consumed += <span class="number">1</span>;</span><br><span class="line">  local_preload_modules[preload_module_count++] = <span class="keyword">module</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>如果遇到了 <code>--require</code> 这个参数，则对静态变量 <code>local_preload_modules</code> 和 <code>preload_module_count</code> 做处理，把这个预加载模块路径加进去。</p><p>待到<a href="https://github.com/nodejs/node/blob/master/src/node.cc#L2933" target="_blank" rel="external">要生成 <code>process</code> 这个变量的时候</a>，再把预加载模块的信息放到 <code>process._preload_modules</code> 里面去。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupProcessObject</span><span class="params">(Environment* env,</span><br><span class="line">                        <span class="keyword">int</span> argc,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* argv,</span><br><span class="line">                        <span class="keyword">int</span> exec_argc,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* exec_argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (preload_module_count) &#123;</span><br><span class="line">    CHECK(preload_modules);</span><br><span class="line">    Local&lt;Array&gt; <span class="built_in">array</span> = Array::New(env-&gt;isolate());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preload_module_count; ++i) &#123;</span><br><span class="line">      Local&lt;String&gt; <span class="keyword">module</span> = String::NewFromUtf8(env-&gt;isolate(),</span><br><span class="line">                                                 preload_modules[i]);</span><br><span class="line">      <span class="built_in">array</span>-&gt;Set(i, <span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    READONLY_PROPERTY(process,</span><br><span class="line">                      <span class="string">"_preload_modules"</span>,</span><br><span class="line">                      <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] preload_modules;</span><br><span class="line">    preload_modules = <span class="literal">nullptr</span>;</span><br><span class="line">    preload_module_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的就是这句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">READONLY_PROPERTY(process,</span><br><span class="line">                  <span class="string">"_preload_modules"</span>,</span><br><span class="line">                  <span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><h4 id="require-‘module’-preloadModules"><a href="#require-‘module’-preloadModules" class="headerlink" title="require(‘module’)._preloadModules"></a>require(‘module’)._preloadModules</h4><p>上面我们讲了这个 <code>process._preload_modules</code>，然后现在我们说说是如何把 <code>$ node --require bar.js foo.js</code> 给预加载进去的。</p><p>接下去我们就要移步到 lib/module.js 文件里面去了。</p><p>在<a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/lib/module.js#L496" target="_blank" rel="external">第 496 行左右</a>的地方有这个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module._preloadModules = <span class="function"><span class="keyword">function</span>(<span class="params">requests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(requests))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Preloaded modules have a dummy parent module which is deemed to exist</span></span><br><span class="line">  <span class="comment">// in the current working directory. This seeds the search path for</span></span><br><span class="line">  <span class="comment">// preloaded modules.</span></span><br><span class="line">  <span class="keyword">var</span> parent = <span class="keyword">new</span> Module(<span class="string">'internal/preload'</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    parent.paths = Module._nodeModulePaths(process.cwd());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  requests.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    parent.require(request);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大概我们能看到，就是以 <code>internal/preload</code> 为 ID 的 Module 对象来载入这些预加载模块。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Module(<span class="string">'internal/preload'</span>, <span class="literal">null</span>);</span><br><span class="line">requests.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  parent.require(request);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据这个函数的注释说明，这个 Module 对象是一个虚拟的 Module 对象，主要是跟非预加载的那些模块给隔离或者区别开来，并且提供一个模块搜索路径。</p><h3 id="Module-runMain"><a href="#Module-runMain" class="headerlink" title="Module.runMain()"></a>Module.runMain()</h3><p>看完上面的说明，我们接下去看看 <code>Module.runMain()</code> 函数。</p><p>这个函数还是位于 <a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/lib/module.js#L455" target="_blank" rel="external">lib/module.js</a>  文件里面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Load the main module--the command line argument.</span></span><br><span class="line">  Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Handle any nextTicks added in the first tick of the program</span></span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们看到了就是在这句话中，Module 载入了 <code>process.argv[1]</code> 也就是文件名，自此一发不可收拾。</p><h4 id="Module-load"><a href="#Module-load" class="headerlink" title="Module._load"></a>Module._load</h4><p>这个函数相信很多人都知道它的用处了，无非就是载入文件，并加载到一个闭包里面。</p><p>这样一来在文件里面 <code>var</code> 出来的变量就不在根作用域下面了，所以不会粘到 <code>global</code> 里面去。它的 <code>this</code> 就是包起来的这个闭包了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.load(filename);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码首先是根据传入的文件名找到真的文件地址，就是所谓的搜索路径了。比如 <code>require(&quot;foo&quot;)</code> 就会分别从 <code>node_modules</code> 路径等依次查找下来。</p><p>我经常 Hack 这个 <code>_resolveFilename</code> 函数来简化 <code>require</code> 函数，比如我希望我用 <code>require(&quot;controller/foo&quot;)</code> 就能直接拿到 ./src/controller/foo.js 文件。有兴趣讨论一下这个用法的童鞋可以转到我的 <a href="https://gist.github.com/XadillaX/bc0e7c92925de0647477" target="_blank" rel="external">Gist</a> 上查看 Hack 的一个 Demo。</p><p>第二步就是我们常说的缓存了。如果这个模块之前加载过，那么在 <code>Module._cache</code> 下面会有个缓存，直接去取就是了。</p><p>第三步就是看看是不是 <code>NativeModule</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">  debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">  <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NativeModule"><a href="#NativeModule" class="headerlink" title="NativeModule"></a>NativeModule</h5><p>之前的代码里面其实也没少出现这个 <code>NativeModule</code>。那这个 <code>NativeModule</code> 到底是个 shenmegui 呢？</p><p>其实它还是在 Node.js 的入口 <a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/src/node.js#L886" target="_blank" rel="external">src/node.js</a> 里面。</p><p>它主要用来加载 Node.js 的一些原生模块，比如说 <code>NativeModule.require(&quot;child_process&quot;)</code> 等，也用于一些 <code>internal</code> 模块的载入，比如 <code>NativeModule.require(&quot;internal/repl&quot;)</code>。</p><p>之前代码的这个判断就是说如果判断要载入的文件是一个原生模块，那么就使用 <code>NativeModule.require</code> 来载入。</p><h6 id="NativeModule-require"><a href="#NativeModule-require" class="headerlink" title="NativeModule.require"></a>NativeModule.require</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NativeModule.require = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="string">'native_module'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cached = NativeModule.getCached(id);</span><br><span class="line">  <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">    <span class="keyword">return</span> cached.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!NativeModule.exists(id)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No such native module '</span> + id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process.moduleLoadList.push(<span class="string">'NativeModule '</span> + id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nativeModule = <span class="keyword">new</span> NativeModule(id);</span><br><span class="line"></span><br><span class="line">  nativeModule.cache();</span><br><span class="line">  nativeModule.compile();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nativeModule.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看看是否是本身，再看看是否被缓存，然后看看是否合法。接下去就是填充 <code>process.moduleLoadList</code>，最后载入这个原生模块、缓存、编译并返回。</p><blockquote><p>有兴趣的同学可以在 Node.js 中输出 <code>process.moduleLoadList</code> 看看。</p></blockquote><p>这个 <code>compile</code> 很重要。</p><h6 id="NativeModule-prototype-compile"><a href="#NativeModule-prototype-compile" class="headerlink" title="NativeModule.prototype.compile"></a>NativeModule.prototype.compile</h6><p>在 <code>NativeModule</code> 编译的过程中，大概的步骤是获取代码、包裹（Wrap）代码，把包裹的代码 <code>runInContext</code> 一遍得到包裹好的函数，然后执行一遍就算载入好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">  source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = runInThisContext(source, &#123; <span class="attr">filename</span>: <span class="keyword">this</span>.filename &#125;);</span><br><span class="line">  fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们往这个 src/node.js 文件这个函数的上面几行看一下，就知道包裹代码是怎么回事了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.wrapper = [</span><br><span class="line">  <span class="string">'(function (exports, require, module, __filename, __dirname) &#123;\n'</span>,</span><br><span class="line">  <span class="string">'\n&#125;);'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们能知道的就是比如我们一个内置模块的代码是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>那么包裹好的代码将会是这样子的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样一看就明白了这些 <code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code> 和 <code>__dirname</code> 是怎么来了吧。</p><p>当我们通过 <code>var fn = runInThisContext(source, { filename: this.filename });</code> 得到了这个包裹好的函数之后，我们就把相应的参数传进这个闭包函数去执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br></pre></td></tr></table></figure><p>这个 <code>this</code> 就是对应的这个 <code>module</code>，自然这个 <code>module</code> 里面就有它的 <code>exports</code>；<code>require</code> 函数就是 <code>NativeModule.require</code>。</p><p>所以我们看到的在 <code>lib/*.js</code> 文件里面的那些 <code>require</code> 函数，实际上就是包裹好之后的代码的 <code>NativeModule.require</code> 了。</p><p>所以说实际上这些内置模块内部的根作用域下的 <code>var</code> 再怎么样高级也都是在包裹好的闭包里面 <code>var</code>，怎么的也跟 <code>global</code> 搭不着边。</p><h6 id="内部原生模块"><a href="#内部原生模块" class="headerlink" title="内部原生模块"></a>内部原生模块</h6><p>通过上面的追溯我们知道了，如果我们在代码里面使用 <code>require</code> 的话，会先看看这个模块是不是原生模块。</p><p>不过回过头看一下它的这个判断条件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果是原生模块并且不是原生内部模块的话。</p></blockquote><p>那是怎么区分原生模块和内部原生模块呢？</p><p>我们再来看看这个 <code>NativeModule.nonInternalExists(filename)</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NativeModule.nonInternalExists = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NativeModule.exists(id) &amp;&amp; !NativeModule.isInternal(id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.isInternal = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id.startsWith(<span class="string">'internal/'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码是去除各种杂七杂八的条件之后的一种情况，别的情况还请各位童鞋自行看 Node.js 源码。</p></blockquote><p>也就是说我们在我们自己的代码里面是请求不到 Node.js 源码里面 <code>lib/internal/*.js</code> 这些文件的——因为它们被上面的这个条件分支给过滤了。（比如 <code>require(&quot;internal/module&quot;)</code> 在自己的代码里面是无法运行的）</p><blockquote><p><strong>注意：</strong> 不过有一个例外，那就是 <code>require(&quot;internal/repl&quot;)</code>。详情可以参考这个 <a href="https://github.com/nodejs/node/issues/3393" target="_blank" rel="external">Issue</a> 和<a href="https://github.com/nodejs/node/blob/9148114c93861359a502801499d4c26d0b761174/lib/module.js#L276-L277" target="_blank" rel="external">这段代码</a>。</p></blockquote><h5 id="Module-prototype-load"><a href="#Module-prototype-load" class="headerlink" title="Module.prototype.load"></a>Module.prototype.load</h5><p>解释完了上面的 <code>NativeModule</code> 之后，我们要就上面 <code>Module._load</code> 里面的下一步 <code>module.load</code> 也就是 <code>Module.prototype.load</code> 做解析了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>做了一系列操作之后得到了真·文件名，然后判断一下后缀。如果是 <code>&quot;.js&quot;</code> 的话执行 <code>Module._extensions[&quot;.js&quot;]</code> 这个函数去编译代码，如果是 <code>&quot;.json&quot;</code> 则是 <code>Module._extensions[&quot;.json&quot;]</code>。</p><p>这里我们略过 JSON 和 C++ Addon，直奔 <code>Module._extensions[&quot;.js&quot;]</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">module</span>._compile(internalModule.stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它也很简单，就是奔着 <code>_compile</code> 去的。</p><h6 id="Module-prototype-compile"><a href="#Module-prototype-compile" class="headerlink" title="Module.prototype._compile"></a>Module.prototype._compile</h6><p>先上<a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/lib/module.js#L378-L426" target="_blank" rel="external">代码</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// remove shebang</span></span><br><span class="line">  content = content.replace(shebangRe, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.require(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Module._resolveFilename(request, self);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>.main = process.mainModule;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enable support to add extra extension types</span></span><br><span class="line">  <span class="built_in">require</span>.extensions = Module._extensions;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">require</span>.cache = Module._cache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dirname = path.dirname(filename);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create wrapper function</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> compiledWrapper = runInThisContext(wrapper,</span><br><span class="line">                                      &#123; <span class="attr">filename</span>: filename, <span class="attr">lineOffset</span>: <span class="number">-1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = [self.exports, <span class="built_in">require</span>, self, filename, dirname];</span><br><span class="line">  <span class="keyword">return</span> compiledWrapper.apply(self.exports, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉流程上跟 <code>NativeModule</code> 的编译相似，不过这里是事先准备好要在载入的文件里面用的 <code>require</code> 函数，以及一些 <code>require</code> 的周边。</p><p>接下去就是用 <code>Module.wrap</code> 来包裹代码了，包裹完之后把得到的函数用参数 <code>self.exports, require, self, filename, dirname</code> 去执行一遍，就算是文件载入完毕了。</p><p>最后回到之前载入代码的那一刻，把载入完毕得到的 <code>module.exports</code> 再 <code>return</code> 出去就好了。</p><h6 id="Module-wrap"><a href="#Module-wrap" class="headerlink" title="Module.wrap"></a>Module.wrap</h6><p>这个就不用说了。</p><p>在 lib/module.js 的<a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/lib/module.js#L46-L48" target="_blank" rel="external">最顶端附近</a>有这么几行代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.wrapper = NativeModule.wrapper;</span><br><span class="line">Module.wrap = NativeModule.wrap;</span><br><span class="line">Module._debug = util.debuglog(<span class="string">'module'</span>);</span><br></pre></td></tr></table></figure><p>一切豁然开朗了吧。</p><p>连 <code>NativeModule</code> 的代码都逃不开被之前说的闭包所包裹，那么你自己写的 JS 文件当然也会被 <code>NativeModule.wrap</code> 所包裹。</p><p>那么你在代码根作用域申明的函数实际上在运行时里面已经被一个闭包给包住了。</p><p>以前可能很多同学只知道是被闭包包住了，但是包的方法、流程今天算是解析了一遍了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个 <code>var a</code> 怎么也不可能绑到 <code>global</code> 去啊。</p><h6 id="Module-prototype-require"><a href="#Module-prototype-require" class="headerlink" title="Module.prototype.require"></a>Module.prototype.require</h6><p>虽然我们上面讲得差不多了，可能很多童鞋也厌烦了。</p><p>不过该讲完的还是得讲完。</p><p>我们在我们自己文件中用的 <code>require</code> 在上一节里面有提到过，传到我们闭包里面的 <code>require</code> 实际上是长这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> self.require(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实际上就是个 <code>Module.prototype.require</code>。</p><p>我们再看看<a href="https://github.com/nodejs/node/blob/e25f8683f1735f55a27c00d41691be286f50e13f/lib/module.js#L362-L366" target="_blank" rel="external">这个函数</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  assert(path, <span class="string">'missing path'</span>);</span><br><span class="line">  assert(<span class="keyword">typeof</span> path === <span class="string">'string'</span>, <span class="string">'path must be a string'</span>);</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一下子又绕回到了我们一开始的 <code>Module._load</code>。</p><p>所以基本上就差不多到这过了。</p><h2 id="REPL-vs-文件启动"><a href="#REPL-vs-文件启动" class="headerlink" title="REPL vs 文件启动"></a>REPL vs 文件启动</h2><p>最后我们再点一下，或者说回顾一下吧。</p><p>REPL 启动的时候 Node.js 是开了个 <code>vm</code> 直接让你跑，并没有把代码包在一个闭包里面，所以再根作用域下的变量会 <code>Biu</code> 一下贴到 <code>global</code> 中去。</p><p>而文件启动的时候，会做本文中说的一系列事情，然后就会把各文件都包到一个闭包去，所以变量就无法通过这种方式来贴到 <code>global</code> 去了。</p><p>不过这种二义性会在 <code>&quot;use strict&quot;;</code> 中戛然而止。</p><p>珍爱生命，<code>use strict</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文可能很多童鞋看完后悔觉得很坑——JS 为什么有那么多二义性那么坑呢。</p><p>其实不然，主要是可能很多人对 Node.js 执行的机制不是很了解。</p><p>本文从小龙抛出的一个简单问题进入，然后浅入浅出 Node.js 的一些执行机制什么的，希望对大家还是有点帮助，更何况我在意的不是问题本身，而是分析的这个过程。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><blockquote><p>以下均为臆想。</p><p><strong>小龙：</strong> 喂喂喂，我就问一个简单的小破题目，你至于嘛！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是上文《&lt;a href=&quot;https://xcoder.in/2015/11/26/a-js-problem-about-global/&quot;&gt;Node.js 启动方式：一道关于全局变量的题目引发的思考&lt;/a&gt;》的续章。&lt;/p&gt;
&lt;h2 id=&quot;原题回顾&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="源码分析" scheme="https://xcoder.in/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="REPL" scheme="https://xcoder.in/tags/REPL/"/>
    
      <category term="vm" scheme="https://xcoder.in/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 启动方式：一道关于全局变量的题目引发的思考</title>
    <link href="https://xcoder.in/2015/11/26/a-js-problem-about-global/"/>
    <id>https://xcoder.in/2015/11/26/a-js-problem-about-global/</id>
    <published>2015-11-26T13:51:37.000Z</published>
    <updated>2017-12-11T07:59:20.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>　　题目是这样的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>上题由我们亲爱的<a href="http://f2e.souche.com/blog/author/wang-xing-long/" target="_blank" rel="external">小龙</a>童鞋发现并在我们的 901 群里提问的。</p></blockquote><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>　　然后有下面的小对话。</p><blockquote><p><strong>小龙：</strong>你们猜这个输出什么？</p><p><strong>弍纾：</strong>2</p><p><strong>力叔：</strong>2 啊</p><p><strong>死月·丝卡蕾特：</strong>2</p><p><strong>力叔：</strong>有什么问题么？</p><p><strong>小龙：</strong>输出 undefind。</p><p><strong>死月·丝卡蕾特：</strong>你确定？</p><p><strong>小龙：</strong>是不是我电脑坏了</p><p><strong>力叔：</strong>你确定？</p><p><strong>弍纾：</strong>你确定？</p><p><strong>小龙：</strong>为什么我 node 文件名跑出来的是 undefined？</p><p><strong>郑昱：</strong>-.- 一样阿。undefined</p></blockquote><p>　　以上就是刚见到这个题目的时候群里的一个小讨论。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>　　后来我就觉得奇怪，既然小龙验证过了，说明他也不是随地大小便，无的放矢什么的。</p><p>　　于是我也验证了一下，不过由于偷懒，没有跟他们一样写在文件里面，而是直接 node 开了个 REPL 来输入上述代码。</p><blockquote><p><strong>结果是 2！</strong></p><p><strong>结果是 2！</strong></p><p><strong>结果是 2！</strong></p></blockquote><p>　　于是这就出现了一个很奇怪的问题。</p><p>　　尼玛为毛我是 <code>2</code> 他们俩是 <code>undefined</code> 啊！</p><p>　　不过马上我就反应过来了——我们几个的环境不同，他们是 <code>$ node foo.js</code> 而我是直接 node 开了个 REPL，所以有一定的区别。</p><p>　　而力叔本身就是前端大神，我估计是以 Chrome 的调试工具下为基础出的答案。</p><h2 id="REPL-vs-文件执行"><a href="#REPL-vs-文件执行" class="headerlink" title="REPL vs 文件执行"></a>REPL vs 文件执行</h2><p>　　其实上述的问题，需要解释的问题大概就是 <code>a</code> 到底挂在哪了。</p><p>　　因为细细一想，在 <code>function</code> 当中，<code>this</code> 指向的目标是 <code>global</code> 或者 <code>window</code>。</p><blockquote><p>还无法理解上面这句话的童鞋需要先补一下基础。</p></blockquote><p>　　那么最终需要解释的就是 <code>a</code> 到底有没有挂在全局变量上面。</p><p>　　这么一想就有点细思恐极的味道了——如果在 node 线上运行环境里面的源代码文件里面随便 <code>var</code> 一个变量就挂到了全局变量里面那是有多恐怖！</p><p>　　于是就有些释然了。</p><p>　　但究竟是什么原因导致 REPL 和文件执行方式不一样的呢？</p><h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>　　首先是弍纾找出了阮老师 ES6 系列文章中的<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="external">全局对象属性</a>一节。</p><blockquote><p>全局对象是最顶层的对象，在浏览器环境指的是 window 象，在 Node.js 指的是 global 对象。ES5 之中，全局对象的属性与全局变量是等价的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）</p></blockquote><p>有了阮老师的文章验证了这个猜想，我可以放心大胆继续看下去了。</p><h3 id="repl-js"><a href="#repl-js" class="headerlink" title="repl.js"></a>repl.js</h3><p>　　知道了上文的内容之后，感觉首要查看的就是 Node.js 源码中的 <a href="https://github.com/nodejs/node/blob/master/lib/repl.js#L513" target="_blank" rel="external">repl.js</a> 了。</p><p>　　先是结合了一下自己以前用自定义 REPL 的情况，一般的步骤先是获取 REPL 的上下文，然后在上下文里面贴上各种自己需要的东西。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = relp.start(<span class="string">" ➜ "</span>);</span><br><span class="line"><span class="keyword">var</span> c = r.context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 c 里面贴上各种上下文</span></span><br><span class="line">c.foo = bar;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><blockquote><p>关于自定义 REPL 的一些使用方式可以参考下老雷写的《<a href="https://cnodejs.org/topic/563735ed677332084c319d95" target="_blank" rel="external">Node.js 定制 REPL 的妙用</a>》。</p></blockquote><p>　　有了之前写 REPL 的经验，大致明白了 REPL 里面有个上下文的东西，那么在 repl.js 里面我们也找到了类似的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">REPLServer.prototype.createContext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.useGlobal) &#123;</span><br><span class="line">    context = global;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = vm.createContext();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> global) context[i] = global[i];</span><br><span class="line">    context.console = <span class="keyword">new</span> Console(<span class="keyword">this</span>.outputStream);</span><br><span class="line">    context.global = context;</span><br><span class="line">    context.global.global = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.module = <span class="built_in">module</span>;</span><br><span class="line">  context.require = <span class="built_in">require</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.lines = [];</span><br><span class="line">  <span class="keyword">this</span>.lines.level = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// make built-in modules available directly</span></span><br><span class="line">  <span class="comment">// (loaded lazily)</span></span><br><span class="line">  exports._builtinLibs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(context, name, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> lib = <span class="built_in">require</span>(name);</span><br><span class="line">        context._ = context[name] = lib;</span><br><span class="line">        <span class="keyword">return</span> lib;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// allow the creation of other globals with this name</span></span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> context[name];</span><br><span class="line">        context[name] = val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　看到了关键字 <code>vm</code>。我们暂时先不管 <code>vm</code>，光从上面的代码可以看出，<code>context</code> 要么等于 <code>global</code>，要么就是把 <code>global</code> 上面的所有东西都粘过来。</p><p>　　然后顺带着把必须的两个不在 <code>global</code> 里的两个东西 <code>require</code> 和 <code>module</code> 给弄过来。</p><p>　　下面的东西就不需要那么关心了。</p><h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><p>　　接下去我们来讲讲 <code>vm</code>。</p><p>　　VM 是 node 中的一个内置模块，可以在<a href="https://nodejs.org/dist/v4.2.2/docs/api/vm.html" target="_blank" rel="external">文档</a>中看到说明和使用方法。</p><p>　　大致就是将代码运行在一个沙箱之内，并且事先赋予其一些 <code>global</code> 变量。</p><p>　　而真正起到上述 <code>var</code> 和 <code>global</code> 区别的就是这个 <code>vm</code> 了。</p><p>　　<code>vm</code> 之中在根作用域（也就是最外层作用域）中使用 <code>var</code> 应该是跟在浏览器中一样，会把变量粘到 <code>global</code>（浏览器中是 <code>window</code>）中去。</p><p>　　我们可以试试这样的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">var</span> localVar = <span class="string">'initial value'</span>;</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(<span class="string">'var localVar = "vm";'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'localVar: '</span>, localVar);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global.localVar: '</span>, global.localVar);</span><br></pre></td></tr></table></figure><p>　　其输出结果是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localVar: initial value</span><br><span class="line">global.localVar: vm</span><br></pre></td></tr></table></figure><p>　　如文档中所说，<code>vm</code> 的一系列函数中跑脚本都无法对当前的局部变量进行访问。各函数能访问自己的 <code>global</code>，而 <code>runInThisContext</code> 的 <code>global</code> 与当前上下文的 <code>global</code> 是一样的，所以能访问当前的全局变量。</p><p>　　所以出现上述结果也是理所当然的了。</p><p>　　所以在 <code>vm</code> 中跑我们一开始抛出的问题，答案自然就是 <code>2</code> 了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="built_in">require</span>(<span class="string">"vm"</span>);</span><br><span class="line"><span class="keyword">var</span> sandbox = &#123;</span><br><span class="line">    <span class="attr">console</span>: <span class="built_in">console</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line">vm.runInContext(<span class="string">"var a = 2;function foo()&#123;console.log(this.a);&#125;foo();"</span>, sandbox);</span><br></pre></td></tr></table></figure><h3 id="Node-REPL-启动的沙箱"><a href="#Node-REPL-启动的沙箱" class="headerlink" title="Node REPL 启动的沙箱"></a>Node REPL 启动的沙箱</h3><p>　　最后我们再只需要验证一件事就能真相大白了。</p><p>　　平时我们自定义一个 <code>repl.js</code> 然后执行 <code>$ node repl.js</code> 的话是会启动一个 REPL，而这个 REPL 会去调 <code>vm</code>，所以会出现 <code>2</code> 的答案；或者我们自己在代码里面写一个 <code>vm</code> 然后跑之前的代码，也是理所当然出现 <code>2</code>。</p><p>　　那么我们就输入 <code>$ node</code> 来进入的 REPL 跟我们之前讲的 REPL 是不是同一个东西呢？</p><p>　　如果是的话，一切就释然了。</p><p>　　首先我们进入到 Node 的入口文件——C++ 的 <code>int main()</code>。</p><p>　　它在 Node.js 源码 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/src/node_main.cc#L45" target="_blank" rel="external">src/node_main.cc</a> 之中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">return</span> node::Start(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　就在主函数中执行了 <code>node::Start</code>。而这个 <code>node::Start</code> 又存在 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/src/node.cc#L4109" target="_blank" rel="external">src/node.cc</a> 里面。</p><p>　　然后在 <code>node::Start</code> 里面又调用 <code>StartNodeInstance</code>，在这里面是 <code>LoadEnvironment</code> 函数。</p><p>　　最后在 <code>LoadEnvironment</code> 中看到了几句关键的语句：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), <span class="string">"node.js"</span>);</span><br><span class="line">Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">Local&lt;Function&gt; f = Local&lt;Function&gt;::Cast(f_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Local&lt;Object&gt; global = env-&gt;context()-&gt;Global();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Local&lt;Value&gt; arg = env-&gt;process_object();</span><br><span class="line">f-&gt;Call(global, <span class="number">1</span>, &amp;arg);</span><br></pre></td></tr></table></figure><p>　　还有这么一段关键的注释。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Now we call 'f' with the 'process' variable that we've built up with</span></span><br><span class="line"><span class="comment">// all our bindings. Inside node.js we'll take care of assigning things to</span></span><br><span class="line"><span class="comment">// their places.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We start the process this way in order to be more modular. Developers</span></span><br><span class="line"><span class="comment">// who do not like how 'src/node.js' setups the module system but do like</span></span><br><span class="line"><span class="comment">// Node's I/O bindings may want to replace 'f' with their own function.</span></span><br></pre></td></tr></table></figure><p>　　也就是说，启动 <code>node</code> 的时候，在做了一些准备之后是开始载入执行 src 文件夹下面的 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/src/node.js" target="_blank" rel="external">node.js</a> 文件。</p><p>　　在 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/src/node.js#L92" target="_blank" rel="external">92 行</a>附近有针对 <code>$ node foo.js</code> 和 <code>$ node</code> 的判断启动不同的逻辑。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.argv[<span class="number">1</span>]) &#123;</span><br><span class="line">  <span class="comment">// make process.argv[1] into a full path</span></span><br><span class="line">  <span class="keyword">var</span> path = NativeModule.require(<span class="string">'path'</span>);</span><br><span class="line">  process.argv[<span class="number">1</span>] = path.resolve(process.argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  startup.preloadModules();</span><br><span class="line">  <span class="keyword">if</span> (global.v8debug &amp;&amp;</span><br><span class="line">      process.execArgv.some(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.match(<span class="regexp">/^--debug-brk(=[0-9]*)?$/</span>);</span><br><span class="line">      &#125;)) &#123;</span><br><span class="line">    <span class="keyword">var</span> debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || <span class="number">50</span>;</span><br><span class="line">    setTimeout(Module.runMain, debugTimeout);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Main entry point into most programs:</span></span><br><span class="line">    Module.runMain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process._forceRepl || NativeModule.require(<span class="string">'tty'</span>).isatty(<span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// REPL</span></span><br><span class="line">    <span class="keyword">var</span> cliRepl = Module.requireRepl();</span><br><span class="line">    cliRepl.createInternalRepl(process.env, <span class="function"><span class="keyword">function</span>(<span class="params">err, repl</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在上述节选代码的第一个 <code>else if</code> 中，就是对 <code>$ node foo.js</code> 这种情况进行处理了，再做完各种初始化之后，使用 <code>Module.runMain();</code> 来运行入口代码。</p><p>　　第二个 <code>else if</code> 里面就是 <code>$ node</code> 这种情况了。</p><p>　　我们在终端中打开 <code>$ node</code> 的时候，TTY 通常是关连着的，所以 <code>require(&#39;tty&#39;).isatty(0)</code> 为 <code>true</code>，也就是说会进到条件分支并且执行里面的 <code>cliRepl</code> 相关代码。</p><p>　　我们进入到 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/lib/module.js#L490" target="_blank" rel="external">lib/module.js</a> 看看这个 <code>Module.requireRepl</code> 是什么东西。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module.requireRepl = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module._load(<span class="string">'internal/repl'</span>, <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　所以我们还是得转入 <a href="https://github.com/nodejs/node/blob/0966ab99966b7d3fbe4d7b93797fb299595fca72/lib/internal/repl.js#L23" target="_blank" rel="external">lib/internal/repl.js</a> 来一探究竟。</p><p>　　上面在 <code>node.js</code> 里面我们看到它执行了这个 <code>cliRepl</code> 的 <code>createInternalRepl</code> 函数，它的实现大概是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRepl</span>(<span class="params">env, opts, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  opts = opts || &#123;</span><br><span class="line">    <span class="attr">ignoreUndefined</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">terminal</span>: process.stdout.isTTY,</span><br><span class="line">    <span class="attr">useGlobal</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  opts.replMode = &#123;</span><br><span class="line">    <span class="string">'strict'</span>: REPL.REPL_MODE_STRICT,</span><br><span class="line">    <span class="string">'sloppy'</span>: REPL.REPL_MODE_SLOPPY,</span><br><span class="line">    <span class="string">'magic'</span>: REPL.REPL_MODE_MAGIC</span><br><span class="line">  &#125;[<span class="built_in">String</span>(env.NODE_REPL_MODE).toLowerCase().trim()];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repl = REPL.start(opts);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　转头一看这个 lib/internal/repl.js 顶端的模块引入，赫然看到一句话：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> REPL = <span class="built_in">require</span>(<span class="string">'repl'</span>);</span><br></pre></td></tr></table></figure><p>　　真相大白。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　最后再梳理一遍。</p><p>　　在于 Node.js 的 <code>vm</code> 里面，顶级作用域下的 <code>var</code> 会把变量贴到 <code>global</code> 下面。而 REPL 使用了 <code>vm</code>。然后 <code>$ node</code> 进入的一个模式就是一个特定参数下面启动的一个 <code>REPL</code>。</p><p>　　所以我们一开始提出的问题里面在 <code>$ node foo.js</code> 模式下执行是 <code>undefined</code>，因为不在全局变量上，但是启用 <code>$ node</code> 这种 REPL 模式的时候得到的结果是 <code>2</code>。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><blockquote><p><strong>小龙：</strong>我用 node test.js 跑出来是 <code>a: undefined</code>；那我应该怎么修改“环境”，来让他跑出：<code>a: 2</code> 呢？</p></blockquote><p>　　于是有了上面写的那段代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="built_in">require</span>(<span class="string">"vm"</span>);</span><br><span class="line"><span class="keyword">var</span> sandbox = &#123;</span><br><span class="line">    <span class="attr">console</span>: <span class="built_in">console</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line">vm.runInContext(<span class="string">"var a = 2;function foo()&#123;console.log(this.a);&#125;foo();"</span>, sandbox);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h2&gt;&lt;p&gt;　　题目是这样的。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="源码分析" scheme="https://xcoder.in/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="REPL" scheme="https://xcoder.in/tags/REPL/"/>
    
      <category term="vm" scheme="https://xcoder.in/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要使用哈希</title>
    <link href="https://xcoder.in/2015/10/16/why-i-use-hash/"/>
    <id>https://xcoder.in/2015/10/16/why-i-use-hash/</id>
    <published>2015-10-16T06:52:06.000Z</published>
    <updated>2017-12-11T07:59:20.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是哈希（Hash）"><a href="#什么是哈希（Hash）" class="headerlink" title="什么是哈希（Hash）"></a>什么是哈希（Hash）</h2><p>本来这里不应该出现这一节的，因为实际上大家应该都知道什么是哈希。不过有时候为了文章的完整性，我这里就稍微教条性地说明一下吧。ヽ(́◕◞౪◟◕‵)ﾉ</p><blockquote><p>散列（英语：Hashing），通常音译作哈希，是电脑科学中一种对资料的处理方法，通过某种特定的函数、算法将要检索的项与用来检索的索引关联起来，生成一种便于搜索的数据结构。也译为散列。</p><p style="text-align: right;">– From <a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97" target="_blank">散列</a>, Wikipedia</p></blockquote><p>实际上通俗的说法就是把某种状态或者资料给映射到某个值上的操作。</p><p>本酱大概就解释到这里了，至于哈希的进一步认知包括冲突的产生和解决等，如果米娜桑不了解的话还请自行学习咕。థ౪థ</p><h2 id="引子——子树问题"><a href="#引子——子树问题" class="headerlink" title="引子——子树问题"></a>引子——子树问题</h2><p>这个不是我在实践中遇到的问题，而是当年去某不作恶的大厂面试时候遇到的问题，觉得比较经典，所以就拿出来了。ᕙ༼ຈل͜ຈ༽ᕗ</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一棵二叉树，假设每个节点的数据只有左右子节点，自身并不存储数据。请找出两两完全相等的子树们。</p><blockquote><p>有兴趣的童鞋可以自己先思考一下。₍₍◝(･’ω’･)◟⁾⁾ </p></blockquote><h3 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h3><p>实际上我也不知道自己的做法是不是正确做法，不过既然通过了那一轮面试，想来也不会偏差到哪去喵。ლ（╹ε╹ლ）</p><p>做法大概如下：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#.E5.90.8E.E5.BA.8F.E9.81.8D.E5.8E.86" target="_blank" rel="external">后序遍历</a>一遍整棵树。</li><li>对于遍历到每一个节点，都获取到左右子节点的哈希值，然后将其拼接重新计算出自身的哈希值，并返回给父亲节点。</li></ol><p>至于哈希值怎么算，方法有很多。最简单的就是设叶子节点一个哈希值，比如是 <code>md5(&quot;&quot;)</code>，然后每次非叶子节点的哈希值就用 <code>md5(LEFT_HASH + RIGHT_HASH)</code> 来计算。大家也可以自己随便想一种方法来做就好了。</p><p>很多人可能不解了，明明是用 <code>md5</code>，这篇文章是讲哈希，有毛线关系。(╯°O°)╯┻━┻</p><p>实际上 <code>md5</code> 就是一种哈希算法，而且是非常经典的哈希算法。</p><blockquote><p>典型的哈希算法包括 MD2、MD4、MD5 和 SHA-1 等。当然不局限于这些，对于数字来说，取模也算是哈希算法，对于字符串状态转整数状态哈希来说还有诸如 <a href="http://www.partow.net/programming/hashfunctions/#BKDRHashFunction" target="_blank" rel="external">BKDR</a>、<a href="http://www.partow.net/programming/hashfunctions/#ELFHashFunction" target="_blank" rel="external">ELF</a> 等等。</p></blockquote><p>如果大家想多了解一些字符串转数字哈希的算法，可以参考一下 BYVoid 的这篇《<a href="https://www.byvoid.com/blog/string-hash-compare/" target="_blank" rel="external">各种字符串Hash函数比较</a>》，或者想直接在 Node.js 里面使用的小伙伴们可以光顾下这个包——<a href="https://github.com/XadillaX/bling_hashes" target="_blank" rel="external">bling-hashes</a>。</p><p>初步的轮廓已经明晰了，说白了就是将每个节点的哈希全算出来，如果是父亲节点就用子节点的哈希拼接起来再哈希一遍。σ`∀´)σ</p><p>把这些哈希算出来之后放在一个散列表里面待查。如果一个算出来的哈希跟之前已有的哈希值相等，那么就是说这个节点跟那个节点为根节点的子树有可能完全相等。</p><blockquote><p>注意：<strong>有可能</strong>完全相等。</p><p>注意：只是<strong>有可能</strong>完全相等。</p><p>注意：重要的事情说三遍，只是<strong>有可能</strong>完全相等。</p></blockquote><p>哈希是存在着一定的冲突概率的，所以说两个相等的哈希所检索到的源不一定一样，所以我们根据这些计算到的哈希建立哈希表，然后把表中同哈希值的子树再两两同时遍历一遍以检验是否相等。</p><ol><li>同时递归，取两个子树的根节点。</li><li>后序遍历，看看每个节点是不是都一样存在（或者不存在）左子节点以及存在（或者不存在）右子节点。</li><li>循环往复一直到两两遍历完整棵树得到验证结果。如果半路有一个节点的左右子节点状态不一样就可以直接跳出递归返回 <code>false</code>。</li></ol><p>至此为止，我们可以看出大概是两大步——<strong>计算各子树的哈希值</strong>和<strong>验证各同哈希子树的相等性</strong>。不过稍微变通一下，我们就可以在计算出哈希值的时候就去跟以前的对比了。</p><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>实际上上面的做法还有一个优化的方案，不过跟哈希相关性已经基本上很小了。不过还是跟<strong>解决冲突</strong>有一丢丢的关系的，没兴趣的童鞋也可以直接跳过了。(๑•́ ₃ •̀๑)</p><p>由于子树哈希值是存在一定的冲突概率的，所以两个同哈希的子树不一定相同。那么我们如果能一眼看出这样的两棵子树是不相等的，就可以省略验证这一个递归的步骤了。</p><p>这里有一种最显而易见的情况我们是可以忽略省略步骤的，那就是深度。</p><p>如果两棵子树两两完全相等，那么说明这俩基佬的深度（或者说高度）是一样的，如果连深度都不一样了还如何愉快搞基——所以说如果有两个相等哈希值的子树的深度不一样的话可以直接略过验证步骤了。</p><p>那么就可以这么做：</p><ol><li>设所有叶子节点的深度为 <code>0</code>，然后每往上一层加一。</li><li>遇到左右子节点深度不一样的父节点时，取深度大的那个子节点深度去加一。</li></ol><p>以上步骤在遍历计算哈希的时候顺便也做了，这样就多了一个验证标记了。</p><p>所以差不多就这样了，浅尝辄止。( ˘･з･)</p><h3 id="引子的小结"><a href="#引子的小结" class="headerlink" title="引子的小结"></a>引子的小结</h3><p>就上述的场景来说，哈希非常好地将一个非常复杂的状态转化成一个可以检索的状态。本来毫无头绪的一个问题使用了哈希之后就完全变成了一个检索加验证的过程了。</p><h2 id="报告图问题"><a href="#报告图问题" class="headerlink" title="报告图问题"></a>报告图问题</h2><p>这个问题就是我在大搜车中确实遇到的场景了。大家也不需要知道什么是报告图，就当它是一个代号了。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>要做的事情大概就是说给定一个报告，我们根据报告的各个细节选定各种图层然后揉成一团叠加在一起形成最后一个结果图。</p></blockquote><p>其实本来就有个系统在做这件事情的——每来一个报告就生成一张图，然后存储好之后给前端使用。</p><p>我做的事情是将逻辑迁移到另一套计算密集型任务集中处理系统中去。(<em>´艸`</em>)</p><p>其实生成这样一张图片的逻辑是 CPU 计算密集型的逻辑，所以比较耗费资源和时间的，那么我们就能在这上面做点手脚优化一下。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>首先我们要知道的是，有哪些图层是固定的，所以其实这算半个排列组合的问题了。</p><p>不过我们也知道排列组合的增长性非常快，更何况我这里有约 100 个图层选择，所以可能性非常多，一下子全生成好不可能。</p><p>那么就可以用哈希和懒惰的思想来实现了。(<em>ˇωˇ</em>人)</p><p>虽然报告是有无限种可能的，但是把报告转成图层数据之后，拥有完全一样的图层数据的报告就可以用同一张图片了，这样就可以大大节省空间和时间了。</p><p>其实大概的步骤非常简单：</p><ol><li>把图层数据计算成哈希。（比如把所有图层文件路径用某种符号拼接，再用 <code>md5</code> 计算一下）</li><li>去数据库查找这个哈希主键存不存在。<ul><li>如果存在则验证源图层数据域当前图层数据是否吻合。<ul><li>如果不吻合则按某种算法重新计算哈希，继续步骤 2。</li><li><strong>如果吻合则可以直接拿着这个数据返回了，跳出计算。</strong></li></ul></li><li>如果不存在就说明当前数据库还没有这个图层情况的报告图生成，那么就执行生成报告图逻辑。</li></ul></li><li>报告图生成之后，将其存入数据库中。<ul><li>计算出这个报告图图层数据的哈希，去数据库查存不存在。<ul><li>如果不存在则说明哈希不冲突，能用，直接用这个哈希存进去。</li><li>如果存在则说明哈希冲突，那么按某种算法重新计算哈希，继续上面的步骤直到不冲突为止。</li></ul></li></ul></li></ol><p>如果大家想知道“按某种算法重新生成哈希”里面“某种算法”的话可以看看下面的瞎狗眼的说明了。(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</p><blockquote><p>其实很简单，把图层数据的这个字符串加某个固定字符当小尾巴，如果哈希还是冲突则继续加这个小尾巴，直到计算出来的哈希不冲突为止。</p><p>比如我就用了这字符当小尾巴——<strong>🀣</strong>（麻将牌中的兰）。(♛‿♛)</p></blockquote><h3 id="报告图的小结"><a href="#报告图的小结" class="headerlink" title="报告图的小结"></a>报告图的小结</h3><p>在这种场景中，我把哈希拿来作检索某种报告图是否已经生成的用途。如果没有生成则生成一张，如果已经生成则直接拿已有的报告图去用。</p><p>至少比原来的来一张报告就生成一张图片来得快，并且省空间——相当于作冗余处理了。</p><p>事实上在很多的网盘系统中也有作冗余处理的。你以为你有多少多少 T 的空间，实际上相同的文件最终在网盘系统里面只存一份（不过排除备份的那些），而我相信做这些冗余判断的原理就是哈希了，SHA-1 也好 MD5 也好，反正就是这样。</p><blockquote><p>上面网盘的冗余处理原理也只是我的猜测，我没在那些厂子里面工作过所以不能说就是就是这样子的。欢迎指正。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡</p></blockquote><h2 id="唯一主键问题"><a href="#唯一主键问题" class="headerlink" title="唯一主键问题"></a>唯一主键问题</h2><p>这是我来这边工作后的另一个小插曲了，遇到一个主键生成的小需求。</p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个数据要插入到数据库，所以要给它生成一个主键，但是需求比较奇葩，可能是历史遗留问题吧。(눈‸눈)</p><ul><li>非自增。</li><li>是一个全是数字的字符串。</li><li>不同类型的这个表的数据用不同的前缀，比如 <code>10</code>、<code>11</code>、<code>12</code> 等。</li><li>位数在十几位左右（不过在我这里就固定了）。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果是 <code>前缀 + 随机数</code> 的冲突概率会比较大的，所以还是用哈希来搞。</p><p>非常简单。首先前缀是固定的，我们就不管了，然后我根据这次进来的数据拼接成字符串（数据不会完全一样的），加上一点随机盐，然后用字符串哈希计算一遍，加上前导零，加上当前时间戳的后几位拼接起来，最后接上前缀就好了。</p><p>这个 <code>generate</code> 函数看起来就像这样子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bling = <span class="built_in">require</span>(<span class="string">"bling-hashes"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">type, bodyParamStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basePrefix;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'foo'</span>: basePrefix = <span class="string">'10'</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'bar'</span>: basePrefix = <span class="string">'11'</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: base_prefix = <span class="string">'00'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> date = moment();</span><br><span class="line">    <span class="keyword">var</span> hash = bling.bkdr(bodyParamStr + date.valueOf()).pad(<span class="number">10</span>);</span><br><span class="line">    hash = date.millisecond().pad(<span class="number">3</span>) + hash;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> basePrefix + hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这里的 <code>bling</code> 就是上面提到过的那个 <a href="https://github.com/XadillaX/bling_hashes" target="_blank" rel="external">bling-hashes</a>，采用了 <code>BKDR</code> 算法来计算哈希。以及 <code>Number.prototype.pad</code> 函数是我邪恶得使用了 <a href="http://sugarjs.com/api/Number/pad" target="_blank" rel="external">SugarJs</a> 里面的函数，就是加上前导零的意思。如果受“千万不要修改原型链”影响较深地童鞋别学我哦。<code>bodyParamStr</code> 是前端传过来的 <strong>Raw Form Data</strong>，它看起来像 <code>&quot;data1=1&amp;data2=2&amp;...&quot;</code>。</p></blockquote><p>最后得到的这个字符串是我们所要的主键了。｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡</p><p>不过要注意的是，这个主键仍然又冲突的可能性，所以一旦冲突了（无论是自己检测到的还是插入数据库的时候疼了）就需要再生产一遍。就目前来说再生成的时候毫秒时间戳后三位会不一样，所以问题不大，允许存在的误差——毕竟不是那种分分钟集千万条的数据，肯定在 <code>int</code> 范围内。如果到时候真出问题了再改进。</p><h3 id="主键的小结"><a href="#主键的小结" class="headerlink" title="主键的小结"></a>主键的小结</h3><p>这里的哈希是用在生成基本上没有碰撞的主键身上，感觉效果也是非常不错的——前提是你也有这种奇葩需求。</p><h2 id="真·小结"><a href="#真·小结" class="headerlink" title="真·小结"></a>真·小结</h2><p>本文大致介绍了哈希的几种用途，有可能是大家熟知的用途，也有可能是巧用，总之就是说了为什么我要用哈希。</p><p>在编程中，无论是实际用途还是自己玩玩的题目，多动动脑子就会出来一些“奇技淫巧”。哈希也好，别的东西也罢，反正都是为了解决问题的——千万别因为实际开发中通常性的“并没有什么卵用”而去忽视它们，虽然哈希已经是够常用的了。(๑•ૅω•´๑)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是哈希（Hash）&quot;&gt;&lt;a href=&quot;#什么是哈希（Hash）&quot; class=&quot;headerlink&quot; title=&quot;什么是哈希（Hash）&quot;&gt;&lt;/a&gt;什么是哈希（Hash）&lt;/h2&gt;&lt;p&gt;本来这里不应该出现这一节的，因为实际上大家应该都知道什么是哈希。不过
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="数据结构" scheme="https://xcoder.in/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希" scheme="https://xcoder.in/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>初探 MySQL 的 Binlog</title>
    <link href="https://xcoder.in/2015/08/10/mysql-binlog-try/"/>
    <id>https://xcoder.in/2015/08/10/mysql-binlog-try/</id>
    <published>2015-08-10T03:39:53.000Z</published>
    <updated>2017-12-11T07:59:20.522Z</updated>
    
    <content type="html"><![CDATA[<p>　　花瓣网的搜索架构需要重构，尤其是在索引建立或者更新层面。</p><p>　　目前的一个架构导致的结果就是时间越久，数据本体与搜索引擎索引中的数据越不同步，相差甚大。</p><p>　　新的一个架构打算从 MySQL 的 Binlog 中读取数据更新、删除、新增等历史记录，并把相应信息提取出来丢到队列中慢慢去同步。</p><p>　　所以我就在这里小小去了解一下 Binlog。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="什么是-Binlog"><a href="#什么是-Binlog" class="headerlink" title="什么是 Binlog"></a>什么是 Binlog</h3><p>　　MySQL Server 有四种类型的日志——Error Log、General Query Log、Binary Log 和 Slow Query Log。</p><p>　　第一个是错误日志，记录 mysqld 的一些错误。第二个是一般查询日志，记录 mysqld 正在做的事情，比如客户端的连接和断开、来自客户端每条 Sql Statement 记录信息；如果你想准确知道客户端到底传了什么瞎 [哔哔] 玩意儿给服务端，这个日志就非常管用了，不过它非常影响性能。第四个是慢查询日志，记录一些查询比较慢的 SQL 语句——这种日志非常常用，主要是给开发者调优用的。</p><p>　　剩下的第三种就是 Binlog 了，包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，也包括一些潜在改动，比如 <code>DELETE FROM ran WHERE bing = luan</code>，然而一条数据都没被删掉的这种情况。除非使用 Row-based logging，否则会包含所有改动数据的 SQL Statement。</p><p>　　那么 Binlog 就有了两个重要的用途——复制和恢复。比如主从表的复制，和备份恢复什么的。</p><h3 id="启用-Binlog"><a href="#启用-Binlog" class="headerlink" title="启用 Binlog"></a>启用 Binlog</h3><p>　　通常情况 MySQL 是默认关闭 Binlog 的，所以你得配置一下以启用它。</p><p>　　启用的过程就是修改配置文件 <code>my.cnf</code> 了。</p><p>　　至于 <code>my.cnf</code> 位置请自行寻找。例如通过 OSX 的 <code>brew</code> 安装的 <code>mysql</code> 默认配置目录通常在</p><blockquote><p>/usr/local/Cellar/mysql/$VERSION/support-files/my-default.cnf</p></blockquote><p>　　这个时候需要将它拷贝到 <code>/etc/my.cnf</code> 下面。</p><blockquote><p>详见 &lt;<a href="http://stackoverflow.com/questions/10757169/mysql-my-cnf-location" target="_blank" rel="external">StackOverflow - MySQL ‘my.cnf’ location?</a>&gt;。</p></blockquote><p>　　紧接着配置 <code>log-bin</code> 和 <code>log-bin-index</code> 的值，如果没有则自行加上去。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=master-bin</span><br><span class="line"><span class="attr">log-bin-index</span>=master-bin.index</span><br></pre></td></tr></table></figure><p>　　这里的 <code>log-bin</code> 是指以后生成各 Binlog 文件的前缀，比如上述使用 <code>master-bin</code>，那么文件就将会是 <code>master-bin.000001</code>、<code>master-bin.000002</code> 等。而这里的 <code>log-bin-index</code> 则指 binlog index 文件的名称，这里我们设置为 <code>master-bin.index</code>。</p><p>　　如果上述工作做完之后重启 MySQL 服务，你可以进入你的 MySQL CLI 验证一下是否真的启用了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mysql -u <span class="variable">$USERNAME</span> ...</span><br></pre></td></tr></table></figure><p>　　然后在终端里面输入下面一句 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%log_bin%'</span>;</span><br></pre></td></tr></table></figure><p>　　如果结果里面出来这样类似的话就表示成功了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| Variable_name                   | Value                                 |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| log_bin                         | ON                                    |</span><br><span class="line">| log_bin_basename                | /usr/<span class="built_in">local</span>/var/mysql/master-bin       |</span><br><span class="line">| log_bin_index                   | /usr/<span class="built_in">local</span>/var/mysql/master-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                   |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                   |</span><br><span class="line">| sql_log_bin                     | ON                                    |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>　　更多的一些相关配置可以参考这篇《<a href="http://blog.csdn.net/jolly10/article/details/13998761" target="_blank" rel="external">MySQL 的 binary log 初探</a>》。</p><h3 id="随便玩玩"><a href="#随便玩玩" class="headerlink" title="随便玩玩"></a>随便玩玩</h3><p>　　然后你就可以随便去执行一些数据变动的 SQL 语句了。当你执行了一堆语句之后就可以看到你的 Binlog 里面有内容了。</p><p>　　如上表所示，<code>log_bin_basename</code> 的值是 <code>/usr/local/var/mysql/master-bin</code> 就是 Binlog 的基础文件名了。</p><p>　　那我们进去看，比如我的这边就有这么几个文件：</p><p><img src="binlog-files.jpg" alt="Binlog 文件"></p><p>　　很容易发现，里面有 <code>master-bin.index</code> 和 <code>master-bin.000001</code> 两个文件，这两个文件在上文中有提到过了。</p><p>　　我们打开那个 <code>master-bin.index</code> 文件，会发现这个索引文件就是一个普通的文本文件，然后列举了各 binlog 的文件名。而 <code>master-bin.000001</code> 文件就是一堆乱码了——毕竟人家是二进制文件。</p><h2 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h2><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>　　索引文件就是上文中的 <code>master-bin.index</code> 文件，是一个普通的文本文件，以换行为间隔，一行一个文件名。比如它可能是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master-bin.000001</span><br><span class="line">master-bin.000002</span><br><span class="line">master-bin.000003</span><br></pre></td></tr></table></figure><p>　　然后对应的每行文件就是一个 Binlog 实体文件了。</p><h3 id="Binlog-文件"><a href="#Binlog-文件" class="headerlink" title="Binlog 文件"></a>Binlog 文件</h3><p>　　Binlog 的文件结构大致由如下几个方面组成。</p><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>　　文件头由一个四字节 Magic Number，其值为 <code>1852400382</code>，在内存中就是 <code>&quot;\xfe\x62\x69\x6e&quot;</code>，参考 MySQL 源码的 <a href="://github.com/mysql/mysql-server/blob/a2757a60a7527407d08115e44e889a25f22c96c6/sql/log_event.h#L187">log_event.h</a>，也就是 <code>&#39;\0xfe&#39; &#39;b&#39; &#39;i&#39; &#39;n&#39;</code>。</p><p>　　与平常二进制一样，通常都有一个 Magic Number 进行文件识别，如果 Magic Number 不吻合上述的值那么这个文件就不是一个正常的 Binlog。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>　　在文件头之后，跟随的是一个一个事件依次排列。每个事件都由一个事件头和事件体组成。</p><p>　　事件头里面的内容包含了这个事件的类型（如新增、删除等）、事件执行时间以及是哪个服务器执行的事件等信息。</p><p>　　第一个事件是一个事件描述符，描述了这个 Binlog 文件格式的版本。接下去的一堆事件将会按照第一个事件描述符所描述的结构版本进行解读。最后一个事件是一个衔接事件，指定了下一个 Binlog 文件名——有点类似于链表里面的 <code>next</code> 指针。</p><p>　　根据《<a href="High-Level Binary Log Structure and Contents">High-Level Binary Log Structure and Contents</a>》所述，不同版本的 Binlog 格式不一定一样，所以也没有一个定性。在我写这篇文章的时候，目前有三种版本的格式。</p><ul><li>v1，用于 MySQL 3.2.3</li><li>v3，用于 MySQL 4.0.2 以及 4.1.0</li><li>v4，用于 MySQL 5.0 以及更高版本</li></ul><p>　　实际上还有一个 v2 版本，不过只在早期 4.0.x 的 MySQL 版本中使用过，但是 v2 已经过于陈旧并且不再被 MySQL 官方支持了。</p><blockquote><p><strong>通常我们现在用的 MySQL 都是在 5.0 以上的了，所以就略过 v1 ~ v3 版本的 Binlog，如果需要了解 v1 ~ v3 版本的 Binlog 可以自行前往上述的《High-level…》文章查看。</strong></p></blockquote><h5 id="事件头"><a href="#事件头" class="headerlink" title="事件头"></a>事件头</h5><p>　　一个事件头有 19 字节，依次排列为四字节的时间戳、一字节的当前事件类型、四字节的服务端 ID、四字节的当前事件长度描述、四字节的下个事件位置（方便跳转）以及两字节的标识。</p><p>　　用 ASCII Diagram 表示如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+---------+------------+-------------+-------+</span><br><span class="line">|timestamp|type code|server_id|event_length|next_position|flags  |</span><br><span class="line">|4 bytes  |1 byte   |4 bytes  |4 bytes     |4 bytes      |2 bytes|</span><br><span class="line">+---------+---------+---------+------------+-------------+-------+</span><br></pre></td></tr></table></figure><p>　　也可以字节编造一个结构体来解读这个头：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span></span><br><span class="line">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>   timestamp;</span><br><span class="line">    <span class="keyword">char</span>  type_code;</span><br><span class="line">    <span class="keyword">int</span>   server_id;</span><br><span class="line">    <span class="keyword">int</span>   event_length;</span><br><span class="line">    <span class="keyword">int</span>   next_position;</span><br><span class="line">    <span class="keyword">char</span>  flags[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果你要直接用这个结构体来读取数据的话，需要加点手脚。</p><p>因为默认情况下 GCC 或者 G++ 编译器会对结构体进行字节对齐，这样读进来的数据就不对了，因为 Binlog 并不是对齐的。为了统一我们需要取消这个结构体的字节对齐，一个方法是使用 <code>#pragma pack(n)</code>，一个方法是使用 <code>__attribute__((__packed__))</code>，还有一种情况是在编译器编译的时候强制把所有的结构体对其取消，即在编译的时候使用 <code>fpack-struct</code> 参数，如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ temp.cpp -o a -fpack-struct=1</span><br></pre></td></tr></table></figure></blockquote><p>　　根据上述的结构我们可以明确得到各变量在结构体里面的偏移量，所以在 MySQL 源码里面（<a href="https://github.com/mysql/mysql-server/blob/5.7/libbinlogevents/include/binlog_event.h#L353" target="_blank" rel="external">libbinlogevents/include/binlog_event.h</a>）有下面几个常量以快速标记偏移：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_OFFSET    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ID_OFFSET     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LEN_OFFSET     9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_POS_OFFSET       13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS_OFFSET         17</span></span><br></pre></td></tr></table></figure><p>　　而具体有哪些事件则在 <a href="https://github.com/mysql/mysql-server/blob/5.7/libbinlogevents/include/binlog_event.h#L245" target="_blank" rel="external">libbinlogevents/include/binlog_event.h#L245</a> 里面被定义。如有个 <code>FORMAT_DESCRIPTION_EVENT</code> 事件的 <code>type_code</code> 是 15、<code>UPDATE_ROWS_EVENT</code> 的 <code>type_code</code> 是 31。</p><p>　　还有那个 <code>next_position</code>，在 v4 版本中代表从 Binlog 一开始到下一个事件开始的偏移量，比如到第一个事件的 <code>next_position</code> 就是 4，因为文件头有一个字节的长度。然后接下去对于事件 n 和事件 n + 1 来说，他们有这样的关系：</p><blockquote><p>next_position(n + 1) = next_position(n) + event_length(n)</p></blockquote><p>　　关于 flags 暂时不需要了解太多，如果真的想了解的话可以看看 MySQL 的<a href="http://dev.mysql.com/doc/internals/en/event-flags.html" target="_blank" rel="external">相关官方文档</a>。</p><h5 id="事件体"><a href="#事件体" class="headerlink" title="事件体"></a>事件体</h5><p>　　事实上在 Binlog 事件中应该是有三个部分组成，<code>header</code>、<code>post-header</code> 和 <code>payload</code>，不过通常情况下我们把 <code>post-header</code> 和 <code>payload</code> 都归结为事件体，实际上这个 <code>post-header</code> 里面放的是一些定长的数据，只不过有时候我们不需要特别地关心。想要深入了解可以去查看 MySQL 的官方文档。</p><p>　　所以实际上一个真正的事件体由两部分组成，用 ASCII Diagram 表示就像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | fixed part (post-header)   |</span><br><span class="line">| data   +----------------------------+</span><br><span class="line">|        | variable part (payload)    |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure><p>　　而这个 <code>post-header</code> 对于不同类型的事件来说长度是不一样的，同种类型来说是一样的，而这个长度的预先规定将会在一个“格式描述事件”中定好。</p><h5 id="格式描述事件"><a href="#格式描述事件" class="headerlink" title="格式描述事件"></a>格式描述事件</h5><p>　　在上文我们有提到过，在 Magic Number 之后跟着的是一个格式描述事件（Format Description Event），其实这只是在 v4 版本中的称呼，在以前的版本里面叫起始事件（Start Event）。</p><p>　　在 v4 版本中这个事件的结构如下面的 ASCII Diagram 所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | timestamp         0 : 4    |</span><br><span class="line">| header +----------------------------+</span><br><span class="line">|        | type_code         4 : 1    | = FORMAT_DESCRIPTION_EVENT = 15</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | server_id         5 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | event_length      9 : 4    | &gt;= 91</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | next_position    13 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | flags            17 : 2    |</span><br><span class="line">+=====================================+</span><br><span class="line">| event  | binlog_version   19 : 2    | = 4</span><br><span class="line">| data   +----------------------------+</span><br><span class="line">|        | server_version   21 : 50   |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | create_timestamp 71 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | header_length    75 : 1    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | post-header      76 : n    | = array of n bytes, one byte per event</span><br><span class="line">|        | lengths for all            |   type that the server knows about</span><br><span class="line">|        | event types                |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure><p>　　这个事件的 <code>type_code</code> 是 15，然后 <code>event_length</code> 是大于等于 91 的值的，这个主要取决于所有事件类型数。</p><p>　　因为从第 76 字节开始后面的二进制就代表一个字节类型的数组了，一个字节代表一个事件类型的 <code>post-header</code> 长度，即每个事件类型固定数据的长度。</p><p>　　那么按照上述的一些线索来看，我们能非常快地写出一个简单的解读 Binlog 格式描述事件的代码。</p><blockquote><p>如上文所述，如果需要正常解读 Binlog 文件的话，下面的代码编译时候需要加上 <code>-fpack-struct=1</code> 这个参数。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span></span><br><span class="line">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  timestamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type_code;</span><br><span class="line">    <span class="keyword">int</span>  server_id;</span><br><span class="line">    <span class="keyword">int</span>  event_length;</span><br><span class="line">    <span class="keyword">int</span>  next_position;</span><br><span class="line">    <span class="keyword">short</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/usr/local/var/mysql/master-bin.000001"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> magic_number;</span><br><span class="line">    fread(&amp;magic_number, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d - %s\n"</span>, magic_number, (<span class="keyword">char</span>*)(&amp;magic_number));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span> <span class="title">format_description_event_header</span>;</span></span><br><span class="line">    fread(&amp;format_description_event_header, <span class="number">19</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BinlogEventHeader\n&#123;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    timestamp: %d\n"</span>, format_description_event_header.timestamp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    type_code: %d\n"</span>, format_description_event_header.type_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    server_id: %d\n"</span>, format_description_event_header.server_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    event_length: %d\n"</span>, format_description_event_header.event_length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    next_position: %d\n"</span>, format_description_event_header.next_position);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    flags[]: %d\n&#125;\n"</span>, format_description_event_header.flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> binlog_version;</span><br><span class="line">    fread(&amp;binlog_version, <span class="number">2</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"binlog_version: %d\n"</span>, binlog_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> server_version[<span class="number">51</span>];</span><br><span class="line">    fread(server_version, <span class="number">50</span>, <span class="number">1</span>, fp);</span><br><span class="line">    server_version[<span class="number">50</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"server_version: %s\n"</span>, server_version);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> create_timestamp;</span><br><span class="line">    fread(&amp;create_timestamp, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create_timestamp: %d\n"</span>, create_timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> header_length;</span><br><span class="line">    fread(&amp;header_length, <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"header_length: %d\n"</span>, header_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type_count = format_description_event_header.event_length - <span class="number">76</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> post_header_length[type_count];</span><br><span class="line">    fread(post_header_length, <span class="number">1</span>, type_count, fp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; type_count; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  - type %d: %d\n"</span>, i + <span class="number">1</span>, post_header_length[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个时候你得到的结果有可能就是这样的了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1852400382 - �binpz�</span><br><span class="line">BinlogEventHeader</span><br><span class="line">&#123;</span><br><span class="line">    timestamp: 1439186734</span><br><span class="line">    type_code: 15</span><br><span class="line">    server_id: 1</span><br><span class="line">    event_length: 116</span><br><span class="line">    next_position: 120</span><br><span class="line">    flags[]: 1</span><br><span class="line">&#125;</span><br><span class="line">binlog_version: 4</span><br><span class="line">server_version: 5.6.24-log</span><br><span class="line">create_timestamp: 1439186734</span><br><span class="line">header_length: 19</span><br><span class="line">  - type 1: 56</span><br><span class="line">  - type 2: 13</span><br><span class="line">  - type 3: 0</span><br><span class="line">  - type 4: 8</span><br><span class="line">  - type 5: 0</span><br><span class="line">  - type 6: 18</span><br><span class="line">  - ...</span><br></pre></td></tr></table></figure><p>　　一共会输出 40 种类型（从 1 到 40），如官方文档所说，这个数组从 <code>START_EVENT_V3</code> 事件开始（<code>type_code</code> 是 1）。</p><h5 id="跳转事件"><a href="#跳转事件" class="headerlink" title="跳转事件"></a>跳转事件</h5><p>　　跳转事件即 <code>ROTATE_EVENT</code>，其 <code>type_code</code> 是 4，其 <code>post-header</code> 长度为 8。</p><p>　　当一个 Binlog 文件大小已经差不多要分割了，它就会在末尾被写入一个 <code>ROTATE_EVENT</code>——用于指出这个 Binlog 的下一个文件。</p><p>　　它的 <code>post-header</code> 是 8 字节的一个东西，内容通常就是一个整数 <code>4</code>，用于表示下一个 Binlog 文件中的第一个事件起始偏移量。我们从上文就能得出在一般情况下这个数字只可能是四，就偏移了一个魔法数字。当然我们讲的是在 v4 这个 Binlog 版本下的情况。</p><p>　　然后在 <code>payload</code> 位置是一个字符串，即下一个 Binlog 文件的文件名。</p><h5 id="各种不同的事件体"><a href="#各种不同的事件体" class="headerlink" title="各种不同的事件体"></a>各种不同的事件体</h5><p>　　由于篇幅原因这里就不详细举例其它普通的不同事件体了，具体的详解在 <a href="http://dev.mysql.com/doc/internals/en/event-data-for-specific-event-types.html" target="_blank" rel="external">MySQL 文档</a>中一样有介绍，用到什么类型的事件体就可以自己去查询。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　本文大概介绍了 Binlog 的一些情况，以及 Binlog 的内部二进制解析结构。方便大家造轮子用——不然老用别人的轮子，只知其然而不知其所以然多没劲。</p><p>　　好了要下班了，就写到这里过吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://my.oschina.net/leejun2005/blog/75273" target="_blank" rel="external">MySQL’s binary log 结构简介</a>，目测原文在 <a href="http://www.taobaodba.com/html/474_mysqls-binary-log_details.html" target="_blank" rel="external">TaobaoDBA</a>（已无法访问）</li><li><a href="http://www.linuxidc.com/Linux/2014-09/107095.htm" target="_blank" rel="external">MySQL Binlog 的介绍</a></li><li><a href="http://blog.csdn.net/jolly10/article/details/13998761" target="_blank" rel="external">MySQL 的 binary log 初探</a></li><li><a href="http://dev.mysql.com/doc/internals/en/binary-log-structure-and-contents.html" target="_blank" rel="external">High-Level Binary Log Structure and Contents</a> and related official documents</li><li><a href="http://stackoverflow.com/questions/21912098/pragma-pack-vs-fpack-struct-for-intel-c" target="_blank" rel="external">#pragma pack vs -fpack-struct for Intel C</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　花瓣网的搜索架构需要重构，尤其是在索引建立或者更新层面。&lt;/p&gt;
&lt;p&gt;　　目前的一个架构导致的结果就是时间越久，数据本体与搜索引擎索引中的数据越不同步，相差甚大。&lt;/p&gt;
&lt;p&gt;　　新的一个架构打算从 MySQL 的 Binlog 中读取数据更新、删除、新增等历史记录
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://xcoder.in/tags/MySQL/"/>
    
      <category term="Binary Log" scheme="https://xcoder.in/tags/Binary-Log/"/>
    
      <category term="Binlog" scheme="https://xcoder.in/tags/Binlog/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中使用 Redis 来实现定时任务</title>
    <link href="https://xcoder.in/2015/06/05/scheduled-task-using-redis/"/>
    <id>https://xcoder.in/2015/06/05/scheduled-task-using-redis/</id>
    <published>2015-06-05T07:23:51.000Z</published>
    <updated>2017-12-11T07:59:20.542Z</updated>
    
    <content type="html"><![CDATA[<p>　　好久没写博文了，最近在跟随着公司大牛们的脚步秘密研发新产品中。</p><p>　　不过前几天有一个小需求的东西可以提出来写一点点小干货儿跟大家分享分享。米娜桑会的就可以忽略了，反正我也是随便写的；如果觉得本文对你有用的话还请多多支持喵。(●´ω｀●)ゞ</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　本文所说的定时任务或者说计划任务并不是很多人想象中的那样，比如说每天凌晨三点自动运行起来跑一个脚本。这种都已经烂大街了，随便一个 <strong><a href="https://wiki.archlinux.org/index.php/Cron" target="_blank" rel="external">Crontab</a></strong> 就能搞定了。</p><p>　　这里所说的定时任务可以说是计时器任务，比如说用户触发了某个动作，那么从这个点开始过二十四小时我们要对这个动作做点什么。那么如果有 1000 个用户触发了这个动作，就会有 1000 个定时任务。于是这就不是 <strong>Cron</strong> 范畴里面的内容了。</p><p>　　举个最简单的例子，一个用户推荐了另一个用户，我们定一个二十四小时之后的任务，看看被推荐的用户有没有来注册，如果没注册就给他搞一条短信过去。Σ&gt;―(〃°ω°〃)♡→</p><h2 id="最初的设想"><a href="#最初的设想" class="headerlink" title="最初的设想"></a>最初的设想</h2><p>　　一开始我是想把这个计时器做在内存里面直接调用的。</p><p>　　考虑到 Node.js 的定时并不是那么准确（无论是 <code>setTimeout</code> 还是 <code>setInterval</code>），所以本来打算自己维护这个定时器队列。</p><p>　　又考虑到 Node.js 原生对象比较耗内存。之前我用 <code>JSON</code> 对象存了一本字典，约十二万多的词条，原文件大概也就五六兆，用 Node.js 的原生对象一存居然有五六百兆的内存占用——所以打算这个定时器队列用 C++ 来写 addon。</p><p>　　考虑到任何时候插入的任务都有可能在已有的任务之前或者之后，所以本来想用 C++ 来写一个<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86" target="_blank" rel="external">小根堆</a>。每次用户来一个任务的时候就将这个任务插入到堆中。</p><p>　　如果按照上述方法的话，再加上对时间要求掐得也不是那么紧，于是就是一个不断的 <code>process.nextTick()</code> 的过程。</p><p>　　在 <code>process.nextTick()</code> 当中执行这么一个函数：</p><ol><li>从小根堆中不断获取堆顶的任务并处理，一直处理到堆顶任务的执行时间大于当前时间为止。</li><li>继续 <code>process.nextTick()</code> 来让下一个 tick 执行步骤 1 中的流程。</li></ol><p>　　所以最后就是一边往小根堆插入任务，另一边通过不断 <code>process.nextTick()</code> 消费任务的这么一个过程。</p><p>　　最后，为了考虑到程序重启的时候内存数据会丢失，还应该做一个持久化的事情——在每次插入任务的时候顺便往持久化中间件中插一条副本，比如 MySQL、MongoDB、Redis、Riak 等等任何三方依赖。消费任务的时候顺便把中间件中的这条任务数据给删除。</p><p>　　也就是说中间件中永远存的就是当前尚未完成的任务。每当程序重启的时候都先从中间件中把所有任务读取进来重建一下堆，然后就能继续工作了。</p><blockquote><p>如果当时我没有发现 Redis 的这个妙用的话，上述的流程将会是我实现我们定时任务的流程了。</p></blockquote><h2 id="Redis-妙用"><a href="#Redis-妙用" class="headerlink" title="Redis 妙用"></a>Redis 妙用</h2><p>　　在 Redis 的 2.8.0 版本之后，其推出了一个新的特性——键空间消息（<a href="http://redis.io/topics/notifications" target="_blank" rel="external">Redis Keyspace Notifications</a>），它配合 2.0.0 版本之后的 <code>SUBSCRIBE</code> 就能完成这个定时任务的操作了，<strong>不过定时的单位是秒</strong>。</p><h3 id="Publish-Subscribe"><a href="#Publish-Subscribe" class="headerlink" title="Publish / Subscribe"></a>Publish / Subscribe</h3><p>　　Redis 在 2.0.0 之后推出了 <a href="http://redis.io/topics/pubsub" target="_blank" rel="external">Pub / Sub</a> 的指令，大致就是说一边给 Redis 的特定频道发送消息，另一边从 Redis 的特定频道取值——形成了一个简易的消息队列</p><p>　　比如我们可以往 <code>foo</code> 频道推一个消息 <code>bar</code>，那么就可以直接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH foo bar</span><br></pre></td></tr></table></figure><p>　　另一边我们在客户端订阅 <code>foo</code> 频道就能接受到这个消息了。</p><p>　　举个例子，如果在 Node.js 里面使用 <a href="https://github.com/luin/ioredis" target="_blank" rel="external">ioredis</a> 这个包那么看起来就会像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Redis = <span class="built_in">require</span>(<span class="string">"ioredis"</span>);</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Redis(<span class="comment">/** 连接信息 */</span>);</span><br><span class="line">sub.once(<span class="string">"connect"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 假设我们需要选择 redis 的 db，因为实际上我们不会去污染默认的 db 0</span></span><br><span class="line">    sub.select(DB_NUMBER, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) process.exit(<span class="number">4</span>);</span><br><span class="line">        sub.subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//... 订阅频道成功</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听从 `foo` 来的消息</span></span><br><span class="line">sub.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">channel, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(channel, msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Redis-Keyspace-Notifications"><a href="#Redis-Keyspace-Notifications" class="headerlink" title="Redis Keyspace Notifications"></a>Redis Keyspace Notifications</h3><p>　　在 Redis 里面有一些事件，比如键到期、键被删除等。然后我们可以通过配置一些东西来让 Redis 一旦触发这些事件的时候就往特定的 Channel 推一条消息。</p><p>　　本文所涉及到的需求的话我们所需要关心的事件是 <code>EXPIRE</code> 即过期事件。</p><p>　　大致的流程就是我们给 Redis 的某一个 db 设置过期事件，使其键一旦过期就会往特定频道推消息，我在自己的客户端这边就一直消费这个频道就好了。</p><p>　　以后一来一条定时任务，我们就把这个任务状态压缩成一个键，并且过期时间为距这个任务执行的时间差。那么当键一旦到期，就到了任务该执行的时间，Redis 自然会把过期消息推去，我们的客户端就能接收到了。这样一来就起到了定时任务的作用。</p><h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>　　当达到一定条件后，有两种类型的这种消息会被触发，用哪个需要自己选了。举个例子，我们删除了在 db 0 中一个叫 <code>foo</code> 的键，那么系统会往两个频道推消息，一个是 <code>del</code> 事件频道推 <code>foo</code> 消息，另一个是 <code>foo</code> 频道推 <code>del</code> 消息，它们小俩口被系统推送的指令分别等价于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:foo del</span><br><span class="line">PUBLISH __keyevent@0__:del foo</span><br></pre></td></tr></table></figure><p>　　其中往 <code>foo</code> 推送 <code>del</code> 的频道名为 <code>__keyspace@0__:foo</code>，即是 <code>&quot;__keyspace@&quot; + DB_NUMBER + &quot;__:&quot; + KEY_NAME</code>；而 <code>del</code> 的频道名为 <code>&quot;__keyevent@&quot; + DB_NUMBER + &quot;__:&quot; + EVENT_NAME</code>。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>　　即使你的 Redis 版本达标了，但是 Redis 默认是关闭这个功能的，你需要修改配置文件来打开它，或者直接在 CLI 里面通过指令修改。这里就说说配置文件的修改吧。</p><p>　　如果不想看我在这里罗里吧嗦的，也可以直接去看 Redis 的<a href="http://redis.io/topics/notifications#configuration" target="_blank" rel="external">相关文档</a>。</p><p>　　首先打开 Redis 的配置文件，在不同的系统和安装方式下文件位置可能不同，比如通过 <code>brew</code> 安装的 MacOS 下可能是在 <code>/usr/local/etc/redis.conf</code> 下面，通过 <code>apt-get</code> 安装的 Ubuntu 下可能是在 <code>/etc/redis/redis.conf</code> 下，总之找到配置文件。<strong>或者自己写一个配置文件，启动的时候指定配置文件地址就好。</strong></p><p>　　然后找到一项叫 <code>notify-keyspace-events</code> 的地方，如果找不到则自行添加，其值可以是 <code>Ex</code>、<code>Klg</code> 等等。这些字母的具体含义如下所示：</p><ul><li><strong>K</strong>，表示 <code>keyspace</code> 事件，有这个字母表示会往 <code>__keyspace@&lt;db&gt;__</code> 频道推消息。</li><li><strong>E</strong>，表示 <code>keyevent</code> 事件，有这个字母表示会往 <code>__keyevent@&lt;db&gt;__</code> 频道推消息。</li><li><strong>g</strong>，表示一些通用指令事件支持，如 <code>DEL</code>、<code>EXPIRE</code>、<code>RENAME</code> 等等。</li><li><strong>$</strong>，表示字符串（String）相关指令的事件支持。</li><li><strong>l</strong>，表示列表（List）相关指令事件支持。</li><li><strong>s</strong>，表示集合（Set）相关指令事件支持。</li><li><strong>h</strong>，哈希（Hash）相关指令事件支持。</li><li><strong>z</strong>，有序集（Sorted Set）相关指令事件支持。</li><li><strong>x</strong>，过期事件，与 <strong>g</strong> 中的 <code>EXPIRE</code> 不同的是，<strong>g</strong> 的 <code>EXPIRE</code> 是指执行 <code>EXPIRE key ttl</code> 这条指令的时候顺便触发的事件，而这里是指那个 <code>key</code> 刚好过期的这个时间点触发的事件。</li><li><strong>e</strong>，驱逐事件，一个 <code>key</code> 由于内存上限而被驱逐的时候会触发的事件。</li><li><strong>A</strong>，<code>g$lshzxe</code> 的别名。也就是说 <code>AKE</code> 的意思就代表了所有的事件。</li></ul><p>　　结合上述列表我们就能拼凑出自己所需要的事件支持字符串了，在我的需求中我只需要 <code>Ex</code> 就可以满足了，所以配置项就是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events Ex</span><br></pre></td></tr></table></figure><p>　　然后保存配置文件，启动 Redis 就启用了过期事件的支持了。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>　　我们先说任务的创造者吧。由于这里 <strong>Redis</strong> 的事件只会传键名，并不会传键值，而过期事件触发的时候那个键已经没了，你也无法获取键值，加上我的主系统和任务系统是分布式的，所以就把所有需要的信息往键名塞。</p><p>　　一个最简单的键名设计就是 <code>任务类型 + &quot;:&quot; + JSON.stringify 化后的参数数组</code>；更有甚者可以直接把任务类型替换成所需的函数路径，比如需要执行这个任务的函数在 <code>task/foo/bar</code> 文件下面的 <code>baz</code> 函数，参数 <code>arguments</code> 数组为 <code>[ 1, 2 ]</code>，那么键名的设计可以是 <code>task/foo/bar.baz:[1,2]</code>，反正我们只需要触发这个键，用不着去查询这个键。等到真正过期了任务系统接收到这个键名的时候再一一解析，得到需要执行 <code>task/foo/bar.baz</code> 这个消息，并且网函数里面传入 <code>[1,2]</code> 这个 <code>arguments</code>。</p><p>　　所以当接收到一个定时任务的时候，我们得到消息、函数名、过期时间参数，这个函数可以如下设计：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 我们假设 redis 是一个 ioredis 的对象 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sampleTaskMaker = <span class="function"><span class="keyword">function</span>(<span class="params">message, func, timeout</span>) </span>&#123;</span><br><span class="line">    message = <span class="built_in">JSON</span>.stringify(message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received a new task:"</span>, func, message, <span class="string">"after "</span> + timeout + <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 uuid 是 npm 一个包</span></span><br><span class="line">    <span class="comment">// 生成一个唯一 uuid 的目的是为了防止两个任务用了相同的函数和参数，那么</span></span><br><span class="line">    <span class="comment">// 键名可能会重复并覆盖的情况</span></span><br><span class="line">    <span class="comment">// uuid 的文档为 https://www.npmjs.com/package/node-uuid</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这里的 ❤️ 是一个分隔符，冒号是分割 uuid 和后面内容的，而 ❤️ 是分割函数名</span></span><br><span class="line">    <span class="comment">// 和消息的</span></span><br><span class="line">    <span class="keyword">var</span> key = uuid.v1().replace(<span class="regexp">/-/g</span>, <span class="string">""</span>) +</span><br><span class="line">        <span class="string">":❤️"</span> + func + <span class="string">"❤️"</span> + message;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    redis.multi()</span><br><span class="line">        .set(key, content)</span><br><span class="line">        .expire(key, timeout)</span><br><span class="line">        .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">"Failed to publish EXPIRE EVENT for "</span> + content);</span><br><span class="line">                <span class="built_in">console</span>.error(err);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Ioredis 的稳定可以<a href="https://github.com/luin/ioredis" target="_blank" rel="external">点此</a>查看。</p></blockquote><p>　　然后在任务系统里面的一开始监听这个过期频道：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assign 是 sugarjs 里面的函数</span></span><br><span class="line"><span class="comment">// 把 db 塞到字符串里面的 &#123;db&#125; 里去</span></span><br><span class="line"><span class="keyword">var</span> subscribeKey = <span class="string">"__keyevent@&#123;db&#125;__:expired"</span>.assign(&#123; <span class="attr">db</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 sub 是 ioredis 的对象</span></span><br><span class="line">sub.once(<span class="string">"connect"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 假设我们需要选择 redis 的 db，因为实际上我们不会去污染默认的 db 0</span></span><br><span class="line">    sub.select(<span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) process.exit(<span class="number">4</span>);</span><br><span class="line">        sub.subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//... 订阅频道成功</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听从 `foo` 来的消息</span></span><br><span class="line">sub.on(<span class="string">"message"</span>, sampleOnExpired);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 我们这里选择 db 1 是因为一旦开启过期事件监听，那么这个 db 的所有过期事件都会被发送。为了不跟正常使用的 redis 过期键混淆，我们为这个事情专门用一个新的 db。比如我们在自己正常使用的 db 0 里面监听了，那么不是我们任务触发的过期事件也会传过来，这个时候我们解析的键名就不对了。</p></blockquote><p>　　最后就是我们的 <code>sampleOnExpired</code> 函数了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sampleOnExpired = <span class="function"><span class="keyword">function</span>(<span class="params">channel, key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// UUID:❤️func❤️params</span></span><br><span class="line">    <span class="keyword">var</span> body = key.split(<span class="string">"❤️"</span>);</span><br><span class="line">    <span class="keyword">if</span>(body.length &lt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 body 第一位为 func</span></span><br><span class="line">    <span class="keyword">var</span> func = body[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推出前两位，后面剩下的有可能是参数里面自带 ❤️ 而被分割，所以要拼回去</span></span><br><span class="line">    body.shift(); body.shift();</span><br><span class="line">    <span class="keyword">var</span> params = body.join(<span class="string">"❤️"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后把 params 传入 func 去执行</span></span><br><span class="line">    <span class="comment">// func:</span></span><br><span class="line">    <span class="comment">//   path1/path2.func</span></span><br><span class="line">    func = func.split(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">if</span>(func.length !== <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">"Bad params for task:"</span>, func.join(<span class="string">"."</span>), <span class="string">"-"</span>, params);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path = func[<span class="number">0</span>];</span><br><span class="line">    func = func[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mod;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mod = <span class="built_in">require</span>(<span class="string">"./tasks/"</span> + path);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">"Failed to load module"</span>, path);</span><br><span class="line">        <span class="built_in">console</span>.error(e.stack);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mod[func].apply(<span class="literal">null</span>, <span class="built_in">JSON</span>.parse(params));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"Failed to call function"</span>, path, <span class="string">"-"</span>, func, <span class="string">"-"</span>, params);</span><br><span class="line">            <span class="built_in">console</span>.error(e.stack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　这个简易的架子搭好后，你只需要去写一堆任务执行函数，然后在生成任务的时候把相应参数传给 <code>sampleTaskMaker</code> 就好了。Redis 会自动过期并且触发事件给你的 <code>sampleOnExpired</code> 函数，然后就会去执行相应的任务处理函数了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　其实这个需求在我们项目目前就是给用户定时发提醒短信用的。如果没有发现 Redis 的这个妙用，我还是会去用<a href="#最初的设想">第二节</a>里面的方法来写的。其实这期间也有考虑过用 RabbitMQ，不过貌似它的定时消息需要做一些 Hack，比较麻烦，最后就放弃了。</p><p>　　Redis 的这个方法其实是我在谷歌搜出来的，别人在 StackOverflow 回答的答案。我参考了之后用我自己的方法实现了出来，并且把代码的关键部分提取出来整理成这篇小文，还希望能给各位看官一些用吧，望打赏。</p><p>　　如果没有什么用也憋喷我，毕竟我是个蒟蒻。有更好的方法希望留个言，望告知。谢谢。(´,,•ω•,,)♡</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　好久没写博文了，最近在跟随着公司大牛们的脚步秘密研发新产品中。&lt;/p&gt;
&lt;p&gt;　　不过前几天有一个小需求的东西可以提出来写一点点小干货儿跟大家分享分享。米娜桑会的就可以忽略了，反正我也是随便写的；如果觉得本文对你有用的话还请多多支持喵。(●´ω｀●)ゞ&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="Redis" scheme="https://xcoder.in/tags/Redis/"/>
    
      <category term="定时任务" scheme="https://xcoder.in/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Remilia 结构图</title>
    <link href="https://xcoder.in/2015/01/08/remilia-structure/"/>
    <id>https://xcoder.in/2015/01/08/remilia-structure/</id>
    <published>2015-01-08T08:47:17.000Z</published>
    <updated>2017-12-11T07:59:20.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="蕾米莉亚？"><a href="#蕾米莉亚？" class="headerlink" title="蕾米莉亚？"></a>蕾米莉亚？</h2><p>其实这是花瓣的一个入库系统结构图，蕾米莉亚是这个项目的名字。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="pic.jpg" alt="Remilia"></p><p>设计得不好，纯属做归档。</p><p>其中 SanaeHDCS 是另一套系统，给 RemiliaHDPS 提供数据的。</p><h3 id="Data-Layer"><a href="#Data-Layer" class="headerlink" title="Data Layer"></a>Data Layer</h3><p>主要分为 Bathtub，Dryer，Vampire 三个部分。</p><h4 id="Bathtub-浴缸"><a href="#Bathtub-浴缸" class="headerlink" title="Bathtub 浴缸"></a>Bathtub 浴缸</h4><p>由 SanaeHDCS 提供的数据，存储在 MongoDB 当中。</p><h4 id="Dryer-吹轰鸡"><a href="#Dryer-吹轰鸡" class="headerlink" title="Dryer 吹轰鸡"></a>Dryer 吹轰鸡</h4><p>将 Bathtub 出来的湿数据变成干货的解析器，根据不同的数据用不同的规则进行解析。</p><h4 id="Vampire-血族"><a href="#Vampire-血族" class="headerlink" title="Vampire 血族"></a>Vampire 血族</h4><p>全名其实是 Vampire Coffin，只不过把这个写到项目里面看着貌似不是很吉利，于是取了前半部分。吹轰机处理好的干活会存储在这边，实际上也是<br>MongoDB 里面。然后 Vampire 提供给外部接口，让其能够用正确的姿势获取正确的干货数据。</p><h3 id="Fake-Internet"><a href="#Fake-Internet" class="headerlink" title="Fake Internet"></a>Fake Internet</h3><p>一个视窗。</p><h3 id="Fake-Koumakan"><a href="#Fake-Koumakan" class="headerlink" title="Fake Koumakan"></a>Fake Koumakan</h3><p>假的红魔馆，里面一堆 Puppet。</p><blockquote><p>每个 Puppet 都有自己的属性、人格、作息时间和生活。</p></blockquote><h2 id="01-12-2015"><a href="#01-12-2015" class="headerlink" title="01 / 12 / 2015"></a>01 / 12 / 2015</h2><p>重新设计了 Remilia 结构图。</p><p><img src="new.jpg" alt="Remilia"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好吧还是我的脑洞太大了。我知道你们看着这货不知所云。</p><p>好吧忘了这个东西吧，我只是无聊发一篇而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;蕾米莉亚？&quot;&gt;&lt;a href=&quot;#蕾米莉亚？&quot; class=&quot;headerlink&quot; title=&quot;蕾米莉亚？&quot;&gt;&lt;/a&gt;蕾米莉亚？&lt;/h2&gt;&lt;p&gt;其实这是花瓣的一个入库系统结构图，蕾米莉亚是这个项目的名字。&lt;/p&gt;
&lt;h2 id=&quot;结构图&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Remilia" scheme="https://xcoder.in/tags/Remilia/"/>
    
      <category term="蕾米莉亚" scheme="https://xcoder.in/tags/%E8%95%BE%E7%B1%B3%E8%8E%89%E4%BA%9A/"/>
    
  </entry>
  
  <entry>
    <title>在 C++ 中链接 C 的 文件</title>
    <link href="https://xcoder.in/2014/12/10/link-c-on-gpp/"/>
    <id>https://xcoder.in/2014/12/10/link-c-on-gpp/</id>
    <published>2014-12-10T07:30:32.000Z</published>
    <updated>2017-12-11T07:59:20.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于某些原因，我写了个很搓的<a href="https://github.com/XadillaX/xmempool" target="_blank" rel="external">内存池</a>（C 版本的）。</p><p>然后我想到了把之前写的一个 Node.js 包 <a href="https://github.com/XadillaX/thmclrx" target="_blank" rel="external">thmclrx</a> 的更挫的“伪·内存池”用新写的内存池去替换掉。(❛◡❛✿)</p><p>然后问题就来了，我貌似不能控制 node-gyp 去用 G++ 编译 <code>*.c</code> 文件，这样的话所有文件编译好之后链接 <code>*.o</code> 文件会出问题。虽然链接的时候没报错，但是使用的时候就会报这么个错 (;´༎ຶД༎ຶ`)：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ thmclrx git:(master) ✗ node <span class="built_in">test</span>/test.js</span><br><span class="line">dyld: lazy symbol binding failed: Symbol not found: __Z16xmem_create_poolj</span><br><span class="line">  Referenced from: /Users/.../code/huaban/thmclrx/build/Release/thmclrx.node</span><br><span class="line">  Expected <span class="keyword">in</span>: dynamic lookup</span><br><span class="line"></span><br><span class="line">dyld: Symbol not found: __Z16xmem_create_poolj</span><br><span class="line">  Referenced from: /Users/.../code/huaban/thmclrx/build/Release/thmclrx.node</span><br><span class="line">  Expected <span class="keyword">in</span>: dynamic lookup</span><br><span class="line"></span><br><span class="line">[1]    52501 trace <span class="built_in">trap</span>  node <span class="built_in">test</span>/test.js</span><br></pre></td></tr></table></figure><p>大致意思就是说在我编译好链接好的 <code>thmclrx.node</code> 中找不到 <code>__Z16xmem_create_poolj</code> 这个符号，也就是说 <code>xmempool.o</code> 这个用 C 编译出来的文件并没有正确被链接。</p><h2 id="假想方案"><a href="#假想方案" class="headerlink" title="假想方案"></a>假想方案</h2><h3 id="假想一"><a href="#假想一" class="headerlink" title="假想一"></a>假想一</h3><p>一开始我想找的是“如何在 node-gyp 中手动选择编译器”，即不让机器自动选择 GCC 去编译 <code>*.c</code> 文件。后来无果。ル||☛_☚|リ</p><h3 id="假想二"><a href="#假想二" class="headerlink" title="假想二"></a>假想二</h3><p>再后来我想开了，于是决定让编译的时候去识别我在跟 C 说话还是跟 C++ 说话。(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>于是我找到了这么个帖子：<a href="http://grokbase.com/t/gg/nodejs/14amregx72/linking-c-sources-files-in-cc-files" target="_blank" rel="external">http://grokbase.com/t/gg/nodejs/14amregx72/linking-c-sources-files-in-cc-files</a></p><p>他貌似也遇到了跟我相似的问题。下面这个提问者自己提出了这样的回答：</p><blockquote><p>Nevermind, found my own answer after finally hitting the right google search terms.</p><p>Added</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//... source code here...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>So that the CPP compiler would know I was talking C and not CPP :)</p></blockquote><p>答案的大意就是在你的 C 头文件中添加上面 blahblah 一大段宏，好让 C++ 的编译器知道它是在跟 C 的中间文件交流而不是 C++，这样的话链接的时候就能正常接轨了。于是我在我的新版 <a href="https://github.com/XadillaX/xmempool/commit/b06351836c9b51952a3d98c438df6626dda8738c" target="_blank" rel="external">xmempool</a> 的头文件里面就已经添加上了这两段话了。</p><h2 id="事后烟"><a href="#事后烟" class="headerlink" title="事后烟"></a>事后烟</h2><p>其实以前我也老在别的项目里面看到这个 <code>#ifdef __cplusplus</code> 的宏定义，只不过以前不知道什么意思。</p><p>今天通过这么一件事情终于知道了它的用途了，新技能 get √。</p><p>ε(*´･∀･｀)зﾞ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;由于某些原因，我写了个很搓的&lt;a href=&quot;https://github.com/XadillaX/xmempool&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何生成一个覆盖广的色板</title>
    <link href="https://xcoder.in/2014/10/16/generate-color-space/"/>
    <id>https://xcoder.in/2014/10/16/generate-color-space/</id>
    <published>2014-10-16T03:00:54.000Z</published>
    <updated>2017-12-11T07:59:20.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>　　在主题色提取的过程中，要把颜色加入搜索引擎。但是如果是真彩色任意值加进去的话，对于搜索的时候来说无疑是一个复杂的操作。搜索条件要各种计算距离什么的。</p><p>　　于是一个妥协的做法就是提供一套调色板，保证所有颜色都被吸纳到调色板中的某一色值当中。</p><p>　　那么这个时候调色板的覆盖率以及距离什么的就比较重要了。本文就讲如何生成一套看起来还不错的自用“标准色板”。</p><h2 id="Windows-色板"><a href="#Windows-色板" class="headerlink" title="Windows 色板"></a>Windows 色板</h2><p>　　一开始我用了一套 256 色的色板，不知道哪里搞来的 Windows 色板。</p><p>　　由于颜色太多，不好贴代码，我就直接把链接贴过来了：</p><blockquote><p><a href="https://github.com/XadillaX/thmclrx/blob/4a5bff429f25294af7111de800063ffd90cce1d8/src/common.cpp#L29" target="_blank" rel="external">点我萌萌哒 ฅ(๑<em>д</em>๑)ฅ!!</a></p></blockquote><p>　　这一套色板大致的效果如下：</p><style>#standard-256 {    line-height: 10px;    padding: 0;    margin: 0;}#standard-256 span {    width: 40px;    height: 20px;    display: inline-block;}</style><div class="well"><div id="standard-256"></div></div><script src="http://blog.xcoder.in/theme-color-slide/palette.js"></script><script>$(function(){    for (var i = 0; i < palette.length; i++)    {        var block = "<span style=\"background: rgba(" +            palette[i][0] + ", " + palette[i][1] + ", " +            palette[i][2] + ", 1);\"></span>";        $("#standard-256").append(block);    }});</script><h2 id="生成更好的色板"><a href="#生成更好的色板" class="headerlink" title="生成更好的色板"></a>生成更好的色板</h2><p>　　我指的更好并不一定真的比之前找到的 256 色要好，毕竟上面那个是人家智慧和劳动的结晶。我指的更好是颜色更多，但是偏差又不会太大。</p><p>　　理论上我们能按照那种规则生成比真彩色少的任意种数的色板。</p><h3 id="相关的色彩模式"><a href="#相关的色彩模式" class="headerlink" title="相关的色彩模式"></a>相关的色彩模式</h3><p>　　这里有必要重新普及下 N 多种色彩模式中的其中两种，也就是我们今天生成一个色板所用到的两种模式。</p><h4 id="RGB-色彩模式"><a href="#RGB-色彩模式" class="headerlink" title="RGB 色彩模式"></a>RGB 色彩模式</h4><p>　　这个大家都已经耳熟能详了，无非是 RGB 通道中的分量结合起来生成的一种颜色。</p><blockquote><p>RGB 色彩模式是工业界的一种颜色标准，是通过对红 (R)、绿 (G)、蓝 (B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p><p>使用 RGB 模型为图像中每一个像素的 RGB 分量分配一个 0 ~ 255 范围内的强度值。RGB 图像只使用三种颜色，就可以使它们按照不同的比例混合，在屏幕上呈现 16777216 (<code>256 * 256 * 256</code>) 种颜色。</p></blockquote><h4 id="HSL-色彩模式"><a href="#HSL-色彩模式" class="headerlink" title="HSL 色彩模式"></a>HSL 色彩模式</h4><blockquote><p>HSL 色彩模式是工业界的一种颜色标准，是通过对色相 (H)、饱和度 (S)、明度 (L) 三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，HSL 即是代表色相，饱和度，明度三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p></blockquote><p>　　HSL 色彩模式就是今天的主角了。我们将会用 HSL 生成一张类似下图的色板，而色板的粒度将会与你决定色板的颜色数量相关：</p><p><img src="SqfinPalette-RealColorWheel-RGB-14inwide72dpi-1024x437.png" alt="HSL Color Space"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>　　为了简化代码，我们暂时不考虑饱和度，也就是说所有颜色让它饱和度都为 <strong>100%</strong>。</p><p>　　而且实际上色相是在一个圆里面的 0° ~ 360°，那么也就是说我们只需要做两步就是了：</p><ol><li>色相 0° ~ 360° 循环；</li><li>以及明度 0% ~ 100% 循环。</li></ol><p>　　在这里我定了一个步长：色相以 10° 为一个步长，明度以 5% 为一个步长。并且剔除 RGB 相等的黑白灰色。</p><blockquote><p>当然这里步长完全可以按照自己的喜好来。</p></blockquote><p>　　我们以前端的 Javascript 为例，能想到下面的一段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">36</span>; j++) &#123;</span><br><span class="line">            $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div class='color'&gt;&lt;/div&gt;"</span>);</span><br><span class="line">            $(<span class="string">".color"</span>).eq(count++).css(<span class="string">"background-color"</span>, <span class="string">"hsl("</span> + (j * <span class="number">10</span>) + <span class="string">", "</span> + <span class="string">"100%, "</span> + <span class="built_in">parseInt</span>(((i + <span class="number">1</span>) / <span class="number">21</span>) * <span class="number">100</span>) + <span class="string">"%)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div style='clear: both;'&gt;&lt;/div&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　这里需要注意的是，实际上我明度的步长是 <code>(100 / 22)</code>。然后 <code>0</code> 和 <code>100</code> 这两个明度我们另外拎出来，所以只取了 1 ~ 21 的明度。</p><p>　　剩下的就是跟刚才说的一样，各色相的各明度生成一个 HSL 颜色赋值给 <code>background-color</code>。</p><p>　　接下去我们生成一个灰色条的色板，专治灰黑白。这个时候实际上我们可以直接用 RGB 搞定：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#palette"</span>).append(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">36</span>; i++) &#123;</span><br><span class="line">    $(<span class="string">"#palette"</span>).append(<span class="string">"&lt;div class='color'&gt;&lt;/div&gt;"</span>);</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">parseInt</span>(((<span class="number">19</span> - i) / <span class="number">19</span>) * <span class="number">255</span>);</span><br><span class="line">    $(<span class="string">".color"</span>).eq(count++).css(<span class="string">"background-color"</span>, <span class="string">"rgb("</span> + val + <span class="string">", "</span> + val + <span class="string">", "</span> + val + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后把颜色输出到一个数组就好了。</p><blockquote><p>这里有一点 happy 的是，就算你是用 HSL 来搞的背景色，用 <strong><em>jQuery</em></strong> 的 <code>$(foo).css(&quot;background-color&quot;)</code> 获取到的仍然是 RGB 值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [];</span><br><span class="line">$(<span class="string">".color"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="regexp">/rgb\((\d+), (\d+), (\d+)\)/</span>.exec($(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>));</span><br><span class="line">    colors.push(&#123; <span class="attr">r</span>: <span class="built_in">parseInt</span>(result[<span class="number">1</span>]), <span class="attr">g</span>: <span class="built_in">parseInt</span>(result[<span class="number">2</span>]), <span class="attr">b</span>: <span class="built_in">parseInt</span>(result[<span class="number">3</span>]) &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"textarea"</span>).val(<span class="built_in">JSON</span>.stringify(colors));</span><br></pre></td></tr></table></figure><p>　　所以最后我们还需要初始的 HTML 了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"palette"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear: both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　效果的话这里能看到：</p><ul><li><a href="http://blog.xcoder.in/hsl-color-space/" target="_blank" rel="external">http://blog.xcoder.in/hsl-color-space/</a></li><li><a href="http://runjs.cn/code/spahru8w" target="_blank" rel="external">http://runjs.cn/code/spahru8w</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　用 HSL 生成的色彩空间（色板）一个是表现力好，相对于 RGB 来说，好像更好知道如何去生成分部比较 OK 的一个色彩空间。</p><p>　　但是也有一个缺点，当我们不去管饱和度的时候，实际上我们还是丢失了一部分的颜色。好在本身我们生成色板也只是为了合并颜色，可以通过 k-D 树来快速寻找某个颜色在色板中是属于哪种色块的。当然，目前我们就是这么做的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://websafecolorcodes.com/colors-palette/color-wheel-palette/" target="_blank" rel="external">Color Wheel Palette</a></li><li><a href="http://www.waldronconstructionllc.com/wp-content/uploads/2012/03/SqfinPalette-RealColorWheel-RGB-14inwide72dpi-1024x437.png" target="_blank" rel="external">Refer Image</a></li><li><a href="http://codeforartists.com/samples/cfa-color-palette-hsl.php" target="_blank" rel="external">Algorithm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h2&gt;&lt;p&gt;　　在主题色提取的过程中，要把颜色加入搜索引擎。但是如果是真彩色任意值加进去的话，对于搜索的时候来说无疑是一个复杂的操作。搜索条件要各种计算
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="HSL" scheme="https://xcoder.in/tags/HSL/"/>
    
      <category term="RGB" scheme="https://xcoder.in/tags/RGB/"/>
    
      <category term="色板" scheme="https://xcoder.in/tags/%E8%89%B2%E6%9D%BF/"/>
    
      <category term="Palette" scheme="https://xcoder.in/tags/Palette/"/>
    
      <category term="Color Space" scheme="https://xcoder.in/tags/Color-Space/"/>
    
      <category term="色彩空间" scheme="https://xcoder.in/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>用 Javascript 实现一个简易 BrainF**k 解释器</title>
    <link href="https://xcoder.in/2014/10/08/brainf**k/"/>
    <id>https://xcoder.in/2014/10/08/brainf**k/</id>
    <published>2014-10-08T03:42:32.000Z</published>
    <updated>2017-12-11T07:59:20.462Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先祝贺自己在 <a href="http://www.codewars.com/users/XadillaX" target="_blank" rel="external">CodeWars</a> 升级到 3 Kyu，以及感谢 @<a href="http://www.html-js.com/card/473" target="_blank" rel="external">Bolt_白衣苍狗</a> 童鞋让我知道有 CodeWars 这么个好玩的东西。</p><p>　　虽然里面水题居多，不过在上班比较空闲的档口 #<strong>带薪刷题</strong># 的感觉还是蛮不错的。</p><h2 id="话唠一下"><a href="#话唠一下" class="headerlink" title="话唠一下"></a>话唠一下</h2><p>　　高中的时候就跟 @<a href="http://www.lvchaoshuai.com/" target="_blank" rel="external">MatRush</a> 发现了一个名字超级好玩的编程语言叫 <a href="http://en.wikipedia.org/wiki/Brainfuck" target="_blank" rel="external">BrainF**k</a>，它比较搞脑筋，因为所有的编程操作都是集合在操作符里面，然后控制指针偏移和内存值的修改来进行一系列操作。</p><p>　　这与后面发现的 <a href="http://www.hacker.org/hvm/" target="_blank" rel="external">HVM</a>（Hack Virtual Machine）有异曲同工之妙。其实之前也出过一个“<a href="http://acm.nbut.edu.cn/Problem/view.xhtml?id=1062" target="_blank" rel="external">实现一个简易 HVM 解释器</a>”的题目，所以在 CodeWars 看到这个题目的时候还感觉蛮亲切的。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　问题很简单，就是让你实现一个函数来解释一句 BrainF**k 的语句，并且根据输入数据来输出相应的内容。</p><p>　　至于这题所需的 BrainF**k 的语法，大致如下：</p><ul><li><code>&gt;</code>: 指针右移一位。</li><li><code>&lt;</code>: 指针左移一位。</li><li><code>+</code>: 当前指针所指的内存值加一，以 255 为界，溢出为 0，即 <code>255 + 1 = 0</code>。</li><li><code>-</code>: 当前指针所指的内存值减一，以 0 为界，溢出为 255，即 <code>0 - 1 = 255</code>。</li><li><code>.</code>: 输出当前指针所指的值，即输出该值 ASCII 码所对应的字符。</li><li><code>,</code>: 从输入取一个字符转为 ASCII 码存入当前指针所指的内存。</li><li><code>[</code>: 若当前指针所指的值为 0，则命令跳到该 <code>[</code> 匹配的结束 <code>]</code> 符号位置的下一位置的指令。</li><li><code>]</code>: 若当前指针所指的值不为 0，则指令向前跳到该 <code>]</code> 匹配到的 <code>[</code> 符号位置的下一位置的指令。</li></ul><p>　　举个例子：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="string">,</span><span class="literal">+</span><span class="title">[</span><span class="literal">-</span><span class="string">.</span><span class="string">,</span><span class="literal">+</span><span class="title">]</span></span><br></pre></td></tr></table></figure><p>　　上面的句子大致就是说：</p><ol><li>获取输入到当前指针。</li><li>当前指针值加一。</li><li>如果当前指针的值为 0，那么跳到结束位置；否则下一步。</li><li>当前指针值减一。</li><li>输出当前指针的值（综上所述，就是输出输入的值）。</li><li>获取输入到当前指针。</li><li>当前指针值加一。</li><li>若当前指针值不为 0，那么跳到 <code>[</code> 后面的位置——即第四步。</li></ol><p>　　说白了，就是不断获取输入的值，如果输入的值是 255，那么就跳出循环，否则原样输出。</p><h2 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h2><p>　　明白了上面的题意之后就可以开始实现了，步骤大致上就是逐位遍历指令，然后一个 <code>switch</code> 来处理各种指令即可。</p><p>　　<strong>CodeWars</strong> 给了你一个函数原型，你在里面实现代码就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span>(<span class="params">code, input</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前趋工作"><a href="#前趋工作" class="headerlink" title="前趋工作"></a>前趋工作</h3><p>　　在开始之前，我们做一些初始化工作，比如申明几个变量什么的：</p><ul><li>输入数据当前的位置，也就是说读取几个之后，这个位置要偏移几位。</li><li>当前指令的位置。</li><li>当前指针的位置。</li><li>“伪内存块”的值，用一个数组表示，默认一个 <code>[ 0 ]</code>。</li><li>需要 <code>return</code> 的字符串，即输出的值。</li><li>某个括号匹配的括号的指令下标的这么一个映射数组。</li></ul><p>　　所以接下去我们要把架子填成这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span>(<span class="params">code, input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> commandPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> pointerPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bytes = [ <span class="number">0</span> ];</span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> matching = getMatchingBra(code);    <span class="comment">///&lt; 人家才不是罩罩呢，我是 Brackets 的缩写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号匹配函数"><a href="#括号匹配函数" class="headerlink" title="括号匹配函数"></a>括号匹配函数</h4><p>　　上面的 <code>getMatchingBra</code> 就是我们要实现的一个括号匹配函数了，思想就是用栈。</p><p>　　碰到前括号就把这个前括号的下标入栈；碰到后括号，就把栈顶元素即前括号的下标推出，这个时候括号匹配数组的这个前括号下标的值就是当前后括号的下标，而后括号下标的值就是前括号的下标了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 你才是 Bra ／/( ◕‿‿◕ )＼</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMatchingBra</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> bra = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) bra.push(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(code[i] === <span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(code[i] === <span class="string">']'</span>) &#123;</span><br><span class="line">            bra[i] = stack.pop();</span><br><span class="line">            bra[bra[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bra;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　有了这个数组就可以随便跳了，如果指令第 <code>i</code> 位是一个括号（不管前括号还是后括号），那么它的匹配括号下标就是 <code>matching[i]</code> 了。</p><h3 id="各种指令的处理"><a href="#各种指令的处理" class="headerlink" title="各种指令的处理"></a>各种指令的处理</h3><p>　　要处理指令的话实际上就是一个 <code>while</code> 语句不断循环指令，然后判断当前指令是什么然后做相应的事，最后指令位置加一就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(commandPos &lt; code.length) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(code[commandPos]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'.'</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">','</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'['</span>: &#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">']'</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commandPos++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h4><p>　　指针右移的话就把指针位置加一，如果内存数组还没当前指针位置的值的话 <code>push</code> 一个 <code>0</code> 就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">undefined</span> === bytes[++pointerPos]) bytes.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lt"><a href="#lt" class="headerlink" title="&lt;"></a>&lt;</h4><p>　　左移就是减一，如果位置小于 0，那么内存数组从前推入一个值，并让指针等于 0。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;</span><br><span class="line">    <span class="keyword">if</span>(--pointerPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        bytes.unshift(<span class="number">0</span>);</span><br><span class="line">        pointerPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="+"></a>+</h4><p>　　没什么好说的，内存加一就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>: &#123;</span><br><span class="line">    bytes[pointerPos] = (bytes[pointerPos] + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h4><p>　　减一。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>: &#123;</span><br><span class="line">    bytes[pointerPos]--;</span><br><span class="line">    <span class="keyword">if</span>(bytes[pointerPos] &lt; <span class="number">0</span>) bytes[pointerPos] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title="."></a>.</h4><p>　　输出的话直接往 <code>output</code> 字符串里面加上当前指针的值就好了，注意要 ASCII 转变之后的字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'.'</span>: &#123;</span><br><span class="line">    output += <span class="built_in">String</span>.fromCharCode(bytes[pointerPos]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-3"><a href="#-3" class="headerlink" title=","></a>,</h4><p>　　输入的话就让 <code>input</code> 当前位置的值变成 ASCII 存进当前指针，然后输入位置加一就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">','</span>: &#123;</span><br><span class="line">    bytes[pointerPos] = input.charCodeAt(inputPos++);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-4"><a href="#-4" class="headerlink" title="["></a>[</h4><p>　　由于之前已经做好了匹配数组，所以我们只需要判断当前指针是不是 0，然后如果是就跳到匹配括号处。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'['</span>: &#123;</span><br><span class="line">    commandPos = !bytes[pointerPos] ? matching[commandPos] : commandPos;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-5"><a href="#-5" class="headerlink" title="]"></a>]</h4><p>　　同上，只不过条件改一下而已。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">']'</span>: &#123;</span><br><span class="line">    commandPos = bytes[pointerPos] ? matching[commandPos] : commandPos;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="善后工作"><a href="#善后工作" class="headerlink" title="善后工作"></a>善后工作</h3><p>　　上面的函数体完成之后，我们只需要在最后把 <code>output</code> 给返回就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> output;</span><br></pre></td></tr></table></figure><h2 id="肢体组装"><a href="#肢体组装" class="headerlink" title="肢体组装"></a>肢体组装</h2><p>　　完成了上面七零八落的肢体之后，我们要把五马分尸的代码给凑回去，所以最后就长这个样子了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMatchingBra</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> bra = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) bra.push(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(code[i] === <span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(code[i] === <span class="string">']'</span>) &#123;</span><br><span class="line">            bra[i] = stack.pop();</span><br><span class="line">            bra[bra[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">brainLuck</span>(<span class="params">code, input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> commandPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> pointerPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bytes = [ <span class="number">0</span> ];</span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> matching = getMatchingBra(code);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(commandPos &lt; code.length) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(code[commandPos]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;</span><br><span class="line">                pointerPos++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">undefined</span> === bytes[pointerPos]) &#123;</span><br><span class="line">                    bytes.push(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;</span><br><span class="line">                pointerPos--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &gt; pointerPos) &#123;</span><br><span class="line">                    bytes.unshift(<span class="number">0</span>);</span><br><span class="line">                    pointerPos = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: &#123;</span><br><span class="line">                bytes[pointerPos] = (bytes[pointerPos] + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: &#123;</span><br><span class="line">                bytes[pointerPos]--;</span><br><span class="line">                <span class="keyword">if</span>(bytes[pointerPos] &lt; <span class="number">0</span>) bytes[pointerPos] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: &#123;</span><br><span class="line">                output += <span class="built_in">String</span>.fromCharCode(bytes[pointerPos]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = input.charCodeAt(inputPos++);</span><br><span class="line">                bytes[pointerPos] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(!bytes[pointerPos]) &#123;</span><br><span class="line">                    commandPos = matching[commandPos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(bytes[pointerPos]) &#123;</span><br><span class="line">                    commandPos = matching[commandPos];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        commandPos++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题后语"><a href="#题后语" class="headerlink" title="题后语"></a>题后语</h2><p>　　艾玛，忘了放题目链接了：<a href="http://www.codewars.com/kata/526156943dfe7ce06200063e" target="_blank" rel="external">http://www.codewars.com/kata/526156943dfe7ce06200063e</a>。以及大家如果有兴趣的话也可以去试试看写个 <a href="http://acm.nbut.edu.cn/Problem/view.xhtml?id=1062" target="_blank" rel="external">HVM</a> 看看。</p><p>　　实际上本文实现的东西实用性几乎没有，只不过是抛砖引玉，让大家在做一些模拟题逻辑（或者说是简单模拟逻辑）的时候理清思路、按部就班，切忌自己乱了思路和逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　首先祝贺自己在 &lt;a href=&quot;http://www.codewars.com/users/XadillaX&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CodeWars&lt;/a&gt; 升级到 3 Kyu，以及感谢 @&lt;a href=&quot;http://ww
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="Javascript" scheme="https://xcoder.in/tags/Javascript/"/>
    
      <category term="解释器" scheme="https://xcoder.in/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
      <category term="BrainFuck" scheme="https://xcoder.in/tags/BrainFuck/"/>
    
  </entry>
  
  <entry>
    <title>用 Node.js 实现一个 Singleton</title>
    <link href="https://xcoder.in/2014/09/30/javascript-singleton/"/>
    <id>https://xcoder.in/2014/09/30/javascript-singleton/</id>
    <published>2014-09-30T07:21:13.000Z</published>
    <updated>2017-12-11T07:59:20.501Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天随便玩了一道 <a href="http://www.codewars.com/kata/singleton-pattern/javascript" target="_blank" rel="external">CodeWar 的题</a>。</p><p>　　题意大致就是你需要实现一个 <code>Singleton</code> 也就是单件模式的类，让其下面代码执行成功：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> Singleton();</span><br><span class="line">obj1 === obj2; <span class="comment">// =&gt; true</span></span><br><span class="line">obj1.test = <span class="number">1</span>;</span><br><span class="line">obj2.test; <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>　　并且还有很重要的一点就是 <code>Singleton</code> 的对象的 <code>instanceof</code> 也得的确是 <code>Singleton</code> 才行。</p><h2 id="开始试验"><a href="#开始试验" class="headerlink" title="开始试验"></a>开始试验</h2><p>　　我们猜想 <code>new Singleton()</code> 的结果，如果 <code>Singleton</code> 函数也就是这个类的构造函数没返回值的话，直接会返回 <code>this</code>，有返回值的话，那么就是等于其返回值了。</p><p>　　我们码下面的代码看一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Singleton());</span><br></pre></td></tr></table></figure><p>　　跑一遍之后我们的确发现了输出的值就是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="小作弊失败"><a href="#小作弊失败" class="headerlink" title="小作弊失败"></a>小作弊失败</h2><p>　　于是我这么做：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　结果上面的几个条件都符合了，不信大家可以自己输出一遍看看。</p><p>　　但是——</p><p>　　这东西不是一个 <code>Singleton</code> 的实例，它只是一个简单的 <code>JSON</code> 对象，所以还是无法通过。</p><h2 id="死月の正解"><a href="#死月の正解" class="headerlink" title="死月の正解"></a>死月の正解</h2><p>　　答案有很多，CodeWar 上面每个人的解法都不一样，但是归根结底本质还是大同小异的。</p><p>　　就是第一次的时候先直接返回 <code>this</code>，并且把 <code>this</code> 放在某个地方。以后每次来这里创建的时候返回之前存好的 <code>this</code> 即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Singleton.prototype.instance) <span class="keyword">return</span> Singleton.prototype.instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some initialize things</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Singleton.prototype.instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="别的写法"><a href="#别的写法" class="headerlink" title="别的写法"></a>别的写法</h2><p>　　写法很多，我这里随意挑几个别人的答案吧。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * By tjwudi</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Singleton.ins = Singleton.ins ? Singleton.ins : <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * By nonowarn</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance || (instance = <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　今天随便玩了一道 &lt;a href=&quot;http://www.codewars.com/kata/singleton-pattern/javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CodeWar 的题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　题意
      
    
    </summary>
    
      <category term="Node.js" scheme="https://xcoder.in/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="设计模式" scheme="https://xcoder.in/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>让我们用 Node.js 写自己的 DDNS 动态域名程序</title>
    <link href="https://xcoder.in/2014/09/20/lets-build-ourselves-ddns/"/>
    <id>https://xcoder.in/2014/09/20/lets-build-ourselves-ddns/</id>
    <published>2014-09-20T07:51:40.000Z</published>
    <updated>2017-12-11T07:59:20.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>　　一开始我在移动的宽带中。那个时候虽然还不是完全的局域网，但是电信网络访问不了我的外网 IP。又因为我需要一个 DDNS 服务来维持我的 <a href="http://kacaka.ca/" target="_blank" rel="external">kacaka.ca</a>（目前暂失效）。</p><p>　　为了解决让电信网络也能访问我的 Web，于是我想到了免费 CDN 当中比较有名的 <a href="http://cloudflare.com/" target="_blank" rel="external">CloudFlare</a>。而且它也有提供 API 让开发者自己开发通过他的服务解析域名的服务。</p><p>　　再然后，去年的九月份，我的早期 Node.js 作品 <strong><a href="https://github.com/XadillaX/dloucflare/tree/0.0.2" target="_blank" rel="external">dloucflare</a></strong> 发布了。所以就有了<a href="http://cnodejs.org/topic/522b64c3101e574521332451" target="_blank" rel="external">这个帖子</a>。</p><p>　　现在，我已经搬到电信了，然后旧版的貌似不能用了，因为 <strong>CloudFlare</strong> 貌似 API 都迁移到了 <code>https</code> 上面。然后我为了我的小伙伴们能访问我出租屋里的旧电脑，又重构了一遍<a href="https://github.com/XadillaX/dloucflare" target="_blank" rel="external">这个项目</a>。</p><h2 id="使用-dlouc-flare-构建"><a href="#使用-dlouc-flare-构建" class="headerlink" title="使用 dlouc-flare 构建"></a>使用 dlouc-flare 构建</h2><p>　　首先安装最新的 <code>dlouc-flare</code> 包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install dlouc-flare</span><br></pre></td></tr></table></figure><p>　　然后去创建一个 <strong>DF</strong> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DloucFlare = <span class="built_in">require</span>(<span class="string">"dlouc-flare"</span>);</span><br><span class="line"><span class="keyword">var</span> df = DloucFlare.create(<span class="string">"你的邮箱"</span>, <span class="string">"API KEY"</span>, <span class="string">"域名（不需要 www）"</span>);</span><br></pre></td></tr></table></figure><p>　　<strong>CloudFlare</strong> 如何使用的话这里就不多做解释了，至于 <strong>API KEY</strong> 的话，可以在<a href="https://www.cloudflare.com/my-account" target="_blank" rel="external">这里</a>获取到。</p><p>　　然后调用 <code>df.dynamicDomains</code> 函数去把你这个域名下面的一些子域名加入你这个脚本的动态域名范畴当中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df.dynamicDomains([ <span class="string">"@"</span>, <span class="string">"www"</span>, <span class="string">"子域名3"</span>, <span class="string">"子域名4"</span>, ... ], 检测时间间隔);</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>&quot;@&quot;</code> 代表的是域名没有 <code>www</code> 前缀的本身。检测时间间隔以毫秒为单位。</p></blockquote><p>　　事实上，你也可以自定义一个检测你当前主机的 IP 地址的函数（如果你不喜欢用包内的默认检测 IP 函数）。</p><p>　　只要你写一个函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIp</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// blahblah...</span></span><br><span class="line">    callback(<span class="literal">undefined</span>, IP地址);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后覆盖掉默认的 IP 检测函数即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">df.getIpFunction = checkIp;</span><br></pre></td></tr></table></figure><p>　　最后保存退出并用 <code>node</code> 执行你的程序就好了，程序就会开始欢快地跑了。</p><p><img src="preview.png" alt="Preview"></p><h2 id="如何自己写？"><a href="#如何自己写？" class="headerlink" title="如何自己写？"></a>如何自己写？</h2><p>　　其实要完全自己写也是很简单的——无非就是调用一下 <strong>CloudFlare</strong> 的 API 而已。</p><p>　　我们定位明确就是要做 DDNS，所以没必要关系其它很多不相关的 API，只需要最基础的几个就够了。</p><h3 id="API-解析"><a href="#API-解析" class="headerlink" title="API 解析"></a>API 解析</h3><p>　　所有 API 的基础 URI 都为：<a href="https://www.cloudflare.com/api_json.html" target="_blank" rel="external">https://www.cloudflare.com/api_json.html</a>。</p><h4 id="验证信息"><a href="#验证信息" class="headerlink" title="验证信息"></a>验证信息</h4><p>　　根据 <strong>CloudFlare</strong> 文档所说，所有的提交都要黏上<a href="https://www.cloudflare.com/docs/client-api.html#s2.1" target="_blank" rel="external">验证信息</a>给 POST 过去。而验证的字段如下：</p><ul><li><strong>tkn:</strong> 从你的个人页面当中复制出来的 API KEY。</li><li><strong>email:</strong> 你的登录邮箱。</li><li><strong>a:</strong> 操作名，每种操作都有其特有的操作名。</li></ul><h4 id="获取域名下的子域名记录"><a href="#获取域名下的子域名记录" class="headerlink" title="获取域名下的子域名记录"></a>获取域名下的子域名记录</h4><p>　　其操作名为 <code>rec_load_all</code>，我们不关心其它不重要的参数，只需要再传一个 <code>z</code> 字段代表其域名就好了，举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    <span class="attr">a</span>       : <span class="string">"rec_load_all"</span>,</span><br><span class="line">    <span class="attr">tkn</span>     : <span class="keyword">this</span>.apiKey,</span><br><span class="line">    <span class="attr">email</span>   : <span class="keyword">this</span>.email,</span><br><span class="line">    <span class="attr">z</span>       : <span class="keyword">this</span>.domain</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"https://www.cloudflare.com/api_json.html"</span>;</span><br><span class="line">spidex.post(url, <span class="function"><span class="keyword">function</span>(<span class="params">html, status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(status !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error status while fetching DNS records."</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> json;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        json = <span class="built_in">JSON</span>.parse(html);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error while parsing DNS records: "</span> + e.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(json.result === <span class="string">"error"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> msg = json.msg;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">undefined</span> === msg) msg = <span class="string">"Unknown error."</span>;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(msg));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(json.result === <span class="string">"success"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> count = json.response.recs.count;</span><br><span class="line">        <span class="keyword">var</span> objects = json.response.recs.objs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            self.records.push(<span class="keyword">new</span> DNSRecordObject(self, objects[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        callback(<span class="literal">undefined</span>, self.records);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unknown error."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, param, <span class="string">"utf8"</span>).on(<span class="string">"error"</span>, callback);</span><br></pre></td></tr></table></figure><p>　　上述代码就是把 <code>param</code> 数据给 POST 到 API 的 RESTful 里面去。然后根据返回值进行解析。</p><blockquote><p>关于 <code>DNSRecordObject</code> 的代码可以自行翻阅<a href="https://github.com/XadillaX/dloucflare/blob/master/lib/dnsrecordobject.js" target="_blank" rel="external">这里</a>。</p><p>以及 <strong>spidex</strong> 的文档在<a href="https://www.npmjs.org/package/spidex#readme" target="_blank" rel="external">这里</a>。</p></blockquote><h4 id="修改某记录"><a href="#修改某记录" class="headerlink" title="修改某记录"></a>修改某记录</h4><p>　　其操作名为 <code>rec_edit</code>，如<a href="https://www.cloudflare.com/docs/client-api.html#s5.2" target="_blank" rel="external">文档</a>所说，除了固有的几个参数之外，我们还需要有如下参数：</p><ul><li><code>z:</code> 域名。</li><li><code>id:</code> 域名记录编号，从 <code>rec_load_all</code> 中获取。</li><li><code>type:</code> 记录类型。如 <code>A</code> / <code>CNAME</code> 等等。</li><li><code>name:</code> 子域名名，如果无前缀子域名则与域名相同。</li><li><code>content:</code> 值。如果我们只是做动态域名的话，这里的值就是 IP。</li><li><code>service_mode:</code> 服务类型，填原值即可。</li><li><code>ttl</code>: TTL，填原值即可。</li></ul><blockquote><p>上面参数的解说只是对于我们要做 DDNS 脚本而言的解释。</p></blockquote><p>　　所以说在 <strong><a href="https://github.com/XadillaX/dloucflare/blob/master/lib/dnsrecordobject.js" target="_blank" rel="external">dnsrecordobject.js</a></strong> 中我是这么做的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    <span class="attr">a</span>       : <span class="string">"rec_edit"</span>,</span><br><span class="line">    <span class="attr">tkn</span>     : <span class="keyword">this</span>.dloucflare.apiKey,</span><br><span class="line">    <span class="attr">email</span>   : <span class="keyword">this</span>.dloucflare.email,</span><br><span class="line">    <span class="attr">id</span>      : <span class="keyword">this</span>.recordId(),</span><br><span class="line"></span><br><span class="line">    <span class="attr">z</span>       : <span class="keyword">this</span>.domain,</span><br><span class="line">    <span class="attr">type</span>    : <span class="keyword">this</span>.recordType(),</span><br><span class="line">    <span class="attr">name</span>    : <span class="keyword">this</span>.name,</span><br><span class="line">    <span class="attr">content</span> : ip,</span><br><span class="line"></span><br><span class="line">    <span class="attr">service_mode</span>    : <span class="keyword">this</span>.object.service_mode,</span><br><span class="line">    <span class="attr">ttl</span>     : <span class="keyword">this</span>.object.ttl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">spidex.post(config.baseUrl, <span class="function"><span class="keyword">function</span>(<span class="params">html, status, respHeader</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(status !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error status while editing "</span> + self.name + <span class="string">"."</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> json;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        json = <span class="built_in">JSON</span>.parse(html);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error while parsing editing result: "</span> + e.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(json.result === <span class="string">"success"</span>) &#123;</span><br><span class="line">        self.object.content = ip;</span><br><span class="line">        <span class="keyword">return</span> callback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> msg = json.msg || <span class="string">"Unknown error."</span>;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, param, <span class="string">"utf8"</span>).on(<span class="string">"error"</span>, callback);</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码就能将你某个域名（<code>this.domain</code>）下的子域名 <code>this.name</code> 的 IP 给修改成 <code>ip</code> 了。</p></blockquote><h4 id="探测-IP"><a href="#探测-IP" class="headerlink" title="探测 IP"></a>探测 IP</h4><p>　　这种 API 网上就多了去了。</p><p>　　举个简单的例子，我的 <code>dlouc-flare</code> 的获取 IP 的 API 就是从</p><blockquote><p><a href="http://www.telize.com/ip" target="_blank" rel="external">http://www.telize.com/ip</a></p></blockquote><p>　　来的。</p><p>　　请求上面的地址之后，输出的内容（注意有换行符）就是你当前机子所在的网络的公网 IP 了。</p><p>　　类似的 API 还有很多：</p><ul><li><strong><a href="http://ip-api.com/json" target="_blank" rel="external">http://ip-api.com/json</a></strong>: 这个 API 就会输出一堆的 JSON，需要自行解析。</li><li><strong><a href="http://ip.taobao.com/service/getIpInfo2.php?ip=myip" target="_blank" rel="external">http://ip.taobao.com/service/getIpInfo2.php?ip=myip</a></strong>: 这个是淘宝提供的 RESTful 获取 IP 的 API。</li><li>…（其它的可以自己去发现）</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>　　有了上面的仨 API，一切都好说了，流程很简单：</p><ul><li>获取自己某个使用 <code>CloudFlare</code> 解析的域名下的<a href="#获取域名下的子域名记录">子域名</a>。</li><li>自己设置几个子域名名拿来做 DDNS。</li><li>设置一个定时器，每次定时器到时的时候都进行如下操作：<ol><li>通过 <a href="#探测_IP">IP 的 API</a> 获取当前 IP。</li><li>循环遍历每个自己设置的子域名名。</li><li>对于每个子域名，都判断其当前记录 IP 是否等于当前刚探测的 IP。<ul><li><strong>是</strong>：<a href="#修改某记录">修改该子域名的记录值</a>为刚探测的 IP。</li><li><strong>否</strong>：不作任何操作。</li></ul></li></ol></li></ul><p>　　有了上面的几个步骤，加上之前我们讲的几个 API，大家就能轻松加愉快地完成自己的 DDNS 脚本了。</p><p>　　当然，如果自己懒的话也可以用本文一开始的方法，使用 <code>dlouc-flare</code> 这个包，通过简单的编码就能实现自己的 DDNS 动态域名脚本了。</p><blockquote><p>这里的定时器时间自己按需而定，就我自己而言，我是给设置了 <code>1000 * 60</code> 毫秒的间隔。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　最早与动态域名结缘的时候是初中的时候，大概七八年前了吧，那个时候花生壳什么的，但是最终用的是 <code>3322.org</code>。</p><p>　　其实基本的动态域名的原理很简单，无非就是本地开一个脚本，不停去探测本机 IP，一旦有变化就去解析服务器修改。</p><p>　　本人在这里抛砖引玉。如果哪里有别的解析商的 API，大家自己也可以举一反三，写什么 DNSPod 的动态域名，写什么 jiasule 的动态域名等等等等。</p><p>　　喵~<em>ଘ(੭</em>ˊᵕˋ)੭* ੈ✩‧₊˚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;　　一开始我在移动的宽带中。那个时候虽然还不是完全的局域网，但是电信网络访问不了我的外网 IP。又因为我需要一个 DDNS 服务来维持我的 
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="DDNS" scheme="https://xcoder.in/tags/DDNS/"/>
    
      <category term="动态域名" scheme="https://xcoder.in/tags/%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>图片主题色提取算法小结</title>
    <link href="https://xcoder.in/2014/09/17/theme-color-extract/"/>
    <id>https://xcoder.in/2014/09/17/theme-color-extract/</id>
    <published>2014-09-17T03:34:54.000Z</published>
    <updated>2017-12-11T07:59:20.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓主题色提取，就是对于一张图片，近似地提取出一个调色板，使得调色板里面的颜色能组成这张图片的主色调。</p></blockquote><p>　　以上定义为我个人胡诌的。</p><p>　　大家不要太把我的东西当成严谨的文章来看，很多东西什么的都是我用我自己的理解去做，并没有做多少考证。</p><p>　　解析中都会以 Node.js 来写一些小 Demo。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>　　写该文章主要是为了对我这几天对于『主题色提取』算法研究进行一个小结。</p><p>　　花瓣网需要做一件事，就是把图片的主题色提取出来加入到花瓣网搜索引擎的索引当中，以供用户搜索。</p><p>　　于是有了一个需求：提取出图片中在某个规定调色板中的颜色，加入到搜索引擎。</p><p>　　接下去就开始解析两种不同的算法以及在这种业务场景当中的应用。</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><h3 id="魔法数字法"><a href="#魔法数字法" class="headerlink" title="魔法数字法"></a><del>魔法数字法</del></h3><p>　　这个算法大家可以忽略，可能是我使用的姿势不对，总之提取出来（也许它根本就不是这么用的）的东西错误很大。</p><p>　　不过看一下也好开阔下眼界，尤其是我这种想做游戏又不小心掉进互联网的坑里的蒟蒻来说。</p><p>　　首先该算法我是从<a href="http://dev.gameres.com/Program/Visual/Other/256color.htm" target="_blank" rel="external">这里</a>找到的。想当年我还是经常逛 <a href="http://www.gameres.com/" target="_blank" rel="external">GameRes</a> 的。ヾ(;ﾟ;Д;ﾟ;)ﾉﾞ</p><p>　　然后辗转反侧最终发现这段代码是提取自 <a href="https://github.com/liballeg/allegro5/blob/4.3/src/color.c#L268-L328" target="_blank" rel="external">Allegro</a> 游戏引擎。</p><p>　　具体我也就不讲了，毕竟找不到资料，只是粗粗瞄了眼代码里面有几个魔法数字（在游戏和算法领域魔法数字倒是非常常见的），也没时间深入解读这段代码。</p><p>　　我把它翻译成了 Node.js，然后放在了 <a href="https://github.com/XadillaX/theme-color-test/blob/master/version1/magicnumber.js" target="_blank" rel="external">Demo</a> 当中。大家有兴趣可以自己去看看。</p><h3 id="八叉树提取法"><a href="#八叉树提取法" class="headerlink" title="八叉树提取法"></a>八叉树提取法</h3><p>　　这个算法在颜色量化中比较常见的。</p><blockquote><p>该算法最早见于 1988 年，<strong><em>M. Gervautz</em></strong> 和 <strong><em>W. Purgathofer</em></strong> 发表的论文<strong><em>《A Simple Method for Color Quantization: Octree Quantization》</em></strong>当中。其时间复杂度和空间复杂度都有很大的优势，并且保真度也是非常的高。</p></blockquote><p>　　大致的思路就是对于某一个像素点的颜色 <strong>R / G / B</strong> 分开来之后，用二进制逐行写下。</p><p>　　如 <code>#FF7800</code>，其中 <strong>R</strong> 通道为 <code>0xFF</code>，也就是 <code>255</code>，<strong>G</strong> 为 <code>0x78</code> 也就是 <code>120</code>，<strong>B</strong> 为 <code>0x00</code> 也就是 <code>0</code>。</p><p>　　接下去我们把它们写成二进制逐行放下，那么就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R: 1111 1111</span><br><span class="line">G: 0111 1000</span><br><span class="line">B: 0000 0000</span><br></pre></td></tr></table></figure><p>　　<strong>RGB</strong> 通道逐列黏合之后的值就是其在某一层节点的子节点编号了。每一列一共是三位，那么取值范围就是 <code>0 ~ 7</code> 也就是一共有八种情况。这就是为什么这种算法要开八叉树来计算的原因了。</p><p>　　举个例子，上述颜色的第一位黏合起来是 <code>100(2)</code>，转化为十进制就是 4，所以这个颜色在第一层是放在根节点的第五个子节点当中；第二位是 <code>110(2)</code> 也就是 6，那么它就是根节点的第五个儿子的第七个儿子。</p><p>　　于是我们有了这样的一个节点结构：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OctreeNode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isLeaf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.pixelCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.red = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.green = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.blue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.children = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.children.length; i++) <span class="keyword">this</span>.children[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 next 不是指兄弟链中的 next 指针</span></span><br><span class="line">    <span class="comment">// 而是在 reducible 链表中的下一个节点</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>isLeaf</code>: 表明该节点是否为叶子节点。</li><li><code>pixelCount</code>: 在该节点的颜色一共插入了几次。</li><li><code>red</code>: 该节点 <strong>R</strong> 通道累加值。</li><li><code>green</code>: <strong>G</strong> 累加值。</li><li><code>blue</code>: <strong>B</strong> 累加值。</li><li><code>children</code>: 八个子节点指针。</li><li><code>next</code>: <strong><em>reducible</em></strong> 链表的下一个节点指针，后面会作详细解释，目前可以先忽略。</li></ul><h4 id="插入颜色"><a href="#插入颜色" class="headerlink" title="插入颜色"></a>插入颜色</h4><p>　　根据上面的理论，我们大致就知道了往八叉树插入一个像素点颜色的步骤了。</p><p>　　就是每一位 <strong>RGB</strong> 通道黏合的值就是它在树的那一层的子节点的编号。</p><p>　　大致可以看下图：</p><p><img src="http://www.microsoft.com/msj/archive/wicked1.gif" alt="八叉树插入"><br><small>图片来源：<a href="http://www.microsoft.com/msj/archive/S3F1.aspx" target="_blank" rel="external">http://www.microsoft.com/msj/archive/S3F1.aspx</a></small></p><p>　　由此可以推断，在没有任何颜色合并的情况下，插入一种颜色最坏的情况下是进行 64 次检索。</p><blockquote><p><strong>注意：</strong>我们将会把该颜色的 RGB 分量分别累加到该节点的各分量值中，以便最终求平均数。</p></blockquote><p>　　大致的流程就是从根节点开始 DFS，如果到达的节点是叶子节点，那么分量、颜色总数累加；否则就根据层数和该颜色的第层数位颜色黏合值得到其子节点序号。若该子节点不存在就创建一个子节点并与该父节点关联，否则就直接搜下一层去。</p><p>　　创建的时候根据层数来确定它是不是叶子节点，如果是的话需要标记一下，并且全局的叶子节点数要加一。</p><p>　　还有一点需要注意的就是如果这个节点不是叶子节点，就将其丢到 <strong><em>reducible</em></strong> 相应层数的链表当中去，以供之后颜色合并的时候用。关于颜色合并的内容后面会进行解释。</p><p>　　下面是创建节点的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNode</span>(<span class="params">idx, level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> OctreeNode();</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="number">7</span>) &#123;</span><br><span class="line">        node.isLeaf = <span class="literal">true</span>;</span><br><span class="line">        leafNum++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将其丢到第 level 层的 reducible 链表中</span></span><br><span class="line">        node.next = reducible[level];</span><br><span class="line">        reducible[level] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　以及下面是插入某种颜色的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addColor</span>(<span class="params">node, color, level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.isLeaf) &#123;</span><br><span class="line">        node.pixelCount++;</span><br><span class="line">        node.red += color.r;</span><br><span class="line">        node.green += color.g;</span><br><span class="line">        node.blue += color.b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 由于 js 内部都是以浮点型存储数值，所以位运算并没有那么高效</span></span><br><span class="line">        <span class="comment">// 在此使用直接转换字符串的方式提取某一位的值</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 实际上如果用位运算来做的话就是这样子的：</span></span><br><span class="line">        <span class="comment">//   https://github.com/XadillaX/thmclrx/blob/7ab4de9fce583e88da6a41b0e256e91c45a10f67/src/octree.cpp#L91-L103</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> r = color.r.toString(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> g = color.g.toString(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> b = color.b.toString(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(r.length &lt; <span class="number">8</span>) r = <span class="string">'0'</span> + r;</span><br><span class="line">        <span class="keyword">while</span>(g.length &lt; <span class="number">8</span>) g = <span class="string">'0'</span> + g;</span><br><span class="line">        <span class="keyword">while</span>(b.length &lt; <span class="number">8</span>) b = <span class="string">'0'</span> + b;</span><br><span class="line"></span><br><span class="line">        str += r[level];</span><br><span class="line">        str += g[level];</span><br><span class="line">        str += b[level];</span><br><span class="line">        <span class="keyword">var</span> idx = <span class="built_in">parseInt</span>(str, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> === node.children[idx]) &#123;</span><br><span class="line">            node.children[idx] = createNode(node, idx, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">undefined</span> === node.children[idx]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(color.r.toString(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addColor(node.children[idx], color, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并颜色"><a href="#合并颜色" class="headerlink" title="合并颜色"></a>合并颜色</h4><p>　　这一步就是八叉树的空间复杂度低和保真度高的另一个原因了。</p><blockquote><p>勿忘初心。</p></blockquote><p>　　我们用这个算法做的是颜色量化，或者说我要拿它提取主题色、调色板，所以肯定是提取几个有代表性的颜色就够了，否则茫茫世界中 <strong>RRGGBB</strong> 一共有 419430400 种颜色，怎么归纳？</p><p>　　我们可以让指定一棵八叉树不超过多少多少叶子节点（也就是最后能归纳出来的主题色数），比如 8，比如 16、64 或者 256 等等。</p><p>　　所以当叶子节点数超过我们规定的叶子节点数的时候，我们就要合并其中一个节点，将其所有子节点的数据都合并到它身上去。</p><p>　　举个例子，我们有一个节点有八个子节点，并且都是叶子节点，那么我们把八个叶子节点的通道分量全累加到该节点中，颜色总数也累加到该节点中，然后删除八个叶子节点并把该节点设置为叶子节点。那么一下子我们就合并了八个节点有木有！</p><p>　　为什么这些节点可以被合并呢？</p><p>　　我们来看看某个节点下的子节点颜色都有神马相似点吧——它们的三个分量前七位（或者说如果已经不是最底层的节点的话那就是前几位）是相同的，那么比如说刚才的 <code>FF7800</code>，跟它同级并且拥有相同父节点（也就是它的兄弟节点）的颜色都是什么呢：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R: 1111 111(0,1)</span><br><span class="line">G: 0111 100(0,1)</span><br><span class="line">B: 0000 000(0,1)</span><br></pre></td></tr></table></figure><p>　　整合出来一看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FE7800</span><br><span class="line">FE7801</span><br><span class="line">FE7900</span><br><span class="line">FE7901</span><br><span class="line">FF7800</span><br><span class="line">FF7801</span><br><span class="line">FF7900</span><br><span class="line">FF7901</span><br></pre></td></tr></table></figure><p>　　怎么样？是不是确实很相近？这就是八叉树的精髓了，所有的兄弟节点肯定是在一个相近的颜色范围内。</p><p>　　所以说我们要合并就先去最底层的 <strong><em>reducible</em></strong> 链表中寻找一个可以合并的节点，把它从链表中删除之后合并叶子节点并且删除其叶子节点就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduceTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最深层次的并且有可合并节点的链表</span></span><br><span class="line">    <span class="keyword">var</span> lv = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> === reducible[lv]) lv--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出链表头并将其从链表中移除</span></span><br><span class="line">    <span class="keyword">var</span> node = reducible[lv];</span><br><span class="line">    reducible[lv] = node.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并子节点</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> === node.children[i]) <span class="keyword">continue</span>;</span><br><span class="line">        r += node.children[i].red;</span><br><span class="line">        g += node.children[i].green;</span><br><span class="line">        b += node.children[i].blue;</span><br><span class="line">        count += node.children[i].pixelCount;</span><br><span class="line">        leafNum--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    node.isLeaf = <span class="literal">true</span>;</span><br><span class="line">    node.red = r;</span><br><span class="line">    node.green = g;</span><br><span class="line">    node.blue = b;</span><br><span class="line">    node.pixelCount = count;</span><br><span class="line">    leafNum++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样一来，就合并了一个最深层次的节点了，如果满打满算的话，一次合并最多会烧掉 7 个节点（我大 FFF 团壮哉）。</p><h4 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h4><p>　　上面的函数都有了，我们可以开始建树了。</p><p>　　实际上建树的过程就是遍历一遍传入的像素颜色信息，对于每个颜色都插入到八叉树当中；并且每一次插入之后都判断下叶子节点数有没有溢出，如果满出来的话需要及时合并。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildOctree</span>(<span class="params">pixels, maxColors</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pixels.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 添加颜色</span></span><br><span class="line">        addColor(root, pixels[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并叶子节点</span></span><br><span class="line">        <span class="keyword">while</span>(leafNum &gt; maxColors) reduceTree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　整棵树建好之后，我们应该得到了最多有 <code>maxColors</code> 个叶子节点的高保真八叉树。其根节点为 <code>root</code>。</p><h4 id="主题色提取"><a href="#主题色提取" class="headerlink" title="主题色提取"></a>主题色提取</h4><p>　　有了这么一棵八叉树之后我们就可以从里面提取我们想要的东西了。</p><p>　　主题色提取实际上就是把八叉树当中剩下的叶子节点 <strong><em>RGB</em></strong> 通道分量求平均，求出来的就是近似的主题色了。（也许有更好的，不是求平均的方法能获得更好的主题色结果，但是我没有深入去研究，欢迎大家一起来指正 (❀╹◡╹)）</p><p>　　于是我们深度遍历这棵树，每遇到叶子节点，就求出颜色加入到我们所存结果的数组或者任意数据结构当中了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorsStats</span>(<span class="params">node, object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.isLeaf) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">parseInt</span>(node.red / node.pixelCount).toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">var</span> g = <span class="built_in">parseInt</span>(node.green / node.pixelCount).toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">parseInt</span>(node.blue / node.pixelCount).toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(r.length === <span class="number">1</span>) r = <span class="string">'0'</span> + r;</span><br><span class="line">        <span class="keyword">if</span>(g.length === <span class="number">1</span>) g = <span class="string">'0'</span> + g;</span><br><span class="line">        <span class="keyword">if</span>(b.length === <span class="number">1</span>) b = <span class="string">'0'</span> + b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> color = r + g + b;</span><br><span class="line">        <span class="keyword">if</span>(object[color]) object[color] += node.pixelCount;</span><br><span class="line">        <span class="keyword">else</span> object[color] = node.pixelCount;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> !== node.children[i]) &#123;</span><br><span class="line">            colorsStats(node.children[i], object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法小结"><a href="#算法小结" class="headerlink" title="算法小结"></a>算法小结</h4><p>　　八叉树主题色提取算法提取出来的主题色是一个无固定调色板（Non-palette）的颜色群，它有着对原图的尽量保真性，但是由于没有固定的调色板，有时候对于搜索或者某种需要固定值来解释的场景中还是欠了点火候。但是活灵活现非它莫属了。比如某种图片格式里面预先存调色板然后存各像素的情况下，我们就可以用八叉树提取出来的颜色作为该图片调色板，能很大程度上对这张图片进行保真，并且图片颜色也减到一定的量。</p><p>　　该算法的完整 Demo 大家可以在我的 <a href="https://github.com/XadillaX/theme-color-test/blob/master/version3/octree.js" target="_blank" rel="external">Github</a> 当中找到。</p><h3 id="最小差值法"><a href="#最小差值法" class="headerlink" title="最小差值法"></a>最小差值法</h3><p>　　这是一个非常简单又实用的算法。</p><p>　　大致的思想就是给定一个调色板，过来一个颜色就跟调色板中的颜色一一对比，取最小差值的那个调色板里的颜色作为这个颜色的代表。</p><p>　　对比的过程就是分别将 <strong>R / G / B</strong> 通道的值两两相减取绝对值，将三个差相加，得到的这个值就是颜色差值了。</p><p>　　反正最后就是调色板中哪个颜色跟对比的颜色差值最小，就拿过来就是了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> best = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> bestv = pal[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> bestr = <span class="built_in">Math</span>.abs(r - bestv.r) + <span class="built_in">Math</span>.abs(g - bestv.g) + <span class="built_in">Math</span>.abs(b - bestv.b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; pal.length; j++) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = pal[j];</span><br><span class="line">    <span class="keyword">var</span> res = <span class="built_in">Math</span>.abs(r - p.r) + <span class="built_in">Math</span>.abs(g - p.g) + <span class="built_in">Math</span>.abs(b - p.b);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; bestr) &#123;</span><br><span class="line">        best = j;</span><br><span class="line">        bestv = pal[j];</span><br><span class="line">        bestr = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = pal[best].r.toString(<span class="number">16</span>);</span><br><span class="line">g = pal[best].g.toString(<span class="number">16</span>);</span><br><span class="line">b = pal[best].b.toString(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r.length === <span class="number">1</span>) r = <span class="string">"0"</span> + r;</span><br><span class="line"><span class="keyword">if</span>(g.length === <span class="number">1</span>) g = <span class="string">"0"</span> + g;</span><br><span class="line"><span class="keyword">if</span>(b.length === <span class="number">1</span>) b = <span class="string">"0"</span> + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(colors[r + g + b] === <span class="literal">undefined</span>) colors[r + g + b] = <span class="number">-1</span>;</span><br><span class="line">colors[r + g + b]++;</span><br></pre></td></tr></table></figure><h2 id="我是怎么做的"><a href="#我是怎么做的" class="headerlink" title="我是怎么做的"></a>我是怎么做的</h2><p>　　八叉树的缺点我在之前的八叉树小结中提到过了，就是颜色不固定。对于需要有一定固定值范围的主题色提取需求来说不是那么合人意。</p><p>　　而最小差值法的话又太古板了。</p><p>　　于是我的做法是将这两种算法都过一遍。</p><p>　　比如我要将一张图片提取出少于 256 种颜色，我会用八叉树过滤一遍得出保证的两百多种颜色，然后拿着这批颜色和其数量再扔到最小插值法里面将颜色规范化一遍，得出的最终结果可能就是我想要的结果了。</p><p>　　这期间第二步的效率可以忽略不计，毕竟如果是上面的需求的话第一步的结果也就那么两百多种颜色。</p><p>　　这个方法我已经实现并且用在我自己的颜色提取包 <strong><em><a href="https://github.com/XadillaX/thmclrx" target="_blank" rel="external">thmclrx</a></em></strong> 里了。大致的代码可以看<a href="https://github.com/XadillaX/thmclrx/blob/7ab4de9fce583e88da6a41b0e256e91c45a10f67/lib/x.js#L95-L145" target="_blank" rel="external">这里</a>。</p><h2 id="主题色提取-Node-js-包——thmclrx"><a href="#主题色提取-Node-js-包——thmclrx" class="headerlink" title="主题色提取 Node.js 包——thmclrx"></a>主题色提取 Node.js 包——thmclrx</h2><p>　　在这几天的辛勤劳作下，总算完成了某种意义上我的第一个 Node.js C++ Addon。</p><p>　　跟算法相关（八叉树、最小差值）的计算全放在了 <a href="https://github.com/XadillaX/thmclrx/tree/master/src" target="_blank" rel="external">C++ 层</a>进行计算。大家有兴趣的可以去读一下并且帮忙指出各种各样的缺点，算是抛砖引玉了。</p><p>　　这个包的 Repo 在 Github 上面：</p><blockquote><p><a href="https://github.com/XadillaX/thmclrx" target="_blank" rel="external">https://github.com/XadillaX/thmclrx</a></p></blockquote><p>　　文档自认为还算完整吧。并且也可以通过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install thmclrx</span><br></pre></td></tr></table></figure><p>　　进行安装。</p><h2 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h2><p>　　进花瓣两个月了，这一次终于如愿以偿地碰触到了一点点的『算法相关』的活。（我不会告诉你这不是我的任务，是我从别人手中抢来的 2333333 <em>ଘ(੭</em>ˊᵕˋ)੭* ੈ✩‧₊˚</p><p>　　总之几种算法和实现在上方介绍了，具体需要怎么用还是要看大家自己了。我反正大致找到了我使用的途径，那你们呢。( ´･･)ﾉ(._.`)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所谓主题色提取，就是对于一张图片，近似地提取出一个调色板，使得调色板里面的颜色能组成这张图片的主色调。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　以上定义为我个人胡诌的。&lt;/p&gt;
&lt;p&gt;　　大家不要太把我的东西当成严谨的文章来看，很多东西什么的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://xcoder.in/tags/Algorithm/"/>
    
      <category term="Theme Color" scheme="https://xcoder.in/tags/Theme-Color/"/>
    
  </entry>
  
  <entry>
    <title>我是如何实现简单的随机中文名生成器的（Node 版）</title>
    <link href="https://xcoder.in/2014/09/01/how-i-made-chinese-random-x/"/>
    <id>https://xcoder.in/2014/09/01/how-i-made-chinese-random-x/</id>
    <published>2014-09-01T12:36:33.000Z</published>
    <updated>2017-12-11T07:59:20.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>最近闲着蛋疼实现了两个库。</p><ul><li>随机生成中文名字</li><li>随机生成中文技能名</li></ul><p>我当然不会说去用各种人工智能去实现一个强大的的解析器然后生成，也不会说用一个非常庞大如搜狗拼音的姓名库来随机获取——我只是偶然间知道蘑菇街小侠节一个混战 PK 的 Demo 编写比赛，闲来无聊随便写写，然而这其中我需要随机给 Bot 起名以及技能起名而用到的库。</p><p>不需要有多少正确性——这两个库的结果经常出现非常奇葩的名字，让人哭笑不得，但是我要的就是这种效果。</p><h2 id="结果示范"><a href="#结果示范" class="headerlink" title="结果示范"></a>结果示范</h2><p>就两个库，我各生成一批名字以示效果。</p><h3 id="Chinese-Random-Name"><a href="#Chinese-Random-Name" class="headerlink" title="Chinese Random Name"></a>Chinese Random Name</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阙造</span><br><span class="line">广锡一</span><br><span class="line">席寺</span><br><span class="line">扶驾</span><br><span class="line">郑萱黄</span><br><span class="line">林樊牵</span><br><span class="line">孟登元</span><br><span class="line">鱼彰</span><br><span class="line">皮忧暑</span><br><span class="line">左稗</span><br><span class="line">宦醇</span><br><span class="line">糜弋招</span><br><span class="line">席准</span><br><span class="line">方抑</span><br><span class="line">乌泔</span><br><span class="line">苗鲁</span><br><span class="line">孟候依</span><br><span class="line">龙珠饯</span><br><span class="line">洪打鹰</span><br><span class="line">缪负铎</span><br></pre></td></tr></table></figure><h3 id="Chinese-Random-SKill"><a href="#Chinese-Random-SKill" class="headerlink" title="Chinese Random SKill"></a>Chinese Random SKill</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地永心法</span><br><span class="line">缨枪诀</span><br><span class="line">冉腿</span><br><span class="line">尼逻心法</span><br><span class="line">奠拳谱</span><br><span class="line">曲掌法</span><br><span class="line">始刺</span><br><span class="line">娘桶撷刀</span><br><span class="line">璋瑾单养刀</span><br><span class="line">銎刀</span><br><span class="line">励俭驿媛心诀</span><br><span class="line">瞻驰刀诀</span><br><span class="line">晏协骅腿</span><br><span class="line">示嫩帐羽刀诀</span><br><span class="line">赛勘神体刀诀</span><br><span class="line">铸爱指</span><br><span class="line">施净琮萍棍</span><br><span class="line">泊临惇枪诀</span><br><span class="line">我道六分枪</span><br><span class="line">残亭求拳谱</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>实际上无论是起名还是技能名，都用了一个相同的起名字库和一段差不多的复用代码（虽然没有真正意义上的复用，只是复制粘贴而已，谁让他们是两个库呢，已经很简单了，我总不能再给他们搞一个依赖出来吧？）</p><h3 id="起姓"><a href="#起姓" class="headerlink" title="起姓"></a>起姓</h3><p>关于 <code>chinese-random-name</code> 中的姓氏，我找了一个中国百家姓（包括复姓）比较全的词库。</p><blockquote><p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/dict/f.dict" target="_blank" rel="external">词库链接</a></p></blockquote><p>比较幸运，我找到的时候已经是这么分段分好了。我也没有详细做研究，随便给了不同的段不同的权值，当然越前面的段权值越高，被随机到的可能性越大。</p><p>首先用 <code>split</code> 来分割不同段：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dict = dict.split(<span class="string">"\n\n"</span>);</span><br></pre></td></tr></table></figure><p>对于每一段来说通过 <code>Array.reduce</code> (详见 <a href="https://github.com/andrewplummer/Sugar/blob/master/lib/es5.js#L287" target="_blank" rel="external">SugarJs</a>) 来分割成行再成字。</p><p>看字典一共有 6 大段，每段的权值分别为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> weights = [ <span class="number">100</span>, <span class="number">70</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span> ];</span><br></pre></td></tr></table></figure><p>然后每个字都有一个其权值区间，是累加上去的。</p><p>最后获取姓的时候随机生成一个在总区间内的数字，然后看看数字在哪个姓的区间内，就返回这个姓。</p><h3 id="技能后缀"><a href="#技能后缀" class="headerlink" title="技能后缀"></a>技能后缀</h3><p>关于 <code>chinese-random-skill</code> 中的技能后缀，我偷懒了。因为那个时候 Demo 就快 Deadline 了，所以随便糊弄了一下——直接把印象里面比较熟的后缀写上去了事，也不给权值了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = [</span><br><span class="line">    <span class="string">"剑"</span>, <span class="string">"剑法"</span>, <span class="string">"剑谱"</span>, <span class="string">"剑诀"</span>,</span><br><span class="line">    <span class="string">"枪"</span>, <span class="string">"枪法"</span>, <span class="string">"枪诀"</span>,</span><br><span class="line">    <span class="string">"拳"</span>, <span class="string">"拳法"</span>, <span class="string">"拳谱"</span>,</span><br><span class="line">    <span class="string">"刀"</span>, <span class="string">"刀法"</span>, <span class="string">"刀谱"</span>, <span class="string">"刀诀"</span>,</span><br><span class="line">    <span class="string">"斩"</span>, <span class="string">"刺"</span>, <span class="string">"大法"</span>, <span class="string">"心诀"</span>, <span class="string">"心法"</span>, <span class="string">"诀"</span>, <span class="string">"宝典"</span>,</span><br><span class="line">    <span class="string">"棍"</span>, <span class="string">"棍法"</span>, <span class="string">"棍谱"</span>, <span class="string">"棍诀"</span>,</span><br><span class="line">    <span class="string">"指"</span>, <span class="string">"掌"</span>, <span class="string">"掌法"</span>, <span class="string">"腿"</span>, <span class="string">"攻"</span>, <span class="string">"钩"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="共用部分"><a href="#共用部分" class="headerlink" title="共用部分"></a>共用部分</h3><p>名字主体为两个包的共用部分。</p><p>实际上他们依赖于一个特定款式的字库——我也就网上随便那么一搜。</p><blockquote><p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/dict/n.dict" target="_blank" rel="external">字库链接</a></p></blockquote><p>它每一行的结构一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number UniChar UniChar：String</span><br></pre></td></tr></table></figure><p>其中第一个数字我目测是繁体的笔画数，比如 899 行的 <code>书</code> 繁体就是 <code>书</code>，数一下的确是 10 划。</p><p>第二个就是字本体，第三个是该字的五行属性，最后是这个字在什么什么命数（请不要迷信）描述。</p><p>为了让名字看起来稍微正常点（只是稍微而已），我尽可能让同属性的字在一块儿，于是有了以下组合：</p><ul><li>金金</li><li>木木</li><li>水水</li><li>火火</li><li>土土</li></ul><p><a href="https://github.com/XadillaX/chinese-random-name/blob/master/lib/name.js#L41" target="_blank" rel="external">这些字</a>凑在一起的权值为 100。</p><p>然后隔一个属性的话是相克的，我不懂什么起名大法什么的，只是用膝盖想了下相克的属性不好起名吧（猜错了不要怨我），于是给了 20 的权值。</p><p>至于隔壁属性，是相生吧？于是给了 50 权值。</p><p>对于三个字的起名来说，也是用了类似的方法给权值，具体可以参考代码。</p><p>总之就是根据其两两之间的五行关系来起名的，听起来还是有那么点道理的。</p><p>哈哈，权当玩的，认真你就输了。</p><h3 id="综合说明"><a href="#综合说明" class="headerlink" title="综合说明"></a>综合说明</h3><p>上面的分步做完了，然后真·生成名字的步骤是：</p><p>随机生成一个姓（或者技能后缀），然后按照某个权值随机生成一个数字代表剩下的名字的长度，然后随机生成一串该长度的名字即可。</p><p>最后拼接上去就 OK 了。</p><h2 id="无节操小广告"><a href="#无节操小广告" class="headerlink" title="无节操小广告"></a>无节操小广告</h2><p>最后还是贴一下两个包的 repo 地址吧：</p><blockquote><ul><li><a href="https://github.com/XadillaX/chinese-random-name" target="_blank" rel="external">Chinese Random Name</a></li><li><a href="https://github.com/XadillaX/chinese-random-skill" target="_blank" rel="external">Chinese Random Skill</a></li></ul></blockquote><p>以及安装的话照下去弄就好了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install chinese-random-name</span><br><span class="line">$ npm install chinese-random-skill</span><br></pre></td></tr></table></figure><p><code>README</code> 文件两个包都有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;最近闲着蛋疼实现了两个库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机生成中文名字&lt;/li&gt;
&lt;li&gt;随机生成中文技能名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我当然不会
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="https://xcoder.in/tags/NodeJS/"/>
    
      <category term="中文名" scheme="https://xcoder.in/tags/%E4%B8%AD%E6%96%87%E5%90%8D/"/>
    
      <category term="中文技能" scheme="https://xcoder.in/tags/%E4%B8%AD%E6%96%87%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Storm 中 Clojure 的 Prepare Bolt 实现</title>
    <link href="https://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/"/>
    <id>https://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/</id>
    <published>2014-08-04T03:50:21.000Z</published>
    <updated>2017-12-11T07:59:20.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>　　Storm 中的 Bolt 都是通过 Nimbus 这个服务将序列化好的 Bolt 断章取义地发到各个 worker 中。所以，任何在 bolt 之外你自认为加载期间初始化计算好的上下文环境并不会被打包上去，Java 我不懂也不知道，但是至少在 Clojure 这个类的概念被淡化的 LIST 方言中，你要做的就是把所有跟 bolt 初始化计算相关的代码放到其 <code>prepare</code> 的代码当中去。</p><p>　　你想一下，当你在文件加载的时候初始化了一个 MongoDB 链接，这个链接总不能被序列化到远程去吧？所以说办法就是把 bolt 搞上去之后，bolt 自动去初始化一个链接——这就是 <code>prepare</code> 的作用了。</p><p>　　说白了，这个还是我们在 <strong><em>Suwako</em></strong> 当中踩到的坑。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>　　大致的骨架如下：</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defbolt</span> bolt [...] &#123;<span class="symbol">:prepare</span> <span class="literal">true</span>&#125;</span><br><span class="line"> [...]</span><br><span class="line"> (<span class="name"><span class="builtin-name">let</span></span> [...]</span><br><span class="line">  (<span class="name">bolt</span></span><br><span class="line">   (<span class="name">prepare</span> [...]</span><br><span class="line">    (<span class="name">...</span>))</span><br><span class="line">   (<span class="name">execute</span> [tuple]</span><br><span class="line">    (<span class="name">...</span>))))</span><br></pre></td></tr></table></figure><p>　　首先就是 <code>{:prepare true}</code> 代表了它是一个需要初始化的 Bolt。</p><p>　　然后在 <code>(bolt)</code> 的作用域之内有两个 form——<code>prepare</code> 和 <code>execute</code>。</p><p>　　其中 <code>prepare</code> 就是你要初始化的语句了。举个例子，我们让这里面初始化一个 <a href="http://clojuremongodb.info/" target="_blank" rel="external">Monger</a>，于是我们要在 <code>let</code> 里面定义一个用于链接的 <code>atom {}</code>。</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defbolt</span> bolt [<span class="string">"..."</span>] &#123;<span class="symbol">:prepare</span> <span class="literal">true</span>&#125;</span><br><span class="line"> [conf context collector]</span><br><span class="line"> (<span class="name"><span class="builtin-name">let</span></span> [conn (<span class="name"><span class="builtin-name">atom</span></span> &#123;&#125;)</span><br><span class="line">       db (<span class="name"><span class="builtin-name">atom</span></span> &#123;&#125;)]</span><br><span class="line">   (<span class="name">bolt</span></span><br><span class="line">    (<span class="name">prepare</span> [conf context collector]</span><br><span class="line">     (<span class="name"><span class="builtin-name">reset!</span></span> conn (<span class="name">mg/connect</span> ...))</span><br><span class="line">     (<span class="name"><span class="builtin-name">reset!</span></span> db (<span class="name">mg/get-db</span> @conn ...)))</span><br><span class="line">    (<span class="name">execute</span> [tuple]</span><br><span class="line">     (<span class="name">...</span>)))))</span><br></pre></td></tr></table></figure><p>　　这样一来，当 Bolt 被 Nimbus 打包传到各个 worker 之后，Bolt 执行起来的时候会自动执行 <code>prepare</code> 当中的代码，即初始化 MongoDB 的链接，并且将其赋值给 <code>conn</code> 和 <code>db</code> 两个 atom。</p><p>　　那么，我们就能在本体 <code>execute</code> 当中使用 <code>@conn</code> 和 <code>@db</code> 来使唤 MongoDB 了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>　　可能很多人不解，不是说尽量保持 LISP 语系当中值的不变性的么？</p><p>　　其实不变性只是为了提高程序在运行时的效率——而事实上是，上面那段代码并没有在运行时去做变量。</p><p>　　虽然说这么说有点牵强，但是的确就是这个意思——因为我们是在程序执行真正有用的好逻辑的时候没有去改变一些值，相反只是在 Bolt 启动的时候做一些变量的操作。</p><p>　　换句话说，虽然严谨的讲那个时候是算运行时，但是在运行时里面我们却可以把它归类为预处理——这一类东西反正程序还没真正开始跑有用的东西，效率慢一点无所谓，而且就初始化这么屁大点事儿能有多少影响？</p><p>　　效率和效果之间权衡上面的还是要仁者见仁智者见智了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　本以为 <code>Suwako</code> 终于可以暂时告一段落了，紧要关头居然还是阻塞了。</p><p>　　说多都是泪，不说了，找 Bug 去了。</p><p><img src="suwako.jpg" alt="泄矢诹访子"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;　　Storm 中的 Bolt 都是通过 Nimbus 这个服务将序列化好的 Bolt 断章取义地发到各个 worker 中。所以，任何在 
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="Storm" scheme="https://xcoder.in/tags/Storm/"/>
    
      <category term="Clojure" scheme="https://xcoder.in/tags/Clojure/"/>
    
      <category term="Huaban" scheme="https://xcoder.in/tags/Huaban/"/>
    
  </entry>
  
  <entry>
    <title>开发测试时给 Kafka 发消息的 UI 发送器——Mikasa</title>
    <link href="https://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/"/>
    <id>https://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/</id>
    <published>2014-07-30T02:14:29.000Z</published>
    <updated>2017-12-11T07:59:20.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起-灬ºωº灬"><a href="#起-灬ºωº灬" class="headerlink" title="起 (灬ºωº灬)"></a>起 (灬ºωº灬)</h2><p>　　说来话长，自从入了花瓣，整个人就掉进连环坑了。</p><p>　　后端元数据采集是用 Storm 来走拓扑流程的，又因为 @<a href="http://weibo.com/zolazhou" target="_blank" rel="external">Zola</a> 不是很喜欢 Java，所以退而求其次选择了 Clojure，所以正在苦逼地学习 Clojure 和 Storm 中。</p><p>　　目前来说外面的 Storm 拓扑的 Spout 是从 Kafka 中流入数据的。但是我们要给 Kafka 发送测试数据的时候，就需要跑到 Kafka 的测试服务器打开它的一个发送脚本进去发送，非常蛋疼；要么就是直接通过特定的发送业务逻辑代码测试，没有一个稍微泛一点的测试用发数据工具，于是 Mikasa 诞生了。</p><h2 id="承-ﾟ3ﾟ-～♪"><a href="#承-ﾟ3ﾟ-～♪" class="headerlink" title="承 (ﾟ3ﾟ)～♪"></a>承 (ﾟ3ﾟ)～♪</h2><p>　　讲到 Mikasa 名字的来源，实际上看过『巨人』都知道，八块腹肌的三爷。</p><p>　　这里小爆料一下，又拍云和花瓣（都是同宗）的项目名很大部分都是以海贼王的角色命名的——尤其是又拍云更是丧心病狂。不过这让我这个伪·二次元的小伙伴异常欣喜，因为我也能用各种啪啪啪来命名我的角色了。比如我的第一个 Storm 相关的项目就叫 Suwako，即诹访子大人，因为脑子需要各种跳，于是就对诹访子大人这位青蛙之神各种膜拜。</p><p>　　至于这个发射器为什么要用三爷呢？因为三爷相当于先锋军哇！</p><p><img src="mikasa.jpeg" alt="Mikasa"></p><p>　　这里的 Kafka 依赖用了搜狐小伙伴 @<a href="http://weibo.com/crzidea" target="_blank" rel="external">Crzidea</a> 他们团队写的模块。</p><h2 id="转-ㄏ￣▽￣-ㄏ-ㄟ-￣▽￣ㄟ"><a href="#转-ㄏ￣▽￣-ㄏ-ㄟ-￣▽￣ㄟ" class="headerlink" title="转 (ㄏ￣▽￣)ㄏ   ㄟ(￣▽￣ㄟ)"></a>转 (ㄏ￣▽￣)ㄏ   ㄟ(￣▽￣ㄟ)</h2><p>　　于是，话也不多说，直接上 repo 吧。在公司内网的 gitlab 里面有一份，还有一个 repo 在 <a href="https://github.com/" target="_blank" rel="external">GitHub</a> 上。</p><blockquote><p><a href="https://github.com/XadillaX/mikasa" target="_blank" rel="external">点我</a></p></blockquote><h3 id="Download-Clone"><a href="#Download-Clone" class="headerlink" title="Download || Clone"></a>Download || Clone</h3><p>　　如果要直接下载的话就用这个链接：</p><blockquote><p><a href="https://github.com/XadillaX/mikasa/archive/master.zip" target="_blank" rel="external">https://github.com/XadillaX/mikasa/archive/master.zip</a></p></blockquote><p>　　如果要克隆的话就：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/XadillaX/mikasa.git</span></span><br></pre></td></tr></table></figure><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>　　直接安装一下依赖：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>　　接下去就是简单的配置一下了，其实就是配置下配置文件。由于是快速开发，直接用了自己之前的 <a href="https://github.com/XadillaX/exframess" target="_blank" rel="external">Exframess</a> 框架，所以很多无用代码也懒得删了。</p><h4 id="config-server-js"><a href="#config-server-js" class="headerlink" title="config/server.js"></a>config/server.js</h4><p>　　这里其实别的也不用动，主要是修改下端口即可。</p><h4 id="config-kafka-js"><a href="#config-kafka-js" class="headerlink" title="config/kafka.js"></a>config/kafka.js</h4><p>　　这里修改一下 Kafka 的 <code>Connection String</code> 就好了。</p><h3 id="Start-up"><a href="#Start-up" class="headerlink" title="Start up"></a>Start up</h3><p>　　最后启动服务即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node app.js</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pm2 app.js</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or some other<span class="string">'s</span></span></span><br></pre></td></tr></table></figure><h2 id="合-ﾉ◕ヮ◕-ﾉ-･ﾟ✧"><a href="#合-ﾉ◕ヮ◕-ﾉ-･ﾟ✧" class="headerlink" title="合 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧"></a>合 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</h2><p>　　最后的效果是这样的：</p><p><img src="mikasa-preview.png" alt="Preview"></p><p>　　只要在 Topics 栏里面输入你要发送的 Topic，然后再下面的消息栏里面输入你要传的消息（字符串），最后点击 <code>Send</code> 即可将你的测试消息发进 Kafka 中去了。</p><blockquote><p>托大家的福，今天我的 Suwako 整个逻辑终于跑通了，撒花！ε٩(๑&gt; ₃ &lt;)۶з</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起-灬ºωº灬&quot;&gt;&lt;a href=&quot;#起-灬ºωº灬&quot; class=&quot;headerlink&quot; title=&quot;起 (灬ºωº灬)&quot;&gt;&lt;/a&gt;起 (灬ºωº灬)&lt;/h2&gt;&lt;p&gt;　　说来话长，自从入了花瓣，整个人就掉进连环坑了。&lt;/p&gt;
&lt;p&gt;　　后端元数据采集是用 S
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="Kafka" scheme="https://xcoder.in/tags/Kafka/"/>
    
      <category term="Mikasa" scheme="https://xcoder.in/tags/Mikasa/"/>
    
      <category term="花瓣" scheme="https://xcoder.in/tags/%E8%8A%B1%E7%93%A3/"/>
    
  </entry>
  
  <entry>
    <title>Untrusted - 游戏题解</title>
    <link href="https://xcoder.in/2014/06/12/untrusted-solution/"/>
    <id>https://xcoder.in/2014/06/12/untrusted-solution/</id>
    <published>2014-06-12T03:08:34.000Z</published>
    <updated>2017-12-11T07:59:20.548Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="http://alexnisnevich.github.io/untrusted/" target="_blank" rel="external">Trusted</a> 是一个代码解谜游戏，用 Javascript 来过关的。</p><p>　　昨天凌晨花了仨小时通关了这个游戏，在这里就粗粗做一下题解吧，好几题都是 Hack 过去的。（不要脸，( ﾟДﾟ)σ</p><h2 id="Ceil-Block-A"><a href="#Ceil-Block-A" class="headerlink" title="Ceil Block A"></a>Ceil Block A</h2><p>　　这有点像教学关吧，总之先拿到那台电脑你就能操作了。拿到电脑后你就能修改地图内部黑色底色的代码了。</p><p>　　这个时候你只需要把中间设置墙的代码去掉就可以了，或者注释掉：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for(y = 3; y &lt;= map.getHeight() - 10; y++) &#123;</span></span><br><span class="line"><span class="comment">//    map.placeObject(5, y, 'block');</span></span><br><span class="line"><span class="comment">//    map.placeObject(map.getWidth() - 5, y, 'block');</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for(x = 5; x &lt;= map.getWidth() - 5; x++) &#123;</span></span><br><span class="line"><span class="comment">//    map.placeObject(x, 3, 'block');</span></span><br><span class="line"><span class="comment">//    map.placeObject(x, map.getHeight() - 10, 'block');</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>　　然后 <code>&lt;ctrl-5&gt;</code> 重新执行——哒哒～墙就消失了，赶紧到蓝色的出口处吧。</p><h2 id="The-Long-Way-Out"><a href="#The-Long-Way-Out" class="headerlink" title="The Long Way Out"></a>The Long Way Out</h2><p>　　代码大致是给你创建了一个迷宫，并且出口处四面用围墙围起来。</p><p>　　我用了一个比较 Hack 的方法，在第一个黑色区域的最上方把 <code>maze.create</code> 重定向到自己的一个空函数，这样下面调用创建迷宫的函数就不会被执行，这个时候再执行的话迷宫就不见了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">maze.create = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>　　迷宫不见了还不靠谱，因为还有一个出口四周有墙——那就自己再建一个出口呗，在第二个黑色区域写上建立一个新出口的代码即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.placeObject(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"exit"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>勇敢的少年啊，快去创造奇迹！</p></blockquote><h2 id="Validation-Engaged"><a href="#Validation-Engaged" class="headerlink" title="Validation Engaged"></a>Validation Engaged</h2><p>　　这题的要求是在还存在着一定量『壁』的情况下你能到达出口，也就是说纯粹地删除它加『壁』的代码是不行的，那我们做点改动就 OK 了。把『壁』往外移动，直到把人和出口都是在『壁』内。</p><blockquote><p>那一天，人类终于回想起曾经一度被他们所支配的恐怖，还有囚禁于鸟笼中的那份屈辱。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(y = <span class="number">0</span>; y &lt;= map.getHeight() - <span class="number">3</span>; y++) &#123;</span><br><span class="line">    map.placeObject(<span class="number">5</span>, y, <span class="string">'block'</span>);</span><br><span class="line">    map.placeObject(map.getWidth() - <span class="number">5</span>, y, <span class="string">'block'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(x = <span class="number">0</span>; x &lt;= map.getWidth() - <span class="number">5</span>; x++) &#123;</span><br><span class="line">    map.placeObject(x, <span class="number">3</span>, <span class="string">'block'</span>);</span><br><span class="line">    map.placeObject(x, map.getHeight() - <span class="number">3</span>, <span class="string">'block'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Multiplicity"><a href="#Multiplicity" class="headerlink" title="Multiplicity"></a>Multiplicity</h2><p>　　嘛嘛，这是第二关的简化版——直接再搞一个出口就 OK 了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.placeObject(<span class="number">20</span>, <span class="number">10</span>, <span class="string">'exit'</span>);</span><br></pre></td></tr></table></figure><h2 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a>Minesweeper</h2><p>　　这是一个雷区，你不碰雷就好。从代码里面看出来有个 <code>map.setSquareColor</code> 函数可以设置某个格子的颜色。那好办，我们在设置一个地雷后把它用别的颜色标记出来就好了，然后重新执行只要你不是色盲都能安全通过。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.setSquareColor(x, y, <span class="string">"#ff7800"</span>);</span><br></pre></td></tr></table></figure><h2 id="Drones-101"><a href="#Drones-101" class="headerlink" title="Drones 101"></a>Drones 101</h2><p>　　这题大概就是说有个痴汉会跟你靠近，然后把你先奸后杀。</p><p>　　但是痴汉很笨，在他的必经之路用墙堵住他就不会继续动了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.placeObject(<span class="number">30</span>, <span class="number">12</span>, <span class="string">'block'</span>);</span><br><span class="line">map.placeObject(<span class="number">31</span>, <span class="number">11</span>, <span class="string">'block'</span>);</span><br></pre></td></tr></table></figure><h2 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h2><p>　　这个是那个卖相不错的电话机的教学关卡。所以大致的意思是设置了打电话的回调函数即可。ε٩(๑&gt; ₃ &lt;)۶з</p><p>　　分析代码可知，要通过那几个长得跟菊花一样的带色儿的墙你就要跟那个菊花颜色一样。所以电话机的回调函数大致是让你自己变色就好了。</p><p>　　按照顺序所见，如果人是绿色的通过之后要变成红色，然后再变成黄色再绿色。于是写以下的变色过程就可以了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> player = map.getPlayer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = player.getColor();</span><br><span class="line"><span class="keyword">switch</span>(color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"#0f0"</span>:</span><br><span class="line">        player.setColor(<span class="string">"#f00"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"#f00"</span>:</span><br><span class="line">        player.setColor(<span class="string">"#ff0"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"#ff0"</span>:</span><br><span class="line">        player.setColor(<span class="string">"#0f0"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　重新执行捡起电话机，然后通过绿菊花之后按 <code>Q</code> 使用电话机让自己变色儿就好了。</p><blockquote><p>“哎呀，天！他是惦记弟弟了。……可我还不知道呢！那么这是他老人家的狗？很高兴。……你把它带去吧。……这条小狗怪不错的。……挺伶俐。……一口就把这家伙的手指咬破了！哈哈哈哈！……咦，你干吗发抖？呜呜，……呜呜。……它生气了，小坏蛋，……好一条小狗……”</p></blockquote><h2 id="Into-the-Woods"><a href="#Into-the-Woods" class="headerlink" title="Into the Woods"></a>Into the Woods</h2><p>　　森林里面有树和墙，我也懒得想或者写代码了。（明明是自己想不出来#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</p><p>　　总之我是尽可能向出口靠近，然后到死路了赶紧打电话让森林重新生成一遍，如此循环往复直到出口。</p><h2 id="Fording-the-River"><a href="#Fording-the-River" class="headerlink" title="Fording the River"></a>Fording the River</h2><p>　　23333333333333！做这题的时候差点没把自己浏览器卡死。</p><p>　　大致的意思是河的上面有一条船，你直接遇水会死，要上船。但是船貌似不跟你走啊 QAQ。</p><p>　　而且设定写着只能有一条 <code>raft</code>。</p><p>　　咱就来个偷天换日，自己造诺亚方舟铺满整条河（因为懒得计算）。</p><p>　　首先定义诺亚方舟的类型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.defineObject(<span class="string">"noah"</span>, &#123;</span><br><span class="line">    <span class="string">'type'</span>: <span class="string">'dynamic'</span>,</span><br><span class="line">    <span class="string">'symbol'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'#420'</span>,</span><br><span class="line">    <span class="string">'transport'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'behavior'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">me</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　然后呢把它铺满整条大河吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; map.getWidth(); x++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">5</span>; y &lt; <span class="number">15</span>; y++) &#123;</span><br><span class="line">        map.placeObject(x, y, <span class="string">'noah'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一条大河，两岸宽，风吹稻花香两岸。（喂喂喂，小心卡死<em>(┐「ε:)</em></p></blockquote><h2 id="Ambush"><a href="#Ambush" class="headerlink" title="Ambush"></a>Ambush</h2><p>　　后来我去 <code>Untrusted</code> 的 repo 去看题解，发现他们都是去驱使这群痴汉干嘛干嘛。我感觉我的最简单暴力了——直接废了他们。</p><p>　　其实呢只要把碰撞函数重写一遍，这堆痴汉马上就变得人畜无害，你走过去人家还行礼呢233333333333</p><p>　　仔细看一下我们要完成的部分在 <code>behavior</code> 里面，所以在这里面用 <code>this</code> 是妥妥生效的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.onCollision = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>看我碎蛋大粉拳！（忽然觉得下身一阵疼痛  |Д`)ノ⌒●～*</p></blockquote><h2 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h2><p>　　你走一步机器人走一步，也是教学关卡。</p><p>　　机器人能往下走就往下走，能往右走就往右走就拿到钥匙了，最后你再追上机器人把钥匙抢过来就好了。因为机器人是可以穿过紫翔色的那扇门的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(me.canMove(<span class="string">"down"</span>)) me.move(<span class="string">"down"</span>);</span><br><span class="line"><span class="keyword">else</span> me.move(<span class="string">"right"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>站住，保护费。你不装 X 我们还是好朋友。</p></blockquote><h2 id="Robot-Nav"><a href="#Robot-Nav" class="headerlink" title="Robot Nav"></a>Robot Nav</h2><p>　　我居然无聊到自己把路线数出来了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> road = <span class="string">"ddddrrrrrrrrrrrrrrrrrrrrrrrrrrrrrruurrrrrrrrrrrrrrrrrddddddd"</span>;</span><br><span class="line"><span class="keyword">this</span>.cur = <span class="keyword">this</span>.cur === <span class="literal">undefined</span> ? <span class="number">0</span> : (<span class="keyword">this</span>.cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.cur &gt;= road.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"d"</span>) me.move(<span class="string">"down"</span>);</span><br><span class="line"><span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"r"</span>) me.move(<span class="string">"right"</span>);</span><br><span class="line"><span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"u"</span>) me.move(<span class="string">"up"</span>);</span><br></pre></td></tr></table></figure><h2 id="Robot-Maze"><a href="#Robot-Maze" class="headerlink" title="Robot Maze"></a>Robot Maze</h2><p>　　好吧作者早就想到了有人会无聊地去数。</p><p>　　嘛嘛，就如作者所愿写个最基础的 DFS 了事吧。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> direct = &#123;</span><br><span class="line">    <span class="string">"d"</span>: <span class="string">"down"</span>,</span><br><span class="line">    <span class="string">"u"</span>: <span class="string">"up"</span>,</span><br><span class="line">    <span class="string">"l"</span>: <span class="string">"left"</span>,</span><br><span class="line">    <span class="string">"r"</span>: <span class="string">"right"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs...</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">undefined</span> === <span class="keyword">this</span>.dfs) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">this</span>.step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vis = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        vis.push([]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) vis[i].push(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dir = [</span><br><span class="line">        [ <span class="number">0</span>, <span class="number">-1</span>, <span class="string">"u"</span>, <span class="string">"#f00"</span> ],</span><br><span class="line">        [ <span class="number">0</span>, <span class="number">1</span>, <span class="string">"d"</span>, <span class="string">"#0f0"</span> ],</span><br><span class="line">        [ <span class="number">-1</span>, <span class="number">0</span>, <span class="string">"l"</span>, <span class="string">"#00f"</span> ],</span><br><span class="line">        [ <span class="number">1</span>, <span class="number">0</span>, <span class="string">"r"</span>, <span class="string">"#fff"</span> ]</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x === map.getWidth() - <span class="number">2</span> &amp;&amp; y === <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[y][x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> newx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> newy = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(newx &lt; <span class="number">0</span> || newy &lt; <span class="number">0</span> ||</span><br><span class="line">                newx &gt;= map.getWidth() ||</span><br><span class="line">                newy &gt;= map.getHeight() ||</span><br><span class="line">                vis[newy][newx] ||</span><br><span class="line">                map.getObjectTypeAt(newx, newy) === <span class="string">"block"</span></span><br><span class="line">                ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> oldans = <span class="keyword">this</span>.ans;</span><br><span class="line">            <span class="keyword">this</span>.ans += dir[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.dfs(newx, newy)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.ans = oldans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.setSquareColor(x, y, dir[i][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.ans += <span class="string">"dd"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.step &gt;= <span class="keyword">this</span>.ans.length) <span class="keyword">return</span>;</span><br><span class="line">me.move(direct[<span class="keyword">this</span>.ans[<span class="keyword">this</span>.step++]]);</span><br></pre></td></tr></table></figure><blockquote><p>红魔馆的地下室一样呢。反正是机器人多走几步路没事，没必要用 BFS 求最优解2333333333</p></blockquote><h2 id="Crisps-Contest"><a href="#Crisps-Contest" class="headerlink" title="Crisps Contest"></a>Crisps Contest</h2><p>　　刚才那仨 2B 机器人引领你拿到了仨颜色的钥匙在这边派上用场了。</p><p>　　钻红菊花你需要有红钥匙，并且用了之后会少掉。其它颜色也一样。最终你要拿到 <code>A</code> 所代表的 <code>theAlgorithm</code> 走到出口。</p><blockquote><p>等等！啊咧？绿钥匙的通过判定有个地方可以修改？就是你通过绿菊花的时候需要有绿钥匙并且你可以选择你丢弃的东西。丢什么好呢？电脑？不行不行，过关还靠它呢。电话机？以后肯定要用到。其它颜色钥匙？那你肯定会被锁在某个地方出不来。那就只有丢弃 <code>theAlgorithm</code> 了——反正只要拿到 <code>theAlgorithm</code> 之后不再通过绿菊花就没事了。</p></blockquote><p>　　于是只要把绿菊花的通过判断函数里面可修改的区域改成 <code>theAlgorithm</code> 就好了。</p><p>　　最后走的顺序大概是：</p><blockquote><p>进左上角的门拿到<span style="color: yellow;">黄药屎</span>和<span style="color: blue;">蓝药屎</span>出来。然后右上角把<span style="color: red;"><strong>红</strong></span>和<span style="color: blue;"><strong>蓝</strong></span>拿出来。然后向下直捣黄龙，左黄菊花进拿到 <code>theAlgorithm</code> 蓝菊花通过拿到<span style="color: yellow;">黄药屎</span>然后再黄菊花出。</p><p>大功告成！走向胜利的出口吧！</p><p><strong>自古红蓝出 CP！</strong></p></blockquote><h2 id="Exceptional-Crossing"><a href="#Exceptional-Crossing" class="headerlink" title="Exceptional Crossing"></a>Exceptional Crossing</h2><p>　　又是过河啊，这次你只能是死了，因为你的编辑区域只有在 <code>player.killedBy()</code> 里面。</p><blockquote><p>《订制死神》：这个时候让死神笑就可以了。</p></blockquote><p>　　让我们一起来玩坏它吧！在里面填上 <code>) = (0</code> 就好了。什么什么看不懂？你填进去看一下整句话就知道了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">player.killedBy() = (<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>　　然后死神就会被你玩坏了。你走过去的时候这句话执行出错了2333333</p><h2 id="Lasers"><a href="#Lasers" class="headerlink" title="Lasers"></a>Lasers</h2><p>　　有很多隐藏线，你人必须要跟隐藏线的颜色一致才能通过，然后目前所有线都用白色给画出来。</p><p>　　目测作者的意思是让你把硬编码的白色改成隐藏线的颜色，这样就能把线的颜色给标记出来，然后再给电话机写个函数就是让你自己的人变色。</p><p>　　不过我还是用了个 Hack 的方法——</p><p>　　第一条线他要画就画，咱不碰它就好了，只不过在第一条线画完的后面我们把这个画线函数给 Hack 掉：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using canvas to draw the line</span></span><br><span class="line"><span class="keyword">var</span> ctx = map.getCanvasContext();</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.strokeStyle = <span class="string">'white'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.moveTo(x1, y1);</span><br><span class="line">ctx.lineTo(x2, y2);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">createLaser = abc;</span><br></pre></td></tr></table></figure><p>　　接下去是在第二片区域写下自己的画线函数吧，这题最下方检测了线的数量不能少于 25 条。么事，爷高兴画 100 条都么问题，因为我都把它缩在左上角了 2333333</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        map.createLine([<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//... Ahahaha</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ctx = map.getCanvasContext();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">        ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">        ctx.moveTo(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>　　有好多传送门，每次执行随机生成传送位置，有些传送门会把你传到二小姐的地下室然后被吃掉。</p><p>　　我也懒得多动脑筋或者画线什么的，直接对两个都是传送门的 CP 标记一样的随机颜色就好了，最后跟着颜色走到出口去（有个坑就是有时候这个地图本身就是死局，所以得多试几次重新执行 இдஇ</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line"><span class="keyword">if</span>(t1.getType() === <span class="string">"teleporter"</span> &amp;&amp; t2.getType() === <span class="string">"teleporter"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"#"</span> + dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +</span><br><span class="line">        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +</span><br><span class="line">        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)];</span><br><span class="line"></span><br><span class="line">    map.setSquareColor(t1.getX(), t1.getY(), color);</span><br><span class="line">    map.setSquareColor(t2.getX(), t2.getY(), color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Super-Dr-Eval-Bros"><a href="#Super-Dr-Eval-Bros" class="headerlink" title="Super Dr. Eval Bros"></a>Super Dr. Eval Bros</h2><p>　　好吧本意是让你设置一个 <code>timer</code> 然后一直跳啊跳的。</p><p>　　不过呢，定一个新方块给自己搭一座桥就是了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.defineObject(<span class="string">"❤"</span>, &#123;</span><br><span class="line">    <span class="attr">impassable</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">symbol</span>: <span class="string">"❤"</span></span><br><span class="line">&#125;);</span><br><span class="line">map.placeObject(<span class="number">20</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">21</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">22</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">23</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">24</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">25</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">26</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">27</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">28</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br><span class="line">map.placeObject(<span class="number">29</span>, <span class="number">12</span>, <span class="string">"❤"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>你只要打个电话桥就会出现的。</p></blockquote><h2 id="Document-Object-Madness"><a href="#Document-Object-Madness" class="headerlink" title="Document Object Madness"></a>Document Object Madness</h2><p>　　好神奇！好奇葩！我键盘 <code>hjkl</code> 乱按一通就过了。</p><h2 id="Boss-Fight"><a href="#Boss-Fight" class="headerlink" title="Boss Fight"></a>Boss Fight</h2><p>　　打 Boss 了。</p><p>　　好吧我承认我 Cheat 了——原谅我用了 <code>console.log</code>。</p><blockquote><p>因为当我打开控制台的时候下面的语句出现在我的眼里：</p><blockquote><p><strong><em>If you can read this, you are cheating!</em></strong></p><p><strong><em>But really, you don’t need this console to play the game. Walk around using arrow keys (or Vim keys), and pick up the computer (⌘). Then the fun begins!</em></strong></p></blockquote></blockquote><p>　　嘛嘛，无论如何，过关了就好。</p><p>　　这题呢是要让所有的 <code>boss</code> 给毁灭掉即可—— 当所有的 <code>boss</code> 毁灭之后会爆出任务道具 <code>theAlgorithm</code> 然后就能通关了。</p><p>　　后来我发现可以让子弹消灭 <code>boss</code>。但是我当时没这么做。</p><p>　　我先弄了堵墙把子弹挡住先：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.defineObject(<span class="string">"保命的"</span>, &#123;</span><br><span class="line">    <span class="attr">impassable</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">symbol</span>: <span class="string">"❤"</span>,</span><br><span class="line">    <span class="attr">onCollision</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; map.getWidth(); i++) &#123;</span><br><span class="line">    map.placeObject(i, <span class="number">9</span>, <span class="string">"保命的"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这下你就能捡到电话机了——然后给电话机写回调函数。</p><p>　　怎么说呢，当你每用一次电话机，我就把当前存在于屏幕的 <code>boss</code> 和 <code>bullet</code> 给分开罗列，然后把 <code>boss</code> 的 <code>_destroy</code>（警察叔叔，就是这个函数是我 <code>console.log</code> 出来的）给嫁接到 <code>bullet</code> 的 <code>_destroy</code> 去。</p><p>　　这样会出现什么样的结果呢？——当子弹碰到墙的时候就会销毁，这个时候会触发 <code>_destroy</code> 函数，但是这个时候的 <code>_destroy</code> 函数已经会变成了 <code>boss</code> 的了，也就是说这个时候子弹不会被销毁反而是某一个 <code>boss</code> 的 <code>_destroy</code> 函数被调用然后被销毁了。</p><p>　　再怎么说这都是 Hack 的办法，所以并不会触发 <code>boss</code> 的 <code>onDestroy</code> 函数也就是说即使所有 <code>boss</code> 都没了也不会出现 <code>theAlgorithm</code> 这玩意儿。</p><blockquote><p>自己动手丰衣足食！</p></blockquote><p>　　敌人不给我们我们就自己造呗！反正通关判定是——<code>boss</code> 数量为 <code>0</code> 且你有 <code>theAlgorithm</code> 这个道具。</p><p>　　所以说当所有 <code>boss</code> 都被销毁之后，我们自己去 <code>map.replaceObject</code> 一个 <code>theAlgorithm</code> 道具即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.getPlayer().setPhoneCallback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bosses = [];</span><br><span class="line">    <span class="keyword">var</span> bullets = [];</span><br><span class="line">    <span class="keyword">var</span> objects = map.getDynamicObjects();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(objects[i].getType() == <span class="string">"boss"</span>) &#123;</span><br><span class="line">            bosses.push(objects[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bullets.push(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(bosses.length, bullets.length); i++) &#123;</span><br><span class="line">        bullets[i]._destroy = bosses[i]._destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bosses.length === <span class="number">0</span>) &#123;</span><br><span class="line">        map.placeObject(map.getPlayer().getX(), map.getPlayer().getY() + <span class="number">1</span>,</span><br><span class="line">            <span class="string">'theAlgorithm'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　以上代码写完后就开始打 <code>boss</code> 吧！赶紧去拿到电话机，然后你会发现打一个电话 <code>boss</code> 就少一堆，那感觉倍爽儿！</p><h2 id="End-of-the-Line"><a href="#End-of-the-Line" class="headerlink" title="End of the Line"></a>End of the Line</h2><p>　　马上要通关了。这里是个坑，开始我还以为这里就是真·通关了 QAQ。</p><p>　　随后看看后面还是有关卡啊。但是我突然发现 <code>&lt;ctrl+0&gt;</code> 跳出来的 menu 左边多出了文件夹！然后进去随意翻看了。</p><p>　　最后发现原来是要修改 <code>scripts/objects.js</code> 文件→＿→。</p><p>　　好吧，分析通关验证来看，这一关的 <code>map.finalLevel</code> 为 <code>true</code>。所以我们只需要把 <code>scripts/objects.js</code> 文件里面的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!game.map.finalLevel) &#123;</span><br><span class="line">    game._moveToNextLevel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给改成如果是 <code>finalLevel</code> 就跑到下一关去就可以了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(game.map.finalLevel) &#123;</span><br><span class="line">    game._moveToNextLevel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>　　由于事先文章结构没有写好，就接这关的坑位来小结吧 0. 0。（反正人家只是序幕章了</p><p>　　好的，其实也什么总结的，但是总觉得得有这么个小结才对。</p><p>　　找工作啊找工作——有想要我的请联系我 2333333333</p><p>　　联系资料在 <a href="http://xcoder.in/curriculumvitae/">CV</a> 里面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;http://alexnisnevich.github.io/untrusted/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Trusted&lt;/a&gt; 是一个代码解谜游戏，用 Javascript 来过关的。&lt;/p&gt;
&lt;p&gt;　　昨天
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://xcoder.in/tags/Javascript/"/>
    
      <category term="untrusted" scheme="https://xcoder.in/tags/untrusted/"/>
    
      <category term="游戏" scheme="https://xcoder.in/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x 3.1.1 开发环境搭建（Win篇）</title>
    <link href="https://xcoder.in/2014/06/07/cocos2d-311-setup/"/>
    <id>https://xcoder.in/2014/06/07/cocos2d-311-setup/</id>
    <published>2014-06-07T11:34:02.000Z</published>
    <updated>2017-12-11T07:59:20.465Z</updated>
    
    <content type="html"><![CDATA[<p>　　由于偷懒，所以在此感谢 Etond 的指导（喂喂喂，明明是自己懒得看文档，明明 <a href="README"><code>READEME.md</code></a> 里面就有！(´≖◞౪◟≖)</p><p>　　另，在搭建环境的时候，最好保证你在<span style="background: #222;">墙外</span>。以及我默认觉得大家已经有了 <code>Python</code> 环境和 <code>JDK</code>。</p><h2 id="前驱工作"><a href="#前驱工作" class="headerlink" title="前驱工作"></a>前驱工作</h2><p>　　先去 <a href="http://www.cocos2d-x.org/download" target="_blank" rel="external">cocos2d-x 官网</a>下压缩包，放到一个只有神知道的世界里面。</p><p>　　接下去需要安装仨东西：</p><h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>　　<a href="http://developer.android.com/sdk/index.html#download" target="_blank" rel="external">这东西</a>真尼玛大啊！我家的小水管真吃不起。</p><p>　　然后把 <strong>adt-bundle-…zip</strong> 这个包压缩到任意木有中文和空格的路径下面。</p><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>　　<a href="http://developer.android.com/tools/sdk/ndk/index.html#download" target="_blank" rel="external">这小伙伴</a>也不小啊。都是 500M 的主儿啊（٩(ŏ﹏ŏ、)۶</p><p>　　也解压到一个地方不用管它。</p><h3 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h3><p>　　据说这货是阿帕奇出的？总之下载地址在<a href="http://ant.apache.org/bindownload.cgi" target="_blank" rel="external">这里</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>　　哦对了你还得有个 Python 路径，这里就不累述了。接下去在命令行里面执行 Cocos2d 的 <code>setup.py</code> 文件即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/&gt; py setup.py</span><br></pre></td></tr></table></figure><p>　　接下去终端会停在下面一行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Please enter the path of NDK_ROOT (or press Enter to skip):</span><br></pre></td></tr></table></figure><p>　　在后面输入你放好的 NDK 目录即可。</p><p>　　如果下面又出现了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Please enter the path of ANDROID_SDK_ROOT (or press Enter to skip):</span><br></pre></td></tr></table></figure><p>　　你只需在里面输入你刚放好的 Android SDK 的目录即可。（注意是要刚才的 SDK 压缩包解压出来的 sdk 路径）</p><p>　　再如果下面还出现：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Please enter the path of ANT_ROOT (or press Enter to skip):</span><br></pre></td></tr></table></figure><p>　　那么再把 Ant 的路径搞上去就好了。（又得注意这里得是 Ant 的 bin 目录）</p><p>　　最后确保终端（或者说命令行）里面出现如下字样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Please restart the terminal or restart computer to make added system variables take effect</span><br></pre></td></tr></table></figure><p>　　然后你把终端关了再开一个就好了。至此，大致就安装完毕了。</p><h2 id="新建一个-Demo-项目"><a href="#新建一个-Demo-项目" class="headerlink" title="新建一个 Demo 项目"></a>新建一个 Demo 项目</h2><p>　　随意跑到一个目录下面执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/&gt; cocos new FirstGame -p in.xcoder.firstgame -l cpp -d FirstGame</span><br></pre></td></tr></table></figure><blockquote><p>大致意思就是说创建一个新的项目路径，叫 <code>FirstGame</code>，其包名叫 <code>in.xcoder.firstgame</code>，然后语言是 <code>cpp</code>，最后 <code>-d</code> 是路径。</p></blockquote><p>　　命令详情帮助可以看 <code>cocos --help</code>。</p><h3 id="编译-Demo"><a href="#编译-Demo" class="headerlink" title="编译 Demo"></a>编译 Demo</h3><p>　　读标题，是 Win 篇。所以我们跑到项目路径下面的 <code>proj.win32</code> 目录下面用 M$ VS 打开 <code>FirstGame.sln</code> 就可以打开刚创建的模板项目了。</p><p>　　无论如何先编译看看吧！～</p><p>　　如何？跑起来了吧？</p><h3 id="打包-Demo"><a href="#打包-Demo" class="headerlink" title="打包 Demo"></a>打包 Demo</h3><p>　　这里就讲讲如何打包安卓的版本吧：</p><h4 id="Debug-版本"><a href="#Debug-版本" class="headerlink" title="Debug 版本"></a>Debug 版本</h4><p>　　跑到你的项目目录下面（即有 <code>.cocos-project.json</code> 文件的目录），然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/&gt; cocos run -p android</span><br></pre></td></tr></table></figure><p>　　等工具编译打包完成就 OK 了。（记得要查安卓手机并且调试模式哦～）</p><h4 id="Release-版本"><a href="#Release-版本" class="headerlink" title="Release 版本"></a>Release 版本</h4><p>　　如果要上传到 Google Play 之类的地方，需要有签名。所以发布 Release 版本之前，你先得搞好自己的签名。</p><h5 id="Keytool"><a href="#Keytool" class="headerlink" title="Keytool"></a>Keytool</h5><p>　　在终端跑到你的项目路径下面，然后执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/&gt; keytool -genkey -v -keystore FirstGame.keystore -alias FirstGame -keyalg RSA -keysize 2048 -validaty 10000</span><br></pre></td></tr></table></figure><p>　　照着命令行给的提示完成创建密钥即可。</p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>　　生成之后啊就直接执行编译命令了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/&gt; cocos run -p android -m release</span><br></pre></td></tr></table></figure><p>　　在里面呢最后会让你输入 <code>.keystore</code> 文件的路径。</p><p>　　我们输入相对路径，由于我们刚才把这个文件搞在项目根目录，所以我们只需要输入 <code>../FirstGame.keystore</code> 即可。接下去他会让你输入密码、别名和别名信息的密码。你都正确输入一遍他就会安安分分跑在你的手机里面了。</p><h4 id="仨版本的文件路径"><a href="#仨版本的文件路径" class="headerlink" title="仨版本的文件路径"></a>仨版本的文件路径</h4><p>　　上面都弄好之后，你的仨版本 <code>*.apk</code> 文件也就生成了。很多人可能很困惑，为什么是仨版本。因为其中 Release 版本还分带签名和没签名版本。</p><p>　　总之那个路径在 <code>publish/android</code> 下面，里面有仨 <code>*.apk</code> 文件，你拿出来发布就可以了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　其实也没什么结不结的，这些东西你们自己去看看官方文档就好了。总之就这样了吧，以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　由于偷懒，所以在此感谢 Etond 的指导（喂喂喂，明明是自己懒得看文档，明明 &lt;a href=&quot;README&quot;&gt;&lt;code&gt;READEME.md&lt;/code&gt;&lt;/a&gt; 里面就有！(´≖◞౪◟≖)&lt;/p&gt;
&lt;p&gt;　　另，在搭建环境的时候，最好保证你在&lt;span styl
      
    
    </summary>
    
      <category term="游戏开发" scheme="https://xcoder.in/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="cocos2d" scheme="https://xcoder.in/tags/cocos2d/"/>
    
  </entry>
  
  <entry>
    <title>【转】TCP 的那些事儿（上）</title>
    <link href="https://xcoder.in/2014/06/07/tcp-those-things-1/"/>
    <id>https://xcoder.in/2014/06/07/tcp-those-things-1/</id>
    <published>2014-06-06T17:47:10.000Z</published>
    <updated>2017-12-11T07:59:20.543Z</updated>
    
    <content type="html"><![CDATA[<p>　　TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习 TCP 本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于 TCP 这个协议的细节，我还是推荐你去看 <a href="http://www.kohala.com/start/" target="_blank" rel="external">W.Richard Stevens</a> 的《<a href="http://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下 <a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a> 以及后面 N 多的 RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p><p>　　之所以想写这篇文章，目的有三个，</p><ul><li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li><li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li><li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li></ul><p>　　所以，本文不会面面俱到，只是对 TCP 协议、算法和原理的科普。</p><p>　　我本来只想写一个篇幅的文章的，但是 TCP 真 TMD 的复杂，比 C++ 复杂多了，这 30 多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p><ul><li>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。</li><li>下篇中，重点介绍TCP的流迭、拥塞处理。</li></ul><p>　　废话少说，首先，我们需要知道 TCP 在网络 OSI 的七层模型中的第四层 —— 传输层(Transport)，IP 在第三层 —— 网络层(Network)，ARP 在第二层 —— 数据链路层(Data Link)，在第二层上的数据，我们叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。</p><p>　　首先，我们需要知道，我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p><h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p>　　接下来，我们来看一下 TCP 头的格式</p><p><img src="TCP-Header-01.jpg" alt="TCP 头格式 1"></p><center>TCP 头格式 1（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank" rel="external">图片来源</a>）</center><p>　　你需要注意这么几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（<code>src_ip</code>, <code>src_port</code>, <code>dst_ip</code>, <code>dst_port</code>）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong><em>Sequence Number</em></strong> 是包的序号，用来<strong>解决网络包乱序（reordering）问题</strong>。</li><li><strong><em>Acknowledgement Number</em></strong> 就是 ACK —— 用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong><em>Window</em></strong> 又叫 <strong><em>Advertised-Window</em></strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong><em>TCP Flag</em></strong> ，也就是包的类型，主要是<strong>用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><p>　　关于其它的东西，可以参看下面的图示</p><p><img src="TCP-Header-02.jpg" alt="TCP 头格式 2"></p><center>TCP 头格式 2（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank" rel="external">图片来源</a>）</center><h2 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h2><p>　　其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。</p><p>　　下面是：“<strong>TCP 协议的状态机</strong>”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank" rel="external">图片来源</a>） 和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以 TCP 协议其实也挺坑爹的）</p><p><img src="tcpfsm.png" alt="TCP 协议的状态机"> <img src="tcp_open_close.jpg" alt="握手次数"></p><p>　　很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p><ul><li><strong>对于建链接的 3 次握手</strong>，主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number） —— 所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li><li><strong>对于 4 次挥手</strong>，其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达T IME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li></ul><p><img src="tcpclosesimul.png" alt="两端同时断开链接"></p><center>两端同时断开链接（<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm" target="_blank" rel="external">图片来源</a>）</center><p>　　另外，有几个事情需要注意一下：</p><ul><li><strong>关于建连接时 SYN 超时</strong>。试想一下，如果 server 端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的 ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。在 Linux 下，默认重试次数为 5 次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 - 1 = 63s，TCP 才会把断开这个连接。</li><li><strong>关于 SYN Flood 攻击</strong>。一些恶意的人就为此制造了 SYN Flood 攻击 —— 给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫 <code>tcp_syncookies</code> 的参数来应对这个事 —— 当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，请先千万别用 <code>tcp_syncookies</code> 来处理正常的大负载的连接的情况。因为，<code>synccookies</code> 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：<code>tcp_synack_retries</code> 可以用他来减少重试次数；第二个是：<code>tcp_max_syn_backlog</code>，可以增大 SYN 连接数；第三个是：<code>tcp_abort_on_overflow</code> 处理不过来干脆就直接拒绝连接了。</li><li><strong>关于 ISN 的初始化</strong>。ISN 是不能 hard code 的，不然会出问题的 —— 比如：如果连接建好后始终用 1 来做 ISN，如果 client 发了 30 个 segment 过去，但是网络断了，于是 client 重连，又用了 1 做 ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client 的 Sequence Number 可能是 3，而 Server 端认为 client 端的这个号是 30 了。全乱了。RFC793 中说，ISN 会和一个假的时钟绑在一起，这个时钟会在每4微秒对 ISN 做加一操作，直到超过 2^32，又从 0 开始。这样，一个ISN的周期大约是 4.55 个小时。因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过 Maximum Segment Lifetime（缩写为 MSL - Wikipedia 语条），所以，只要 MSL 的值小于 4.55 小时，那么，我们就不会重用到 ISN。</li><li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的 ISN 的描述，相信你也知道 MSL 是怎么来的了。我们注意到，在 TCP 的状态图中，从 TIME_WAIT 状态到 CLOSED 状态，有一个超时设置，这个超时设置是 2 * MSL（RFC793 定义了 MSL 为 2 分钟，Linux 设置成了 30s）为什么要这有 TIME_WAIT？为什么不直接给转成 CLOSED 状态呢？主要有两个原因：<ol><li>TIME_WAIT 确保有足够的时间让对端收到了 ACK，如果被动关闭的那方没有收到 Ack，就会触发被动端重发 Fin，一来一去正好 2 个MSL；</li><li>有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank" rel="external">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li></ol></li><li><strong>关于 TIME_WAIT 数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT 是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫 <code>tcp_tw_reuse</code>，另一个叫 <code>tcp_tw_recycle</code> 的参数，这两个参数默认值都是被关闭的，后者 recyle 比前者 resue 更为激进，resue 要温柔一些。另外，如果使用 <code>tcp_tw_reuse</code>，必需设置 <code>tcp_timestamps = 1</code>，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑 —— 可能会让 TCP 连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">官方文档</a>上说的一样“<strong><em>It should not be changed without advice/request of technical experts</em></strong>”）。<ol><li><strong>关于 <code>tcp_tw_reuse</code></strong>。官方文档上说 <code>tcp_tw_reuse</code> 加上 <code>tcp_timestamps</code>（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要 <code>tcp_timestamps</code> 在两边都被打开（你可以读一下 <code>tcp_twsk_unique</code> 的源码 ）。我个人估计还是有一些场景会有问题。</li><li><strong>关于 <code>tcp_tw_recycle</code></strong>。如果是 <code>tcp_tw_recycle</code> 被打开了话，会假设对端开启了 <code>tcp_timestamps</code>，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建链接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）（如果你想观摩一下 Linux 的内核代码，请参看源码 <code>tcp_timewait_state_process</code>）。</li><li><strong>关于 <code>tcp_max_tw_buckets</code></strong>。这个是控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗 DDoS 攻击的。也说的默认值 180000 并不小。这个还是需要根据实际情况考虑。</li></ol></li></ul><blockquote><p>Again，使用 <code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 来解决 TIME_WAIT 的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank" rel="external">RFC 1122</a>） 。</p></blockquote><h2 id="数据传输中的-Sequence-Number"><a href="#数据传输中的-Sequence-Number" class="headerlink" title="数据传输中的 Sequence Number"></a>数据传输中的 Sequence Number</h2><p>　　下图是我从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 <code>Statistics -&gt; Flow Graph…</code>）</p><p><img src="tcp_data_seq_num.jpg" alt="数据传输图"></p><p>　　你可以看到，SeqNum 的增加是和传输的字节数相关的。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。</p><blockquote><p><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum —— 相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了。</p></blockquote><h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>　　TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>　　注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>　　一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4 —— 意味着 3 和 4 都收到了。</p><p>　　但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。</p><p>　　对此有两种选择：</p><ul><li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li><li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li></ul><p>　　这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p><h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>　　于是，TCP 引入了一种叫 <strong><em>Fast Retransmit</em></strong> 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。<strong><em>Fast Retransmit</em></strong> 的好处是不用等 timeout 了再重传。</p><p>　　比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack = 2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：</p><p><img src="FASTIncast021.png" alt="快速重传"></p><p>　　Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是重转之前的一个还是重装所有的问题。对于上面的示例来说，是重传 #2 呢还是重传 #2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2) 是谁传回来的？也许发送端发了 20 份数据，是 #6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p><h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>　　另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（参看 <a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="external">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：</p><p><img src="tcp_sack_example-1024x577.jpg" alt="SACK方法"></p><p>　　这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过 <code>tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p><p>　　这里还需要注意一个问题 —— 接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</p><blockquote><p><strong>注意</strong>：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank" rel="external">TCP SACK的性能权衡</a>》</p></blockquote><h3 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h3><p>　　Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2833</a> 里有详细描述和示例。下面举几个例子（来源于 <a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2833</a>）</p><p>　　D-SACK使用了SACK的第一个段来做标志，</p><ul><li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li><li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li></ul><h4 id="示例一：ACK-丢包"><a href="#示例一：ACK-丢包" class="headerlink" title="示例一：ACK 丢包"></a>示例一：ACK 丢包</h4><p>　　下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000 - 3499），于是接收端发现重复收到，于是回了一个 SACK = 3000 - 3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK —— 旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line"></span><br><span class="line">3000-3499    3000-3499   3500 (ACK dropped)</span><br><span class="line">3500-3999    3500-3999   4000 (ACK dropped)</span><br><span class="line">3000-3499    3000-3499   4000, SACK=3000-3500</span><br><span class="line">                                    ---------</span><br></pre></td></tr></table></figure><h4 id="示例二：网络延误"><a href="#示例二：网络延误" class="headerlink" title="示例二：网络延误"></a>示例二：网络延误</h4><p>　　下面的示例中，网络包（1000 - 1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK = 1000 - 1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK —— 标识收到了重复的包。</p><p>　　这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line"> </span><br><span class="line">500-999        500-999     1000</span><br><span class="line">1000-1499      (delayed)</span><br><span class="line">1500-1999      1500-1999   1000, SACK=1500-2000</span><br><span class="line">2000-2499      2000-2499   1000, SACK=1500-2500</span><br><span class="line">2500-2999      2500-2999   1000, SACK=1500-3000</span><br><span class="line">1000-1499      1000-1499   3000</span><br><span class="line">               1000-1499   3000, SACK=1000-1500</span><br><span class="line">                                      ---------</span><br></pre></td></tr></table></figure><p>　　可见，引入了 D-SACK，有这么几个好处：</p><ol><li>可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</li><li>是不是自己的 timeout 太小了，导致重传。</li><li>网络上出现了先发的包后到的情况（又称 reordering）</li><li>网络上是不是把我的数据包给复制了。</li></ol><p>　　<strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。</strong></p><p>　　Linux 下的 <code>tcp_dsack</code> 参数用于开启这个功能（Linux 2.4 后默认打开）</p><p>　　好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《<a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP的那些事（下）</a>》</p><p>　　[原文链接：<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">http://coolshell.cn/articles/11564.html</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习 TCP 本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于 TCP 这个协议的细节，我还是推荐你去看 &lt;a href=&quot;http://www.kohala.co
      
    
    </summary>
    
    
      <category term="TCP" scheme="https://xcoder.in/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>一个任务队列的 module</title>
    <link href="https://xcoder.in/2014/06/03/scartlet-task/"/>
    <id>https://xcoder.in/2014/06/03/scartlet-task/</id>
    <published>2014-06-02T16:17:38.000Z</published>
    <updated>2017-12-11T07:59:20.541Z</updated>
    
    <content type="html"><![CDATA[<p>　　事情很曲折，我某天在萌否收音机里面听到了一首歌，很好听，叫 <code>hypnotized</code>，于是红心了。</p><p>　　过了几天我再去听——发现这首歌变了。</p><p>　　最后经过多方面求证，我大概得出结果就是应该有人传错了歌，然后后来有人重新传了一遍，导致我听的不是原来那首歌了。那我那天听的那首歌到底叫什么名字呢？</p><p>　　然后大致看了一下，虽然歌被重新传了，但是<a href="http://moe.fm/music/9600" target="_blank" rel="external">这里</a>显示的这首歌的时间没变！还是11分钟，目测是数据库没更新。</p><p>　　于是我就想了个笨办法，去爬收音机里面所有 tag 为 <code>东方project</code> 的专辑，然后跑到专辑页看歌曲的长度。</p><p>　　问题来了，如果我直接爬，然后爬完 <code>callback</code> 之后又直接爬，没有任何间隔，就相当于我在 <code>DDOS</code> 它的站子。或者即使没那么严重——反正最后到一定程度并发太大我就访问不了了。</p><p>　　于是我就想到了做一个任务队列的 module。该 module 的作用就是把一堆任务扔到队列中，完成一个才开始下一个。</p><p>　　然后如果同时执行一个也太慢，module 还允许你开多几个子队列同时执行。</p><p>　　模块的 repo 在 <a href="https://github.com/XadillaX/scarlet-task" target="_blank" rel="external">GitHub</a> 上面。名字叫 <code>Scarlet Task</code> 的原因一是我本身就喜欢二小姐，二是为了纪念这次事件我是为了找有关二小姐的歌。</p><p>　　要安装也很简单：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm install scarlet-task</span><br></pre></td></tr></table></figure><p>　　然后 repo 的 <code>README.md</code> 里面有使用方法的——大致就是实例化一个对象，然后定义好某个任务的任务标识（可以是字符串，可以是 json 对象，可以是任何类型的数据），然后再定义好处理这个任务的函数，将这个数据推倒队列中即可。然后在处理函数中任务处理完的时候执行以下任务完成的函数即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　事情很曲折，我某天在萌否收音机里面听到了一首歌，很好听，叫 &lt;code&gt;hypnotized&lt;/code&gt;，于是红心了。&lt;/p&gt;
&lt;p&gt;　　过了几天我再去听——发现这首歌变了。&lt;/p&gt;
&lt;p&gt;　　最后经过多方面求证，我大概得出结果就是应该有人传错了歌，然后后来有人重新传
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="任务队列" scheme="https://xcoder.in/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>搭建 VIM 下的 Hexo 编辑环境</title>
    <link href="https://xcoder.in/2014/06/02/vim-hexo-environment/"/>
    <id>https://xcoder.in/2014/06/02/vim-hexo-environment/</id>
    <published>2014-06-01T20:52:30.000Z</published>
    <updated>2017-12-11T07:59:20.548Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文只讲两个函数，对于 <code>markdown</code> 如何高亮之类的问题还请自行谷歌。</p><p>　　然后请打开你自己的 <code>.vimrc</code> 文件。</p><h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><p>　　首先定义一个变量——你自己的 <code>hexo</code> 目录，如果要跨平台可以做个判断之类的，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if has(&quot;win32&quot;)</span><br><span class="line">    let g:hexoProjectPath=&quot;E:\\cygwin\\home\\XadillaX\\hexo&quot;</span><br><span class="line">else</span><br><span class="line">    let g:hexoProjectPath=&quot;~/hexo/&quot;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h2 id="几个函数"><a href="#几个函数" class="headerlink" title="几个函数"></a>几个函数</h2><h3 id="进入-Hexo-目录"><a href="#进入-Hexo-目录" class="headerlink" title="进入 Hexo 目录"></a>进入 Hexo 目录</h3><p>　　这个函数大致就是让你进入你自己的 <code>Hexo</code> 路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun! OpenHexoProjPath()</span><br><span class="line">    execute &quot;cd &quot; . g:hexoProjectPath</span><br><span class="line">endfun</span><br></pre></td></tr></table></figure><h3 id="打开一篇-Post"><a href="#打开一篇-Post" class="headerlink" title="打开一篇 Post"></a>打开一篇 Post</h3><p>　　接下去就是一个打开 <code>Post</code> 的函数了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function! OpenHexoPost(...)</span><br><span class="line">    call OpenHexoProjPath()</span><br><span class="line"></span><br><span class="line">    let filename = &quot;source/_posts/&quot; . a:1 . &quot;.md&quot;</span><br><span class="line">    execute &quot;e &quot; . filename</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><blockquote><p>解析：上面的代码大意就是进入 Hexo 路径，然后设定好文件名，最后执行 <code>:e filename</code> 即可打开文件了。</p></blockquote><h3 id="新建一篇-Post"><a href="#新建一篇-Post" class="headerlink" title="新建一篇 Post"></a>新建一篇 Post</h3><p>　　新建的流程跟打开相似，只不过首先要在 <code>Hexo</code> 目录下执行一遍 <code>hexo new FOO</code> 的命令而已，命令执行完毕之后再打开即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function! NewHexoPost(...)</span><br><span class="line">    call OpenHexoProjPath()</span><br><span class="line"></span><br><span class="line">    let filename = a:1</span><br><span class="line">    execute &quot;!hexo new &quot; . filename</span><br><span class="line"></span><br><span class="line">    call OpenHexoPost(a:1)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h2 id="指令映射"><a href="#指令映射" class="headerlink" title="指令映射"></a>指令映射</h2><p>　　函数写好后我们最后把函数映射成类似于 <code>:e</code>, <code>:w</code> 之类的后面能跟着参数的指令即可。</p><p>　　以前木有接触过的同学可以参考一下<a href="http://vimdoc.sourceforge.net/htmldoc/usr_40.html#40.2" target="_blank" rel="external">这里</a>的文档。</p><h3 id="打开指令"><a href="#打开指令" class="headerlink" title="打开指令"></a>打开指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command -nargs=+ HexoOpen :call OpenHexoPost(&quot;&lt;args&gt;&quot;)</span><br></pre></td></tr></table></figure><h3 id="新建指令"><a href="#新建指令" class="headerlink" title="新建指令"></a>新建指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command -nargs=+ HexoNew :call NewHexoPost(&quot;&lt;args&gt;&quot;)</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>　　当你做完以上步骤的时候，你就可以无论在什么目录下在 VIM 里面通过下面的指令进行新建一篇日志了：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:HexoNew artical-name</span><br></pre></td></tr></table></figure><p>　　以及下面的指令来打开一篇已存在的日志：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:HexoOpen artical-name</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>　　相信看到这里之后，大家也能自己写出一个生成的指令了，这里就不累述了，无非就是：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:!hexo generate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　本文只讲两个函数，对于 &lt;code&gt;markdown&lt;/code&gt; 如何高亮之类的问题还请自行谷歌。&lt;/p&gt;
&lt;p&gt;　　然后请打开你自己的 &lt;code&gt;.vimrc&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h2 id=&quot;预备工作&quot;&gt;&lt;a href=&quot;#预备工作&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="vim" scheme="https://xcoder.in/tags/vim/"/>
    
      <category term="hexo" scheme="https://xcoder.in/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>「NBUT 2014 校赛·网络同步赛」题解 (未完成...)</title>
    <link href="https://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/"/>
    <id>https://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/</id>
    <published>2014-05-05T07:08:39.000Z</published>
    <updated>2017-12-11T07:59:20.523Z</updated>
    
    <content type="html"><![CDATA[<p>　　这次比赛由 <a href="http://blog.163.com/surgy_han/" target="_blank" rel="external">Hungar</a>，<a href="http://www.cnblogs.com/Wine93/" target="_blank" rel="external">8Mao</a> 以及我负责的。明明都读研了，还诈尸回来出题——归结起来大概是因为各种面试不顺吧，想来虐虐学弟妹们怒刷存在感。结果网络赛还是被虐得死去活来。（果然我是蒟蒻 (◓Д◒)✄╰⋃╯</p><p>　　好了废话不多说，还是直接上题解吧。</p><h2 id="Minecraft-Server-Bug"><a href="#Minecraft-Server-Bug" class="headerlink" title="Minecraft Server Bug"></a>Minecraft Server Bug</h2><p>　　题意大概就是说一排岩浆和水，你要拿一桶水和岩浆，并且水的下标小于岩浆。</p><p>　　为了更便于理解，我们从后往前做。首先将序列读进来之后从后往前遍历——若是岩浆，那么岩浆数加一，如果是水，那么这桶水能选择后面岩浆的任意一桶，也就是说答案加上当前的岩浆数即可。</p><blockquote><p>注意用 <code>__int64</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">1000005</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c%c"</span>, ch + i, &amp;tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        __int64 ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] == <span class="string">'L'</span>) cnt++;</span><br><span class="line">            <span class="keyword">else</span> ans += (__int64)cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Beautiful-Walls"><a href="#Beautiful-Walls" class="headerlink" title="Beautiful Walls"></a>Beautiful Walls</h2><p>　　一堵墙，每单位高度不定。你需要选择其中任意连续的墙，使得你选择的墙每单位的高度都是唯一的——问有多少种选法。</p><p>　　先求出总的种数，然后求不满足的数量，最后用总数减去不满足数即为答案。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">int</span> p[N], A[N];</span><br><span class="line"><span class="function">lint <span class="title">solution</span><span class="params">(lint n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    lint ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>, Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(lint i=<span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(~p[A[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Max &lt; p[A[i]]) Max = p[A[i]];</span><br><span class="line">            p[A[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[A[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans -= Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solution(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　这次比赛由 &lt;a href=&quot;http://blog.163.com/surgy_han/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hungar&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/Wine93/&quot; targe
      
    
    </summary>
    
      <category term="ACM" scheme="https://xcoder.in/categories/ACM/"/>
    
    
      <category term="ACM" scheme="https://xcoder.in/tags/ACM/"/>
    
      <category term="算法" scheme="https://xcoder.in/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>死月出品：Hero Snake 英雄蛇</title>
    <link href="https://xcoder.in/2014/04/11/hero-snake/"/>
    <id>https://xcoder.in/2014/04/11/hero-snake/</id>
    <published>2014-04-11T05:53:35.000Z</published>
    <updated>2017-12-11T07:59:20.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：备份到这篇日志的时候，感觉眼睛进了什么奇怪的东西。（才……才不是眼泪呢，那一定是沙子！(;´༎ຶД༎ຶ`)</p><p>主要引起感伤的还是这首轩辕剑的 BGM 吧。因为 Hero Snake 的BGM就是这个。</p><p>这篇文章原文是在 2011年5月1日 发的。游戏是跟 <strong>MatRush</strong> 在2011年寒假一起写的，虽然是我边教边写的。呵呵，转眼间三年过去了。</p><p>想当年我还是那么执着于游戏行业，现在纠结于到底要从事游戏行业还是互联网呢？半年真的能改变很多，要是我当时没有去汽族网实习，也许现在并不会有那么大的改变吧。</p><p>自从被 <a href="http://weibo.com/shyvo" target="_blank" rel="external">@朴大</a> 刷了之后，我又开始着重考虑了。是不是我玩互联网只是觉得新鲜好玩而已呢？毕竟我是半路出家的，虽然有着十来年的 <code>Web经历</code>，但那都是小打小闹哇。还记得小学的时候买的第一本电脑书——<a href="http://www.amazon.cn/%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6-%E6%9C%B1%E6%83%A0%E5%BC%BA/dp/B0011A9QSA/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1397196202&amp;sr=1-1&amp;keywords=%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6" target="_blank" rel="external">《在网上安个家》</a>，到现在还记得那个时候捧着书的激动心情。</p><p>我是不是有点偏离了自己本身的轨道呢？总之还是在这两块领域犹豫不决。</p><p>废话有点扯远了，还是把文章从 Capture 备份回来再说吧。</p></blockquote><p>　　这是一款正宗基于HGE的小游戏，算是我做的游戏中自己比较满意的小游戏吧。</p><p>　　幕后故事是这样的：MatRush寒假找我一起做游戏，因为他们学校弄了一个蛋疼的游戏制作比赛。然后命题是贪吃蛇，于是我们加了一点自己的小创意，给他讲解了一些HGE的基础之后，就写了这个游戏了。然后因为我们都比较喜欢轩辕剑，于是BGM就是轩辕剑的《永远的三个人的快乐时光》，由于MatRush比较喜欢MapleStory，便有了素材是那些像素画面。</p><p>　　首先这个游戏有两种模式：单人模式和双人模式。</p><p>　　关於单人模式，这是一个闯关型模式，大家在每一关必须通过吃道具获得一定的分数以及吃圈圈获得一定圈圈数才能开启通往下一关的门，默认一共20关，可以自己编辑关卡，这是后话。下面是几种道具的解说：</p><blockquote><p><img src="treasure0.png" alt="开山斧"></p><p>开山斧：捡到这货随机获得1~3个斧头并且附赠100分数。斧头的作用是能破开木桶，安全通过，一个斧头用一次。斧头数在左下角的Axe(s)后面。</p><p><img src="treasure1.png" alt="命运之剪"></p><p>命运之剪：捡到这个之后获得100分并且给你断掉一个尾巴以降低难度。</p><p><img src="treasure2.png" alt="降速器"></p><p>降速器：因为你每吃一个圈圈会增加一定速度，而这个降速器是降低你的速度让你容易些。并且附赠100分。</p><p><img src="treasure8.png" alt="药水"></p><p>药水：药水是装饰变色用的，其实是送分的。前四种药水100分，紫色的300分。</p><p><img src="treasure3.png" alt="降速器"></p><p>骷髅头：想死的话就碰碰它试试。</p><p><img src="door.png" alt="传送门"></p><p>传送门：遇到这货就说明你功德圆满了。恭喜，可以通过它前往下一关。</p></blockquote><p>　　接下去是双人模式。双人模式因为当初设想有些问题，所以实现起来仅仅是简单的双人走啊走，看谁碰到谁谁就输。在双人模式中，先要选择一张对战地图，然后开始双人走啊走啊走。</p><p>　　然后Rank是排行榜，Option是游戏的一些选项，Introduction是游戏介绍，这个介绍有些蛋疼，最后不用说Exit就是退出了。</p><p>　　下面是关于地图编辑器的说明：</p><p>　　首先在游戏目录小有一个config.ini文件，是一些游戏设置。其中levelnum是游戏关卡数。注意这个数字必须要跟地图数量一致或者小于它，否则会因为找不到之后的地图而出错。地图就存在data里，命名方式是mapX.txt，从0开始。地图编辑器则在MapEditor文件夹下。操作很简单，说明都在编辑器下方的文字上，就几个快捷键。可以用鼠标操作也可以用上下左右控制方向。</p><p>　　最后，预祝大家玩得愉快。附上下载地址和几张预览图吧：</p><p>　　<a href="bin.7z">点击下载</a></p><p>　　<a href="https://github.com/XadillaX/hero-snake" target="_blank" rel="external">代码地址</a></p><p><img src="1.png" alt="标题画面"><br><img src="2.png" alt="玩的画面"><br><img src="4.png" alt="双人模式"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注：备份到这篇日志的时候，感觉眼睛进了什么奇怪的东西。（才……才不是眼泪呢，那一定是沙子！(;´༎ຶД༎ຶ`)&lt;/p&gt;
&lt;p&gt;主要引起感伤的还是这首轩辕剑的 BGM 吧。因为 Hero Snake 的BGM就是这个。&lt;/p&gt;
&lt;p&gt;这篇文章原文是在
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="HGE" scheme="https://xcoder.in/tags/HGE/"/>
    
      <category term="游戏开发" scheme="https://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>让Node.js和C++一起搞基 —— 3 (未完成...)</title>
    <link href="https://xcoder.in/2014/04/06/nodejs-cpp-addons-3/"/>
    <id>https://xcoder.in/2014/04/06/nodejs-cpp-addons-3/</id>
    <published>2014-04-06T08:15:39.000Z</published>
    <updated>2017-12-11T07:59:20.527Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="/2014/04/03/nodejs-cpp-addons-2/">上一章</a>我们偷偷学习了如何在 <code>C++</code> 中实现 <code>Node.js</code> 调用时传参数和调用回调函数，并且我自己也心血来潮写了个<a href="/2014/04/05/cpp-class-inline-keng/#simpleini">小 Demo</a> 供大家参考。</p><p>　　今天我们就不复习了，直捣黄龙吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;/2014/04/03/nodejs-cpp-addons-2/&quot;&gt;上一章&lt;/a&gt;我们偷偷学习了如何在 &lt;code&gt;C++&lt;/code&gt; 中实现 &lt;code&gt;Node.js&lt;/code&gt; 调用时传参数和调用回调函数，并且我自己也心血来潮写了个&lt;a hr
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中类成员函数 inline 的坑</title>
    <link href="https://xcoder.in/2014/04/05/cpp-class-inline-keng/"/>
    <id>https://xcoder.in/2014/04/05/cpp-class-inline-keng/</id>
    <published>2014-04-05T08:55:57.000Z</published>
    <updated>2017-12-11T07:59:20.466Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天我来讲一讲 <code>C++</code> 中类成员函数 <code>inline</code> 修饰符的一个坑。</p><p>　　这个坑是我在尝试着写我的第一个 <code>Node.js</code> 扩展 <code>simpleini</code> 时候遇到的。</p><h2 id="坑描述"><a href="#坑描述" class="headerlink" title="坑描述"></a>坑描述</h2><p>　　因为只是尝试着写，所以懒得自己实现，于是网上找了个开源的 <code>C++</code> 阅读 ini 文件的项目，名不见经传，叫 <a href="http://miniini.tuxfamily.org/" target="_blank" rel="external">miniini</a>。</p><p>　　好了，问题来了，当我写好我的源文件的时候，然后写好了我的 <code>binding.gyp</code> ，总之一切大功告成开始编译的时候—— <code>Windows</code> 下没问题，<code>MacOS</code> 下也可以正常运行，但是在 <code>Linux</code> 下就出问题了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node: symbol lookup err: .../simpleIni.node: undefined symbol: _ZNK10INISection10ReadStringEPKcRS1_</span><br></pre></td></tr></table></figure><p>　　大致的意思呢就是说找不到 <code>INISection</code> 的 <code>ReadString</code> 函数符号。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>　　又是怀着崇敬的心情去 <a href="http://stackoverflow.com/questions/22868307/undefined-symbol-in-node-js-c-addon-under-linux-why" target="_blank" rel="external">SO</a> 求解了。</p><p>　　最后的解答大概<a href="http://isocpp.org/wiki/faq/inline-functions#inline-member-fns" target="_blank" rel="external">如下</a>：</p><blockquote><p>内联成员函数的声明看起来像一个非内联函数的声明：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但是你的内敛成员函数定义前面又加了 <code>inline</code> 这个关键字时，你必须把这个定义放到头文件中：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">void</span> Fred::f(<span class="keyword">int</span> i, <span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么做的原因就是为了避免链接器 <code>unresolved external</code> 的发生。如果你不这么做，这个错误就将会在你从另外一个 <code>.cpp</code> 文件中调用它时出现。</p></blockquote><p>　　好嘛，原来是原作者自己写的代码有问题啊。但是不得不说一下又涨姿势了。C++还真是有千奇百怪的坑和错误啊。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>　　最后的解决方案大致就是把函数定义放到头文件中去，或者在函数声明前面也加上 <code>inline</code> 关键字。</p><h2 id="simpleini"><a href="#simpleini" class="headerlink" title="simpleini"></a>simpleini</h2><p>　　我的第一个 <code>C++</code> 模块，叫 <code>simpleini</code> ，其实只是抱着试试看 <code>Node.j</code> 的 <code>C++</code> 模块是不是这么写的而已，并没有多大实际用处。Repo 在 <a href="https://github.com/XadillaX/node-simple-ini" target="_blank" rel="external">Github</a> 上。</p><p>　　然后用法很简单，先安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install simpleini</span><br></pre></td></tr></table></figure><p>　　然后下面的代码就是例子了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simpleIni = <span class="built_in">require</span>(<span class="string">"simpleini"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(simpleIni.open(<span class="string">"./node_modules/simpleini/src/miniini-0.9/test/test.ini"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(simpleIni.read(<span class="string">"SETTINGS"</span>, <span class="string">"sections"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(simpleIni.read(<span class="string">"vals"</span>, <span class="string">"float"</span>));</span><br></pre></td></tr></table></figure><p>　　读取配置的时候第一个参数是 <code>Section</code>，第二个参数是 <code>Key</code>，第三个参数是取不到该值时的默认值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　今天我来讲一讲 &lt;code&gt;C++&lt;/code&gt; 中类成员函数 &lt;code&gt;inline&lt;/code&gt; 修饰符的一个坑。&lt;/p&gt;
&lt;p&gt;　　这个坑是我在尝试着写我的第一个 &lt;code&gt;Node.js&lt;/code&gt; 扩展 &lt;code&gt;simpleini&lt;/code&gt; 时候
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="Programming" scheme="https://xcoder.in/tags/Programming/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>让Node.js和C++一起搞基 —— 2</title>
    <link href="https://xcoder.in/2014/04/03/nodejs-cpp-addons-2/"/>
    <id>https://xcoder.in/2014/04/03/nodejs-cpp-addons-2/</id>
    <published>2014-04-03T14:37:15.000Z</published>
    <updated>2017-12-11T07:59:20.527Z</updated>
    
    <content type="html"><![CDATA[<p>　　好，今天让我们更深入地搞基吧！</p><h2 id="温故而知新，可以为湿矣"><a href="#温故而知新，可以为湿矣" class="headerlink" title="温故而知新，可以为湿矣"></a>温故而知新，可以为湿矣</h2><p>　　首先请大家记住这个 V8 的在线手册——<a href="http://izs.me/v8-docs/main.html" target="_blank" rel="external">http://izs.me/v8-docs/main.html</a>。</p><p>　　还记得上次的 <code>building.gyp</code> 文件吗？</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">      <span class="attr">"sources"</span>: [ <span class="string">"addon.cc"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　就像这样，举一反三，如果多几个 <code>*.cc</code> 文件的话就是这样的：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"sources": [ "addon.cc", "myexample.cc" ]</span><br></pre></td></tr></table></figure><p>　　上次我们把俩步骤分开了，实际上配置和编译可以放在一起的：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node-gyp configure build</span><br></pre></td></tr></table></figure><p>　　复习完了吗？没？！</p><p><img src="mama.jpg" alt="啪"></p><p>　　好的，那我们继续吧。</p><h2 id="表番"><a href="#表番" class="headerlink" title="表番"></a>表番</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>　　现在我们终于要讲参数了呢。</p><p>　　让我们设想有这样一个函数 <code>add(a, b)</code> 代表把 <code>a</code> 和 <code>b</code> 相加返回结果，所以先把函数外框写好：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line">Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... 又来！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h4><p>　　这个就是函数的参数了。我们不妨先看看 v8 的<a href="http://izs.me/v8-docs/classv8_1_1Arguments.html" target="_blank" rel="external">官方手册参考</a>。</p><ul><li><code>int Length() const</code></li><li><code>Local&lt;Value&gt; operator[](int i) const</code></li></ul><p>　　其它的我们咱不关心，这两个可重要了！一个代表传入函数的参数个数，另一个中括号就是通过下标索引来访问第 <code>n</code> 个参数的。</p><p>　　所以如上的需求，我们大致就可以理解为 <code>args.Length()</code> 为 <code>2</code>，<code>args[0]</code> 代表 <code>a</code> 以及 <code>args[1]</code> 代表 <code>b</code> 了。并且我们要判断这两个数的类型必须得是 <code>Number</code>。</p><p>　　注意到没，中括号的索引操作符返回结果是一个 <code>Local&lt;Value&gt;</code> 也就是 <code>Node.js</code> 的所有类型基类。所以传进来的参数类型不定的，我们必须得自己判断是什么参数。这就关系到了这个 <code>Value</code> 类型的一些<a href="http://izs.me/v8-docs/classv8_1_1Value.html" target="_blank" rel="external">函数</a>了。</p><ul><li><code>IsArray()</code></li><li><code>IsBoolean()</code></li><li><code>IsDate()</code></li><li><code>IsFunction()</code></li><li><code>IsInt32()</code></li><li><code>IsNativeError()</code></li><li><code>IsNull()</code></li><li><code>IsNumber()</code></li><li><code>IsRegExp()</code></li><li><code>IsString()</code></li><li>…</li></ul><p>　　我就不一一列举了，剩下的自己看文档。｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡</p><h4 id="ThrowException"><a href="#ThrowException" class="headerlink" title="ThrowException"></a>ThrowException</h4><p>　　这个是我们等下要用到的一个函数。具体在 <a href="http://izs.me/v8-docs/namespacev8.html#a2469af0ac719d39f77f20cf68dd9200e" target="_blank" rel="external">v8 文档</a>中可以找到。</p><p>　　顾名思义，就是抛出错误啦。执行这个语句之后，相当于在 <code>Node.js</code> 本地文件中执行了一条 <code>throw()</code> 语句一样。比如说：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));</span><br></pre></td></tr></table></figure><p>　　就相当于执行了一条 <code>Node.js</code> 的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong number of arguments"</span>);</span><br></pre></td></tr></table></figure><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined()"></a>Undefined()</h4><p>　　这个函数呢也在<a href="http://izs.me/v8-docs/namespacev8.html#ad39cfade81e77137fc11ff3a24284340" target="_blank" rel="external">文档</a>里面。</p><p>　　具体就是一个空值，因为有些函数并不需要返回什么具体的值，或者说没有返回值，这个时候就需要用 <code>Undefined()</code> 来代替了。</p><h4 id="动手吧骚年！"><a href="#动手吧骚年！" class="headerlink" title="动手吧骚年！"></a>动手吧骚年！</h4><p>　　在理解了以上的几个要点之后，我相信你们很快就能写出 <code>a + b</code> 的逻辑了，我就把 <code>Node.js</code> 官方手册的代码抄过来给你们过一遍就算完事了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line">Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表了可以传入 2 个以上的参数，但实际上我们只用前两个</span></span><br><span class="line">    <span class="keyword">if</span>(args.Length() &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 抛出错误</span></span><br><span class="line">        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回空值</span></span><br><span class="line">        <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若前两个参数其中一个不是数字的话</span></span><br><span class="line">    <span class="keyword">if</span>(!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 抛出错误并返回空值</span></span><br><span class="line">        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong arguments"</span>)));</span><br><span class="line">        <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体参考 v8 文档</span></span><br><span class="line">    <span class="comment">//     http://izs.me/v8-docs/classv8_1_1Value.html#a6eac2b07dced58f1761bbfd53bf0e366)</span></span><br><span class="line">    <span class="comment">// 的 `NumberValue` 函数</span></span><br><span class="line">    Local&lt;Number&gt; num = Number::New(args[<span class="number">0</span>]-&gt;NumberValue() + args[<span class="number">1</span>]-&gt;NumberValue());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scope.Close(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数大功告成！</p><p>　　最后把尾部的导出函数给写好就 OK 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Handle&lt;Object&gt; exports)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    exports-&gt;Set(String::NewSymbol(<span class="string">"add"</span>),</span><br><span class="line">        FunctionTemplate::New(Add)-&gt;GetFunction());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(addon, Init)</span><br></pre></td></tr></table></figure><p>　　等你编译好之后，我们就能这样用了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addon = <span class="built_in">require</span>(<span class="string">'./build/Release/addon'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addon.add(<span class="number">1</span>, <span class="number">1</span>) + <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure><p>　　你会看到一个 <code>2b</code> ！✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>　　上一章我们只讲了个 <code>Hello world</code>，这一章阿婆主就良心发现一下，再来个回调函数的写法。</p><p>　　惯例我们先写好框架：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line">Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">  HandleScope scope;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 噼里啪啦噼里啪啦</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后我们决定它的用法是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　即它会给回调函数传入一个参数，我们设想它是一个字符串，然后我们可以 <code>console.log()</code> 出来看。</p><h4 id="首先你要有一个字符串系列"><a href="#首先你要有一个字符串系列" class="headerlink" title="首先你要有一个字符串系列"></a>首先你要有一个字符串系列</h4><p>　　废话不多说，先给它一个字符串喂饱了再说吧。<em>(√ ζ ε:)</em></p><p>　　不过我们得让这个字符串是通用类型的，因为 <code>Node.js</code> 代码是弱类型的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>));</span><br></pre></td></tr></table></figure><p>　　什么？你问我什么是 <code>Local&lt;Value&gt;</code>？</p><p>　　那我稍稍讲一下吧，参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank" rel="external">这里</a>和<a href="http://izs.me/v8-docs/classv8_1_1Local.html" target="_blank" rel="external">V8参考文档</a>。</p><p>　　如文档所示，<code>Local&lt;T&gt;</code> 实际上继承自 <code>Handle&lt;T&gt;</code>，我记得<a href="/2014/04/02/nodejs-cpp-addons-1/#Handle&lt;Value">上一章</a>已经讲过 <code>Handle&lt;T&gt;</code> 这个东西了。</p><p>　　然后下面就是讲 Local 了。</p><blockquote><p>Handle 有两种类型， Local Handle 和 Persistent Handle ，类型分别是 <code>Local&lt;T&gt; : Handle&lt;T&gt;</code> 和 <code>Persistent&lt;T&gt; : Handle&lt;T&gt;</code> ，前者和 <code>Handle&lt;T&gt;</code> 没有区别生存周期都在 scope 内。而后者的生命周期脱离 scope ，你需要手动调用 <code>Persistent::Dispose</code> 结束其生命周期。也就是说 Local Handle 相当于在 C++`在栈上分配对象而 Persistent Handle 相当于 C++ 在堆上分配对象。</p></blockquote><h4 id="然后你要有个参数表系列"><a href="#然后你要有个参数表系列" class="headerlink" title="然后你要有个参数表系列"></a>然后你要有个参数表系列</h4><p>　　终端命令行调用 C/C++ 之后怎么取命令行参数？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对了，这里的 <code>argc</code> 就是命令行参数个数，<code>argv[]</code> 就是各个参数了。那么调用 <code>Node.js</code> 的回调函数，<code>v8</code> 也采用了类似的<a href="http://izs.me/v8-docs/classv8_1_1Function.html#ac61877494d2d8bb81fcef96003ec4059" target="_blank" rel="external">方法</a>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">V8EXPORT Local&lt;Value&gt; v8::Function::Call(Handle&lt;Object&gt;recv,</span><br><span class="line">    <span class="keyword">int</span> argc,</span><br><span class="line">    Handle&lt;Value&gt; argv[]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><del>QAQ 卡在了 <code>Handle&lt;Object&gt; recv</code> 了！！！明天继续写。</del></p></blockquote><p>　　好吧，新的一天开始了我感觉我充满了力量。(∩^o^)⊃━☆ﾟ.*･｡</p><p>　　经过我多方面求证（<a href="http://segmentfault.com/q/1010000000456217" target="_blank" rel="external">SegmentFault</a>和<a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank" rel="external">StackOverflow</a>以及一个扣扣群），终于解决了上面这个函数仨参数的意思。</p><p>　　后面两个参数就不多说了，一个是参数个数，另一个就是一个参数的数组了。至于第一个参数 <code>Handle&lt;Object&gt; recv</code>，StackOverflow 仁兄的解释是这样的：</p><blockquote><p>It is the same as apply in JS. In JS, you do</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> context = ...;</span><br><span class="line">cb.apply(context, [ ...args...]);</span><br></pre></td></tr></table></figure><p>The object passed as the first argument becomes this within the function scope. More documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">MDN</a>. If you don’t know JS well, you can read more about JS’s this here: <a href="http://unschooled.org/2012/03/understanding-javascript-this/" target="_blank" rel="external">http://unschooled.org/2012/03/understanding-javascript-this/</a></p><p style="text-align: right;">—— 摘自 <a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank" rel="external">StackOverflow</a></p></blockquote><p>　　总之其作用就是指定了被调用函数的 <code>this</code> 指针。这个 <code>Call</code> 的用法就跟 JavaScript 中的 <code>bind()</code>、<code>call()</code>、<code>apply()</code> 类似。</p><p>　　所以我们要做的事情就是先把参数表建好，然后传入这个 <code>Call</code> 函数供其执行。</p><p>　　第一步，显示转换函数，因为本来是 <code>Object</code> 类型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>　　第二步，建立参数表（数组）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Local&lt;Value&gt; argv[argc] = &#123; Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) &#125;;</span><br></pre></td></tr></table></figure><h4 id="最后调用函数系列"><a href="#最后调用函数系列" class="headerlink" title="最后调用函数系列"></a>最后调用函数系列</h4><p>　　调用 <code>cb</code> ，把参数传进去：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cb-&gt;Call(Context::GetCurrent()-&gt;Global(), <span class="number">1</span>, argv);</span><br></pre></td></tr></table></figure><p>　　这里第一个参数 <code>Context::GetCurrent()-&gt;Global()</code> 所代表的意思就是获取全局上下文作为函数的 <code>this</code>；第二个参数就是参数表中的个数（毕竟虽然 <code>Node.js</code> 的数组是有长度属性的，但是 <code>C++</code> 里面数组的长度实际上系统是不知道的，还得你自己传进一个数来说明数组长度）；最后一个参数就是刚才我们建立好的参数表了。</p><h4 id="终章之结束文件系列"><a href="#终章之结束文件系列" class="headerlink" title="终章之结束文件系列"></a>终章之结束文件系列</h4><p>　　相信这一步大家已经轻车熟路了吧，就是把函数写好，然后放进导出函数里面，最后申明一下。</p><p>　　我就直接放出代码吧，或者直接跑去 <code>Node.js</code> 的<a href="http://nodejs.org/api/addons.html#addons_callbacks" target="_blank" rel="external">文档</a>看也行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line">Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line">    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">1</span>;</span><br><span class="line">    Local&lt;Value&gt; argv[argc] = &#123; Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) &#125;;</span><br><span class="line">    cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; <span class="keyword">module</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">module</span>-&gt;Set(String::NewSymbol(<span class="string">"exports"</span>),</span><br><span class="line">        FunctionTemplate::New(RunCallback)-&gt;GetFunction());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(addon, Init)</span><br></pre></td></tr></table></figure><p>　　Well done! 最后剩下的步骤就自己去吧。至于 <code>Js</code> 里面这么调用这个函数，我在<a href="#回调函数">之前</a>已经提到过了。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>　　嘛嘛，我感觉我的学习笔记写得越来越奔放了求破～</p><p>　　今天就先写到这里吧，写学习笔记的过程中我又涨姿势了，比如说那个 <code>Call</code> 函数的参数意义。</p><p>　　如果你们觉得本系列学习笔记对你们还有帮助的话，就来和我一起搞基吧么么哒～Σ&gt;―(〃°ω°〃)♡→</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　好，今天让我们更深入地搞基吧！&lt;/p&gt;
&lt;h2 id=&quot;温故而知新，可以为湿矣&quot;&gt;&lt;a href=&quot;#温故而知新，可以为湿矣&quot; class=&quot;headerlink&quot; title=&quot;温故而知新，可以为湿矣&quot;&gt;&lt;/a&gt;温故而知新，可以为湿矣&lt;/h2&gt;&lt;p&gt;　　首先请大家记住
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>让Node.js和C++一起搞基 —— 1</title>
    <link href="https://xcoder.in/2014/04/02/nodejs-cpp-addons-1/"/>
    <id>https://xcoder.in/2014/04/02/nodejs-cpp-addons-1/</id>
    <published>2014-04-01T16:53:22.000Z</published>
    <updated>2017-12-11T07:59:20.527Z</updated>
    
    <content type="html"><![CDATA[<p>　　N久之前的一个坑——用 <strong>Node.js</strong> 来重构 NBUT 的 <strong>Online Judge</strong>，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧</p><p>　　总之我们现在要做的其实简而言之就是——用C/C++来实现 <strong>Node.js</strong> 的模块。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>　　工欲善其事，必先<del>耍流氓</del>利其器。</p><h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><p>　　首先你需要一个 <code>node-gyp</code> 模块。</p><p>　　在任意角落，执行：</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ npm install node-gyp -g</span><br></pre></td></tr></table></figure><p>　　在进行一系列的 <code>blahblah</code> 之后，你就安装好了。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>　　然后你需要有个 <code>python</code> 环境。</p><p>　　自己去<a href="http://python.org/" target="_blank" rel="external">官网</a>搞一个来。</p><blockquote><p><strong>注意：</strong> 根据 <code>node-gyp</code> 的<a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank" rel="external">GitHub</a>显示，请务必保证你的 <code>python</code> 版本介于 <code>2.5.0</code> 和 <code>3.0.0</code> 之间。</p></blockquote><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>　　嘛嘛，我就偷懒点不细写了，还请自己移步到 <a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank" rel="external">node-gyp</a> 去看编译器的需求。并且倒腾好。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>　　我就拿<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank" rel="external">官网的入门 Hello World</a>说事儿了。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>　　请准备一个 <code>C++</code> 文件，比如就叫 <del>sb.cc</del> hello.cc。</p><p>　　然后我们一步步来，先往里面搞出头文件和定义好命名空间：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">#include &lt;node.h&gt;</span><br><span class="line">#include &lt;v8.h&gt;</span><br><span class="line">using namespace v8;</span><br></pre></td></tr></table></figure><h4 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h4><p>　　接下去我们写一个函数，其返回值是 <code>Handle&lt;Value&gt;</code>。</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Hello(const Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    //... 嗷嗷待写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后我来粗粗解析一下这些东西：</p><h5 id="Handle-lt-Value-gt"><a href="#Handle-lt-Value-gt" class="headerlink" title="Handle&lt;Value&gt;"></a>Handle&lt;Value&gt;</h5><p>　　做人要有节操，我事先申明我是从<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank" rel="external">这里</a>(<a href="http://cnodejs.org/user/fool" target="_blank" rel="external">@fool</a>)参考的。</p><blockquote><p>V8 里使用 Handle 类型来托管 JavaScript 对象，与 C++ 的 std::sharedpointer 类似，Handle 类型间的赋值均是直接传递对象引用，但不同的是，V8 使用自己的 GC 来管理对象生命周期，而不是智能指针常用的引用计数。</p><p>JavaScript 类型在 C++ 中均有对应的自定义类型，如 String 、 Integer 、 Object 、 Date 、 Array 等，严格遵守在 JavaScript 中的继承关系。 C++ 中使用这些类型时，必须使用 Handle 托管，以使用 GC 来管理它们的生命周期，而不使用原生栈和堆。</p></blockquote><p>　　而这个所谓的 <strong>Value</strong> ，从 V8 引擎的头文件 <a href="http://code.google.com/p/v8/source/browse/trunk/include/v8.h#1417" target="_blank" rel="external">v8.h</a> 中的各种继承关系中可以看出来，其实就是 JavaScript 中各种对象的基类。</p><p>　　在了解了这件事之后，我们大致能明白上面那段函数的申明的意思就是说，我们写一个 <code>Hello</code> 函数，其返回的是一个不定类型的值。</p><blockquote><p><strong>注意：</strong> 我们只能返回特定的类型，即在 Handle 托管下的 String 啊 Integer 啊等等等等。</p></blockquote><h5 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h5><p>　　这个就是传入这个函数的参数了。我们都知道在 <code>Node.js</code> 中，参数个数是乱来的。而这些参数传进去到 <code>C++</code> 中的时候，就转变成了这个 <code>Arguments</code> 类型的对象了。</p><p>　　具体的用法我们在后面再说，在这里只需要明白这个是个什么东西就好。（为毛要卖关子？因为 <code>Node.js</code> 官方文档中的<a href="https://github.com/rvagg/node-addon-examples" target="_blank" rel="external">例子</a>就是分开来讲的，我现在只是讲第一个 <code>Hello World</code> 的例子而已( ´థ౪థ）σ</p><h4 id="添砖加瓦"><a href="#添砖加瓦" class="headerlink" title="添砖加瓦"></a>添砖加瓦</h4><p>　　接下去我们就开始添砖加瓦了。就最简单的两句话：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Hello(const Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line">    return scope.Close(String::New(&quot;world&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这两句话是什么意思呢？大致的意思就是返回一个 <code>Node.js</code> 中的字符串 <code>&quot;world&quot;</code>。</p><h5 id="HandleScope"><a href="#HandleScope" class="headerlink" title="HandleScope"></a>HandleScope</h5><p>　　同参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank" rel="external">这里</a>。</p><blockquote><p>Handle 的生命周期和 C++ 智能指针不同，并不是在 C++ 语义的 scope 内生存（即{} 包围的部分），而需要通过 HandleScope 手动指定。HandleScope 只能分配在栈上，HandleScope 对象声明后，其后建立的 Handle 都由 HandleScope 来管理生命周期，HandleScope 对象析构后，其管理的 Handle 将由 GC 判断是否回收。</p></blockquote><p>　　所以呢，我们得在需要管理他的生命周期的时候申明这个 <code>Scope</code> 。好的，那么为什么我们的代码不这么写呢？</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Hello(const Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line">    return String::New(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为当函数返回时，<code>scope</code> 会被析构，其管理的Handle也都将被回收，所以这个 <code>String</code> 就会变得没有意义。</p><p>　　所以呢 V8 就想出了个神奇的点子——<code>HandleScope::Close(Handle&lt;T&gt; Value)</code> 函数！这个函数的用处就是关闭这个 Scope 并且把里面的参数转交给上一个 Scope 管理，也就是进入这个函数前的 Scope。</p><p>　　于是就有了我们之前的代码 <code>scope.Close(String::New(&quot;world&quot;));</code>。</p><h5 id="String-New"><a href="#String-New" class="headerlink" title="String::New"></a>String::New</h5><p>　　这个 <code>String</code> 类所对应的就是 <code>Node.js</code> 中原生的字符串类。继承自 <code>Value</code> 类。与此类似，还有：</p><ul><li>Array</li><li>Integer</li><li>Boolean</li><li>Object</li><li>Date</li><li>Number</li><li>Function</li><li>…</li></ul><p>　　这些东西有些是继承自 <code>Value</code>，有些是二次继承。我们这里就不多做研究，自己可以看看 V8 的代码（至少是头文件）研究研究或者看看这个<a href="http://bespin.cz/~ondras/html/classv8_1_1Value.html#a70d4afaccc7903e6a01f40a46ad04188" target="_blank" rel="external">手册</a>。</p><p>　　而这个 <code>New</code> 呢？<a href="http://bespin.cz/~ondras/html/classv8_1_1String.html" target="_blank" rel="external">这里</a>可以看的。就是新建一个 <code>String</code> 对象。</p><p>　　至此，这个主要函数我们就解析完毕了。</p><h4 id="导出对象"><a href="#导出对象" class="headerlink" title="导出对象"></a>导出对象</h4><p>　　我们来温习一下，如果是在 <code>Node.js</code> 里面写的话，我们怎么导出函数或者对象什么的呢？</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">exports.hello = function() &#123;&#125;</span><br></pre></td></tr></table></figure><p>　　那么，在 <code>C++</code> 中我们该如何做到这一步呢？</p><h5 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h5><p>　　首先，我们写个初始化函数：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">void init(Handle&lt;Object&gt; exports)</span><br><span class="line">&#123;</span><br><span class="line">    //... 嗷嗷待写你妹啊！#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是龟腚！函数名什么的无所谓，但是传入的参数一定是一个 <code>Handle&amp;lt;Object&gt;</code>，代表我们下面将要在这货上导出东西。</p><p>　　然后，我们就在这里面写上导出的东西了：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">void init(Handle&lt;Object&gt; exports)</span><br><span class="line">&#123;</span><br><span class="line">    exports-&gt;Set(String::NewSymbol(&quot;hello&quot;),</span><br><span class="line">        FunctionTemplate::New(Hello)-&gt;GetFunction());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　大致的意思就是说，为这个 <code>exports</code> 对象添加一个字段叫 <code>hello</code>，所对应的东西是一个<a href="http://bespin.cz/~ondras/html/classv8_1_1FunctionTemplate.html" target="_blank" rel="external">函数</a>，而这个函数就是我们亲爱的 <code>Hello</code> 函数了。</p><p>　　用伪代码写直白点就是：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">void init(Handle&lt;Object&gt; exports)</span><br><span class="line">&#123;</span><br><span class="line">    exports.Set(&quot;hello&quot;, function hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　大功告成！</p><p>　　（大功告成你妹啊！闭嘴( ‘д‘⊂彡☆))Д´)</p><h5 id="真·导出"><a href="#真·导出" class="headerlink" title="真·导出"></a>真·导出</h5><p>　　这才是最后一步，我们最后要申明，这个就是导出的入口，所以我们在代码的末尾加上这一行：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">NODE_MODULE(hello, init)</span><br></pre></td></tr></table></figure><p>　　纳了个尼？！这又是什么东西？</p><p>　　别着急，这个 <code>NODE_MODULE</code> 是一个宏，它的意思呢就是说我们采用 <code>init</code> 这个初始化函数来把要导出的东西导出到 <code>hello</code> 中。那么这个 <code>hello</code> 哪来呢？</p><p>　　<strong>它来自文件名！</strong>对，没错，它来自文件名。你并不需要事先申明它，你也不必担心不能用，总之你的这个最终编译好的二进制文件名叫什么，这里的 <code>hello</code> 你就填什么，当然要除去后缀名了。</p><p>　　详见<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank" rel="external">官方文档</a>。</p><blockquote><p>Note that all Node addons must export an initialization function:</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">void Initialize (Handle&lt;Object&gt; exports);</span><br><span class="line">NODE_MODULE(module_name, Initialize)</span><br></pre></td></tr></table></figure><p>There is no semi-colon after NODE_MODULE as it’s not a function (see node.h).</p><p>The module_name needs to match the filename of the final binary (minus the .node suffix).</p></blockquote><h3 id="编译-๑•́-₃-•̀๑"><a href="#编译-๑•́-₃-•̀๑" class="headerlink" title="编译 (๑•́ ₃ •̀๑)"></a>编译 (๑•́ ₃ •̀๑)</h3><p>　　来吧，让我们一起编译吧！</p><p>　　我们再新建一个类似于 <code>Makefile</code> 的归档文件吧——<code>binding.gyp</code>。</p><p>　　并且在里面添加这样的<a href="https://github.com/TooTallNate/node-gyp#the-bindinggyp-file" target="_blank" rel="external">代码</a>：</p><figure class="highlight plain"><figcaption><span>json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;targets&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;target_name&quot;: &quot;hello&quot;,</span><br><span class="line">      &quot;sources&quot;: [ &quot;hello.cc&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为什么这么写呢？可以参考 <code>node-gyp</code> 的<a href="http://code.google.com/p/gyp/wiki/GypUserDocumentation#Skeleton_of_a_typical_Chromium_.gyp_file" target="_blank" rel="external">官方文档</a>。</p><h4 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h4><p>　　在文件搞好之后，我们要在这个目录下面执行这个命令了：</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ node-gyp configure</span><br></pre></td></tr></table></figure><p>　　如果一切正常的话，应该会生成一个 <code>build</code> 的目录，然后里面有相关文件，也许是 <strong>M$ Visual Studio</strong> 的 <code>vcxproj</code> 文件等，也许是 <code>Makefile</code> ，视平台而定。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>　　<code>Makefile</code> 也生成好之后，我们就开始构造编译了：</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ node-gyp build</span><br></pre></td></tr></table></figure><p>　　等到一切编译完成，才算是真正的大功告成了！不信你去看看 <code>build/Release</code> 目录，下面是不是有一个 <code>hello.node</code> 文件了？没错，这个就是 C++ 等下要给 Node.js 捡的肥皂！</p><h3 id="搞基吧！Node-ヽ-✿ﾟ▽ﾟ-ノ-C"><a href="#搞基吧！Node-ヽ-✿ﾟ▽ﾟ-ノ-C" class="headerlink" title="搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++"></a>搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</h3><p>　　我们在刚才那个目录下新建一个文件 <code>jianfeizao.js</code>：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var addon = require(&quot;./build/Release/hello&quot;);</span><br><span class="line">console.log(addon.hello());</span><br></pre></td></tr></table></figure><p>　　看到没！看到没！出来了出来了！Node.js 和 C++ 搞基的结果！这个 <code>addon.hello()</code> 就是我们之前在 C++ 代码中写的 <code>Handle&lt;Value&gt; Hello(const Arguments&amp; args)</code> 了，我们现在就已经把它返回的值给输出了。</p><h2 id="洗洗睡吧，下节更深入"><a href="#洗洗睡吧，下节更深入" class="headerlink" title="洗洗睡吧，下节更深入"></a>洗洗睡吧，下节更深入</h2><p>　　时间不早了，今天就写到这里了，至此为止大家都能搞出最基础的 <strong>Hello world</strong> 的 C++ 扩展了吧。下一次写的应该会更深入一点，至于下一次是什么时候，我也不知道啦其实。<br>　　（喂喂喂，撸主怎么可以这么不负责！(ｏﾟﾛﾟ)┌┛Σ(ﾉ´<em>ω</em>`)ﾉ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　N久之前的一个坑——用 &lt;strong&gt;Node.js&lt;/strong&gt; 来重构 NBUT 的 &lt;strong&gt;Online Judge&lt;/strong&gt;，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧&lt;/p&gt;
&lt;p&gt;　　总之我们现在
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>～公众档所～项目解析</title>
    <link href="https://xcoder.in/2014/03/27/node-public-file-house/"/>
    <id>https://xcoder.in/2014/03/27/node-public-file-house/</id>
    <published>2014-03-26T17:34:04.000Z</published>
    <updated>2017-12-11T07:59:20.525Z</updated>
    
    <content type="html"><![CDATA[<p>　　所谓“公众档所”，其实就是一个公共的临时网盘了。这个东西是一个老物了，在我刚接触 <code>Expressjs</code> 的时候写的。当时还随便搞了一下 <code>backbone.js</code>，但是没有深入，勿笑。关于深入构架 <code>Expressjs</code> 方面也没做，只是粗粗写了下最基础的路由，所以整个文件结构也不是很规范。但是应该能比较适合刚学 <code>Node.js</code> 以及刚接触 <code>Expressjs</code> 的人吧。</p><p>　　Repo地址在<a href="https://github.com/XadillaX/public-file-house" target="_blank" rel="external">我的Github</a>上。Demo地址在 <a href="http://dang.kacaka.ca/" target="_blank" rel="external">http://dang.kacaka.ca/</a>，由于个人电脑的不稳定性，所以不保证你们随时可以访问，保不定哪天就失效了，所以最好的办法还是自己 <code>clone</code> 下来啪啪啪。</p><p>　　它所需要的东西大致就是 <code>Expressjs</code> + <code>Redis</code> + <code>Backbone</code> 了。不过都是最最基础的代码。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>　　把部署写在最前面是为了能让你们自己电脑上有一个能跑的环境啦。公众档所在我自己这边的环境里面是由三台电脑组成的。</p><ul><li>网关“服务器”。这是我这边环境一致对外的机器。实际上是一片树莓派，装了 <code>nginx</code>，然后对内部做反向代理。</li><li>本体“服务器”。跑了 <strong>公众档所</strong> 本体。</li><li>数据库“服务器”。我们用的数据库实际上不是严格意义上的数据库，只是 <code>redis</code> 罢了，也没做与其它数据库的持久化，只是用了他内部自带的持久化。</li></ul><p>　　<strong>如果你们装一台机子上，那么就是：</strong></p><p>　　将 <code>repo</code> 给 clone 到自己的机子上。</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/XadillaX/public-file-house</span><br></pre></td></tr></table></figure><p>　　装好 <strong>redis</strong>，并根据需要修改 <code>redis.conf</code> 文件。</p><p>　　执行 <code>redis.sh</code> 文件开启数据库。如果你自己本身已经开启数据库或者用其它方法开启了，请忽略上面数据库相关步骤。</p><p>　　然后打开 <code>commonConst.js</code> 文件进行编辑，把相关的一些信息改成自己所需要的。</p><p>　　哦对了，还有一个“洁癖相关”的步骤。我以前年轻不懂事，把 <code>node_modules</code> 文件夹也给加到版本库中了，而且也在里面居然自己加了两个没有弄到 <code>nmp</code> 去的模块（<strong>而且这两个模块本来就不应该放在这个文件夹下，但是不要在意这些细节，反正我现在肯定不会做这么傻的事了</strong>）。</p><p>　　至于为什么不要这么做，就跟 <code>node_modules</code> 文件夹的意义相关了。而且里面有可能有一些在我本机编译好的模块，所以最好还是清理下自己重新装一遍为佳。</p><p>　　具体呢大致就是把 <code>node_modules</code> 文件夹里面的 <code>alphaRandomer.js</code> 文件和 <code>smpEncoder.js</code> 文件拷贝出来备份到任意文件夹，然后删除整个 <code>node_module</code> 文件夹。接下去跑到项目根目录执行：</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>　　把三方模块重新装好之后，把刚才拷出去的俩文件放回这个目录下。（<strong>但是以后你们自己写别的项目的话千万别学我这个坏样子啊，以前年轻不懂事 QAQ</strong>）</p><p>　　最后跑起来就行啦：</p><figure class="highlight plain"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">$ node pfh.js</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接下去就是要剖析这小破东西了。</p><h3 id="基础文件"><a href="#基础文件" class="headerlink" title="基础文件"></a>基础文件</h3><h4 id="pfh-js"><a href="#pfh-js" class="headerlink" title="pfh.js"></a>pfh.js</h4><p>　　这个文件其实是 <code>Expressjs</code> 自动生成的，以前不是很懂他，所以也没怎么动，基本上是保持原封不动的。</p><h4 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h4><p>　　这个是路由定义的文件。比较丑陋的一种方法，把需要定义的所有路由都写进两个 <code>json</code> 对象中，一个 <code>POST</code> 和一个 <code>GET</code>。</p><p>　　看过 <code>Expressjs</code> 文档的人或者教程的人都知道，最基础的路由注册写法其实就是：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">app.get(KEY, FUNCTION);</span><br></pre></td></tr></table></figure><p>　　或者：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">app.post(KEY, FUNCTION);</span><br></pre></td></tr></table></figure><p>　　所以我下面有一个函数：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">exports.setRouter = function(app) &#123;</span><br><span class="line">    for(var key in this.getRouter) &#123;</span><br><span class="line">        app.get(key, this.getRouter[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(var key in this.postRouter) &#123;</span><br><span class="line">        app.post(key, this.postRouter[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　其大致意思就是把之前我们定义好的两个路由对象里的内容一一给注册到系统的路由当中去。这个是我最初最简陋的思想，不过后来我把它稍稍完善了一下写到<a href="https://github.com/XadillaX/exframess/blob/master/config/router.js#L17" target="_blank" rel="external">别的地方</a>去了。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="model-fileModel-js"><a href="#model-fileModel-js" class="headerlink" title="model/fileModel.js"></a>model/fileModel.js</h4><p>　　这个就是模型层了，主要就是 <code>redis</code> 的一些操作了。在这里我用的是 <a href="https://github.com/mranney/node_redis" target="_blank" rel="external"><code>redis</code></a> 这个模块，具体的用法大家可以看它 <code>repo</code> 的 <code>README.md</code> 文件。</p><p>　　大致就三个函数：</p><ol><li><code>fileModel.prototype.keyExists</code>: 判断某个提取码存在与否。</li><li><code>fileModel.prototype.get</code>: 获取某个验证码的文件信息。</li><li><code>fileModel.prototype.addFile</code>: 添加一个文件信息。</li></ol><blockquote><p>不过有个坏样子大家不要学，<code>Node.js</code> 大家都约定俗成的回调函数参数一般都是 <code>callback(err, data, blahblah...)</code> 的，第一个参数都是错误，如果没错误都是 <code>null</code> 或者是 <code>undefined</code> 的。但是以前也没这种意识，所以回调函数的参数也都是比较乱的。</p></blockquote><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="action-index-js"><a href="#action-index-js" class="headerlink" title="action/index.js"></a>action/index.js</h4><p>　　这是一些基础控制器。</p><h5 id="exports-index"><a href="#exports-index" class="headerlink" title="exports.index"></a>exports.index</h5><p>　　纯粹的首页显示。</p><h5 id="exports-download"><a href="#exports-download" class="headerlink" title="exports.download"></a>exports.download</h5><p>　　文件下载控制器。由代码可知，首先获取 <code>token</code> 和 <code>code</code>。 <code>token</code> 是验证 <strong>URL</strong> 的有效性而 <code>code</code> 即提取码了。</p><p>　　期间我们验证了下 <code>token</code>：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">if(!functions.verifyBlahblah(token)) &#123;</span><br><span class="line">    resp.redirect(baseConfig.webroot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　而这个 <code>verifyBlahblah</code> 函数就在<a href="https://github.com/XadillaX/public-file-house/blob/master/plugin/functions.js#L21" target="_blank" rel="external">这个文件</a>里面。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">exports.verifyBlahblah = function(blahblah) &#123;</span><br><span class="line">    var array = blahblah.split(&quot;^&quot;);</span><br><span class="line">    var time = array[array.length - 1];</span><br><span class="line">    array.pop();</span><br><span class="line"></span><br><span class="line">    var encoder = require(&quot;smpEncoder&quot;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        var text = encoder.norBack(array, time.toString());</span><br><span class="line">        text = encoder.decode(text);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var now = text.substr(0, 10);</span><br><span class="line">    var token = text.substr(10);</span><br><span class="line"></span><br><span class="line">    if(parseInt(Date.now() / 1000) - parseInt(now) &gt; 300) return false;</span><br><span class="line">    if(token !== require(&quot;../commonConst&quot;).token) return false;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　大体意思就是把其打散到数组里面，其中时间戳是最后一位。然后解密。最后验证解密后的 <code>token</code> 是否等于系统的 <code>token</code> 以及时间戳有没有过期。</p><p>　　大家通过截取 <code>Chrome</code> 或者 <code>Firefox</code> 的请求信息，不难发现有这么个地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request URL:http://localhost/download?file=662ZE&amp;token=65^97^74^68^106^125^88^115^65^96^66^105^127^114^87^123^123^114^84^124^114^125^120^121^99^116^100^118^116^98^124^120^109^98^120^100^80^119^120^87^119^105^116^8^1395904110</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br></pre></td></tr></table></figure><p>　　而这一坨 <code>65^97^74^68^106^125^88^115^65^96^66^105^127^114^87^123^123^114^84...^1395904110</code> 便是所谓的 <code>token</code> 了。而且本来就是个demo，这个 <code>token</code> 也就是随便做做样子罢了。</p><p>　　接下去通过验证之后，便可以从数据库中读取文件信息了。如果有文件，那么通过 <code>resp.download</code> 函数呈现给用户。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var fileModel = new FileModel();</span><br><span class="line">fileModel.get(code, function(status, error, obj) &#123;</span><br><span class="line">    if(error) resp.redirect(baseConfig.webroot);</span><br><span class="line">    else &#123;</span><br><span class="line">        if(obj === null) &#123;</span><br><span class="line">            resp.redirect(baseConfig.webroot + &quot;/get/&quot; + code + &quot;/not-exist&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resp.download(baseConfig.uploadDir + code, require(&quot;urlencode&quot;)(obj.filename));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="exports-getToken"><a href="#exports-getToken" class="headerlink" title="exports.getToken"></a>exports.getToken</h5><p>　　这个函数就是生产一个有效的 <code>token</code> 用的。在前端是通过 <strong>ajax</strong> 来获取的。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var encoder = require(&quot;smpEncoder&quot;);</span><br><span class="line">var token = baseConfig.token;</span><br><span class="line">var now = parseInt(Date.now() / 1000);</span><br><span class="line">var result = encoder.encode(now + token);</span><br><span class="line">result = encoder.norGo(result, now.toString());</span><br><span class="line">var resultString = &quot;&quot;;</span><br><span class="line">for(var i = 0; i &lt; result.length; i++) resultString += (result[i] + &quot;^&quot;);</span><br></pre></td></tr></table></figure><p>　　大体呢就是根据目前的时间戳和系统 <code>token</code> 一起加密生产一个有效的 <code>token</code>。</p><h5 id="exports-send2fetion"><a href="#exports-send2fetion" class="headerlink" title="exports.send2fetion"></a>exports.send2fetion</h5><p>　　通过自己的飞信给自己发送提取码以备忘。</p><p>　　这里的话用了一个 <code>fetion-sender</code> 的模块。<code>Repo</code> 在<a href="https://github.com/XadillaX/fetion-sender" target="_blank" rel="external">这里</a>。</p><h4 id="action-upload-js"><a href="#action-upload-js" class="headerlink" title="action/upload.js"></a>action/upload.js</h4><p>　　这个文件里面其实就一个 <code>exports.upload</code> 函数，另一个是生成提取码用的。</p><h5 id="function-genAlphaKey-time-callback"><a href="#function-genAlphaKey-time-callback" class="headerlink" title="function genAlphaKey(time, callback)"></a>function genAlphaKey(time, callback)</h5><p>　　生成提取码。我们假设最多尝试10次，若尝试10次还没有生成唯一的验证码就输出错误让用户重试。所以就有了：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function genAlphaKey(time, callback) &#123;</span><br><span class="line">    var keyLength = config.uploadLen;</span><br><span class="line">    var filename = alphaRandomer.rand(keyLength);</span><br><span class="line">    var fileModel = new FileModel();</span><br><span class="line"></span><br><span class="line">    fileModel.keyExists(filename, function(status, result) &#123;</span><br><span class="line">        if(!status) &#123;</span><br><span class="line">            if(time &lt; maxTryTime) &#123;</span><br><span class="line">                genAlphaKey(time + 1, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                callback(false, result, &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if(result) genAlphaKey(time, callback);</span><br><span class="line">            else &#123;</span><br><span class="line">                callback(true, &quot;&quot;, filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　不断地生成定长的提取码，然后通过模型的 <code>keyExists</code> 函数来确定这个提取码是否存在，如果存在了就递归调用重新生成，否则就直接回调。</p><h5 id="exports-upload"><a href="#exports-upload" class="headerlink" title="exports.upload"></a>exports.upload</h5><p>　　上传文件的页面了。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">if(req.files.files.length !== 1) &#123;</span><br><span class="line">    result.status = false;</span><br><span class="line">    result.msg = &quot;请用正确的姿势喂我文件。&quot;;</span><br><span class="line">    resp.send(200, result);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fileInfo = req.files.files[0];</span><br><span class="line">if(fileInfo.size &gt; config.maxUploadSize) &#123;</span><br><span class="line">    result.status = false;</span><br><span class="line">    result.msg = &quot;文件太大啦，公众档所一次只能吃10M的文件哦。&quot;;</span><br><span class="line">    resp.send(200, result);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　前面一堆话大致就是做下有效性判断而已。然后调用函数来生成有效的提取码：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">genAlphaKey(1, function(status, msg, filename) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　如果生成成功的话就往数据库中添加文件信息：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var fileModel = new FileModel();</span><br><span class="line">fileModel.addFile(filename,</span><br><span class="line">    fileInfo.name,</span><br><span class="line">    fileInfo.headers[&quot;content-type&quot;],</span><br><span class="line">    function(status, msg) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>　　如果添加也成功了的话，那么把刚上传到临时文件夹的文件给移动到上传文件储存目录中，以便以后可以被下载：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">fs.rename(fileInfo.path, uploadDir + filename, function(err) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　如果移动也成功了的话，那么返回一个成功的json信息：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">result.status = true;</span><br><span class="line">result.code = filename;</span><br><span class="line">resp.send(200, result);</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>　　这里视图就一个 <code>index.ejs</code> 。然后通过 <code>backbone.js</code> 来调用不同的页内模板和逻辑来实现的类似于 <strong>SPA <del>(Solus Par Agula)</del> (Single Page Application)</strong> 的效果。</p><h4 id="views-index-index-ejs"><a href="#views-index-index-ejs" class="headerlink" title="views/index/index.ejs"></a>views/index/index.ejs</h4><p>　　像类似于下面的这种就是 <code>backbone.js</code> 的模板概念了：</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/template&quot; id=&quot;faq-template&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>　　到时候就可以通过 <code>backbone.js</code> 中的函数来填充到页面实体当中去。</p><h4 id="public-js-index-js"><a href="#public-js-index-js" class="headerlink" title="public/js/index.js"></a>public/js/index.js</h4><p>　　在拥有了所有的前端js依赖之后，这个文件就是这个 <code>SPA</code> 的入口了。</p><p>　　逻辑很简单：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var workspace = null;</span><br><span class="line">$(function() &#123;</span><br><span class="line">    workspace = new Workspace();</span><br><span class="line">    Backbone.history.start(&#123; pushState: true, hashChange: false &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　新建一个 <code>Workscpace</code>，然后对 <code>backbone</code> 进行一点配置。</p><blockquote><p>To indicate that you’d like to use HTML5 pushState support in your application, use Backbone.history.start({pushState: true}). If you’d like to use pushState, but have browsers that don’t support it natively use full page refreshes instead, you can add {hashChange: false} to the options.</p><p style="text-align: right">——摘自 <a href="http://backbonejs.org/#History-start" target="_blank" rel="external">backbonejs.org</a></p></blockquote><p>　　然后这个 <code>Workspace</code> 即这个 <code>SPA</code> 的本体了。</p><h4 id="public-backbone-router-workspace-js"><a href="#public-backbone-router-workspace-js" class="headerlink" title="public/backbone/router/workspace.js"></a>public/backbone/router/workspace.js</h4><p>　　这里定义了几个路由，即什么路由要用哪个类去处理。这样才能在 <code>URL</code> 当中各种跳转。其实无非就是把待渲染元素渲染成页内模板，然后把页面的各种事件响应逻辑改掉即可。对于 <code>Backbone</code> 我其实只用过两次，现在也忘不大多了，怕误人子弟，所以一些具体的函数啊用法啊还是去参考下官网比较好来着。</p><h4 id="public-backbone-view-js"><a href="#public-backbone-view-js" class="headerlink" title="public/backbone/view/*.js"></a>public/backbone/view/*.js</h4><p>　　就是各路由所对应的视图了。</p><h5 id="uploadView-js"><a href="#uploadView-js" class="headerlink" title="uploadView.js"></a>uploadView.js</h5><p>　　比如说 <code>uploadView.js</code> 文件当中，执行渲染函数：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">render      : function() &#123;</span><br><span class="line">    $(this.el).html(Mustache.to_html(</span><br><span class="line">        this.template</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    $(&quot;#uploadfile&quot;).fileupload(&#123;</span><br><span class="line">        url         : &quot;../../upload.pfh&quot;,</span><br><span class="line">        dataType    : &quot;json&quot;,</span><br><span class="line">        done        : this.uploaded,</span><br><span class="line">        progressall : this.processUpload,</span><br><span class="line">        start       : this.startUpload</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(&quot;.template&quot;).show(&quot;normal&quot;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　就是用页内模板来渲染：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(this.el).html(Mustache.to_html(</span><br><span class="line">    this.template</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>　　而这个 <code>this.el</code> 是在 <code>Workspace</code> 中定义的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">upload      : function() &#123;</span><br><span class="line">    var uploadView = new UploadView(&#123; el: &quot;#main-template-container&quot; &#125;);</span><br><span class="line">    uploadView.render();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　如你所见，就是这个 <code>#main-template-container</code> 了。</p><p>　　这个渲染完毕之后，然后把 <code>#uploadfile</code> 给变成上传按钮（用了 <strong>jquery.fileupload.js</strong>）。再然后把渲染好的页面给 <code>show</code> 出来。</p><p>　　然后这个　<code>uploadView.js</code> 中还定义了两个<a href="http://backbonejs.org/#View-delegateEvents" target="_blank" rel="external">响应事件</a>：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">events      : &#123;</span><br><span class="line">    &quot;click .upbutton&quot;   : &quot;upload&quot;,</span><br><span class="line">    &quot;click #uploadpage-to-download&quot; : &quot;goDownload&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　即在按下 <code>.upbutton</code> 的时候会执行 <code>upload</code> 函数，在按下“去下载”的按钮时会执行 <code>goDownload</code> 函数。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">upload      : function() &#123;</span><br><span class="line">    $(&quot;#uploadfile&quot;).click();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　执行上传函数的时候，实际上是自动触动了 <code>#uploadfile</code> 按钮的 <code>click</code> 事件。这个时候就会按照之前定义好的 <code>$(&quot;#uploadfile&quot;).fileupload(...)</code> 去处理了。</p><h5 id="getView-js"><a href="#getView-js" class="headerlink" title="getView.js"></a>getView.js</h5><p>　　这个是获取文件的视图。</p><p>　　渲染时会获取 <code>code</code> 。这个 <code>code</code> 同样是 <code>Workspace</code> 传入的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">get         : function(code, err) &#123;</span><br><span class="line">    var getView = new GetView(&#123; el: &quot;#main-template-container&quot; &#125;);</span><br><span class="line">    getView.setCode(code);</span><br><span class="line">    if(err !== undefined) getView.setError(err);</span><br><span class="line">    getView.render();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　上面关于 <code>get</code> 的路由是 <code>get/:code</code> 之类的，所以这个 <code>code</code> 会作为一个路由参数传给 <code>get</code> 函数。</p><p>　　有了这个 <code>code</code> 之后就可以把页面渲染出来了。这就是为什么我们地址输入 <code>http://localhost/get/XXXXX</code> 的时候输入框里面就有提取码了。把这个渲染出来之后，我们对“二维码”的两张图片做下响应：鼠标移动上去会显示出来。再然后我们要获取二维码了（<code>this.genQRCode()</code>）：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">genQRCode   : function() &#123;</span><br><span class="line">    var code = this.code;</span><br><span class="line"></span><br><span class="line">    var dpage = &quot;http://dang.kacaka.ca/get/&quot; + code;</span><br><span class="line">    dpage = UrlEncode(dpage);</span><br><span class="line">    var img = &apos;&lt;img style=&quot;width: 150; height: 150;&quot; src=&quot;https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl=&apos; + dpage + &apos;&quot; /&gt;&apos;;</span><br><span class="line"></span><br><span class="line">    $(&quot;#download-page-qr&quot;).attr(&quot;data-content&quot;, img);</span><br><span class="line"></span><br><span class="line">    var opage = &quot;http://dang.kacaka.ca/download?&quot;;</span><br><span class="line">    this.getToken(function(token) &#123;</span><br><span class="line">        if(undefined === token) &#123;</span><br><span class="line">            $(&quot;#download-origin-qr&quot;).attr(&quot;data-content&quot;, &apos;&lt;div style=&quot;text-align: center;&quot;&gt;二维码生成失败。&lt;/div&gt;&apos;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opage += &quot;token=&quot; + token;</span><br><span class="line">        opage += &quot;&amp;file=&quot; + code;</span><br><span class="line">        opage = UrlEncode(opage);</span><br><span class="line">        var img = &apos;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;width: 150; height: 150;&quot; src=&quot;https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl=&apos; + opage + &apos;&quot; /&gt;&lt;br /&gt;&lt;small&gt;该二维码有效期五分钟。&lt;/small&gt;&lt;/div&gt;&apos;;</span><br><span class="line">        $(&quot;#download-origin-qr&quot;).attr(&quot;data-content&quot;, img);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if(&quot;&quot; === this.code) &#123;</span><br><span class="line">        $(&quot;h2 small&quot;).css(&quot;display&quot;, &quot;none&quot;);</span><br><span class="line">    &#125; else $(&quot;h2 small&quot;).css(&quot;display&quot;, &quot;inline-block&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　无非就是调用谷歌的 API 然后生成图片地址放上去罢了。一个地址就是当前页面地址，另一个就是加上 <code>token</code> 之后的直接下载地址。</p><p>　　如你所见，获取token是通过ajax往服务器请求的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">getToken    : function(callback) &#123;</span><br><span class="line">    $.get(&quot;../../blahblah&quot;, &#123;&#125;, function(e) &#123;</span><br><span class="line">        callback(e.token);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　然后事件的话：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">events      : &#123;</span><br><span class="line">    &quot;click #downloadpage-to-upload&quot; : &quot;toUpload&quot;,</span><br><span class="line">    &quot;click #download-btn&quot;   : &quot;toDownload&quot;,</span><br><span class="line">    &quot;keydown #download-code&quot;: &quot;toDownloadKeydown&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;keyup #download-code&quot;  : &quot;navCode&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　按了“去上传”按钮会跑去上传。如果按下“下载”按钮就下载文件了。然后输入框里面弹起键盘的话，会导致输入框文字变化，这个时候就要更新二维码以及URL了。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">navCode     : function() &#123;</span><br><span class="line">    var code = $(&quot;#download-code&quot;).val();</span><br><span class="line">    workspace.navigate(&quot;get/&quot; + code);</span><br><span class="line">    this.code = code;</span><br><span class="line"></span><br><span class="line">    if(code === &quot;&quot;) &#123;</span><br><span class="line">        $(&quot;h2 small&quot;).css(&quot;display&quot;, &quot;none&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.genQRCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　每当输入框变化之后，地址栏就要变成新的 <code>get/:code</code> (<code>workspace.navigate(&quot;get/&quot; + code)</code>) 了，然后重新获取一遍二维码。</p><p>　　下载按钮的逻辑代码如下：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">toDownload  : function() &#123;</span><br><span class="line">    var code = $(&quot;#download-code&quot;).val();</span><br><span class="line">    workspace.navigate(&quot;get/&quot; + code);</span><br><span class="line">    this.getToken(function(token) &#123;</span><br><span class="line">        if(token === undefined) &#123;</span><br><span class="line">            alert(&quot;获取验证信息失败，请稍后重试。&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var url = &quot;../../download?file=&quot; + code + &quot;&amp;token=&quot; + token;</span><br><span class="line">            window.location.href = url;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　反正就是根据 <code>code</code> 来生成地址，然后从获取token的地址中把token拿出来拼接成下载地址之后再访问（<code>window.location.href = url</code>）就好了。</p><h5 id="uploadedView-js"><a href="#uploadedView-js" class="headerlink" title="uploadedView.js"></a>uploadedView.js</h5><p>　　这个视图是上传成功视图。功能很简单，就是现实下提取码，然后飞信能发送一下，以及能复制验证码罢了。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">render      : function() &#123;</span><br><span class="line">    if(undefined === this.code) &#123;</span><br><span class="line">        workspace.navigate(&quot;upload&quot;, &#123; trigger: true, replace: true &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $(this.el).html(Mustache.to_html(</span><br><span class="line">        this.template,</span><br><span class="line">        &#123; code: this.code &#125;</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    var phoneinfo = store.get(&quot;fetion-info&quot;);</span><br><span class="line">    if(undefined !== phoneinfo) &#123;</span><br><span class="line">        $(&quot;#phonenumber&quot;).val(phoneinfo.phonenumber);</span><br><span class="line">        $(&quot;#password&quot;).val(phoneinfo.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $(&quot;.template&quot;).show(&quot;normal&quot;, function() &#123;</span><br><span class="line">        $(&apos;#copy-code-btn-parent&apos;).zclip(&#123;</span><br><span class="line">            path:&apos;../../ZeroClipboard.swf&apos;,</span><br><span class="line">            copy:function() &#123;</span><br><span class="line">                return $(&quot;#code-input&quot;).val();</span><br><span class="line">            &#125;,</span><br><span class="line">            afterCopy: function() &#123;</span><br><span class="line">                alert(&quot;提取码已经成功复制到剪切板了。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　通过判断有没有 <code>code</code> 来判断是否上传成功。这个 <code>code</code> 的来源是 <code>uploadView.js</code> 中的 <code>uploaded (done: this.uploaded)</code> 函数：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">uploaded    : function(e, data) &#123;</span><br><span class="line">    var result = data.result;</span><br><span class="line">    if(!result.status) &#123;</span><br><span class="line">        $(&quot;#progress&quot;).css(&quot;display&quot;, &quot;none&quot;);</span><br><span class="line">        $(&quot;#progress .progress-bar&quot;).html(&quot;已上传 0%&quot;);</span><br><span class="line">        $(&quot;#progress .progress-bar&quot;).attr(&quot;aria-valuenow&quot;, &quot;0&quot;);</span><br><span class="line">        $(&quot;#progress .progress-bar&quot;).css(&quot;width&quot;, &quot;0%&quot;);</span><br><span class="line"></span><br><span class="line">        $(&quot;#upload-div #feed-doc&quot;).removeClass(&quot;alert-info&quot;);</span><br><span class="line">        $(&quot;#upload-div #feed-doc&quot;).addClass(&quot;alert-danger&quot;);</span><br><span class="line">        $(&quot;#upload-div #feed-doc&quot;).html(result.msg);</span><br><span class="line">        $(&quot;#upload-div #feed-doc&quot;).css(&quot;display&quot;, &quot;block&quot;);</span><br><span class="line">        return;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        store.set(&quot;code&quot;, result.code);</span><br><span class="line">        workspace.navigate(&quot;uploaded&quot;, &#123; trigger: true, replace: true &#125;);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　<code>e</code> 和 <code>data</code> 这两个参数哪来？首先这个 <code>uploaded</code> 函数是在之前渲染的时候定义成 <code>jquery.fileupload</code> 的上传结束回调函数的，所以这两个参数自然是 <code>jquery.fileupload</code> 传过来的。详见<a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Options#done" target="_blank" rel="external">这里</a>。</p><p>　　总之就是上次成功之后，这个upload函数会获取一个 <code>code</code>，然后它就会拿这个 <code>code</code> 存到 <code>store</code> 中。这个 <code>store.js</code> 是一个 <code>localStorage</code> 的封装。它的代码和文档在<a href="https://github.com/cloudhead/store.js" target="_blank" rel="external">这里</a>。</p><p>　　存好之后让 <code>Workspace</code> 给导航到 <code>uploaded</code> 视图中。</p><p>　　而这个 <code>uploaded</code> 视图的初始化函数里面有这样的代码：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line">initialize  : function() &#123;</span><br><span class="line">    this.code = store.get(&quot;code&quot;);</span><br><span class="line">    var self = this;</span><br><span class="line"></span><br><span class="line">    $(&quot;#sending&quot;).click(self.sending);</span><br><span class="line">    $(&quot;#cancel-sending&quot;).click(self.cancelSending);</span><br><span class="line">    $(&quot;#phonenumber, #password&quot;).keydown(function(e) &#123; if(e.keyCode === 13) self.sending(); &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　就是初始化的时候，从 <code>localStorage</code> 中把 <code>code</code> 给取出来。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>　　代码量少，用到的东西也是基础；不过以前的代码由于不了解 <code>Node.js</code> 啊 <code>Expressjs</code> 啊等等的，所以导致代码杂乱无章、脏乱无比，所以一定程度上阻碍了可读性的存在。</p><p>　　希望本文能给各位看官稍稍理清思路。我也不必写得面面俱到，只是在某个程度上点题一下而已。更多的大家自己看代码即可了。不过希望还不要把大家给误导了就好，毕竟这代码我自己现在看觉得好丢脸啊 QAQ。大家就去其糟粕取其精华吧。（喂喂喂，我去年买了个表，哪有什么精华啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　所谓“公众档所”，其实就是一个公共的临时网盘了。这个东西是一个老物了，在我刚接触 &lt;code&gt;Expressjs&lt;/code&gt; 的时候写的。当时还随便搞了一下 &lt;code&gt;backbone.js&lt;/code&gt;，但是没有深入，勿笑。关于深入构架 &lt;code&gt;Express
      
    
    </summary>
    
      <category term="Document" scheme="https://xcoder.in/categories/Document/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="Project Parse" scheme="https://xcoder.in/tags/Project-Parse/"/>
    
  </entry>
  
  <entry>
    <title>浙江大学XPlan项目新闻爬虫手机屏幕适配文档</title>
    <link href="https://xcoder.in/2013/12/28/xplan-spider-doc/"/>
    <id>https://xcoder.in/2013/12/28/xplan-spider-doc/</id>
    <published>2013-12-27T16:00:00.000Z</published>
    <updated>2017-12-11T07:59:20.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>XPlan</strong> 是一个“基于校园强关系的社交应用”的开发代号。其中有一个功能是从学校网站上通过网络爬虫（Web Crawler）形式将学校新闻抓取到XPlan自身的数据库当中。</p><p>而这里出现的一个问题就是学校网站上面的文章是通过类似于 <a href="http://kindeditor.net/" target="_blank" rel="external"><code>KindEditor</code></a>、<a href="http://ueditor.baidu.com/website/" target="_blank" rel="external"><code>UEditor</code></a>这类<strong>在线富文本编辑器</strong>生成的代码。</p><p>这类代码有几个共性：</p><ol><li>代码有大量冗余、多重无用嵌套。</li><li>非常低的代码可读性。</li><li>在PC浏览器中表现力不错，往往能以低效的代码实现预期排版。</li></ol><p>所以这些富文本编辑器可以在PC各大内核浏览器中表现良好，但是不便人工修改代码。</p><p>而 <strong>XPlan</strong> 确是一个由智能手机主导的应用，新闻将会通过一个 <strong>WebView</strong> 体现出来。所以就需要一定的方法将这些脏乱的代码适配成手机屏幕下表现力良好的代码。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>在这里，我们将新闻的代码锁定在新闻内容排版，而排除了其它类似于新闻标题、新闻作者等其它信息。</p><p>以我们浙江大学软件学院为例，我们爬取的新闻内容代码将如下：</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vid_wz&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>所有内容将被包括在这个类型为 <code>vid_wz</code> 的 <code>div</code> 当中。</p><p>这时，我们将其包括在一个自己实现定义好的模板当中。该模板与新闻内容将会形成一个完整的网页，包括完整的 <code>html</code>、<code>head</code>、<code>body</code> 等标签。</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;新闻内页&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;article id=&quot;_xplan-wrapper&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;vid_wz&quot;&gt;</span><br><span class="line">            ...</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里需要注意的一点的就是其中的一个 <code>meta</code> 标签：</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><p>它的意思是定义 <code>viewport</code> 的一些属性，实现了初步的手机网页适配。</p><h3 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h3><p>手机浏览器是把页面放在一个虚拟窗口（即 <code>viewport</code>）中，用户可以通过平移和缩放来看网页的不同部分。</p><p>通过 <code>viewport</code> 我们能对页面的一些缩放进行手机适配。</p><p>我们所需要做的仅是在 <code>head</code> 中插入一个 <code>meta</code> 标签，命名为 <code>viewport</code>，然后定义好其 <code>content</code>。</p><p><code>content</code> 的语法如下：</p><h4 id="width"><a href="#width" class="headerlink" title="width"></a>width</h4><p>控制 <code>viewport</code> 的宽度，可以指定一个值或者特殊的值，如 <code>device-width</code> 为设备宽度。</p><h4 id="height"><a href="#height" class="headerlink" title="height"></a>height</h4><p>与 <code>width</code> 相对应，指定高度</p><h4 id="initial-scale"><a href="#initial-scale" class="headerlink" title="initial-scale"></a>initial-scale</h4><p>初始缩放，即页面初始缩放程度。这是一个浮点值，是页面大小的一个乘数。例如，如果你设置初始缩放为 <code>1.0</code>，那么页面在展现的时候就会以分辨率的1:1来展现。如果你设置为<code>2.0</code>，那么这个页面就会放大为2倍。</p><h4 id="maximum-scale"><a href="#maximum-scale" class="headerlink" title="maximum-scale"></a>maximum-scale</h4><p>最大放大倍数。</p><h4 id="user-scaleble"><a href="#user-scaleble" class="headerlink" title="user-scaleble"></a>user-scaleble</h4><p>用户调整缩放，即用户是否能改变页面缩放程度。如果为 <code>yes</code> 即为可以， <code>no</code> 为不可以。</p><h2 id="Cheerio模块"><a href="#Cheerio模块" class="headerlink" title="Cheerio模块*"></a>Cheerio模块*</h2><p>由于 <strong>XPlan</strong> 的后端是基于 <code>node.js</code> 构架的，所以 <strong>cheerio</strong> 模块是一个 <code>node.js</code> 专有的模块。</p><p>它的作用是将一段HTML代码转换为一棵DOM元素树。</p><p>在其官网上是这么诠释的：为服务端定制的快速、灵活、轻量级实现的 jQuery 内核。通常熟悉 jQuery 使用的开发者应该会对其使用方法比较熟悉。</p><p>所以在我们做接下去适配修改的之前，我们需要将我们刚才生成的完整HTML代码 转换为一棵我们可以操作的DOM元素树。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var cheerio = require(&quot;cheerio&quot;);</span><br><span class="line">$ = cheerio.load(...);</span><br></pre></td></tr></table></figure><p>这时我们便能以熟悉的jQuery模式对其进行操作了，如：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).html(&quot;hello foo!&quot;);</span><br></pre></td></tr></table></figure><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Bootstrap是Twitter推出的一个开源的用于前端开发的工具包。它有一个非常好的响应式的页面风格，使其在个尺寸屏幕上表现良好。</p><p>为了能更好适应屏幕，我们决定采用其自带的栅格系统，于是刚才的页面模板就有了新的变化：</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;新闻内页&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;article class=&quot;container&quot; id=&quot;_xplan-wrapper&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-md-12&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;vid_wz&quot;&gt;...&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>首先最外框的 <code>container</code>，用其包裹的元素将实现居中对齐。在不同的媒体查询阈值范围内都为 <code>container</code> 设置了 <code>width</code>，用以匹配栅格系统。</p><p><code>row</code> 是一行栅格系统的外包元素。一行可以有12个栅格。</p><p>以 <code>.col-md-</code> 开头的栅格的最大 <code>container</code> 宽度为970，最大列宽为78，并能自适应屏幕。</p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>在完成了以上操作以后，我们将对各元素进行微调处理。</p><p>好在在手机浏览器或者 <code>WebView</code> 中，对各种字体的设置不是非常敏感，所以我们仍然可以不处理一些关于字体变更的设置，以减轻开发量。</p><p>这里距几个微调的例子。</p><h3 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img /&gt;"></a>&lt;img /&gt;</h3><p>在新闻当中，图片充当的基本上是新闻照片的角色，在手机当中以单行出现为佳。</p><p>而 Bootstrap 当中本身就有元素类型来让图片元素响应屏幕宽度，并可以加上圆角边框。</p><p>所以我们需要做的就是为所有图片加上响应的类型：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(&quot;img&quot;).addClass(&quot;img-thumbnail&quot;);</span><br><span class="line">$(&quot;img&quot;).addClass(&quot;img-responsive&quot;);</span><br><span class="line">$(&quot;img&quot;).removeAttr(&quot;style&quot;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 最后的一个移除 <code>img</code> 元素自带的 <code>style</code> 属性是因为在文章发布的时候，有可能会被富文本编辑器自动加上一些宽高、边框等信息。为了统一所有图片风格以及让响应式生效，需要将其 <code>style</code> 属性全部移除。</p></blockquote><p>下面是是适配前与适配后的对比：</p><p><img src="./xplan-news-2.jpg" alt="适配前"><br><img src="./xplan-news-1.jpg" alt="适配后"></p><h3 id="lt-table-gt-lt-table-gt"><a href="#lt-table-gt-lt-table-gt" class="headerlink" title="&lt;table&gt;&lt;/table&gt;"></a>&lt;table&gt;&lt;/table&gt;</h3><p>对于 <code>table</code> 元素也需要对它进行自适配，不然很有可能会溢出屏幕，使其多出了一个横向的滚动条。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(&quot;table&quot;).removeAttr(&quot;style&quot;);</span><br><span class="line">$(&quot;table&quot;).removeAttr(&quot;border&quot;);</span><br><span class="line"></span><br><span class="line">$(&quot;table&quot;).addClass(&quot;table&quot;);</span><br><span class="line">$(&quot;table&quot;).addClass(&quot;table-bordered&quot;);</span><br><span class="line">$(&quot;table&quot;).addClass(&quot;table-striped&quot;);</span><br></pre></td></tr></table></figure><p>上面两句是移除 <code>table</code> 的原有的一些风格信息以及属性。后面是为其加上 Bootstrap 特有的 <code>table</code> 类型。</p><p>当然，更多的 <code>table</code> 元素还需要其它更多操作。不过就目前为止，<strong>XPlan</strong> 还没有着手关于 <code>table</code> 的更深一层容错处理。不过这里可以提供一个思路。</p><p>比如说 <a href="http://www.cst.zju.edu.cn/index.php?c=Index&amp;a=detail&amp;catid=72&amp;id=1885" target="_blank" rel="external">这篇文章中</a>，不知道是谁给的在线富文本编辑器勇气，使其下面几张图片都各自被一个 <code>table</code> 及其子元素所包含。更有甚者，有一篇文章的一个段落被一个 <code>table</code> 所包容，并且在其左侧还有一个看不见的 <code>td</code> 元素。</p><p>我们可以提供的思路就是如果一个 <code>table</code> 只有一行一列就直接将其内容取出并删除该 <code>table</code> 。</p><h3 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt;a /&gt;"></a>&lt;a /&gt;</h3><p>超链接元素是一个新闻与用户互动的比较重要的元素之一。我们需要保持其美观性。</p><p>举几个例子来说，我们可以将超链接以一个类按钮的形式出现：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(&quot;a&quot;).removeAttr(&quot;style&quot;);</span><br><span class="line">$(&quot;a&quot;).addClass(&quot;btn btn-default btn-xs btn-info&quot;);</span><br></pre></td></tr></table></figure><p>然后我们甚至可以对其做一些细微的词汇修改。</p><p>比如当新闻发布者上传了一个附件然后不负责任地直接将文件名贴上的时候，我们可以贴心地将其显示文字改为“下载附件”。</p><p>再比如发布者直接以URL形式显示一个超链接的时候，我们可以贴心地将其改变为“打开链接”等等。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">$(&quot;a&quot;).each(function(idx, elem) &#123;</span><br><span class="line">    if($(this).html().match(/.*\.(doc|xls|ppt|docx|xlsx|pptx)/)) &#123;</span><br><span class="line">        $(this).html(&quot;&lt;i class=&apos;glyphicon glyphicon-paperclip&apos;&gt;&lt;/i&gt; 下载附件&quot;);</span><br><span class="line">        $(this).removeClass(&quot;btn-info&quot;);</span><br><span class="line">        $(this).addClass(&quot;btn-warning&quot;);</span><br><span class="line">    &#125; else if($(this).html().match(/http.*\/\/.*/)) &#123;</span><br><span class="line">        $(this).html(&quot;&lt;i class=&apos;glyphicon glyphicon-flag&apos;&gt;&lt;/i&gt; 打开链接&quot;);</span><br><span class="line">        $(this).removeClass(&quot;btn-info&quot;);</span><br><span class="line">        $(this).addClass(&quot;btn-warning&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们再处理几个由于误操作而增加的错误链接，如在经上面操作后，还存在着url与显示内容相关的超链接可以直接取消，如这类：</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">让我们荡&lt;a href=&quot;起双桨&quot;&gt;起双桨&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，当下版本的 <strong>XPlan</strong> 的新闻爬虫手机屏幕适配基本完成。其中当然还存在着一些细节处理和显示错误处理的不足，但是已经定下了基本的适配思路。</p><p>我们还在探索更好的适配方法，而当下的适配形式暂时已经可以满足了我们项目的需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;XPlan&lt;/strong&gt; 是一个“基于校园强关系的社交应用”的开发代号。其中有一个功能是从学校网站上通过网络爬虫（Web
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="XPlan" scheme="https://xcoder.in/tags/XPlan/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder SRM 589 DIV 2</title>
    <link href="https://xcoder.in/2013/08/31/srm-589-div2/"/>
    <id>https://xcoder.in/2013/08/31/srm-589-div2/</id>
    <published>2013-08-30T16:00:00.000Z</published>
    <updated>2017-12-11T07:59:20.542Z</updated>
    
    <content type="html"><![CDATA[<p>　　好久没撸 <strong>TC</strong> 了，手都生了。前两天刚折腾好 <strong>LinuxMint</strong> + <strong>Cinnamon</strong>，顺便手贱把 <strong>TC</strong> 环境配好了。</p><p>　　随便进去扯了一套最新的 <strong>SRM</strong> 来搞，全跑完之后才发现原来这场比赛还处于 <strong>System Running</strong> 阶段。于是知道了比赛一结束还在 <strong>Running</strong> 的时候你就已经可以自己拉出来做了。小绿名大家不要笑。</p><!-- 我是小小分割符 --><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>　　这次 <strong>DIV 2</strong> 的难度一般，一道签到题加两道普通的 <strong>DP</strong>。</p><p>　　<a href="https://github.com/XadillaX/xadillax-topcoder/tree/master/code/SRM589-DIV2" target="_blank" rel="external">Code on GitHub</a>.</p><h2 id="250pt-Goose-Tattarrattat"><a href="#250pt-Goose-Tattarrattat" class="headerlink" title="250pt - Goose Tattarrattat"></a>250pt - Goose Tattarrattat</h2><p>题意很简单，就是给你一个字符串，问你最少改变多少字符让字符串所有字符都一样。</p><p>签到题，找最多的字符跟总长度一减就OK了。</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">#define SIZE(x) ((int)(x.size()))</span><br><span class="line">#define LENGTH(x) ((int)(x.length()))</span><br><span class="line">class GooseTattarrattatDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(string S);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int GooseTattarrattatDiv2::getmin(string S)</span><br><span class="line">&#123;</span><br><span class="line">    int maxsame = 0;</span><br><span class="line">    map&lt;char, int&gt; mp;</span><br><span class="line">    for(int i = 0; i &lt; LENGTH(S); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    mp[S[i]]++;</span><br><span class="line">    maxsame = max(maxsame, mp[S[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return LENGTH(S) - maxsame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="500pt-Gears"><a href="#500pt-Gears" class="headerlink" title="500pt - Gears"></a>500pt - Gears</h2><p>有 <strong><em>N</em></strong> 个齿轮围成一圈，相邻两个齿轮要反方向转才能正常运转不卡到其它轮子。你要从中间拿掉几个齿轮（留空了就不影响其左边的左边的齿轮），问最少拿掉几个使得所有齿轮能正常转。</p><p>我们建两个二维 <strong><em>dp</em></strong> 数组，或者一个三维 <strong><em>dp</em></strong> 数组：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp[i][0|1][0|1]</span><br></pre></td></tr></table></figure><p>第一维 <code>i</code> 代表当前是第 <code>i</code> 个齿轮。第二维若是 <code>0</code> 则表示这个齿轮拿走，若是 <code>1</code> 代表留下。第三维若是 <code>0</code> 则代表第一个齿轮拿走，<code>1</code> 代表第一个齿轮留下。整个数组的每个元素就代表该齿轮留下或者拿走且第一个齿轮是留下或者拿走的情况下的最少拿走齿轮数。</p><p>所以我们能得到几个状态转移方程：</p><blockquote><h3 id="第一个齿轮"><a href="#第一个齿轮" class="headerlink" title="第一个齿轮"></a>第一个齿轮</h3></blockquote><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp[i][0][0] = 1;</span><br><span class="line">dp[i][0][1] = INF;</span><br><span class="line">dp[i][1][1] = 0;</span><br><span class="line">dp[i][1][0] = INF;</span><br></pre></td></tr></table></figure><blockquote><h3 id="第二个齿轮"><a href="#第二个齿轮" class="headerlink" title="第二个齿轮"></a>第二个齿轮</h3><p>如果与第一个同向那么就有了一留一走或者两个都走的情况。否则就是四种情况都可以。</p></blockquote><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">if(与第一个齿轮同向)</span><br><span class="line">&#123;</span><br><span class="line">    dp[1][0][1] = 1;</span><br><span class="line">    dp[1][1][0] = 1;</span><br><span class="line">    dp[1][0][0] = 2;</span><br><span class="line">    dp[1][1][1] = INF;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    dp[i][0][0] = 2;</span><br><span class="line">    dp[i][0][1] = 1;</span><br><span class="line">    dp[i][1][0] = 1;</span><br><span class="line">    dp[i][1][1] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="之后的所有齿轮"><a href="#之后的所有齿轮" class="headerlink" title="之后的所有齿轮"></a>之后的所有齿轮</h3><p>若该齿轮与前一个齿轮方向相同 ，那么该齿轮留下的时候，前一个齿轮必须得走，那么就是 <code>dp[i - 1][0][?]</code>;该齿轮走的时候，前一个齿轮可走可留，就是 <code>dp[i - 1][0|1][?] + 1</code> 的稍微小一点那个。</p><p>若方向不相同 ，那么就是该齿轮留下的时候，前一个齿轮也可以留下。</p></blockquote><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">if(与前一个齿轮同向)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][1][0] = dp[i - 1][0][0];</span><br><span class="line">    dp[i][1][1] = dp[i - 1][0][1];</span><br><span class="line"></span><br><span class="line">    dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">    dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][0]) + 1;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    dp [i][1][0] = min(dp[i - 1][0][0], dp[i - 1][1][0]);</span><br><span class="line">    dp [i][1][1] = min(dp[i - 1][0][1], dp[i - 1][1][1]);</span><br><span class="line"></span><br><span class="line">    dp [i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">    dp [i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][1]) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后若最后一个齿轮与第一个齿轮同向，那么在 <code>dp[i - 1][0][0]</code>、<code>dp[i - 1][0][1]</code>、<code>dp[i - 1][1][0]</code> 中挑一个。若不同向，那么多了个 <code>dp[i - 1][1][1]</code> 这个选择。</p><p>下面就是代码了：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">class GearsDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(string Directions);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int GearsDiv2::getmin(string Directions)</span><br><span class="line">&#123;</span><br><span class="line">    int dp[100][2][2];</span><br><span class="line">    for(int i = 0; i &lt; LENGTH(Directions); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0][0] = 1;</span><br><span class="line">            dp[i][0][1] = 10000000;</span><br><span class="line">            dp[i][1][1] = 0;</span><br><span class="line">            dp[i][1][0] = 10000000;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(Directions[i] == Directions[i - 1])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][0][1] = 1;</span><br><span class="line">                dp[i][1][0] = 1;</span><br><span class="line">                </span><br><span class="line">                dp[i][0][0] = 2;</span><br><span class="line">                dp[i][1][1] = 10000000;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][0][0] = 2;</span><br><span class="line">                dp[i][0][1] = 1;</span><br><span class="line">                dp[i][1][0] = 1;</span><br><span class="line">                dp[i][1][1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(Directions[i] == Directions[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][1][0] = dp[i - 1][0][0];</span><br><span class="line">            dp[i][1][1] = dp[i - 1][0][1];</span><br><span class="line">            </span><br><span class="line">            dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">            dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][0][1]) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][1][0] = min(dp[i - 1][0][0], dp[i - 1][1][0]);</span><br><span class="line">            dp[i][1][1] = min(dp[i - 1][0][1], dp[i - 1][1][1]);</span><br><span class="line">            </span><br><span class="line">            dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">            dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][1]) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ans;</span><br><span class="line">    int mi = LENGTH(Directions) - 1;</span><br><span class="line">    if(Directions[mi] == Directions[0])</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(dp[mi][0][0], min(dp[mi][1][0], dp[mi][0][1]));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(min(dp[mi][0][0], dp[mi][1][1]), min(dp[mi][0][1], dp[mi][1][0]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1000pt-Flipping-Bits"><a href="#1000pt-Flipping-Bits" class="headerlink" title="1000pt - Flipping Bits"></a>1000pt - Flipping Bits</h2><p>给你一个 <strong>01串</strong> 与一个正整数 <strong><em>M</em></strong>。<strong>01串</strong> 有如下三种操作:</p><ul><li>随便反转一位（0 -&gt; 1, 1 -&gt; 0）。</li><li>将开头 <code>k * M</code> 位反转。k 可以是任何正整数。</li><li>将末尾 <code>k * M</code> 位反转。k 可以是任何正整数。</li></ul><p>问最少需要几步将整个字符串变成都是 <code>1</code>。</p><p>这又是一个 <strong>DP</strong> 的题目。</p><p>我们先设有 <strong><em>G</em></strong> 组，一组 <strong><em>M</em></strong> 个 <code>01字符</code>。那么就能有</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][0|1]</span><br><span class="line">dp2[i][0|1]</span><br></pre></td></tr></table></figure><p>其中 <code>i</code> 代表第 <code>i</code> 组，第二维如果是 <code>0</code> 就代表这一组采用一位位反转的操作将这组全变成 <code>1</code>，如果是 <code>1</code> 则将整组全部反转再采用一位位反转的操作将这组全变成 <code>1</code> 。至于 <code>dp1</code> 和 <code>dp2</code> 则代表从头到尾和从尾到头。</p><p>由于只有 <code>0</code> 和 <code>1</code> 反转，那么一组反转两次就能还原原状——这是一个非常重要的性质。</p><p>如果某一组采用<strong>整组反转</strong>的操作，若前一组也是<strong>整组反转</strong>，那么就相当于操作次数不变，只是将前一组的反转范围延续到这一组；若前一组是<strong>非整组反转</strong>，那么就相当于从头到这一组反转之后，前面的所有组再反转回去——相当于是多了两次操作。于是就有了（先只拿 <code>dp1</code> 作为例子）：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][1] = min(</span><br><span class="line">    dp[i - 1][0] + 这一组1的数量 + 2,</span><br><span class="line">    dp[i - 1][1] + 这一组1的数量 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果某一组采用<strong>非整组反转</strong>，那么操作次数就是前一组的<strong>整组反转</strong>或者<strong>非整组反转</strong>的操作次数加上这一组 <code>0</code> 的数量：</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][0] = min(</span><br><span class="line">    dp[i - 1][0] + 这一组0的数量,</span><br><span class="line">    dp[i - 1][0] + 这一组0的数量</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>用上面的转移方程把正反向都求了一遍之后，我们就可以求总答案了，总答案就是我们枚举中间只有<strong>操作1</strong>的段的首尾，加上该中间段前部分的 <strong><em>dp</em></strong> 答案和其后部分的 <strong><em>dp</em></strong> 答案，取出最小值就是了。</p><figure class="highlight plain"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">class FlippingBitsDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(vector &lt;string&gt; S, int M);</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    int group;</span><br><span class="line">    int tn1[2600], tnsum1[2600];</span><br><span class="line">    int tn2[2600], tnsum2[2600];</span><br><span class="line">    </span><br><span class="line">    int dp1[2600][2];</span><br><span class="line">    int dp2[2600][2];</span><br><span class="line">    </span><br><span class="line">    int calcsum(int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l &gt; r) return 0;</span><br><span class="line">        int tot = tnsum1[r] - tnsum1[l - 1];</span><br><span class="line">        return tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int FlippingBitsDiv2::getmin(vector &lt;string&gt; S, int M)</span><br><span class="line">&#123;</span><br><span class="line">    str = &quot;&quot;;</span><br><span class="line">    for(int i = 0; i &lt; SIZE(S); i++) str += S[i];</span><br><span class="line">    group = LENGTH(str) / M;</span><br><span class="line">    ZERO(tn1);</span><br><span class="line">    ZERO(tn2);</span><br><span class="line">    </span><br><span class="line">    // init.</span><br><span class="line">    for(int i = 0; i &lt; group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int op = i * M;</span><br><span class="line">        int ed = op + M;</span><br><span class="line">        for(int j = op; j &lt; ed; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[j] == &apos;0&apos;) tn1[i]++, tn2[group - i - 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp1[i][0] = 100000;</span><br><span class="line">        dp1[i][1] = 100000;</span><br><span class="line">        dp2[i][0] = 100000;</span><br><span class="line">        dp2[i][1] = 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // tnsum</span><br><span class="line">    for(int i = 0; i &lt; group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0) tnsum1[0] = tn1[0], tnsum2[0] = tn2[0];</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tnsum1[i] = tnsum1[i - 1] + tn1[i];</span><br><span class="line">            tnsum2[i] = tnsum2[i - 1] + tn2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // dp.</span><br><span class="line">    for(int i = 0; i &lt;= group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i][0] = dp1[i][1] = dp2[i][0] = dp2[i][1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            // head -&gt; tail</span><br><span class="line">            dp1[i][0] = tn1[i - 1];</span><br><span class="line">            dp1[i][1] = 1 + (M - tn1[i - 1]);</span><br><span class="line">            </span><br><span class="line">            // tail -&gt; head</span><br><span class="line">            dp2[i][0] = tn2[i - 1];</span><br><span class="line">            dp2[i][1] = 1 + (M - tn2[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // head -&gt; tail</span><br><span class="line">            dp1[i][0] = min(</span><br><span class="line">                dp1[i - 1][0] + tn1[i - 1],</span><br><span class="line">                dp1[i - 1][1] + tn1[i - 1]</span><br><span class="line">            );</span><br><span class="line">            dp1[i][1] = min(</span><br><span class="line">                dp1[i - 1][0] + 2 + (M - tn1[i - 1]),</span><br><span class="line">                dp1[i - 1][1] + (M - tn1[i - 1])</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            // tail -&gt; head</span><br><span class="line">            dp2[i][0] = min(</span><br><span class="line">                dp2[i - 1][0] + tn2[i - 1],</span><br><span class="line">                dp2[i - 1][1] + tn2[i - 1]</span><br><span class="line">            );</span><br><span class="line">            dp2[i][1] = min(</span><br><span class="line">                dp2[i - 1][0] + 2 + (M - tn2[i - 1]),</span><br><span class="line">                dp2[i - 1][1] + (M - tn2[i - 1])</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minans = 100000000;</span><br><span class="line">    for(int i = 0; i &lt;= group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0; j &lt;= group - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int zzl = i;</span><br><span class="line">            int zzr = group - j - 1;</span><br><span class="line">            </span><br><span class="line">            minans = min(minans,</span><br><span class="line">                min(dp1[i][0], dp1[i][1]) +</span><br><span class="line">                min(dp2[j][0], dp2[j][1]) +</span><br><span class="line">                calcsum(zzl, zzr)</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return minans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　好久没撸 &lt;strong&gt;TC&lt;/strong&gt; 了，手都生了。前两天刚折腾好 &lt;strong&gt;LinuxMint&lt;/strong&gt; + &lt;strong&gt;Cinnamon&lt;/strong&gt;，顺便手贱把 &lt;strong&gt;TC&lt;/strong&gt; 环境配好了。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://xcoder.in/categories/Programming/"/>
    
    
      <category term="TopCoder" scheme="https://xcoder.in/tags/TopCoder/"/>
    
      <category term="SRM" scheme="https://xcoder.in/tags/SRM/"/>
    
  </entry>
  
  <entry>
    <title>一起撸Node.JS（壹）——基本语法和类型</title>
    <link href="https://xcoder.in/2013/08/16/node-4-base/"/>
    <id>https://xcoder.in/2013/08/16/node-4-base/</id>
    <published>2013-08-15T16:00:00.000Z</published>
    <updated>2017-12-11T07:59:20.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Node.js</strong> 的基础是 <strong>JavaScript</strong> 这门 <strong><em>脚本语言</em></strong>。而大多数的脚本语言一个共同的特点就是“<a href="http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.92.8C.E5.BC.B1.E5.9E.8B.E5.88.A5" target="_blank" rel="external">弱类型</a>”。</p><p>　　不同于 <strong>PHP</strong> 的是，<strong>PHP</strong> 就是是有了新变量也无需申明，而 <strong>JavaScript</strong> 则还是需要 <code>var</code> 来申明一下的。而这个 <code>var</code> 涵盖了 <strong>C++</strong> 中的<code>int</code>、<code>string</code>、<code>char</code>等一切类型的含义，甚至是 <code>function</code>。</p><p>　　本篇以及后篇的所有内容都是在 <strong>Linux</strong> 或者 <strong>Cygwin</strong> 下用 <strong>vim</strong> 进行编辑（若不是则请自行转变成你自己的方法），然后在命令行下进行查看结果的。</p><!-- 我是小小分割符 --><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在 <strong>C/C++</strong> 中，我们这么声明变量的：</p><figure class="highlight plain"><figcaption><span>c++</span></figcaption><table><tr><td class="code"><pre><span class="line">void foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">int a = 0;</span><br><span class="line">char b = &apos;a&apos;;</span><br><span class="line">float c = 1.0f;</span><br><span class="line">void (*d)() = foo;  ///&lt; 忘了是不是这么写的了，总之是函数指针</span><br></pre></td></tr></table></figure><p>而在 <strong>Node.js</strong> 中则是这样的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a = 0;</span><br><span class="line">var b = &apos;a&apos;;</span><br><span class="line">var c = 1.0;</span><br><span class="line">var d = foo;</span><br></pre></td></tr></table></figure><p>所以，无论是什么类型的变量，在 <strong>Node.js</strong> 中都是以一个 <code>var</code> 来解决的。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for…i"><a href="#for…i" class="headerlink" title="for…i"></a>for…i</h4><p>这个循环语句基本上跟 <strong>C/C++</strong> 一样，都是</p><figure class="highlight plain"><figcaption><span>c++</span></figcaption><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; foo; i++)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而鉴于 <strong>Node.js</strong> 是弱类型，所以只需要：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">for(var i = 0; i &lt; foo; i++) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>这是一种后有型的循环语句，类似于 <strong>PHP</strong> 的 <code>foreach</code>。</p><p>比如我们有一个 <strong>JSON对象</strong> 如下：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    &quot;hello&quot;     : &quot;world&quot;,</span><br><span class="line">    &quot;node&quot;      : &quot;js&quot;,</span><br><span class="line">    &quot;blahblah&quot;  : &quot;bar&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以用 <code>for...in</code> 来循环遍历了：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">for(var key in foo) &#123;</span><br><span class="line">    console.log(key + &quot;: &quot; + foo[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果在命令行中打入下面的命令：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ node foo.js</span><br></pre></td></tr></table></figure><p>屏幕上就会显示下面的内容了：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">hello: world</span><br><span class="line">node: js</span><br><span class="line">blahblah: bar</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：由上可知，<code>for...in</code> 语句是用来遍历 <strong>JSON对象</strong>、<strong>数组</strong>、<strong>对象</strong>的键名的，而不提供键值的遍历。如果要获取键值，只能通过</p></blockquote><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">foo[&lt;当前键名&gt;]</span><br></pre></td></tr></table></figure><p>的形式来获取。这个跟 <strong>PHP</strong> 的 <code>foreach</code> 还是有一定区别的。</p><h4 id="while…do-do…while"><a href="#while…do-do…while" class="headerlink" title="while…do, do…while"></a>while…do, do…while</h4><p>这个就不多做解释了，跟其它语言没什么大的区别，无非就是如果有变量声明的话，需要用 <code>var</code> 就够了。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id=""><a href="#" class="headerlink" title="+, -, *, /"></a>+, -, *, /</h4><p>这几个运算符也就这样，要注意的是 <code>+</code>。它既可以作用于字符串，也可以作用于数值运算。弱类型语言虽然说类型是弱的，数字有时候可以以字符串的形态出现，字符串有时候可以用数值的形态出现，但是在必要的时候也还是要说一下它是什么类型的，我们可以用下面的代码去看看结果：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var a = &quot;1&quot;;</span><br><span class="line">var b = 2;</span><br><span class="line">console.log(a + b);</span><br><span class="line">console.log(parseInt(a) + b);</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>parseInt</code> 是 <strong>Node.js</strong> 的一个内置函数，作用是将一个字符串解析成 <code>int</code> 类型的变量。</p></blockquote><p>上面的代码执行结果是</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>第一个 <code>console.log</code> 结果是 <code>12</code>，由于 <code>a</code> 是字符串，所以 <code>b</code> 也被系统以字符串的姿态进行加操作，结果就是将两个字符串黏连在一起就变成了 <code>12</code>。而第二个 <code>console.log</code> 结果是 <code>3</code>，是因为我们将第一个 <code>a</code> 转变为了 <code>int</code> 类型，两个 <code>int</code> 型的变量相加即数值相加，结果当然就是 <code>3</code> 了。</p><h4 id="-1"><a href="#-1" class="headerlink" title="==, ===, !=, !=="></a>==, ===, !=, !==</h4><p>这里有一点要解释，当这个逻辑运算符长度为 <code>2</code> 的时候（<code>==</code>, <code>!=</code>），只是判断外在的值是不是一样的，而不会判断类型。如</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var a = 1, b = &quot;1&quot;;</span><br><span class="line">console.log(a == b);</span><br></pre></td></tr></table></figure><p>它输出的结果就是 <code>true</code>。但是如果我们在中间判断的时候再加上一个等号，那么就是严格判断了，需要类型和值都一样的时候才会是 <code>true</code>，否则就是 <code>false</code>。也就是说</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var a = 1, b = &quot;1&quot;;</span><br><span class="line">console.log(a === b);</span><br></pre></td></tr></table></figure><p>的时候，返回的结果就是 <code>false</code> 了，因为 <code>a</code> 是 <code>int</code> 型的，而 <code>b</code> 则是字符串。</p><blockquote><p>顺带着就把条件语句讲了吧，其实这里的 <code>if</code> 跟别的语言没什么两样，就是几个逻辑运算符两个等号三个等号的问题。所以就不多做累述了。</p></blockquote><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>这里我姑且把它当成是一个运算符而不是函数了。</p><p>这个运算符的作用是判断一个变量的类型，会返回一个字符串，即类型名，具体的执行下面的代码就知道了：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a = 0;</span><br><span class="line">var b = &apos;嘘~蛋花汤在睡觉。&apos;;</span><br><span class="line">var c = 1.0;</span><br><span class="line">var d = foo;</span><br><span class="line">var e = &#123; &quot;a&quot; : a &#125;;</span><br><span class="line">var f = [ 1, 2, 3 ];</span><br><span class="line">var g = null;</span><br><span class="line">var h = undefined;</span><br><span class="line"></span><br><span class="line">console.log(typeof a);</span><br><span class="line">console.log(typeof b);</span><br><span class="line">console.log(typeof c);</span><br><span class="line">console.log(typeof d);</span><br><span class="line">console.log(typeof e);</span><br><span class="line">console.log(typeof f);</span><br><span class="line">console.log(typeof g);</span><br><span class="line">console.log(typeof h);</span><br></pre></td></tr></table></figure><p>这里的执行结果就将会是：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">number</span><br><span class="line">string</span><br><span class="line">number</span><br><span class="line">function</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><h3 id="null-undefined-NaN"><a href="#null-undefined-NaN" class="headerlink" title="null, undefined, NaN"></a>null, undefined, NaN</h3><p>在 <strong>JavaScript</strong> 中，有三个特殊的值，如标题所示。其中第一个大家可能都比较熟悉吧，<strong>C/C++</strong> 里面也有，不过是大写的，其本质就是一个</p><figure class="highlight plain"><figcaption><span>c++</span></figcaption><table><tr><td class="code"><pre><span class="line">#define NULL 0</span><br></pre></td></tr></table></figure><p>而在 <strong>JavaScript</strong> 中，这三个值所代表的意义都不同。</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p><code>null</code> 是一种特殊的 <strong>object</strong>，大致的意思就是空。比如说：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var a = null;</span><br></pre></td></tr></table></figure><p>大家都能看懂，就不多做解释了。但是跟 <strong>C/C++</strong> 不同的是，这个 <code>null</code> 跟 <code>0</code> 不相等。</p><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>这个东西的意思就是说这个变量未声明。为了能够更好地区分 <code>null</code>，我们的样例代码如下写：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    &quot;foo&quot;       : null</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a[&quot;foo&quot;]);</span><br><span class="line">console.log(a[&quot;bar&quot;]);</span><br></pre></td></tr></table></figure><p>上面的代码中，我们让 <code>a[&quot;foo&quot;]</code> 的值为空，即 <code>null</code>。而压根没有声明 <code>a[&quot;bar&quot;]</code> 这个东西，它连空都不是。输出的结果大家都差不多应该猜到了：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>这是一个空的数值，是一个特殊的 <code>number</code>。它的全称是 <code>Not a Number</code>。有点奇怪，大家可以理解为 <strong>不是数字形态，或者数值出错的 <code>number</code> 类型变量</strong>。</p><p>多在浮点型数值运算错误（如被0除）的情况下出现，甚至可以是用户自己让一个变量等于 <code>NaN</code> 以便返回一个错误值让大家知道这个函数运算出错了云云。</p><h3 id="小杂碎"><a href="#小杂碎" class="headerlink" title="小杂碎"></a>小杂碎</h3><p>其它剩余的语句也跟已存在的其它语言差不多，比如说 <code>break</code> 啊、<code>switch</code> 啊、<code>continue</code> 啊等等等等。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>这一节主要讲的是 <strong>JavaScript</strong> 对象，其它类型差不多一带而过吧。</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p><strong>Node.js</strong> 包含的基础类型差不多有如下几个：</p><ul><li>number</li><li>string</li><li>boolean</li><li>array</li></ul><p>其中前三种类型可以直接赋值，而 <code>array</code> 的赋值只是一个引用赋值而已，在新变量中改变某个值的话旧变量的值也会改变，直接可以试试下面的代码：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var foo = [ 1, 2, 3 ];</span><br><span class="line">var bar = foo;</span><br><span class="line">bar[0] = 3;</span><br><span class="line">console.log(foo);</span><br></pre></td></tr></table></figure><p>它得出的结果是：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">[ 3, 2, 3 ]</span><br></pre></td></tr></table></figure><p>也就是说 <code>array</code> 要是复制出一个新的数组的话，不能用直接赋值的方法，而必须“<strong><a href="#深拷贝">深拷贝</a></strong>”。</p><p>这里有必要讲一下 <code>array</code> 的三种创建方法。</p><p>第一种：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var dog = new Array();</span><br><span class="line">dog[0] = &quot;嘘~&quot;;</span><br><span class="line">dog[1] = &quot;蛋花汤&quot;;</span><br><span class="line">dog[2] = &quot;在睡觉&quot;;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var dog = new Array( &quot;嘘~&quot;, &quot;蛋花汤&quot;, &quot;在睡觉&quot; );</span><br></pre></td></tr></table></figure><p>第四种：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var dog = [</span><br><span class="line">    &quot;嘘~&quot;,</span><br><span class="line">    &quot;蛋花汤&quot;,</span><br><span class="line">    &quot;在睡觉&quot;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>我个人比较喜欢第三种写法，比较简洁。</p><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>这里我把 <strong>JSON对象</strong> 单独拎出来而不是把它归类为 <strong>JavaScript对象</strong>，如果觉得我有点误人子弟就可以直接跳过这一节了。</p><p>本人对于 <strong>JSON对象</strong> 和 <strong>JavaScript</strong> 对象的区分放在 <strong>是否只用来存储数据，而并非是一个类的实例化</strong>。其实 <strong>JSON</strong> 的本质便是 <strong>JavaScript Object Notation</strong>。</p><blockquote><p>更多有关 <strong><a href="http://zh.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a></strong> 的信息请自行百科。</p></blockquote><p>在 <strong>Node.js</strong> 中声明一个 <strong>JSON对象</strong> 非常简单：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var dog = &#123;</span><br><span class="line">    &quot;pre&quot;       : &quot;嘘~&quot;,</span><br><span class="line">    &quot;sub&quot;       : &#123;</span><br><span class="line">        &quot;name&quot;  : &quot;蛋花汤&quot;,</span><br><span class="line">        &quot;act&quot;   : &quot;在睡觉&quot;,</span><br><span class="line">        &quot;time&quot;  : 12</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;suf&quot;       : [ &quot;我说了&quot;, &quot;它在睡觉&quot;, &quot;就是在睡觉&quot; ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有两种方式能得到 <strong>JSON对象</strong> 中的某个键名的键值，第一种是用点连接，第二种是用中括号：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">dog.pre;</span><br><span class="line">dog[&quot;pre&quot;];</span><br></pre></td></tr></table></figure><blockquote><p><strong>试试看</strong>：现在你自己动手试试看，用 <code>for...in</code> 的形式遍历一遍上面的 <code>JSON对象</code>。别忘了用上 <code>typeof</code> 喵~</p></blockquote><h3 id="类（对象）的基础"><a href="#类（对象）的基础" class="headerlink" title="类（对象）的基础"></a>类（对象）的基础</h3><p>严格意义上来讲，<strong>Node.js</strong> 的类不能算是类，其实它只是一个函数的集合体，加一些成员变量。它的本质其实是一个函数。</p><p>不过为了通俗地讲，我们接下去以及以后都将其称为“类”，实例化的叫“对象”。</p><p>因为类有着很多 <strong>函数</strong> 的特性，或者说它的本质就是一个 <strong>函数</strong>，所以这里面我们可能一不留神就顺带着把函数基础给讲了。</p><h4 id="类的声明和实例化"><a href="#类的声明和实例化" class="headerlink" title="类的声明和实例化"></a>类的声明和实例化</h4><p>声明一个类非常简单，大家不要笑：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我们已经写好了一个 <code>foo</code> 类了。</p><blockquote><p>真的假的？！真的。</p></blockquote><p>不信？不信你可以接下去打一段代码看看：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var bar = new foo();</span><br></pre></td></tr></table></figure><p>别看它是一个函数，如果以这样的形式（<code>new</code>）写出来，它就是这个类的实例化。</p><p>而这个所谓的 <code>foo()</code> 其实就是这个 <code>foo()</code> 类的构造函数。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量有好两种方法。</p><p>第一种就是在类的构造函数或者任何构造函数中使用 <code>this.&lt;变量名&gt;</code> 。你可以在任何时候声明一个成员变量，在外部不影响使用，反正就算在还未声明的时候使用它，也会有一个 <code>undefined</code> 来撑着。所以说这就是第一种方法：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.hello = &quot;world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：只有在加了 <code>this</code> 的时候才是调用类的<strong>成员变量</strong>，否则只是函数内的一个局部变量而已。要分清楚有没有 <code>this</code> 的时候变量的作用范围。</p></blockquote><p>第二种方法就是在构造函数或者任何成员函数外部声明，其格式是 <code>&lt;类名&gt;.prototype.&lt;变量名&gt;</code>：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.prototype.hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure><p>无聊上面哪种方法都是对成员变量的声明，我们可以看看效果：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var bar = new foo();</span><br><span class="line">console.log(bar.hello);</span><br></pre></td></tr></table></figure><p>甚至你可以这么修改这个类：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.hello = &quot;world&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.prototype.hello = &quot;蛋花汤&quot;;</span><br></pre></td></tr></table></figure><p>然后再用上面的代码输出。</p><blockquote><p>想想看为什么输出的还是 <code>world</code> 而不是 <code>蛋花汤</code>。</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们之前说过了这个 <code>foo()</code> 实际上是一个 <strong>构造函数</strong>。那么显然我们可以给构造函数传参数，所以就有了下面的代码：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">// 代码2.1</span><br><span class="line">function foo(hello) &#123;</span><br><span class="line">    if(hello === undefined) &#123;</span><br><span class="line">        this.hello = &quot;world&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到上面有一个奇葩的判断 <code>if(hello === undefined)</code>，这个判断有什么用呢？第一种可能，就是开发者很蛋疼地特意传进去一个 <code>undefined</code> 进去，这个时候它是 <code>undefined</code> 无可厚非。</p><p>还有一种情况。我们一开始就说了 <strong>JavaScript</strong> 是一门弱类型语言，其实不仅仅是弱类型，它的传参数也非常不严谨。你可以多传或者少传（只要保证你多传或者少传的时候可以保证程序不出错，或者逻辑不出错），原则上都是可以的。多传的参数会被自动忽略，而少传的参数会以 <code>undefined</code> 补足。</p><p>看看下面的代码就明白了：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">// 上接代码2.1</span><br><span class="line">var bar1 = new foo();</span><br><span class="line">var bar2 = new foo(&quot;蛋花汤&quot;);</span><br></pre></td></tr></table></figure><p>请自行输出一下两个 <code>bar</code> 的 <code>hello</code> 变量，会发现一个是 <strong>world</strong> 一个是 <strong>蛋花汤</strong>。显而易见，我们的第一个 <code>bar1</code> 在声明的时候，被 <strong>Node.js</strong> 自动看成了：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var bar1 = new foo(undefined);</span><br></pre></td></tr></table></figure><p>所以就有了它是 <strong>world</strong> 一说。</p><p>还有就是在这个构造函数中，我们看到了传进去的参数是 <code>hello</code> 而这个类中本来就有个成员变量就是 <code>this.hello</code>。不过我们之前说过了有 <code>this</code> 和没 <code>this</code> 的时候作用域不同，那个参数只是作用于构造函数中，而加了 <code>this</code> 的那个则是成员变量。用一个 <code>this</code> 就马上区分开来他们了，所以即使同名也没关系。</p><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><h5 id="成员函数声明"><a href="#成员函数声明" class="headerlink" title="成员函数声明"></a>成员函数声明</h5><p>成员函数的声明跟成员变量的第二种声明方法差不多，即 <code>&lt;类名&gt;.prototype.&lt;函数名&gt; = &lt;函数&gt;;</code></p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">// 上接代码2.1</span><br><span class="line">function setHello(hello) &#123;</span><br><span class="line">    this.hello = hello;</span><br><span class="line">&#125;</span><br><span class="line">foo.prototype.setHello = setHello;</span><br><span class="line"></span><br><span class="line">bar1.setHello(&quot;鸡蛋饼&quot;);</span><br></pre></td></tr></table></figure><p>上面这段代码显而易见，我们实现了 <code>foo</code> 类的 <code>setHello</code> 函数，能通过它修改 <code>foo.hello</code> 的值。</p><p>但是这么写是不是有点麻烦？接下去我要讲一个 <strong>JavaScript</strong> 函数重要的特性了。</p><h4 id="★-匿名函数"><a href="#★-匿名函数" class="headerlink" title="★ 匿名函数"></a>★ 匿名函数</h4><p>很多时候我们的某些函数只在一个地方被引用或者调用，那么我们为这个函数起一个名字就太不值了，没必要，所以我们可以临时写好这个函数，直接让引用它的人引用它，调用它的人调用它。所以函数可以省略函数名，如：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function(hello) &#123;</span><br><span class="line">    this.hello = hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于怎么引用或者调用呢？如果是上面的那个类需要引用的话，就是写成这样的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">foo.prototype.setHello = function(hello) &#123;</span><br><span class="line">    this.hello = hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法跟 <strong><a href="#成员函数声明">2.3.3.1. 成员函数声明</a></strong> 是一个效果的，而且省了很多的代码量。而且实际上，基本上的类成员函数的声明都是采用这种匿名函数的方式来声明的。</p><p>至于说怎么样让匿名函数被调用呢？这通常用于传入一个只被某个函数调用的函数时这样写。</p><p>比如我们有一个函数的原型是：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我们将传入a，b两个变量，</span><br><span class="line"> * 在算出a+b的值后，交由func(num)</span><br><span class="line"> * 去进行输出</span><br><span class="line"> */</span><br><span class="line">function sumab(a, b, func) &#123;</span><br><span class="line">    var c = a + b;</span><br><span class="line">    func(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们有两个版本的输出函数，一个是中文输出，一个是英文输出，那么如果不用匿名函数时候是这么写的：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function zh(a, b, sum) &#123;</span><br><span class="line">    console.log(a + &quot; + &quot; + b + &quot; 的值是：&quot; + sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function en(a, b, sum) &#123;</span><br><span class="line">    console.log(a + &quot; plus &quot; + b + &quot; is &quot; + sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumab(1, 2, zh);</span><br><span class="line">sumab(3, 4, en);</span><br></pre></td></tr></table></figure><p>执行一遍这段代码，输出的结果将会是：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">1 + 2 的值是：3</span><br><span class="line">3 plus 4 is 7</span><br></pre></td></tr></table></figure><p>这样的代码如果采用匿名函数的形式则将会是：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">sumab(1, 2, function(a, b, sum) &#123;</span><br><span class="line">    console.log(a + &quot; + &quot; + b + &quot; 的值是：&quot; + sum);</span><br><span class="line">&#125;);</span><br><span class="line">sumab(3, 4, function(a, b, sum) &#123;</span><br><span class="line">    console.log(a + &quot; plus &quot; + b + &quot; is &quot; + sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种形式通常使用于回调函数。回调机制算是 <strong>Node.js</strong> 或者说 <strong>JavaScript</strong> 的精髓。在以后的篇章会做介绍。</p><h4 id="成员函数声明的匿名函数声明方式"><a href="#成员函数声明的匿名函数声明方式" class="headerlink" title="成员函数声明的匿名函数声明方式"></a>成员函数声明的匿名函数声明方式</h4><p>虽然上一节讲过了，不过还是再讲一遍吧。</p><p>通常我们声明类的成员函数时候都是用匿名函数来声明的，因为反正那个函数也就是这个类的一个成员函数而已，不会在其它地方被单独引用或者调用，所以就有了下面的代码：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">// 上接代码2.1</span><br><span class="line">foo.prototype.setHello = function(hello) &#123;</span><br><span class="line">    this.hello = hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就使得 <code>foo</code> 类有了 <code>setHello</code> 这个函数了。</p><h4 id="类的随意性"><a href="#类的随意性" class="headerlink" title="类的随意性"></a>类的随意性</h4><p>这个又是我胡扯的。所谓类的随意性即 <strong>JavaScript</strong> 中你可以在任何地方修改你的类，这跟 <strong>Ruby</strong> 有着一定的相似之处。</p><p>比如说 <code>string</code> ，它其实也是一个类，有着诸如 <code>length</code> 这样的成员变量，也有 <code>indexOf</code>、<code>substr</code> 等成员函数。但是万一我们觉得这个 <code>string</code> 有些地方不完善，想加自己的方法，那么可以在你想要的地方给它增加一个函数，比如：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">String.prototype.sb = function() &#123;</span><br><span class="line">    var newstr = &quot;&quot;;</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if(i % 2 === 0) newstr += &quot;s&quot;;</span><br><span class="line">        else newstr += &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newstr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数的意思就是填充一个字符串，使其变成 <code>sb</code> 的化身。</p><p>我们来测试一下：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">var str = &quot;嘘~蛋花汤在睡觉。&quot;;</span><br><span class="line">console.log(str.sb());</span><br></pre></td></tr></table></figure><p>你将会得到这样的结果：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">sbsbsbsbs</span><br></pre></td></tr></table></figure><blockquote><p>你跟你的电脑说“嘘~蛋花汤在睡觉。”，你的电脑会骂你四次半傻逼。（赶快砸了它）</p></blockquote><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>所谓深拷贝就是自己新建一个数组或者对象，把源数组或者对象中的基础类型变量值一个个手动拷过去，而不是只把源数组或者对象的引用拿过来。所以这就涉及到了一个递归的调用什么的。</p><p>下面是我实现的一个深拷贝函数，大家可以写一个自己的然后加入到自己的 <strong>Node.js</strong> 知识库中。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">function cloneObject(src) &#123;</span><br><span class="line">    var dest = &#123;&#125;;</span><br><span class="line">    for(var key in src) &#123;</span><br><span class="line">        if(typeof src === &quot;object&quot;) dest[key] = cloneObject(src[key]);</span><br><span class="line">        else dest[key] = src[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统默认对象参考手册"><a href="#系统默认对象参考手册" class="headerlink" title="系统默认对象参考手册"></a>系统默认对象参考手册</h3><ul><li><strong>字符串</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_string.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_string.asp</a></li><li><strong>数字</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_number.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_number.asp</a></li><li><strong>数组</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_array.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_array.asp</a></li><li><strong>布尔</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_boolean.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_boolean.asp</a></li><li><strong>日期</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_date.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_date.asp</a></li><li><strong>数学库</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_math.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_obj_math.asp</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt; 的基础是 &lt;strong&gt;JavaScript&lt;/strong&gt; 这门 &lt;strong&gt;&lt;em&gt;脚本语言&lt;/em&gt;&lt;/strong&gt;。而大多数的脚本语言一个共同的特点就是“&lt;a href=&quot;http://zh.wikiped
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="JavaScript" scheme="https://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="https://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node-JS/"/>
    
  </entry>
  
  <entry>
    <title>一起撸Node.JS（负贰）——环境</title>
    <link href="https://xcoder.in/2013/08/15/node-2-environment-in-windows/"/>
    <id>https://xcoder.in/2013/08/15/node-2-environment-in-windows/</id>
    <published>2013-08-14T16:00:00.000Z</published>
    <updated>2017-12-11T07:59:20.523Z</updated>
    
    <content type="html"><![CDATA[<p>　　由于<a href="!--￼11--&gt;#linux-环境">Linux</a>中的环境搭建比较简单，所以草草略过。</p><p>　　其实<a href="!--￼12--&gt;#windows-环境">Windows</a>下也不算麻烦，但是这里会讲一定量的别的环境的搭建。</p><!-- 我是小小分割符 --><h2 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h2><p>讲到这个就很简单了，跟着下面的 <strong>bash</strong> 操作即可：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd /usr/local/bin</span><br><span class="line">$ wget http://nodejs.org/dist/v0.00.00/node-v0.00.00-linux-x00.tar.gz</span><br><span class="line">$ tar zxf node-v0.00.00-linux-x00.tar.gz</span><br><span class="line">$ cd node-v0.00.00-linux-x00</span><br></pre></td></tr></table></figure><blockquote><p>其中将上方的 <strong>v0.00.00</strong> 替换成 <strong>Node.js</strong> 最新的版本号，把 <strong>x00</strong> 替换成你自己电脑的位数。</p><p>也可以直接去官网 <a href="http://nodejs.org/download/" target="_blank" rel="external">http://nodejs.org/download/</a> 找到相应的地址。</p></blockquote><p>最后将其的连接加入到 <code>/usr/bin</code> 下即可。</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd bin</span><br><span class="line">$ ln node /usr/bin</span><br><span class="line">$ ln npm /usr/bin</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 该用 <code>sudo</code> 的地方就用 <code>sudo</code> 或者 <code>su</code> 。</p></blockquote><p>至此，<strong>Linux</strong> 下的 <strong>Node.js</strong> 环境基本搭建完毕。</p><h2 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h2><h3 id="Cygwin-安装和配置"><a href="#Cygwin-安装和配置" class="headerlink" title="Cygwin 安装和配置"></a>Cygwin 安装和配置</h3><p><strong><em>Cygwin</em></strong> 是一个在 <strong><em>Windows</em></strong> 平台上运行的 <strong><em>Unix</em></strong> 模拟环境。对于学习 <strong><em>Unix/Linux</em></strong> 操作环境，或者从 <strong><em>Unix</em></strong> 到 <strong><em>Windows</em></strong> 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 <strong><em>GNU工具集</em></strong> 在 <strong><em>Windows</em></strong> 上进行嵌入式系统开发，非常有用。</p><h4 id="Cygwin-安装"><a href="#Cygwin-安装" class="headerlink" title="Cygwin 安装"></a>Cygwin 安装</h4><p>我们先跑到 <strong>Cygwin</strong> 的官网上去把东西下来：</p><blockquote><p><a href="http://cygwin.com/install.html" target="_blank" rel="external">http://cygwin.com/install.html</a></p><blockquote><p>注意，最好下 <strong>x86</strong> 的包，因为我们之后要讲一个 <code>cyg-apt</code> 的脚本插件，这是一个能让 <strong>Cygwin</strong> 能跟 <strong>Linux</strong> 一样通过脚本从源安装软件包的脚本。为了方便修改，我们将其下成 <strong>x86</strong> 的版本。</p></blockquote></blockquote><p>然后就是安装步骤了。</p><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-1.png" alt="从网络安装"></center><br><center><small>[图2.1]</small></center><p>到 <strong>[图2.1]</strong> 这个步骤的时候，选择默认的 <code>Install from Internet</code> 即可。</p><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-2.png" alt="选择安装路径"></center><br><center><small>[图2.2]</small></center><p>在 <strong>[图2.2]</strong> 的时候选一个安装路径。</p><blockquote><p><strong>注意</strong>：尽可能让这个安装路径简单，而不要是类似于</p><p><code>c:\Program Files\blahblah</code></p><p>这样的文件路径。</p></blockquote><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-3.png" alt="本地包路径"></center><br><center><small>[图2.3]</small></center><p><strong>[图2.3]</strong> 的时候选一个本地包的路径，我这里选的是 <code>e:\cygwin\tmp</code>。</p><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-4.png" alt="直连"></center><br><center><small>[图2.4]</small></center><p><strong>[图2.4]</strong> 选择直接连接。</p><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-5.png" alt="163"></center><br><center><small>[图2.5]</small></center><p>我们国内的用户源还是选择 <code>163</code> 的速度比较快。所以在 <strong>[图2.5]</strong> 这一步的时候就直接选用默认的 <code>163</code> 的源了。如果不是默认的话，请选中它。</p><p>在 <strong>Select Package</strong> 也就是选择预安装的软件的时候，把下列表中的软件包勾选起来：</p><blockquote><ul><li><strong>wget</strong>: 在 <strong>Utils</strong> 中</li><li><strong>vim</strong>: 在 <strong>Editors</strong> 中</li><li><strong>gcc</strong>: 在 <strong>Devel</strong> 中</li><li><strong>gcc-g++</strong>: 在 <strong>Devel</strong> 中</li><li><strong>make</strong>: 在 <strong>Devel</strong> 中</li><li><strong>cmake</strong>: 在 <strong>Devel</strong> 中</li></ul></blockquote><p>若是这些选项已经被选起来了就不用再选了，如果没有选起来则把它选中。</p><p>勾选好了之后就可以下一步安装了，直至安装完毕，你就可以打开你的 <strong>Cygwin</strong> 了。</p><center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-6.png" alt="Cygwin"></center><br><center><small>[图2.6]</small></center><blockquote><p><strong>提示</strong>：你可以点击窗口左上角的小图片，然后里面的 <strong>Options</strong> 中，你可以调整你自己的 <strong>Cygwin</strong> 外观。</p></blockquote><h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p>上一步我们已经选中了 <strong>vim</strong> ，也就是说我们已经在 <strong>Cygwin</strong> 中装上了 <strong>vim</strong>。但是由于这里的 <strong>vim</strong> 默认配置非常蛋疼，所以我们得改一下。</p><p>在你的 <strong>Cygwin</strong> 中一句句输入下面的命令：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd /home/&lt;你自己的用户名&gt;</span><br><span class="line">$ wget http://blog-xcoder-in.qiniudn.com/.vimrc</span><br><span class="line">$ mkdir .vim</span><br><span class="line">$ cd .vim</span><br><span class="line">$ mkdir colors</span><br><span class="line">$ cd colors</span><br><span class="line">$ wget http://blog-xcoder-in.qiniudn.com/molokai.vim</span><br></pre></td></tr></table></figure><p>这样你的 <strong>vim</strong> 就用上了上面的那个地址的配置文件，当然你也可以编辑你自己的配置文件或者说从网上下别的配置文件以满足你的个性化需求。</p><p><strong>vim</strong> 配置以及使用请参照：<a href="https://wiki.archlinux.org/index.php/Vim" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Vim</a></p><blockquote><p>事无巨细问 <strong>ArchWiki</strong>。</p><div style="text-align: right;"><em>– <a href="https://github.com/kalxd" target="_blank" rel="external">kalxd</a></em></div></blockquote><h3 id="apt-cyg"><a href="#apt-cyg" class="headerlink" title="apt-cyg"></a>apt-cyg</h3><blockquote><p>apt-cyg is a command-line installer for Cygwin which cooperates with Cygwin Setup and uses the same repository. The syntax is similar to apt-get.</p><div style="text-align: right;"><em>– From apt-cyg googlecode page</em></div></blockquote><p>总之意思就是说 <code>apt-cyg</code> 是类似于 <strong>Linux</strong> 中的 <code>apt-get</code>， <code>yum</code>, <code>zypper</code> 等命令行软件包安装器一样，可以通过</p><ul><li><code>apt-cyg install &lt;package names&gt;</code> 来安装软件包</li><li><code>apt-cyg remove &lt;package names&gt;</code> 来移除软件包</li><li><code>apt-cyg update</code> 来更新 setup.ini</li><li><code>apt-cyg show</code> 来列出已安装的软件包</li><li><code>apt-cyg find &lt;pattern(s)&gt;</code> 来查找符合条件的软件包</li><li><code>apt-cyg describe &lt;pattern(s)&gt;</code> 来描述符合条件的软件包</li><li><code>apt-cyg packageof &lt;commands or files&gt;</code> 来定位其父软件包</li></ul><h4 id="apt-cyg-安装"><a href="#apt-cyg-安装" class="headerlink" title="apt-cyg 安装"></a>apt-cyg 安装</h4><p>其实也不能说是安装，纯粹是把脚本从网络上拷到自己的 <strong>Cygwin</strong> 的环境目录中。</p><p>在你的 <strong>Cygwin</strong> 中输入以下命令：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ cd /usr/local/bin</span><br><span class="line">$ wget http://apt-cyg.googlecode.com/svn/trunk/apt-cyg</span><br></pre></td></tr></table></figure><p>这样你就“安装”好了 <strong>apt-cyg</strong> 了。不过这里用的是默认的源，所有东西都是默认的。</p><p>如果你现在已经心安理得或者不想折腾了可以跳过 <strong><a href="#apt-cyg-修改">2.1.3.2. apt-cyg 修改</a></strong>，如果你想把源换成 <code>163</code> 的话那么稍微看一下吧。</p><h4 id="apt-cyg-修改"><a href="#apt-cyg-修改" class="headerlink" title="apt-cyg 修改"></a>apt-cyg 修改</h4><p>接下去我们要对 <strong>apt-cyg</strong> 做一些编辑。</p><p>你有下面两个选择：</p><ol><li>如果你想学习 <strong>vim</strong> 操作或者你已经熟悉了，那么直接使用 <code>vim apt-cyg</code> 来进行编辑。</li><li>如果你是懒人还是想要直接编辑的话，请跑到你的 <strong>Cygwin</strong> 的安装目录，找到 <strong>usr</strong> 文件夹，飞进 <strong>local/bin</strong> 目录中去，用你自己喜欢的文本编辑器打开并编辑。</li></ol><p>大约是 <code>68</code> 行上下吧，有一句是：</p><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">mirror=ftp://mirror.mcs.anl.gov/pub/cygwin</span><br></pre></td></tr></table></figure><p>将其改成：</p><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">mirror=http://mirrors.163.com/cygwin</span><br></pre></td></tr></table></figure><p>还有就是大概在 <code>98</code> 行和 <code>105</code> 行左右：</p><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">wget -N $mirror/setup.bz2</span><br><span class="line">...</span><br><span class="line">wget -N $mirror/setup.ini</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">wget -N $mirror/x86/setup.bz2</span><br><span class="line">...</span><br><span class="line">wget -N $mirror/x86/setup.ini</span><br></pre></td></tr></table></figure><p>至此，你的 <strong>Cygwin</strong> 环境基本完成，以后可以再慢慢完善。</p><h3 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a>Node.js 安装</h3><p>这个就很简单了，打开 <strong><a href="http://nodejs.org/download/" target="_blank" rel="external">Node.js</a></strong> 官网下载安装即可。</p><blockquote><p>选择 <strong>Windows Installer (.msi)</strong> 或者 <strong>Windows Binary (.exe)</strong>。</p></blockquote><p>安装好后就能直接在 <strong>Cygwin</strong> 里面使用了。</p><h2 id="真·Hello-World"><a href="#真·Hello-World" class="headerlink" title="真·Hello World"></a>真·Hello World</h2><p>现在，无论你是 <strong>Linux</strong> 用户还是 <strong>Windows</strong> 用户，都可以用一样的步骤来完成下面的 <code>Hello World</code> 了。</p><p>随便跑一个目录里面新建一个文件并且用 <strong>vim</strong> 编辑：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ vim hello.js</span><br></pre></td></tr></table></figure><p>在里面输入下面的东西：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">console.log(&quot;Hello world!&quot;);</span><br></pre></td></tr></table></figure><p>然后退出 <strong>vim</strong> 执行：</p><figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line">$ node hello.js</span><br></pre></td></tr></table></figure><p>终于，<strong>真·Hello world</strong> 出现在了你的眼前，而不需要借助 <strong><a href="http://ideone.com/" target="_blank" rel="external">IDEOne</a></strong> 了。</p><p><strong><em>To be continued…</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　由于&lt;a href=&quot;!--￼11--&amp;gt;#linux-环境&quot;&gt;Linux&lt;/a&gt;中的环境搭建比较简单，所以草草略过。&lt;/p&gt;
&lt;p&gt;　　其实&lt;a href=&quot;!--￼12--&amp;gt;#windows-环境&quot;&gt;Windows&lt;/a&gt;下也不算麻烦，但是这里会讲一定量的
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="JavaScript" scheme="https://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="https://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node-JS/"/>
    
  </entry>
  
  <entry>
    <title>一起撸Node.JS（负叁）——概述</title>
    <link href="https://xcoder.in/2013/08/13/node-1-summary/"/>
    <id>https://xcoder.in/2013/08/13/node-1-summary/</id>
    <published>2013-08-12T16:00:00.000Z</published>
    <updated>2017-12-11T07:59:20.523Z</updated>
    
    <content type="html"><![CDATA[<p>　　本系列教程主要是写给我带的那帮熊孩子们看的。我自己的 <strong>Node.js</strong> 水平半斤八两，措辞之中也免不了有自己错误的理解，会误人子弟。但是对于初学者来说，某些自己助记的理解还是可取的。有些概念性的错误可以等他们进一步深入研究之后再自行更正。</p><p>　　由于那帮人大多还处于使用 <strong>M$ Windows</strong> 的令人不愉快的阶段，所以本教程将会退而求其次，使其在 <strong>Cygwin</strong> 中模拟 <strong>linux</strong> 的命令（Windows的bat脚本实在是让人不敢恭维）。以及在这里会讲述一些 <strong>Git</strong> 操作的初步。当然，如果你已经在使用 <strong>linux</strong> 进行开发的话，可以跳过前面一堆令人感到厌烦的环境配置章节。或者你在使用 <strong>M$ Windows</strong> 但却不想改变自己的脚本习惯的话，也可以选择性地跳过一些章节和步骤。</p><!-- 我是小小分割符 --><h2 id="Node-JS是什么？"><a href="#Node-JS是什么？" class="headerlink" title="Node.JS是什么？"></a>Node.JS是什么？</h2><p>很多人都知道JS是一门语言，而且是一门脚本语言，其全称就是 <strong>JavaScript</strong>，而且与所谓的 <strong>Java</strong> 没有一个屁的关系。</p><h3 id="前端-JavaScript"><a href="#前端-JavaScript" class="headerlink" title="前端 JavaScript"></a>前端 JavaScript</h3><p>在好多年前，<strong>JavaScript</strong> 是网页的一个寄生虫，它必须依赖于网页的浏览器中才能执行，并且作为网页的一部分，以</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//blahblah...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>标签进行包含，这样才能提供其上下文环境。或者说将其单独写入一个 <code>*.js</code> 文件中，并且在网页里以</p><figure class="highlight plain"><figcaption><span>html</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;foo/bar.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>的形式将其包含进来。</p><p>但总而言之，<strong>JavaScript</strong> 只是寄生在网页里面的一只小小可怜虫罢了。它的作用无非就是使网页的交互性更强，页面效果更多而已。</p><p>后来，这帮不甘寂寞的人类将 <strong>JavaScript</strong> 从网页（或者说前端）的帝国中独立了出来（小心快递），于是就出现了 <strong>CommonJS</strong>。</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><strong>CommonJS</strong> 其实不是一门新的语言，甚至都不能说它是一个新的解释器——实际上它只是一个概念或者是一个规范。</p><p>在这个规范中，它定义了很多 <strong>API</strong> ，讲通俗点或者直截了当点就是函数啊类啊什么的，而这些 <strong>API</strong> 是为那些普通应用程序（Native App）而非浏览器应用使用。它的终极目标就是提供一个类似于 <strong>Python</strong>、<strong>Ruby</strong> 之类的脚本一样的标准库，开发者可以用这样的东西一样来做到 <strong>Python</strong>、<strong>Ruby</strong> 能做到的事，而非仅仅局限于网页中的效果或者功能实现，它也可以跑在本地。</p><p>所以说下面的事情对于 <strong>JavaScript</strong> 来说不再是梦：</p><ul><li>服务端JavaScript应用</li><li>命令行工具</li><li>图形界面应用</li><li>混合应用（Titanium、Adobe AIR等）</li></ul><p>那么，它具体弥补了 <strong>前端JavaScript</strong> 的哪些空白呢？其实这也涉及了很多 <strong>前端JavaScript</strong> 所没有涉及的东西，如二进制、编码、IO、文件、系统、断言测试、套接字、事件队列、Worker、控制台等等。</p><p>关于 <strong>CommonJS</strong> 的更进一步了解可以翻阅一下其 <strong><a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">Wiki</a></strong>。</p><h3 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h3><p>上面讲了那么多，却始终停留在“规范”这个层面上。而 <strong>Node.JS</strong> 的出现便是让 <strong>CommonJS</strong> 成为了现实。</p><p>这里要大家明确的一点的就是 <strong>Node.JS</strong> 并不是一门新的语言，它的语言还是 <strong>JavaScript</strong> ，硬要说是一门新的语言那也应该是 <strong>Common JavaScript</strong>。<strong>Node.JS</strong> 只是 <strong>CommonJS</strong> 的一个<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8" target="_blank" rel="external">解释器</a>罢了。</p><p>它是基于 <strong>Google</strong> 的 <strong>V8虚拟机</strong>(Chrome浏览器所使用的JavaScript执行环境) 的一个解释器。</p><p>很多人印象中的概念还是没能摆脱 <strong>前端JavaScript</strong> 的阴霾，认为 <strong>JavaScript</strong> 就是做网站的， <strong>Node.JS</strong> 也是如此。</p><p>包括本人在 <strong><a href="http://cnodejs.org/" target="_blank" rel="external">cnodejs.org</a></strong> 中看到的帖子大多也都是讲 <strong>Node.JS</strong> 如何如何做网站（服务端）云云，如何如何使用 <strong>Express</strong> 模块来搭建一个网站云云。</p><blockquote><p>这是一个误区。</p></blockquote><p><strong>PHP</strong> 还能用 <strong><a href="http://www.php-cli.com/" target="_blank" rel="external">PHP-CLI</a></strong> 来写个脚本放本地跑呢，<strong>Node.JS</strong> 更是可以写任何程序。虽然这么讲有些夸大了，但是我这么说的理由是希望大家能摆脱这么一个误区。</p><p>举个简单的例子吧，大家都是搞过 <strong>ACM</strong> 的孩子了，总对终端窗口的输入输出有一定感觉了吧。现在给我以最快速度码一个 <strong><em><a href="http://acm.nbut.edu.cn/problem/view.xhtml?id=1000" target="_blank" rel="external">A + B Problem</a></em></strong> 给我看看。</p><p>轻车熟路，我知道。但是你们现在做的事用 <strong>Node.JS</strong> 同样能做到。</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">process.stdin.resume();</span><br><span class="line">process.stdin.setEncoding(&quot;utf8&quot;);</span><br><span class="line">process.stdin.on(&quot;data&quot;, function(chunk) &#123;</span><br><span class="line">    var datas = chunk.trim().split(&quot;\n&quot;);</span><br><span class="line">    for(var i = 0; i &lt; datas.length; i++) &#123;</span><br><span class="line">        var ab = datas[i].trim().split(&quot; &quot;);</span><br><span class="line">        var a = parseInt(ab[0]);</span><br><span class="line">        var b = parseInt(ab[1]);</span><br><span class="line">        console.log(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于<del>我们学校</del>我的前任学校OJ不支持 <strong>Node.JS</strong>，所以请你们移步到 <strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1000" target="_blank" rel="external">AIZU OJ</a></strong> 去把上面的代码交过去看看结果看。</p><blockquote><p><strong>注意</strong>：语言要选择 <strong>JavaScript</strong>。</p></blockquote><p>怎么样，同样能过题的对吧？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面对这些东西做了个简单的介绍，我需要你们知道的东西很简单：</p><ol><li><strong>Node.JS</strong> 是一个脚本解释器，用的语言是 <strong>JavaScript</strong>。</li><li><strong>Node.JS</strong> 功能很强大，不是只能拿来做网站的，眼光放开阔些。</li><li>给我好好学。</li></ol><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><blockquote><p>有个码畜老了，想学学书法来修身养性。当他展开宣纸，犹豫了半天之后，终于挥毫泼墨，在纸上龙飞凤舞写下几个大字：</p><blockquote><p><strong><em>Hello World</em></strong></p></blockquote></blockquote><p>虽然这一篇文章没有讲到任何 <strong>Node.JS</strong> 的语法，但是还是可以让你们练练书法的。</p><p><strong>C语言</strong> 的标准输出函数是 <code>printf</code>，而 <strong>Node.JS</strong> 的标准输出则是：</p><figure class="highlight plain"><figcaption><span>javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">console.log(&quot;blahblah...&quot;);</span><br></pre></td></tr></table></figure><p>好的，即使没有装上 <strong>Node.JS</strong> 环境也阻止不了我们向世界问好。</p><p>打开 <strong><a href="http://ideone.com/" target="_blank" rel="external">IDEOne</a></strong>，将你的 <code>Hello World</code> 贴到编辑框中，然后在左侧的语言栏里面选中 <strong>Node.JS</strong> ，点击送出，你就能看到你的第一个 <strong>Node.JS</strong> 程序的运行结果了。</p><p><strong><em>To be continued…</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　本系列教程主要是写给我带的那帮熊孩子们看的。我自己的 &lt;strong&gt;Node.js&lt;/strong&gt; 水平半斤八两，措辞之中也免不了有自己错误的理解，会误人子弟。但是对于初学者来说，某些自己助记的理解还是可取的。有些概念性的错误可以等他们进一步深入研究之后再自行更正。
      
    
    </summary>
    
      <category term="NodeJS" scheme="https://xcoder.in/categories/NodeJS/"/>
    
    
      <category term="Node.js" scheme="https://xcoder.in/tags/Node-js/"/>
    
      <category term="JavaScript" scheme="https://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="https://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node-JS/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript中callback函数的this指针重定义</title>
    <link href="https://xcoder.in/2013/07/15/javascript-callback-this-bind/"/>
    <id>https://xcoder.in/2013/07/15/javascript-callback-this-bind/</id>
    <published>2013-07-15T06:20:29.000Z</published>
    <updated>2017-12-11T07:59:20.501Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在写 <strong>NBUT Virtual Judge</strong> 的内核框架，用的又是 <strong>Node.JS</strong> 了，把它当作一个本地运行的脚本不断进行轮询。</p><p>　　众所周知JS中的一个精髓就是异步回调。</p><p>　　所以在我自己写的框架中也经常会出现类似于下面的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.bar(a, b, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>　　总而言之就是写一个函数，这个函数将会调用一个回调函数。</p><p>　　但是问题出现了：在那个回调函数 <code>function</code> 中，你如果使用了一个 <code>this</code> 指针的话，它将会指向根，而不是 <code>foo</code> 的本体。</p><p>　　那么如果我们想在 <code>function</code> 中也用 <code>this</code> 来指代这个 <code>foo</code> 对象该怎么办呢？</p><p>　　结果还是IRC有用。本人跑 <strong>Node.JS</strong> 的 <strong>IRC</strong> 上问了这个问题，结果有人就这样回复我了：</p><blockquote><p>13:07 &lt;shama&gt; xadillax: foo(a, b callback.bind(foo))</p><p>13:10 &lt;olalonde&gt; foo (a, b fn) { fn = fn.bind(this); …. }</p></blockquote><p>　　然后还很热心地给了我个网址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p><p>　　总之最后得出的结论就是说：</p><p>　　你只要给你的 <code>callback</code> 函数指定一个 <code>this</code> 指针即可。</p><p>　　如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cb = callback.bind(foo);</span><br><span class="line">foo.bar(a, b, cb);</span><br></pre></td></tr></table></figure><p>　　这样就能在回调函数中使用foo来作为其this指针了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近在写 &lt;strong&gt;NBUT Virtual Judge&lt;/strong&gt; 的内核框架，用的又是 &lt;strong&gt;Node.JS&lt;/strong&gt; 了，把它当作一个本地运行的脚本不断进行轮询。&lt;/p&gt;
&lt;p&gt;　　众所周知JS中的一个精髓就是异步回调。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="Javascript" scheme="https://xcoder.in/tags/Javascript/"/>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>关于Node.js下的MongoDB阻塞模式实现</title>
    <link href="https://xcoder.in/2013/03/29/nodejs-mongodb-sync/"/>
    <id>https://xcoder.in/2013/03/29/nodejs-mongodb-sync/</id>
    <published>2013-03-29T01:31:38.000Z</published>
    <updated>2017-12-11T07:59:20.528Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong><em>注：本文仅为我初学 Node.JS 的时候的稚嫩笔记。是从 <a href="http://web.archive.org/" target="_blank" rel="external">http://web.archive.org/</a> 扒回来的。现在看来已无多大参考价值，各位可以略过。我只是把它扒回来纪念一下而已，以记录我的历程。而那个相对应的 <code>SevenzJS</code> 也已经被遗弃</em></strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>　　最近在做公司项目的一个模块，主要用于 <strong>JSON Api</strong> 的传输，所以开发环境的目标就锁定在了 <strong>Node.js</strong>。而这一块的登陆用户又是存在 <strong>MongoDB</strong> 里面的，所以就有了如下的问题。</p><ul><li>网上的 Node.JS 框架都比较重型或者臃肿的，学了 Node 之后还需要学额外的东西。</li><li>所以我就打算自己写一个专注于 JSON Api 的快速开发框架，于是有了 SevenJS。</li><li>问题出现了，虽然 Node.JS 极度推崇异步非阻塞模式，但是阻塞模式在平常开发中还是太常用了。</li></ul><p>　　我们试想一下，如果我们有几句MongoDB的查询之类的，用node-mongodb-native来写的话是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Db(<span class="string">'test'</span>, <span class="keyword">new</span> Server(<span class="string">"127.0.0.1"</span>, <span class="number">27017</span>, &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</span><br><span class="line">    collection.insert(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">        collection.count(<span class="function"><span class="keyword">function</span>(<span class="params">err, count</span>) </span>&#123;</span><br><span class="line">            test.assertEquals(<span class="number">1</span>, count); &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Locate all the entries using find</span></span><br><span class="line">            collection.find().toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">            test.assertEquals(<span class="number">1</span>, results.length);</span><br><span class="line">            test.assertTrue(results[<span class="number">0</span>].a === <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Let's close the db</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.open(<span class="function"><span class="keyword">function</span>(<span class="params">err, client</span>) </span>&#123;</span><br><span class="line">    client.collection(<span class="string">'test_insert'</span>, test);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　各种嵌套回调有木有！这不是我们想要的，尤其是我的那个框架，因为我的框架是流式的。</p><p>　　所以我就想有这样的一种方案：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = mongodb.connect();</span><br><span class="line"><span class="keyword">var</span> collection = mongodb.getCollection(client, <span class="string">"dbname"</span>);</span><br><span class="line"><span class="keyword">var</span> result = mongodb.find(&#123; <span class="string">"foo"</span> : <span class="string">"bar"</span> &#125;);</span><br></pre></td></tr></table></figure><p>　　使得这样就能找出dbname表下的foo为bar值的记录了。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>　　出于这样的想法，我在网上找遍了大江南北，除了 CNode 社区有人问到了类似的问题以外，再也找不到音信了，而且那里也没有一个好的回答。</p><p>　　不过这也正常，因为 Node.js 官方本身就不推荐这么做——他们认为异步非阻塞是非常优雅的一件事情。</p><p>　　包括我在 Node.js 的 IRC 聊天室里面问了这个问题，也有人是这么回答我的：</p><blockquote><p>You can’t use a car as a boat. If you want a boat, use a boat.</p></blockquote><p>　　言简意赅，直截了当地说明 Node.js 是不支持这样的，如果你想这样做，就用 python 或者 ruby 去吧。</p><p>　　不过好在后来 IRC 里面有人推荐了我一个模块：<a href="https://github.com/laverdet/node-fibers" target="_blank" rel="external">fibers</a>。</p><p>　　有了这个模块好啊，直接能用了有木有！</p><p>　　接下来就来讲一下如何使用吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">collection, selector, callback</span>) </span>&#123;</span><br><span class="line">    collection.find(selector).toArray(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Fiber = <span class="built_in">require</span>(<span class="string">'fibers'</span>);</span><br><span class="line"><span class="keyword">var</span> Future = <span class="built_in">require</span>(<span class="string">'fibers/future'</span>);</span><br><span class="line"><span class="keyword">var</span> wait = Future.wait;</span><br><span class="line"></span><br><span class="line">Fiber(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wrapper = Future.wrap(fund);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 这里就是正题了，我们假设已经获取一个collection了 */</span></span><br><span class="line">    <span class="keyword">var</span> result = wrapper(collection, &#123; <span class="string">"foo"</span> : <span class="string">"bar"</span> &#125;).wait();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">&#125;).run();</span><br></pre></td></tr></table></figure><p>　　这就是一个非常简单的同步查询 MongoDB 的例子了，实际上本质还是一个异步，注意到没有，其实 <code>Fiber()</code> 内部的那个 <code>function</code> 本质上还是一个回调函数，只不过在这个回调函数里面，里面的所有 <code>callback</code> 都可以被同步了。不过我们只需要小动一些手脚就能加上这个外壳了。具体请参见 <a href="https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/sevenz/sRouter.js" target="_blank" rel="external">sRouter.js</a> 约 121 行的外壳以及 <a href="https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/sevenz/sMongoSync.js" target="_blank" rel="external">sMongoSync.js</a> 的实现，加上 <a href="http://web.archive.org/web/20130726042859/https://github.com/XadillaX/SevenzJS/blob/a0a0476000c492dd8e70c062cfa432f559edbd16/actions/index.js" target="_blank" rel="external">index.js</a> 中的查询 demo。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>　　所以说当我们做不到某件事的时候，多去IRC看看，多去社区混混，也多去找找模块，要真没有的话就只能自己丰衣足食了（我还没到那水平，笑）。总之这次Fibers帮了我一个大忙。</p><p>　　最后，SevenzJS 欢迎 <a href="https://github.com/XadillaX/SevenzJS" target="_blank" rel="external">Fork</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;strong&gt;&lt;em&gt;注：本文仅为我初学 Node.JS 的时候的稚嫩笔记。是从 &lt;a href=&quot;http://web.archive.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://web.archive.org/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="Node.JS" scheme="https://xcoder.in/tags/Node-JS/"/>
    
      <category term="MongoDB" scheme="https://xcoder.in/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>关于jQuery中“animate()”函数对颜色变化的支持</title>
    <link href="https://xcoder.in/2012/12/24/jquery-animate-color-support/"/>
    <id>https://xcoder.in/2012/12/24/jquery-animate-color-support/</id>
    <published>2012-12-24T01:20:16.000Z</published>
    <updated>2017-12-11T07:59:20.508Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在做一个汽车团购网的项目，由于老大力求简洁，所以界面做得有些小清新。不过得说一下页面不是我设计的，是一位美工同志。</p><p>　　废话不多说，直接切入正题吧——</p><p>　　我要做得就是让下面一段代码生效：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#yourid"</span>).stop().animate(&#123; <span class="string">"backgroundColor"</span> : <span class="string">"#rrggbb"</span>, <span class="string">"color"</span> : <span class="string">"#rrggbb"</span> &#125;, <span class="string">"fast"</span>);</span><br></pre></td></tr></table></figure><p>　　但是，很遗憾，一点也没有动。本来效果应该跟这个版本的xcoder博客的天头导航条一样有个动态效果（只不过xcoder的导航条是透明度变化，而项目中我想让它背景色变化）。</p><p>　　原因是什么呢？死月上网查了很久，找到的东西都很简单地说明了一下，貌似都可以。嘛，也许是jQuery新版本不支持这个特性了吧。</p><p>　　最后，死月在jQuery的官方文档中找到了下面这段话——</p><blockquote><p>All animated properties should be animated to <strong><em>a single numeric value</em></strong>, except as noted below; most properties that are non-numeric cannot be animated using basic jQuery functionality (For example, width, height, or left can be animated but background-color cannot be, unless the <a href="https://github.com/jquery/jquery-color" target="_blank" rel="external">jQuery.Color()</a> plugin is used). Property values are treated as a number of pixels unless otherwise specified. The units em and % can be specified where applicable.</p><p style="text-align: right">—— <a href="http://api.jquery.com/animate/" target="_blank" rel="external">jQuery官方文档 .animate()</a></p></blockquote><p>　　大致的意思就是说所有动画属性都必须是一个单数字值，所以说大多数非数字的属性是不能被动画化的。例如高度、宽度等可以被动画化，但是背景色就不信了。<span style="color: red;"><strong><em>除非你用了jQuery.Color()插件</em></strong></span>。</p><p>　　所以说问题找到了，我们必须得用一个jQuery.Color()插件来对一些颜色进行动画操作。</p><p>　　话不多说，我们去下一个jQuery.Color()插件。把它加在我们的页面中，然后就可以用如下方式来进行动画操作了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">this</span>).stop().animate(&#123;</span><br><span class="line">    <span class="string">"backgroundColor"</span> : jQuery.Color(<span class="string">"rrggbb"</span>),</span><br><span class="line">    <span class="string">"color"</span> : jQuery.Color(<span class="string">"rrggbb"</span>)</span><br><span class="line">&#125;, <span class="string">"fast"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近在做一个汽车团购网的项目，由于老大力求简洁，所以界面做得有些小清新。不过得说一下页面不是我设计的，是一位美工同志。&lt;/p&gt;
&lt;p&gt;　　废话不多说，直接切入正题吧——&lt;/p&gt;
&lt;p&gt;　　我要做得就是让下面一段代码生效：&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="Javascript" scheme="https://xcoder.in/tags/Javascript/"/>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="jQuery" scheme="https://xcoder.in/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>线程安全——Scope Lock模式</title>
    <link href="https://xcoder.in/2012/09/08/scope-lock/"/>
    <id>https://xcoder.in/2012/09/08/scope-lock/</id>
    <published>2012-09-07T17:31:59.000Z</published>
    <updated>2017-12-11T07:59:20.542Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong><em>嘛，本文是建立在M$的Visual Studio基础上的，linux☭勿喷。</em></strong></p><p>　　我最先用到 ScopeLock 模式是在自己开发 <strong>XAE引擎</strong> 的时候。在里面用到挺多的线程函数，那么如何解决临界区就成了一个重要的课题。可能大家想，不就一个线程锁临界区什么的么，一个 <code>EnterCriticalSection</code> 和一个 <code>LeaveCriticalSection</code> 不就解决了么？</p><p>　　其实不然。在 <strong>M$</strong> 中，最常用的当然就是 <code>CRITICAL_SECTION</code> 了，但是如果临界区上锁却木有解锁呢？这就会发生死锁现象。对于一个粗心的程序猿来说这样的错误还是有机率发生的。就算你足够细心，还是有时候会一失足成千古恨。</p><p>　　所以就有了这么一种方法来杜绝这种死锁的产生—— <code>ScopeLock</code>。</p><p>　　那么什么叫 <code>ScopeLock</code>？</p><p>　　我们试想一下如果有这么一个类——在构造的时候，你传进去一个 <code>CRITICAL_SECTION</code> 的引用并且将其 <code>EnterCriticalSection</code> 进入到临界区。当它析构的时候，我们直接 <code>LeaveCriticalSection</code> 就好了。</p><p>　　也许你会问，这样的一个类会有什么用呢？</p><p>　　那么我下面演示一段简单的 ScopeLock 代码先吧：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScopeLock</span></span><br><span class="line">&#123;</span></span><br><span class="line">    CRITICAL_SECTION&amp; m_cs;</span><br><span class="line"></span><br><span class="line">    ScopeLock(CRITICAL_SECTION cs) : m_cs(cs)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;m_cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ScopeLock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(&amp;m_cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...假设我们已经初始化好了这个临界区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScopeLockTest</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ScopeLock <span class="title">oLock</span><span class="params">(cs)</span></span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们可以发现，当我们刚进入 <code>ScopeLockTest</code> 函数的时候，声明了一个 <code>oLock</code> 对象，这个时候运行 <code>oLock</code> 的构造函数，也就是进入了 <code>cs</code> 这个临界区。而当 <code>ScopeLockTest</code> 函数运行完毕要退出这个函数的时候，<code>oLock</code> 对象的生命周期也就走到了尽头，对应的，它将会执行析构函数，那么就自然而然地退出了 <code>cs</code> 临界区。</p><p>　　其实无论 <code>ScopeLockTest</code> 这个函数怎么写，哪怕是中间有一些 <code>if</code> 判断直接 <code>return</code> 掉，只要是 <code>ScopeLockTest</code> 这个函数执行完毕，<code>oLock</code> 就会自动析构，从而达到了解锁过程。那么不管粗心还是细心的童鞋们都不用为忘记退出临界区而烦恼了。</p><p>　　而且 <code>ScopeLock</code> 模式只是一种思想，并不是对于 <strong>M$</strong> 的临界区的一种专用性物品。例如在QT里，我们一样可以用 <code>ScopeLock</code> 来对线程的一些 <code>MutexLock</code> 之类的东西进行操作。</p><p>　　上面所写的例子只是思路的一种形成，并不是一个完整的ScopeLock类（结构体），虽然说它现在已经可以用了。你可以在上面完善，加上自己的东西，使其能确确实实在项目中使用。由于代码的关联性，我单单发出我的 <code>ScopeLock</code> 的话会缺少很多关联的东西，所以咱就不发了，思路在这里，相信谁都能写出自己的一个 <code>ScopeLock</code> 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;strong&gt;&lt;em&gt;嘛，本文是建立在M$的Visual Studio基础上的，linux☭勿喷。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我最先用到 ScopeLock 模式是在自己开发 &lt;strong&gt;XAE引擎&lt;/strong&gt; 的时候。在里面用到挺多的线
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="ScopeLock" scheme="https://xcoder.in/tags/ScopeLock/"/>
    
      <category term="线程安全" scheme="https://xcoder.in/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程死锁" scheme="https://xcoder.in/tags/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces Round 128 DIV2</title>
    <link href="https://xcoder.in/2012/07/04/codeforces-128-div2/"/>
    <id>https://xcoder.in/2012/07/04/codeforces-128-div2/</id>
    <published>2012-07-04T03:38:59.000Z</published>
    <updated>2017-12-11T07:59:20.466Z</updated>
    
    <content type="html"><![CDATA[<p>　　这次玩脱了。好不容易四题都做出来，却因为小细节挂了两题。</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><h3 id="Two-Problems"><a href="#Two-Problems" class="headerlink" title="Two Problems"></a>Two Problems</h3><p>　　题意就是说，CF有两题，每题初始分A和B，然后每题在每分钟会扣DA和DB分。给你比赛总时间T，问你某个人可不可能拿到X分。（注意可能做出一题、两题或者一题也没做出）</p><p>　　(0 ≤ x ≤ 600; 1 ≤ t, a, b, da, db ≤ 300且保证及时比赛时间到了各题的分数也不会小于0)</p><h3 id="Game-on-Paper"><a href="#Game-on-Paper" class="headerlink" title="Game on Paper"></a>Game on Paper</h3><p>　　有一个 N<em>N 方格纸。在上面的方格里一格格涂黑。每一步涂一格一共涂 m 次，给定 xi 和 yi。问最少涂几步方格纸里会出现一个 3</em>3 的正方形。</p><p>　　(1 ≤ n ≤ 1000, 1 ≤ m ≤ min(n· n, 105))</p><h3 id="Photographer"><a href="#Photographer" class="headerlink" title="Photographer"></a>Photographer</h3><p>　　照相内存卡里有d容量。其中高质量照片占a容量、低质量占b容量。然后有n个顾客，每个顾客需要xi张高质量照片和yi张低质量照片。摄影师如果给一个人拍照了，就应该满足他所有要求（即给xi张高质量照片和yi张低质量照片）。问摄影师最多能给几个人拍照。</p><p>　　(1 ≤ n ≤ 105, 1 ≤ d ≤ 109, 1 ≤ a ≤ b ≤ 104, 0 ≤ xi, yi ≤ 105)</p><h3 id="Hit-Ball"><a href="#Hit-Ball" class="headerlink" title="Hit Ball"></a>Hit Ball</h3><p>　　封闭房间里，从房间的一头最底下的中间以某个方向踢球（一定是网对面踢），问踢到另一头的墙上的时候，x、z各是多少。</p><p>　　(各座标以及向量都是小于等于100的正整数)</p><p><img src="hit-ball.png" alt="Hit Ball"></p><h3 id="Transportation"><a href="#Transportation" class="headerlink" title="Transportation"></a>Transportation</h3><p>　　还没看。</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Two-Problems-1"><a href="#Two-Problems-1" class="headerlink" title="Two Problems"></a>Two Problems</h3><p>　　这题只要注意几个trick就行了：可以做出0题、1题或者2题。直接两个for枚举各题在几分钟内做出来，然后做一下0题、1题的特殊判断就好了。</p><h3 id="Game-on-Paper-1"><a href="#Game-on-Paper-1" class="headerlink" title="Game on Paper"></a>Game on Paper</h3><p>　　在每次涂的时候，以当前涂的点位中心，设它为九宫格的其中一个位置（一共九种位置），对于每种位置，都判断其对应的九宫格是不是 3*3 的黑色就好了。(我做的时候在设位置的时候 x - 1, y - 1 手贱敲成了 x - 1, y - 2，lock 之后才发现。悲剧)</p><h3 id="Photographer-1"><a href="#Photographer-1" class="headerlink" title="Photographer"></a>Photographer</h3><p>　　贪心。对于每个人将其所需的总容量算出来再进行递增排序。最后求的时候推荐累减的方式判断，因为我累加然后用 int 最后爆范围了。</p><h3 id="Hit-Ball-1"><a href="#Hit-Ball-1" class="headerlink" title="Hit Ball"></a>Hit Ball</h3><p>　　首先拿出空间几何的线面相交模板。然后来一个 <code>while</code>，每次循环的时候判断当前所在的点与方向适量形成的直线与 (X, 0, Z) 面的交点在不在终点墙壁大小的范围内。若不是则说明中途撞墙了判断方向向量：x &lt; 0则线面相交判断是不是撞左墙，若是则 x 正负值变一下；x &gt; 0 则线面相交判断是不是撞右墙，若是则 x 正负值变一下。z &lt; 0则判断是不是以求抢地，若是则 z 正负变一下。最后 z &gt; 0 则判断是不是撞天花板，若是则z正负值变一下。然后以球撞击的点为新的起点，与新的方向向量形成新的直线，继续下一次循环。因为房间大小最大是 100 <em> 100 </em> 100，而方向向量各方向是 1 到 100 的整数，不是小数，则撞击次数不会很多，直接 <code>while</code> 撞击也不会超。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Two-Problems-2"><a href="#Two-Problems-2" class="headerlink" title="Two Problems"></a>Two Problems</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, t, a, b, da, db;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;x, &amp;t, &amp;a, &amp;b, &amp;da, &amp;db))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == a - i * da)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == b - j * db)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(x == a - i * da + b - j * db)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == x) flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, flag ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Game-on-Paper-2"><a href="#Game-on-Paper-2" class="headerlink" title="Game on Paper"></a>Game on Paper</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> mat[<span class="number">1015</span>][<span class="number">1015</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if(i == 1 &amp;&amp; j == 1) continue;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mat[sx + i][sy + j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check2(x, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">1</span>, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(check2(x - <span class="number">2</span>, y - <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            mat[x + <span class="number">1</span>][y + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(check(x + <span class="number">1</span>, y + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Photographer-2"><a href="#Photographer-2" class="headerlink" title="Photographer"></a>Photographer</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span></span><br><span class="line">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> memo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(client a, client b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.memo &lt; b.memo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client c[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    __int64 d;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>, &amp;n, &amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            c[i].id = i + <span class="number">1</span>;</span><br><span class="line">            c[i].memo = a * x + b * y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(c, c + n, cmp);</span><br><span class="line">        __int64 sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + c[i].memo &lt;= d) sum += c[i].memo, maxi = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxi + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxi; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, c[i].id, i == maxi ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hit-Ball-2"><a href="#Hit-Ball-2" class="headerlink" title="Hit Ball"></a>Hit Ball</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point3</span>&#123;</span><span class="keyword">double</span> x,y,z;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line3</span>&#123;</span>point3 a,b;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plane3</span>&#123;</span>point3 a,b,c;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">point3 <span class="title">xmult</span><span class="params">(point3 u,point3 v)</span></span>&#123;</span><br><span class="line">    point3 ret;</span><br><span class="line">    ret.x=u.y*v.z-v.y*u.z;</span><br><span class="line">    ret.y=u.z*v.x-u.x*v.z;</span><br><span class="line">    ret.z=u.x*v.y-u.y*v.x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point3 <span class="title">subt</span><span class="params">(point3 u,point3 v)</span></span>&#123;</span><br><span class="line">    point3 ret;</span><br><span class="line">    ret.x=u.x-v.x;</span><br><span class="line">    ret.y=u.y-v.y;</span><br><span class="line">    ret.z=u.z-v.z;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point3 <span class="title">pvec</span><span class="params">(plane3 s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xmult(subt(s.a,s.b),subt(s.b,s.c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point3 <span class="title">intersection</span><span class="params">(line3 l,plane3 s)</span></span>&#123;</span><br><span class="line">    point3 ret=pvec(s);</span><br><span class="line">    <span class="keyword">double</span> t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/</span><br><span class="line">        (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));</span><br><span class="line">    ret.x=l.a.x+(l.b.x-l.a.x)*t;</span><br><span class="line">    ret.y=l.a.y+(l.b.y-l.a.y)*t;</span><br><span class="line">    ret.z=l.a.z+(l.b.z-l.a.z)*t;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a, b, m;</span><br><span class="line">    <span class="keyword">double</span> vx, vy, vz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &amp;a, &amp;b, &amp;m, &amp;vx, &amp;vy, &amp;vz))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 5 walls */</span></span><br><span class="line">        plane3 door, lw, rw, top, ground;</span><br><span class="line">        door.a.x = <span class="number">0</span>, door.a.y = <span class="number">0</span>, door.a.z = <span class="number">0</span>;</span><br><span class="line">        door.b.x = <span class="number">1</span>, door.b.y = <span class="number">0</span>, door.b.z = <span class="number">0</span>;</span><br><span class="line">        door.c.x = <span class="number">0</span>, door.c.y = <span class="number">0</span>, door.c.z = <span class="number">1</span>;</span><br><span class="line">        lw.a.x = <span class="number">0</span>, lw.a.y = <span class="number">0</span>, lw.a.z = <span class="number">0</span>;</span><br><span class="line">        lw.b.x = <span class="number">0</span>, lw.b.y = <span class="number">1</span>, lw.b.z = <span class="number">0</span>;</span><br><span class="line">        lw.c.x = <span class="number">0</span>, lw.c.y = <span class="number">0</span>, lw.c.z = <span class="number">1</span>;</span><br><span class="line">        rw.a.x = a, rw.a.y = <span class="number">0</span>, rw.a.z = <span class="number">0</span>;</span><br><span class="line">        rw.b.x = a, rw.b.y = <span class="number">1</span>, rw.b.z = <span class="number">0</span>;</span><br><span class="line">        rw.c.x = a, rw.c.y = <span class="number">0</span>, rw.c.z = <span class="number">1</span>;</span><br><span class="line">        ground.a.x = <span class="number">0</span>, ground.a.y = <span class="number">0</span>, ground.a.z = <span class="number">0</span>;</span><br><span class="line">        ground.b.x = a, ground.b.y = <span class="number">0</span>, ground.b.z = <span class="number">0</span>;</span><br><span class="line">        ground.c.x = a / <span class="number">2</span>, ground.c.y = m, ground.c.z = <span class="number">0</span>;</span><br><span class="line">        top.a.x = <span class="number">0</span>, top.a.y = <span class="number">0</span>, top.a.z = b;</span><br><span class="line">        top.b.x = a, top.b.y = <span class="number">0</span>, top.b.z = b;</span><br><span class="line">        top.c.x = a / <span class="number">2</span>, top.c.y = m, top.c.z = b;</span><br><span class="line"></span><br><span class="line">        line3 l;</span><br><span class="line"></span><br><span class="line">        l.a.x = a / <span class="number">2</span>;</span><br><span class="line">        l.a.y = m;</span><br><span class="line">        l.a.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        l.b.x = (a / <span class="number">2</span>) + vx;</span><br><span class="line">        l.b.y = m + vy;</span><br><span class="line">        l.b.z = vz;</span><br><span class="line"></span><br><span class="line">        point3 v;</span><br><span class="line">        v.x = vx, v.y = vy, v.z = vz;</span><br><span class="line"></span><br><span class="line">        point3 myans;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            point3 ans, ans1, ans2, ans3, ans4;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;ans1, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));</span><br><span class="line">            <span class="built_in">memset</span>(&amp;ans2, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));</span><br><span class="line">            <span class="built_in">memset</span>(&amp;ans3, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));</span><br><span class="line">            <span class="built_in">memset</span>(&amp;ans4, <span class="number">0</span>, <span class="keyword">sizeof</span>(point3));</span><br><span class="line"></span><br><span class="line">            ans = intersection(l, door);</span><br><span class="line">            <span class="keyword">if</span>(ans.x &gt;= <span class="number">0</span> &amp;&amp; ans.z &gt;= <span class="number">0</span> &amp;&amp; ans.x &lt;= a &amp;&amp; ans.z &lt;= b)</span><br><span class="line">            &#123;</span><br><span class="line">                myans = ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point3 totans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(v.x &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 = intersection(l, lw);</span><br><span class="line">                <span class="keyword">if</span>(ans1.z &gt;= <span class="number">0</span> &amp;&amp; ans1.z &lt;= b)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.x = -v.x;</span><br><span class="line">                    totans = ans1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(v.x &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans2 = intersection(l, rw);</span><br><span class="line">                <span class="keyword">if</span>(ans2.z &gt;= <span class="number">0</span> &amp;&amp; ans2.z &lt;= b)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.x = -v.x;</span><br><span class="line">                    totans = ans2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(v.z &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans3 = intersection(l, top);</span><br><span class="line">                <span class="keyword">if</span>(ans3.x &gt;= <span class="number">0</span> &amp;&amp; ans3.x &lt;= a)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.z = -v.z;</span><br><span class="line">                    totans = ans3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(v.z &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans4 = intersection(l, ground);</span><br><span class="line">                <span class="keyword">if</span>(ans4.x &gt;= <span class="number">0</span> &amp;&amp; ans4.x &lt;= a)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.z = -v.z;</span><br><span class="line">                    totans = ans4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l.a = totans;</span><br><span class="line">            l.b = totans;</span><br><span class="line">            l.b.x += v.x;</span><br><span class="line">            l.b.y += v.y;</span><br><span class="line">            l.b.z += v.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, myans.x, myans.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　这次玩脱了。好不容易四题都做出来，却因为小细节挂了两题。&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="CodeForces" scheme="https://xcoder.in/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>HGE做格斗游戏的热点图片碰撞检测法</title>
    <link href="https://xcoder.in/2011/10/18/hge-hotspot-collision/"/>
    <id>https://xcoder.in/2011/10/18/hge-hotspot-collision/</id>
    <published>2011-10-18T07:22:21.000Z</published>
    <updated>2017-12-11T07:59:20.500Z</updated>
    
    <content type="html"><![CDATA[<p>　　碰撞检测始终是做2D游戏中的一个热点话题，我本人并没有做过这类游戏，所以一切只是理论而已，不过正打算做这么个小游戏练练手。</p><p>　　前几天在HGE的群里看到有人突然问到如何判断鼠标有没有点到人（点到纹理的透明区域不算），从而引申出了碰撞检测问题。</p><p>　　他的问题相对好实现，只要算出纹理所按的点是不是透明即可。</p><p>　　接下来我得做下碰撞检测的笔记：</p><p>　　碰撞检测最常用一个方法就是关节设置（当然我并没有做过），关节设置的话因为只是判断多边形的重叠状况，算法的复杂度低、效率高，虽然做工有点粗，但总体效果还是性价比比较高的一种方法。当然，这样的方法需要对每一帧的纹理都设置一个关节，对于人工的代价就稍微大了一些了，并且还要写个关节编辑器啊神马的，于是乎代码量又增加了。我这次是和同寝室木有一点基础的童鞋一起练手的，所以并没有打算引进这个方法。</p><p>　　于是我就用了另一种稍微“非主流”一些的方法了——逐像素判断。</p><p>　　但是逐像素判断还是有问题的——如果你的一个“效果”因为“温度过高”而不需要显示，直接隐藏，但又算伤害，这时纹理的逐像素就失去了意义。于是又有了个“臃肿”的办法，为需要“额外附加像素”的纹理另做一张图片，这张图片上有两种区域——热点区和非热点区。我们把需要“当做空气”的那些区域一律用某一种极其不常用的颜色覆盖，如 <code>ff00ff</code> 这种变态的粉色，然后其它区域的颜色就随你怎么搞了。我们载入的时候两张纹理一起载入，显示的时候显示正常的纹理，而在碰撞检测的时候用“热点图片”来进行逐像素检测。</p><p>　　与上面的关节设置法比较的话，人工的工作量我个人认为是大大地减少了，至于对于机器的执行能力来说，把时间复杂度提到了 <code>O(mn)</code> ，平方级的复杂度了，即纹理相交区域的宽和高。</p><p>　　我们来看一下这种碰撞检测的大体流程吧：</p><ol><li>获得两个精灵的矩形，并得到相交矩形。若无相交则直接返回 <code>false</code>。</li><li>根据相交矩形，我们可以得到精灵1、2的纹理中需要检测的初始座标。</li><li>将精灵1、精灵2的热点图片的相交区域的那一部分像素拷贝出来备用。（因为有可能两个纹理句柄是一样的，不好同时 <code>lock</code>）</li><li>开始对于拷贝出来的像素信息逐一判断对应像素点是否都“不是空气”，若都“不是空气”则可以判断为碰撞。</li></ol><p>　　当然以上的流程我们还可以优化一下，省去拷贝的那一段时间。我们可以直接 <code>hge-&gt;Texture_Lock()</code> 来进行得到两个纹理的像素信息的首指针，如果两个纹理其实只是一个纹理的话，则只需 <code>hge-&gt;Texture_Lock()</code> 一次，而另一个指针也只想 <code>hge-&gt;Texture_Lock</code> 即可，然后直接开始判断。</p><p>　　下面献上我这个函数的实现以及测试代码和素材：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief   Test the collision by the "hot" texture</span><br><span class="line"> * @author  XadillaX</span><br><span class="line"> * @email   admin@xcoder.in</span><br><span class="line"> * @date    2011/10/18</span><br><span class="line"> * @http://xcoder.in</span><br><span class="line"> *</span><br><span class="line"> * @param spr1 The first sprite to test the collision</span><br><span class="line"> * @param x1 "x" of top-left corner of sprite 1</span><br><span class="line"> * @param y1 "y" of top-left corner of sprite 1</span><br><span class="line"> * @param spr2 The second sprite to test the collision</span><br><span class="line"> * @param x2 "x" of top-left corner of sprite 2</span><br><span class="line"> * @param y2 "y" of top-left corner of sprite 2</span><br><span class="line"> * @param hot1 The "hot" texture for sprite 1. It will be the default texture of spr1 if it equal to 0</span><br><span class="line"> * @param hot2 The "hot" texture for sprite 2. It will be the default texture of spr2 if it equal to 0</span><br><span class="line"> * @param airColor The color which considered of "air"</span><br><span class="line"> *</span><br><span class="line"> * @return if they are collided, return true</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCollision</span><span class="params">(hgeSprite* spr1, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, hgeSprite* spr2, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, HTEXTURE hot1 = <span class="number">0</span>, HTEXTURE hot2 = <span class="number">0</span>, DWORD airColor = <span class="number">0xffff00ff</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Set the rect */</span></span><br><span class="line">    hgeRect r1, r2;</span><br><span class="line">    r1.Set(x1, y1, x1 + spr1-&gt;GetWidth(), y1 + spr1-&gt;GetHeight());</span><br><span class="line">    r2.Set(x2, y2, x2 + spr2-&gt;GetWidth(), y2 + spr2-&gt;GetHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Test for the intersect of rectangles */</span></span><br><span class="line">    <span class="keyword">if</span>(r1.Intersect(&amp;r2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x[] = &#123; x1, x2, x1 + spr1-&gt;GetWidth(), x2 + spr2-&gt;GetWidth() &#125;;</span><br><span class="line">        <span class="keyword">int</span> y[] = &#123; y1, y2, y1 + spr1-&gt;GetHeight(), y2 + spr2-&gt;GetHeight() &#125;;</span><br><span class="line">        <span class="built_in">std</span>::sort(x, x + <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(y, y + <span class="number">4</span>);</span><br><span class="line">        hgeRect r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Set the rectangle area where the two rectangles intersected. */</span></span><br><span class="line">        r.Set(x[<span class="number">1</span>], y[<span class="number">1</span>], x[<span class="number">2</span>], y[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The start point of sprite1 and sprite2. (From the intersected area) */</span></span><br><span class="line">        <span class="keyword">int</span> sx1, sy1, sx2, sy2;</span><br><span class="line">        sx1 = x[<span class="number">1</span>] - x1;</span><br><span class="line">        sy1 = y[<span class="number">1</span>] - y1;</span><br><span class="line">        sx2 = x[<span class="number">1</span>] - x2;</span><br><span class="line">        sy2 = y[<span class="number">1</span>] - y2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Get the "hotspot" of texture */</span></span><br><span class="line">        HTEXTURE hTex1 = hot1;</span><br><span class="line">        HTEXTURE hTex2 = hot2;</span><br><span class="line">        <span class="keyword">if</span>(hTex1 == <span class="number">0</span>) hTex1 = spr1-&gt;GetTexture();</span><br><span class="line">        <span class="keyword">if</span>(hTex2 == <span class="number">0</span>) hTex2 = spr2-&gt;GetTexture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> tx1, ty1, tw1, th1, tx2, ty2, tw2, th2;</span><br><span class="line">        <span class="keyword">int</span> w1 = hge-&gt;Texture_GetWidth(hTex1), w2 = hge-&gt;Texture_GetWidth(hTex2);</span><br><span class="line">        spr1-&gt;GetTextureRect(&amp;tx1, &amp;ty1, &amp;tw1, &amp;th1);</span><br><span class="line">        spr2-&gt;GetTextureRect(&amp;tx2, &amp;ty2, &amp;tw2, &amp;th2);</span><br><span class="line"></span><br><span class="line">        DWORD* color1 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];</span><br><span class="line">        DWORD* color2 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];</span><br><span class="line">        DWORD* color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Copy the effectivearea of texture 1 */</span></span><br><span class="line">        color = hge-&gt;Texture_Lock(hTex1, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)</span><br><span class="line">            &#123; </span><br><span class="line">                color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty1 + sy1) * w1 + (<span class="keyword">int</span>)tx1 + sx1 + i * w1 + j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        hge-&gt;Texture_Unlock(hTex1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Copy the effectivearea of texture 2 */</span></span><br><span class="line">        color = hge-&gt;Texture_Lock(hTex2, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++) </span><br><span class="line">            &#123; </span><br><span class="line">                color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty2 + sy2) * w2 + (<span class="keyword">int</span>)tx2 + sx2 + i * w1 + j]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        hge-&gt;Texture_Unlock(hTex2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Test for the collision */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor &amp;&amp; color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">delete</span> []color1;</span><br><span class="line">                    <span class="keyword">delete</span> []color2;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []color1;</span><br><span class="line">        <span class="keyword">delete</span> []color2;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="src.rar">点击下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　碰撞检测始终是做2D游戏中的一个热点话题，我本人并没有做过这类游戏，所以一切只是理论而已，不过正打算做这么个小游戏练练手。&lt;/p&gt;
&lt;p&gt;　　前几天在HGE的群里看到有人突然问到如何判断鼠标有没有点到人（点到纹理的透明区域不算），从而引申出了碰撞检测问题。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="HGE" scheme="https://xcoder.in/tags/HGE/"/>
    
  </entry>
  
  <entry>
    <title>关于HGE的透明背景处理</title>
    <link href="https://xcoder.in/2011/09/13/hge-transparent-color/"/>
    <id>https://xcoder.in/2011/09/13/hge-transparent-color/</id>
    <published>2011-09-13T04:12:32.000Z</published>
    <updated>2017-12-11T07:59:20.500Z</updated>
    
    <content type="html"><![CDATA[<p>　　嘛 = = 在做那个项目的动画预览器的时候，因为那引擎封装得太麻烦了，于是自己基于HGE再移植一遍，发现其中有一个SetTransparentColor函数，即设置透明色。</p><p>　　拿出来分享一下吧。</p><p>　　其实方法很简单，<code>HTEXTURE</code> 是纹理句柄，当你用 <code>Texture_Lock</code> 这个函数锁定这个纹理的时候，它的返回值就是这个纹理在内存中的首地址。也就是说接下来的 width * height 个地址中就是这个纹理的每一个像素了。既然要设置透明色，只要对于每个像素判断一下与运算一下就好了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HTEXTURE <span class="title">SetTransColor</span><span class="params">(HTEXTURE hTex, DWORD dwColor)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** 注：上面的dwColor代表的是RGB，不是ARGB */</span></span><br><span class="line">    <span class="keyword">static</span> HGE* hge = hgeCreate(HGE_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = hge-&gt;Texture_GetWidth(hTex) * hge-&gt;Texture_GetHeight(hTex);</span><br><span class="line">    DWORD* dwTex = hge-&gt;Texture_Lock(hTex);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dwTex[i] &amp; <span class="number">0x00FFFFFF</span>) == dwColor)</span><br><span class="line">        &#123;</span><br><span class="line">            dwTex[i] &amp;= <span class="number">0x00FFFFFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hge-&gt;Texture_Unlock(hTex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hTex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　嘛，这样一来，就透明了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　嘛 = = 在做那个项目的动画预览器的时候，因为那引擎封装得太麻烦了，于是自己基于HGE再移植一遍，发现其中有一个SetTransparentColor函数，即设置透明色。&lt;/p&gt;
&lt;p&gt;　　拿出来分享一下吧。&lt;/p&gt;
&lt;p&gt;　　其实方法很简单，&lt;code&gt;HTEXTU
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="HGE" scheme="https://xcoder.in/tags/HGE/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏资源包的更新、删除</title>
    <link href="https://xcoder.in/2011/06/16/resource-pack/"/>
    <id>https://xcoder.in/2011/06/16/resource-pack/</id>
    <published>2011-06-15T17:20:31.000Z</published>
    <updated>2017-12-11T07:59:20.541Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近除了忙各种各样的期末考试、去西班牙的签证，就是公司的那个韩国项目了。</p><p>　　我的任务基本完成——将原本单屏的游戏改成三屏，完善整个 GUI系统 以及“劫持”了原游戏中的一些逻辑，比如滚轴的排列可以任意控制等。由于原代码中的GUI系统没有文本编辑框，我还得自己写一个。然而我对于IME的操作、GDI和DX的结合不是非常熟悉，所以还是参照了一下 <strong>ShowLong</strong> 所修改的微妙的平衡给HGE写的中文解决方案。</p><p>　　完成了以上的任务之后，由于我的考试以及签证问题以及我本身的任务差不多了，就把这个摊子就扔回公司去了。在交接的时候，老大给我派了一个任务，让我来写这个游戏资源包的代码。</p><p>　　原版游戏代码中有资源包代码，但是写得非常乱，于是需要我来写一个新的文件结构、新的加密算法，然后仍然是“劫持”掉原代码中的资源包加载函数。</p><p>　　在此之前，我拜读了云风的《<a href="http://blog.codingnow.com/2010/08/resource_pack.html" target="_blank" rel="external">游戏资源的压缩、打包与补丁更新</a>》，有了点灵感。</p><p>　　<strong>最主要的就是其删除这一块。为了让用户在更新的时候减少大量的文件IO操作，做法就是减少文件内容的大幅度移动。</strong></p><p>　　而我便是参考了云风大大的这个思想来写我的文件包。首先因为在游戏中需要实时读取，所以文件没有压缩，只是做了两层加密处理，密钥也是通过哈希得到的，所以每个文件的密钥是不同的。</p><p>　　然后在文件索引的时候，我这里是分了两种索引：<strong>文件索引</strong>以及<strong>空块索引</strong>。</p><p>　　所谓空块索引就是：在文件包中删除某一个文件的时候，不把后面的文件内容全部往前挪以覆盖这一块的内容、导致整个文件包在删除文件之后的信息全部往前挪而产生的大量IO操作，而是对这一块内容不作任何处理、把这一块内容的索引从文件索引中移除并附加到空块索引中以供以后新文件加入时所用，<strong>这样就只产生了一点对于索引的文件IO更新</strong>，不过索引的更新充其量也就那么点，相对于文件的操作来说只是九牛一毛，当然前提是这个索引是在整个文件包的最后。而在有新文件插入的时候，先在空块索引中找有比新文件大的空块，如果有的话就直接把这个文件插入到那个空块中，然后更新一下文件索引以及空块索引即可，这里又少掉了一些IO操作。</p><p>　　正如云风所说：</p><blockquote><p>如果新增加的文件较之小，就重复利用这个空间。如果利用不上，就浪费在那里。这有点像内存管理算法，<strong>时间久了，资源包内会有一些空洞，但也是可以接受的。</strong></p></blockquote><p>　　接着就是资源包在游戏中的使用了。在原先的游戏代码中是有判断重复加载的代码，也就是说把已加载的资源存到node里，在之后再次需要加载这个资源（通过文件名判断）就直接从node中去，这样就少了很多内存开销，尤其是当我把单屏改为三屏之后，这样的优化效果更为明显（否则相同的资源要加载三次，等于消耗了三倍的内存）。不得赞一下这05年开发的代码，虽然是棒子。不过原游戏代码中的高耦合度让我蛋疼。</p><p>　　想到以后这个资源包类要用到以后的一些项目，于是我自己也写了一个Cache机制。就是在一个包中，当加载某个资源的时候，顺便把这个资源的Buffer加到一个Cache中，当下次再需要用到这个资源的时候就直接从Cache中取就好了，实际上这就还是之前的代码实现的功能，只不过我自己在这基础上精简了一下。最后写一个ClearCache的函数能清除Cache，我这个资源包类就算完成了。</p><p>　　还有在获取资源的时候，为了防止内存突增，我的Buffer是一段一段获取的，类似于Socket中的获取消息一直到消息结束为止。当然，每一段Buffer的大小是可以自己传进去的。我这种以时间换空间的做法还没自己实际测试过效果如何，只不过是自己想想可能会比较优罢了，因为最近实在是太慢，这篇日志还是考完了概率然后摸着黑地写的。</p><p>　　我对文件系统本身不是非常了解，操作系统还没考呢。所以我现在仅仅做到的是云风九年前的一种设计，然后加上了原先代码有的Cache机制而已。不过写下这篇日志来记录我自己成长的足迹罢了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近除了忙各种各样的期末考试、去西班牙的签证，就是公司的那个韩国项目了。&lt;/p&gt;
&lt;p&gt;　　我的任务基本完成——将原本单屏的游戏改成三屏，完善整个 GUI系统 以及“劫持”了原游戏中的一些逻辑，比如滚轴的排列可以任意控制等。由于原代码中的GUI系统没有文本编辑框，我还得
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="二进制文件" scheme="https://xcoder.in/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
      <category term="游戏制作" scheme="https://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
      <category term="资源包" scheme="https://xcoder.in/tags/%E8%B5%84%E6%BA%90%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>连连看核心算法小分享——1</title>
    <link href="https://xcoder.in/2011/05/16/lianlinakan-algorighm-i/"/>
    <id>https://xcoder.in/2011/05/16/lianlinakan-algorighm-i/</id>
    <published>2011-05-16T04:30:12.000Z</published>
    <updated>2017-12-11T07:59:20.519Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 <code>Kalxd</code> 的对话。</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>　　刚忙完邀请赛，蹭了块铜。刚才在逛别人博客的时候看别人的文章，突然心血来潮想记一些东西。</p><p>　　连连看是我学HGE做的第一个小游戏，素材用的是QQ的。时间大概是去年国庆吧。好吧，废话不多说，就讲讲连连看怎么找到能消的两块吧。</p><p>　　首先来回顾一下消方块的规则，一共有三种可能性：</p><ol><li>直线消除（包括水平或者垂直）</li><li>一个拐角消除</li><li>两个拐角消除</li></ol><p>　　嗯，接下去我们就针对每种可能性开始写代码。</p><p>　　首先讲讲一些定义：</p><p>　　座标结构体，这个结构体包含了x、y的值以及一些座标中常用的函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 地图座标结构体</span><br><span class="line"> *</span><br><span class="line"> * 地图座标结构体，包含x轴值、y轴值</span><br><span class="line"> * 以及一些操作函数。</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;                                          <span class="comment">///&lt; x轴</span></span><br><span class="line">    <span class="keyword">int</span> y;                                          <span class="comment">///&lt; y轴</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 重载构造函数</span><br><span class="line">     * 将x、y值各初始化为-1</span><br><span class="line">     */</span></span><br><span class="line">    CoorType()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造函数重载</span><br><span class="line">     * 将x、y各赋值为b、a</span><br><span class="line">     * @param a 将要赋值的y轴数值</span><br><span class="line">     * @param b 将要赋值的x轴数值</span><br><span class="line">     */</span></span><br><span class="line">    CoorType(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 设置座标</span><br><span class="line">     * 将x、y各赋值为b、a</span><br><span class="line">     * @param a 将要赋值的y轴数值</span><br><span class="line">     * @param b 将要赋值的x轴数值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 运算符"+="重载</span><br><span class="line">     * 将此座标与另一座标相加</span><br><span class="line">     * @param &amp;a 另一座标</span><br><span class="line">     * @return 返回结果座标值</span><br><span class="line">     */</span></span><br><span class="line">    CoorType &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        y += a.y, x += a.x;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 重载运算符"!="</span><br><span class="line">     * 判断与另一座标是否表示同一个值</span><br><span class="line">     * @param &amp;a 另一座标</span><br><span class="line">     * @return 返回布尔类型表示是否相等</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y != a.y || x != a.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断此座标是否合法</span><br><span class="line">     * 若出界则不合法</span><br><span class="line">     * @return 返回布尔类型表示是否合法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIll</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt; MAP_HEIGHT &amp;&amp; x &lt; MAP_WIDTH) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　然后是关于地图数组的定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];</span><br></pre></td></tr></table></figure><p>　　接着是路径结构体：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 路线结构体</span><br><span class="line"> *</span><br><span class="line"> * 合法路线结构体</span><br><span class="line"> * 储存最多四个点（起点终点和两个转折点）</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointPath</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> bExist;                                    <span class="comment">///&lt; 是否有路径</span></span><br><span class="line">    <span class="keyword">int</span> Num;                                        <span class="comment">///&lt; 驻点个数</span></span><br><span class="line">    CoorType Points[<span class="number">4</span>];                             <span class="comment">///&lt; 各驻点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　接着可以正式开始了。首先我们来想一下，哪些条件各符合上面三种情况的哪一种。对于一条直线的，显然是x相等或者y相等；对于有一个转折点的话，我们只需要判断起点横向画线（或者纵向），然后终点纵向画线（或者横向），然后从起点到交点以及从交点到终点各可行不；对于两个转折点，其中一个转折点的x或者y跟起点的x或者y相等，另一个转折点跟终点的x或者y相等。于是这两个转折点就根据这样的性质进行枚举。因为连连看的地图比较小，所以这种O(n^2)的时间复杂度不碍事。</p><p>　　为了方便，我们写一个 <code>Abled(CoorType, CoorType, bool, bool);</code> 函数来进行判断两个点（当然两点是在同一直线上的）是否有同路（即中间没有东西挡着）。我们先放着这个Abled不管，先实现寻路过程吧。</p><p>　　我是用一个CMapSearch类来实现的，声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 地图搜索类</span><br><span class="line"> *</span><br><span class="line"> * 根据指定地图搜索出各合法路径。</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMapSearch</span></span><br><span class="line">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];                                             <span class="comment">///&lt; 地图数据矩阵</span></span><br><span class="line">    PointPath dis[MAP_HEIGHT][MAP_WIDTH][MAP_HEIGHT][MAP_WIDTH];                <span class="comment">///&lt; 路径数组</span></span><br><span class="line">    STLMap grap;                                                                <span class="comment">///&lt; STL映射</span></span><br><span class="line">    CoorType dir[<span class="number">4</span>];                                                            <span class="comment">///&lt; 常量座标增量</span></span><br><span class="line">    PointPath Hint;                                                             <span class="comment">///&lt; 提示时用的合法路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 两点寻径</span><br><span class="line">     *</span><br><span class="line">     * 对(x1, y1)和(x2, y2)进行寻径</span><br><span class="line">     * @param x1 第一个座标的x轴</span><br><span class="line">     * @param y1 第一个座标的y轴</span><br><span class="line">     * @param x2 第二个座标的x轴</span><br><span class="line">     * @param y2 第二个座标的y轴</span><br><span class="line">     * @return 返回一个路线结构体的值，若不存在路径，则结构体的bExist为假</span><br><span class="line">     * @see Abled</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">DoSearch</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param _Map[][Map_Width] 地图矩阵</span><br><span class="line">     */</span></span><br><span class="line">    CMapSearch(<span class="keyword">int</span> _Map[][MAP_WIDTH]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 析构函数</span><br><span class="line">     */</span></span><br><span class="line">    ~CMapSearch(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 载入地图</span><br><span class="line">     * 从矩阵中载入地图到对象</span><br><span class="line">     *</span><br><span class="line">     * @param _Map[][Map_Width] 地图矩阵</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadMap</span><span class="params">(<span class="keyword">int</span> _Map[][MAP_WIDTH])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 搜索地图</span><br><span class="line">     * 对整个地图进行搜索每两个相同方块之间的路径</span><br><span class="line">     *</span><br><span class="line">     * @return 如果存在至少一条路径则返回真，否则为假，用于是否重列</span><br><span class="line">     * @see CreateSTLMap</span><br><span class="line">     * @see DoSearch</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 创建map映射</span><br><span class="line">     * 创建一个方块ID的映射，对每个ID创建一条的该ID的方块在地图中的各座标的链表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateSTLMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 判断是否有障碍</span><br><span class="line">     * 对于a、b两座标（在同一直线）进行判断期间是否有方块障碍而导致不能连线</span><br><span class="line">     *</span><br><span class="line">     * @param a 座标a（头座标）</span><br><span class="line">     * @param b 座标b（尾座标）</span><br><span class="line">     * @param head 若包括头座标则为true，否则为false</span><br><span class="line">     * @param tail 若包括尾座标则为true，否则为false</span><br><span class="line">     * @return 若有障碍则返回false，否则为true</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Abled</span><span class="params">(CoorType a, CoorType b, <span class="keyword">bool</span> head = <span class="literal">false</span>, <span class="keyword">bool</span> tail = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 得到路径</span><br><span class="line">     * 得到两个座标的连线具体路径</span><br><span class="line">     *</span><br><span class="line">     * @param y1 第一个座标的y轴</span><br><span class="line">     * @param x1 第一个座标的x轴</span><br><span class="line">     * @param y2 第二个座标的y轴</span><br><span class="line">     * @param x2 第二个座标的x轴</span><br><span class="line">     * @return 返回一个路线结构体，表示该两个座标直接的路线</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">GetPath</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 得到提示路径</span><br><span class="line">     * 得到一条提示的路径的相应两个方块</span><br><span class="line">     *</span><br><span class="line">     * @param &amp;a 接受第一个方块ID的变量</span><br><span class="line">     * @param &amp;b 接受第二个方块ID的变量</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetRandomHint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　然后我这个分享里所讲的算法就是DoSearch和Abled函数了，因为其它函数就是用于“提示”道具的。在DoSearch中我们先定义两个临时变量，一个是返回值（一个PointPath），四个座标变量：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">PointPath ans;</span><br><span class="line">CoorType a(y1, x1), b(y2, x2), c, d;</span><br></pre></td></tr></table></figure><p>　　其中a、b表示起点和终点，c、d表示可能用到的两个转折点。</p><p>　　首先我们先来判断直线情况吧，这种情况比较简单：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是直线</span></span><br><span class="line"><span class="keyword">if</span>(a.x == b.x || a.y == b.y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Abled(a, b, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ans.bExist = <span class="literal">true</span>;</span><br><span class="line">        ans.Num = <span class="number">2</span>;</span><br><span class="line">        ans.Points[<span class="number">0</span>] = a, ans.Points[<span class="number">1</span>] = b;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于这种情况，我们只需直接判断a、b直接有没有通路就好，如果有通路我们就将结果记录到ans中并返回即可。</p><p>　　而有一个转折点、两个转折点的情况以及Abled函数将在下一篇文章中小分享一下。</p><h2 id="回忆时间"><a href="#回忆时间" class="headerlink" title="回忆时间"></a>回忆时间</h2><p>　　然后下面就是在这篇文章里面我跟 <code>Kalxd</code> 的对话了，想想现在真是沧海桑田啊。</p><p>　　CSS 样式早已经不在了，截图里面是一篇白板</p><p><img src="comment.png" alt="评论回忆"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;strong&gt;注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 &lt;code&gt;Kalxd&lt;/code&gt; 的对话。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="HGE" scheme="https://xcoder.in/tags/HGE/"/>
    
  </entry>
  
  <entry>
    <title>我的编程生涯中第一个商业游戏</title>
    <link href="https://xcoder.in/2011/04/25/my-first-game/"/>
    <id>https://xcoder.in/2011/04/25/my-first-game/</id>
    <published>2011-04-25T04:30:53.000Z</published>
    <updated>2017-12-11T07:59:20.522Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近网之游在和棒子一起开发一个类似赌博的网游（别墙我，做好是给棒子自己玩的），然后机缘巧合，他们的引擎是结合了MFC以及从我用过的几个引擎之一移植过来的。就引擎本身而言很强大，然后我又有一点小经验，所以网之游的柯总便也让我加入了开发行列。之前也是托网之游的福让我研究了一番网狐的平台。</p><p>　　开发过程中学到了不少底层的东西。我的任务是先将游戏的单屏给弄成三份，以三个逻辑来实现。由于工程耦合性太高，原程序员是C语言出生的，造成了我修改工程一定程度上的麻烦。先自己写了个Wrapper类来包含三个SceneGAME，然后一次性将三个SceneGAME渲染到目标上。这样改了一下之后，有两百多个错误。不知道其它游戏是不是也有这样的特点，因为这是我开发的第一款游戏，所以也没经验。</p><p>　　不过幸好最后还是让我给完成了这第一个quest。接着是添加GUI，就是现在正在做的。还有就是完全分离三块分屏的逻辑代码。让我这个大二学生兴奋的是，这个游戏完成之后，是会有奖金的。这个可是让我这个穷孩子两眼放光莫。YY一下到底会有多少呢，我本身也只是过去见识一下真正的工程而已，压根没想过money这事。</p><p>　　今天，额好吧，以现在的时间来说应该是昨天了，一个韩国人以及另一个中国公司的人过来验收我们现在的进度。我打开自己电脑里编译好的可执行文件，心中那种自豪感油然而生啊，毕竟我还是newbie，当然是有些小兴奋啊。期间那个中国公司的人说要赶在韩国人那边任务完成之前完成，这样好体现我们自己程序员不比他们差。无形之间的较量啊，表示鸭梨很大。据说他们那边现在遇到小问题了，我们超前的可能性还是蛮大的，接下去我就是要卯足劲来分离逻辑以及设置GUI了。柯总那边已经把网络通讯方面差不多完成了，我这一块做好，一对接，差不多能在五月初交工了。</p><p>　　最近还是比较忙啊，要学车，有个宁工基金会网站、港城关系研究所网站以及国际港口与物流中心网站，然后团区委那边的志愿者网站还有点小尾巴，浙江能源集团那个用C#写的员工墙完工了还不知道那边怎么说，接着应该还有一个姜老师那边的站子。都堆在一坨了。不过最近最要紧的还是这个游戏以及基金会网站以及去西班牙实习的一些相关事宜了。不管了，先睡觉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近网之游在和棒子一起开发一个类似赌博的网游（别墙我，做好是给棒子自己玩的），然后机缘巧合，他们的引擎是结合了MFC以及从我用过的几个引擎之一移植过来的。就引擎本身而言很强大，然后我又有一点小经验，所以网之游的柯总便也让我加入了开发行列。之前也是托网之游的福让我研究了一
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="游戏开发" scheme="https://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="牢骚" scheme="https://xcoder.in/tags/%E7%89%A2%E9%AA%9A/"/>
    
      <category term="网之游" scheme="https://xcoder.in/tags/%E7%BD%91%E4%B9%8B%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++对象工厂模式：ObjectFactory学习笔记</title>
    <link href="https://xcoder.in/2010/11/17/objectfactory-learning/"/>
    <id>https://xcoder.in/2010/11/17/objectfactory-learning/</id>
    <published>2010-11-17T07:49:45.000Z</published>
    <updated>2017-12-11T07:59:20.528Z</updated>
    
    <content type="html"><![CDATA[<p>　　对象工厂，顾名思义，就是产生对象的一个“工厂”。根据传入的一个参数而产生相应的不同种类的对象。</p><p>　　用于批量生成同一个父类的不同子类的对象时用到。</p><p>　　本学习笔记基于Singleton（单件模式）基础上进行扩展。</p><p>　　看《C++单件模式：Singleton学习笔记》请点击<a href="/2010/11/13/singleton-learning/">链接</a>。</p><p>　　对于工厂模式，网上有很多不同的实现方法。我这里是一个HGE的RPG Demo中所用的，这段代码本身写的非常的好，开始好些语句没看懂，虽然就这么几句话。花了一点时间去研究了其代码，并自己重新实现了一遍，加上了通俗易懂的注释。</p><p>　　工厂类以模板形式实现，基于Singleton：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**--------------------------------</span><br><span class="line"> * 对象工厂模式(Object Factory)</span><br><span class="line"> *</span><br><span class="line"> * Code by XadillaX</span><br><span class="line"> * http://www.xcoder.in</span><br><span class="line"> * Created at 2010-11-17 1:33</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OBJECTFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECTFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../单件模式/Singleton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><br><span class="line"><span class="title">class</span> <span class="title">ObjectFactory</span> :</span> <span class="keyword">public</span> Singleton&lt;ObjectFactory&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* (*tCreator)();                               <span class="comment">///&lt; 重定义对象生成函数指针</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, tCreator&gt; tCreatorMap;    <span class="comment">///&lt; 对象生成函数指针map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 注册新“生产车间”</span><br><span class="line">     * 将生成对象的函数加入对象工厂</span><br><span class="line">     *</span><br><span class="line">     * @param *name 类名称</span><br><span class="line">     * @param procedure “生产”对象的函数</span><br><span class="line">     * @return 是否成功注册</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Register</span><span class="params">(<span class="keyword">char</span> *type, tCreator procedure)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 找到“生产车间”</span><br><span class="line">     * 根据传入的类名返回相应的新对象的生成函数</span><br><span class="line">     *</span><br><span class="line">     * @param &amp;type 类名</span><br><span class="line">     * @return 相应的新对象的生成函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">T* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** “生产车间”映射 */</span></span><br><span class="line">    tCreatorMap _map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><br><span class="line"><span class="title">bool</span> <span class="title">ObjectFactory</span>&lt;T&gt;:</span>:Register(<span class="keyword">char</span> *type, tCreator procedure)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(type)</span></span>;</span><br><span class="line">    <span class="comment">/** 将新函数加入map中 */</span></span><br><span class="line">    _map[tmp] = procedure;</span><br><span class="line">    <span class="keyword">return</span> _map[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><br><span class="line"><span class="title">T</span>* <span class="title">ObjectFactory</span>&lt;T&gt;:</span>:Create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 在映射中找到相应“生产车间” */</span></span><br><span class="line">    tCreatorMap::iterator iter = _map.find(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 检测“车间”是否存在 */</span></span><br><span class="line">    <span class="keyword">if</span>(iter != _map.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 让返回值为相应的“生产车间” */</span></span><br><span class="line">        tCreator r = iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 返回“生产车间” */</span></span><br><span class="line">        <span class="keyword">return</span> r();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　以上就是基於单件模式而实现的工厂模式了。</p><p>　　在样例中，我建立了一个基类Base，然后用A和B来继承它。</p><p>　　在一个for循环中，交替建立了A对象和B对象。这只是一个Demo，看不出有什么方便的，感觉用一个if来各自生成就好了，就像</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == <span class="string">"A"</span>) p = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">else</span> p = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>　　<strong>当然，上面也是一种方法。但是，试想一下，我们将要创建的A、B、C、D、E、F、G类放到一个配置文件中，然后我们从配置文件中读取这些数据并创建相应的对象，并且这些对象的顺序是打乱的，你就要有n个if来判断了，而且扩展性不高。用一个对象工厂进行封装的话，俨然形成了一个静而有序的生产工厂，有秩序地管理着不同的对象车间，不觉得这是一件非常美妙的事情么？</strong></p><p>　　好了，话不多说，直接上Demo。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ObjectFactory.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/** 基类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base类及其子类的对象工厂 */</span></span><br><span class="line"><span class="keyword">typedef</span> ObjectFactory&lt;Base&gt; BaseFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;&#125;;</span><br><span class="line">    ~Base()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"An A object created."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A B object Created."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对象A的“生产车间” */</span></span><br><span class="line"><span class="function">Base* <span class="title">ACreator</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对象B的“生产车间” */</span></span><br><span class="line"><span class="function">Base* <span class="title">BCreator</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 主函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** 将A、B的“生产车间”注册到对象工厂中 */</span></span><br><span class="line">    <span class="keyword">bool</span> AFlag = BaseFactory::Instance().Register(<span class="string">"A"</span>, ACreator);</span><br><span class="line">    <span class="keyword">bool</span> BFlag = BaseFactory::Instance().Register(<span class="string">"B"</span>, BCreator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 若注册失败则退出 */</span></span><br><span class="line">    <span class="keyword">if</span>(!AFlag || !BFlag) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Base *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> type = (i % <span class="number">2</span>) ? <span class="built_in">string</span>(<span class="string">"A"</span>) : <span class="built_in">string</span>(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** p用相应“生产车间”进行生产 */</span></span><br><span class="line">        p = BaseFactory::Instance().Create(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　对象工厂，顾名思义，就是产生对象的一个“工厂”。根据传入的一个参数而产生相应的不同种类的对象。&lt;/p&gt;
&lt;p&gt;　　用于批量生成同一个父类的不同子类的对象时用到。&lt;/p&gt;
&lt;p&gt;　　本学习笔记基于Singleton（单件模式）基础上进行扩展。&lt;/p&gt;
&lt;p&gt;　　看《C++
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="设计模式" scheme="https://xcoder.in/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++单件模式：Singleton学习笔记</title>
    <link href="https://xcoder.in/2010/11/13/singleton-learning/"/>
    <id>https://xcoder.in/2010/11/13/singleton-learning/</id>
    <published>2010-11-13T07:44:15.000Z</published>
    <updated>2017-12-11T07:59:20.542Z</updated>
    
    <content type="html"><![CDATA[<p>　　单件模式（Singleton）是一种用于确保整个应用程序中只有一个类实例且这个实例所占资源在整个应用程序中是共享时的程序设计方法（根据实际情况，可能需要几个类实例）。在某些情况下，这种程序设计方法是很有用处的。</p><p>　　在小小地学习了一下C++的单件模式之后，突然联想到PHP的ThinkPHP的MVC框架，觉得这就是一个单件模式的很好实例吧？</p><p>　　我上次在PUDN上载了一个HGE的RPG Demo，里面就用了Singleton模式还有ObjectFactory模式写的。没看懂，于是问了谷歌。</p><blockquote><p>Singleton可以说是《Design Pattern》中最简单也最实用的一个设计模式。那么，什么是Singleton？<br>顾名思义，Singleton就是确保一个类只有唯一的一个实例。Singleton主要用于对象的创建，这意味着，如果某个类采用了Singleton模式，则在这个类被创建后，它将有且仅有一个实例可供访问。很多时候我们都会需要Singleton模式，最常见的比如我们希望整个应用程序中只有一个连接数据库的Connection实例；又比如要求一个应用程序中只存在某个用户数据结构的唯一实例。我们都可以通过应用Singleton模式达到目的。</p><p>一眼看去，Singleton似乎有些像全局对象。但是实际上，并不能用全局对象代替Singleton模式，这是因为：其一，大量使用全局对象会使得程序质量降低，而且有些编程语言例如C#，根本就不支持全局变量。其二，全局对象的方法并不能阻止人们将一个类实例化多次：除了类的全局实例外，开发人员仍然可以通过类的构造函数创建类的多个局部实例。而Singleton模式则通过从根本上控制类的创建，将”保证只有一个实例”这个任务交给了类本身，开发人员不可能再有其它途径得到类的多个实例。这一点是全局对象方法与Singleton模式的根本区别。</p><p style="text-align: right;">——摘自百度百科（我不是有意在谷歌找百度的）</p></blockquote><p>　　我在看了这个RPG Demo的Pattern里的Singleton之后，仿照着自己写了一个最简单的Singleton模板实例。</p><p>　　<strong><em>思想就是，在Singleton中建立一个静态对象，然后以后就用 <code>Singleton::Instance()</code> 来调用这个静态对象。</em></strong></p><p>　　<strong><em>而作为模板就是可以 <code>class A : public Singleton</code> 来让A继承Singleton的属性，那么我们就可以直接用<br><code>A::Instance()</code> 来访问A这个静态对象了。这个就是这段Singleton代码的主要思想了。</em></strong></p><p>　　先是建立了一个空工程，往里面放了：</p><p>　　Singleton.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><br><span class="line"><span class="title">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 防止拷贝复制</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><br><span class="line"><span class="title">T</span>&amp; <span class="title">Singleton</span>:</span>:Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 建立一个静态对象 */</span></span><br><span class="line">    <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　TestSingleton.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TESTSINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTSINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Singleton.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从Singleton继承本类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> :</span> <span class="keyword">public</span> Singleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestSingleton(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~TestSingleton(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddCount</span><span class="params">()</span></span>&#123; count++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CoutCount</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>　　TestSingleton.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TestSingleton.h"</span></span></span><br><span class="line"></span><br><span class="line">TestSingleton::TestSingleton(<span class="keyword">void</span>)</span><br><span class="line">: count(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestSingleton::~TestSingleton(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　main.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TestSingleton.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 单件对象count值加1 */</span></span><br><span class="line">        TestSingleton::Instance().AddCount();</span><br><span class="line">        <span class="comment">/** 输出此单件对象的count值 */</span></span><br><span class="line">        TestSingleton::Instance().CoutCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　单件模式（Singleton）是一种用于确保整个应用程序中只有一个类实例且这个实例所占资源在整个应用程序中是共享时的程序设计方法（根据实际情况，可能需要几个类实例）。在某些情况下，这种程序设计方法是很有用处的。&lt;/p&gt;
&lt;p&gt;　　在小小地学习了一下C++的单件模式之后，
      
    
    </summary>
    
      <category term="老博客备份归档" scheme="https://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="老博客备份归档" scheme="https://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="https://xcoder.in/tags/C/"/>
    
      <category term="设计模式" scheme="https://xcoder.in/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
