<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[艾克斯の編碼者]]></title>
  <subtitle><![CDATA[一個偽宅级别的蒟蒻碼畜。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xcoder.in//"/>
  <updated>2014-08-04T10:57:24.244Z</updated>
  <id>http://xcoder.in//</id>
  
  <author>
    <name><![CDATA[小鳥遊死月]]></name>
    <email><![CDATA[admin@xcoder.in]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Storm 中 Clojure 的 Prepare Bolt 实现]]></title>
    <link href="http://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/"/>
    <id>http://xcoder.in/2014/08/04/storm-clojure-prepare-bolt/</id>
    <published>2014-08-04T03:50:21.000Z</published>
    <updated>2014-08-04T10:56:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>Storm 中的 Bolt 都是通过 Nimbus 这个服务将序列化好的 Bolt 断章取义地发到各个 worker 中。所以，任何在 bolt 之外你自认为加载期间初始化计算好的上下文环境并不会被打包上去，Java 我不懂也不知道，但是至少在 Clojure 这个类的概念被淡化的 LIST 方言中，你要做的就是把所有跟 bolt 初始化计算相关的代码放到其 <code>prepare</code> 的代码当中去。</p>
<p>你想一下，当你在文件加载的时候初始化了一个 MongoDB 链接，这个链接总不能被序列化到远程去吧？所以说办法就是把 bolt 搞上去之后，bolt 自动去初始化一个链接——这就是 <code>prepare</code> 的作用了。</p>
<p>说白了，这个还是我们在 <strong><em>Suwako</em></strong> 当中踩到的坑。</p>
<h2 id="做法">做法</h2>
<p>大致的骨架如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="list">(<span class="title">defbolt</span> bolt <span class="collection">[...]</span> <span class="collection">{<span class="attribute">:prepare</span> true}</span>
 <span class="collection">[...]</span>
 <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[...]</span>
  <span class="list">(<span class="title">bolt</span>
   <span class="list">(<span class="title">prepare</span> <span class="collection">[...]</span>
    <span class="list">(<span class="title">...</span>)</span>)</span>
   <span class="list">(<span class="title">execute</span> <span class="collection">[tuple]</span>
    <span class="list">(<span class="title">...</span>)</span>)</span>)</span>)</span></span>
</pre></td></tr></table></figure>

<p>　　首先就是 <code>{:prepare true}</code> 代表了它是一个需要初始化的 Bolt。</p>
<p>　　然后在 <code>(bolt)</code> 的作用域之内有两个 form——<code>prepare</code> 和 <code>execute</code>。</p>
<p>　　其中 <code>prepare</code> 就是你要初始化的语句了。举个例子，我们让这里面初始化一个 <a href="http://clojuremongodb.info/" target="_blank">Monger</a>，于是我们要在 <code>let</code> 里面定义一个用于链接的 <code>atom {}</code>。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="list">(<span class="title">defbolt</span> bolt <span class="collection">[<span class="string">"..."</span>]</span> <span class="collection">{<span class="attribute">:prepare</span> true}</span>
 <span class="collection">[conf context collector]</span>
 <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[conn <span class="list">(<span class="title"><span class="built_in">atom</span></span> <span class="collection">{}</span>)</span>
       db <span class="list">(<span class="title"><span class="built_in">atom</span></span> <span class="collection">{}</span>)</span>]</span>
   <span class="list">(<span class="title">bolt</span>
    <span class="list">(<span class="title">prepare</span> <span class="collection">[conf context collector]</span>
     <span class="list">(<span class="title"><span class="built_in">reset!</span></span> conn <span class="list">(<span class="title">mg/connect</span> ...)</span>)</span>
     <span class="list">(<span class="title"><span class="built_in">reset!</span></span> db <span class="list">(<span class="title">mg/get-db</span> @conn ...)</span>)</span>)</span>
    <span class="list">(<span class="title">execute</span> <span class="collection">[tuple]</span>
     <span class="list">(<span class="title">...</span>)</span>)</span>)</span>)</span>)</span>
</pre></td></tr></table></figure>

<p>　　这样一来，当 Bolt 被 Nimbus 打包传到各个 worker 之后，Bolt 执行起来的时候会自动执行 <code>prepare</code> 当中的代码，即初始化 MongoDB 的链接，并且将其赋值给 <code>conn</code> 和 <code>db</code> 两个 atom。</p>
<p>　　那么，我们就能在本体 <code>execute</code> 当中使用 <code>@conn</code> 和 <code>@db</code> 来使唤 MongoDB 了。</p>
<h2 id="思考">思考</h2>
<p>　　可能很多人不解，不是说尽量保持 LISP 语系当中值的不变性的么？</p>
<p>　　其实不变性只是为了提高程序在运行时的效率——而事实上是，上面那段代码并没有在运行时去做变量。</p>
<p>　　虽然说这么说有点牵强，但是的确就是这个意思——因为我们是在程序执行真正有用的好逻辑的时候没有去改变一些值，相反只是在 Bolt 启动的时候做一些变量的操作。</p>
<p>　　换句话说，虽然严谨的讲那个时候是算运行时，但是在运行时里面我们却可以把它归类为预处理——这一类东西反正程序还没真正开始跑有用的东西，效率慢一点无所谓，而且就初始化这么屁大点事儿能有多少影响？</p>
<p>　　效率和效果之间权衡上面的还是要仁者见仁智者见智了。</p>
<h2 id="小结">小结</h2>
<p>　　本以为 <code>Suwako</code> 终于可以暂时告一段落了，紧要关头居然还是阻塞了。</p>
<p>　　说多都是泪，不说了，找 Bug 去了。</p>
<p><img src="suwako.jpg" alt="泄矢诹访子"></p>
]]></content>
    
    
      <category term="Storm" scheme="http://xcoder.in/tags/Storm/"/>
    
      <category term="Clojure" scheme="http://xcoder.in/tags/Clojure/"/>
    
      <category term="Huaban" scheme="http://xcoder.in/tags/Huaban/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发测试时给 Kafka 发消息的 UI 发送器——Mikasa]]></title>
    <link href="http://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/"/>
    <id>http://xcoder.in/2014/07/30/kafka-ui-sender-mikasa/</id>
    <published>2014-07-30T02:14:29.000Z</published>
    <updated>2014-07-30T08:22:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="起_(灬ºωº灬)">起 (灬ºωº灬)</h2>
<p>　　说来话长，自从入了花瓣，整个人就掉进连环坑了。</p>
<p>　　后端元数据采集是用 Storm 来走拓扑流程的，又因为 @<a href="http://weibo.com/zolazhou" target="_blank">Zola</a> 不是很喜欢 Java，所以退而求其次选择了 Clojure，所以正在苦逼地学习 Clojure 和 Storm 中。</p>
<p>　　目前来说外面的 Storm 拓扑的 Spout 是从 Kafka 中流入数据的。但是我们要给 Kafka 发送测试数据的时候，就需要跑到 Kafka 的测试服务器打开它的一个发送脚本进去发送，非常蛋疼；要么就是直接通过特定的发送业务逻辑代码测试，没有一个稍微泛一点的测试用发数据工具，于是 Mikasa 诞生了。</p>
<h2 id="承_(ﾟ3ﾟ)～♪">承 (ﾟ3ﾟ)～♪</h2>
<p>　　讲到 Mikasa 名字的来源，实际上看过『巨人』都知道，八块腹肌的三爷。</p>
<p>　　这里小爆料一下，又拍云和花瓣（都是同宗）的项目名很大部分都是以海贼王的角色命名的——尤其是又拍云更是丧心病狂。不过这让我这个伪·二次元的小伙伴异常欣喜，因为我也能用各种啪啪啪来命名我的角色了。比如我的第一个 Storm 相关的项目就叫 Suwako，即诹访子大人，因为脑子需要各种跳，于是就对诹访子大人这位青蛙之神各种膜拜。</p>
<p>　　至于这个发射器为什么要用三爷呢？因为三爷相当于先锋军哇！</p>
<p><img src="mikasa.jpeg" alt="Mikasa"></p>
<p>　　这里的 Kafka 依赖用了搜狐小伙伴 @<a href="http://weibo.com/crzidea" target="_blank">Crzidea</a> 他们团队写的模块。</p>
<h2 id="转_(ㄏ￣▽￣)ㄏ_ㄟ(￣▽￣ㄟ)">转 (ㄏ￣▽￣)ㄏ   ㄟ(￣▽￣ㄟ)</h2>
<p>　　于是，话也不多说，直接上 repo 吧。在公司内网的 gitlab 里面有一份，还有一个 repo 在 <a href="https://github.com/" target="_blank">GitHub</a> 上。</p>
<blockquote>
<p><a href="https://github.com/XadillaX/mikasa" target="_blank">点我</a></p>
</blockquote>
<h3 id="Download_||_Clone">Download || Clone</h3>
<p>　　如果要直接下载的话就用这个链接：</p>
<blockquote>
<p><a href="https://github.com/XadillaX/mikasa/archive/master.zip" target="_blank">https://github.com/XadillaX/mikasa/archive/master.zip</a></p>
</blockquote>
<p>　　如果要克隆的话就：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="constant">XadillaX</span>/mikasa.git
</pre></td></tr></table></figure>

<h3 id="Setup">Setup</h3>
<p>　　直接安装一下依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install
</pre></td></tr></table></figure>

<h3 id="Configuration">Configuration</h3>
<p>　　接下去就是简单的配置一下了，其实就是配置下配置文件。由于是快速开发，直接用了自己之前的 <a href="https://github.com/XadillaX/exframess" target="_blank">Exframess</a> 框架，所以很多无用代码也懒得删了。</p>
<h4 id="config/server-js">config/server.js</h4>
<p>　　这里其实别的也不用动，主要是修改下端口即可。</p>
<h4 id="config/kafka-js">config/kafka.js</h4>
<p>　　这里修改一下 Kafka 的 <code>Connection String</code> 就好了。</p>
<h3 id="Start_up">Start up</h3>
<p>　　最后启动服务即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>node app.js
<span class="comment"># or</span>
<span class="variable">$ </span>pm2 app.js
<span class="comment"># or some other's</span>
</pre></td></tr></table></figure>

<h2 id="合_(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧">合 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧</h2>
<p>　　最后的效果是这样的：</p>
<p><img src="mikasa-preview.png" alt="Preview"></p>
<p>　　只要在 Topics 栏里面输入你要发送的 Topic，然后再下面的消息栏里面输入你要传的消息（字符串），最后点击 <code>Send</code> 即可将你的测试消息发进 Kafka 中去了。</p>
<blockquote>
<p>托大家的福，今天我的 Suwako 整个逻辑终于跑通了，撒花！ε٩(๑&gt; ₃ &lt;)۶з</p>
</blockquote>
]]></content>
    
    
      <category term="Kafka" scheme="http://xcoder.in/tags/Kafka/"/>
    
      <category term="Mikasa" scheme="http://xcoder.in/tags/Mikasa/"/>
    
      <category term="花瓣" scheme="http://xcoder.in/tags/%E8%8A%B1%E7%93%A3/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Untrusted - 游戏题解]]></title>
    <link href="http://xcoder.in/2014/06/12/untrusted-solution/"/>
    <id>http://xcoder.in/2014/06/12/untrusted-solution/</id>
    <published>2014-06-12T03:08:34.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://alexnisnevich.github.io/untrusted/" target="_blank">Trusted</a> 是一个代码解谜游戏，用 Javascript 来过关的。</p>
<p>　　昨天凌晨花了仨小时通关了这个游戏，在这里就粗粗做一下题解吧，好几题都是 Hack 过去的。（不要脸，( ﾟДﾟ)σ</p>
<h2 id="Ceil_Block_A">Ceil Block A</h2>
<p>　　这有点像教学关吧，总之先拿到那台电脑你就能操作了。拿到电脑后你就能修改地图内部黑色底色的代码了。</p>
<p>　　这个时候你只需要把中间设置墙的代码去掉就可以了，或者注释掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">//for(y = 3; y &lt;= map.getHeight() - 10; y++) {</span>
<span class="comment">//    map.placeObject(5, y, 'block');</span>
<span class="comment">//    map.placeObject(map.getWidth() - 5, y, 'block');</span>
<span class="comment">//}</span>
<span class="comment">//</span>
<span class="comment">//for(x = 5; x &lt;= map.getWidth() - 5; x++) {</span>
<span class="comment">//    map.placeObject(x, 3, 'block');</span>
<span class="comment">//    map.placeObject(x, map.getHeight() - 10, 'block');</span>
<span class="comment">//}</span>
</pre></td></tr></table></figure>

<p>　　然后 <code>&lt;ctrl-5&gt;</code> 重新执行——哒哒～墙就消失了，赶紧到蓝色的出口处吧。</p>
<h2 id="The_Long_Way_Out">The Long Way Out</h2>
<p>　　代码大致是给你创建了一个迷宫，并且出口处四面用围墙围起来。</p>
<p>　　我用了一个比较 Hack 的方法，在第一个黑色区域的最上方把 <code>maze.create</code> 重定向到自己的一个空函数，这样下面调用创建迷宫的函数就不会被执行，这个时候再执行的话迷宫就不见了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>maze.create = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>};
</pre></td></tr></table></figure>

<p>　　迷宫不见了还不靠谱，因为还有一个出口四周有墙——那就自己再建一个出口呗，在第二个黑色区域写上建立一个新出口的代码即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.placeObject(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"exit"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>勇敢的少年啊，快去创造奇迹！</p>
</blockquote>
<h2 id="Validation_Engaged">Validation Engaged</h2>
<p>　　这题的要求是在还存在着一定量『壁』的情况下你能到达出口，也就是说纯粹地删除它加『壁』的代码是不行的，那我们做点改动就 OK 了。把『壁』往外移动，直到把人和出口都是在『壁』内。</p>
<blockquote>
<p>那一天，人类终于回想起曾经一度被他们所支配的恐怖，还有囚禁于鸟笼中的那份屈辱。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">for</span>(y = <span class="number">0</span>; y &lt;= map.getHeight() - <span class="number">3</span>; y++) {
    map.placeObject(<span class="number">5</span>, y, <span class="string">'block'</span>);
    map.placeObject(map.getWidth() - <span class="number">5</span>, y, <span class="string">'block'</span>);
}

<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt;= map.getWidth() - <span class="number">5</span>; x++) {
    map.placeObject(x, <span class="number">3</span>, <span class="string">'block'</span>);
    map.placeObject(x, map.getHeight() - <span class="number">3</span>, <span class="string">'block'</span>);
}
</pre></td></tr></table></figure>

<h2 id="Multiplicity">Multiplicity</h2>
<p>　　嘛嘛，这是第二关的简化版——直接再搞一个出口就 OK 了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.placeObject(<span class="number">20</span>, <span class="number">10</span>, <span class="string">'exit'</span>);
</pre></td></tr></table></figure>

<h2 id="Minesweeper">Minesweeper</h2>
<p>　　这是一个雷区，你不碰雷就好。从代码里面看出来有个 <code>map.setSquareColor</code> 函数可以设置某个格子的颜色。那好办，我们在设置一个地雷后把它用别的颜色标记出来就好了，然后重新执行只要你不是色盲都能安全通过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>map.setSquareColor(x, y, <span class="string">"#ff7800"</span>);
</pre></td></tr></table></figure>

<h2 id="Drones_101">Drones 101</h2>
<p>　　这题大概就是说有个痴汉会跟你靠近，然后把你先奸后杀。</p>
<p>　　但是痴汉很笨，在他的必经之路用墙堵住他就不会继续动了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>map.placeObject(<span class="number">30</span>, <span class="number">12</span>, <span class="string">'block'</span>);
map.placeObject(<span class="number">31</span>, <span class="number">11</span>, <span class="string">'block'</span>);
</pre></td></tr></table></figure>

<h2 id="Colors">Colors</h2>
<p>　　这个是那个卖相不错的电话机的教学关卡。所以大致的意思是设置了打电话的回调函数即可。ε٩(๑&gt; ₃ &lt;)۶з</p>
<p>　　分析代码可知，要通过那几个长得跟菊花一样的带色儿的墙你就要跟那个菊花颜色一样。所以电话机的回调函数大致是让你自己变色就好了。</p>
<p>　　按照顺序所见，如果人是绿色的通过之后要变成红色，然后再变成黄色再绿色。于是写以下的变色过程就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> player = map.getPlayer();

<span class="keyword">var</span> color = player.getColor();
<span class="keyword">switch</span>(color) {
    <span class="keyword">case</span> <span class="string">"#0f0"</span>:
        player.setColor(<span class="string">"#f00"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">"#f00"</span>:
        player.setColor(<span class="string">"#ff0"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">"#ff0"</span>:
        player.setColor(<span class="string">"#0f0"</span>);
        <span class="keyword">break</span>;
}
</pre></td></tr></table></figure>

<p>　　重新执行捡起电话机，然后通过绿菊花之后按 <code>Q</code> 使用电话机让自己变色儿就好了。</p>
<blockquote>
<p>“哎呀，天！他是惦记弟弟了。……可我还不知道呢！那么这是他老人家的狗？很高兴。……你把它带去吧。……这条小狗怪不错的。……挺伶俐。……一口就把这家伙的手指咬破了！哈哈哈哈！……咦，你干吗发抖？呜呜，……呜呜。……它生气了，小坏蛋，……好一条小狗……”</p>
</blockquote>
<h2 id="Into_the_Woods">Into the Woods</h2>
<p>　　森林里面有树和墙，我也懒得想或者写代码了。（明明是自己想不出来#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</p>
<p>　　总之我是尽可能向出口靠近，然后到死路了赶紧打电话让森林重新生成一遍，如此循环往复直到出口。</p>
<h2 id="Fording_the_River">Fording the River</h2>
<p>　　23333333333333！做这题的时候差点没把自己浏览器卡死。</p>
<p>　　大致的意思是河的上面有一条船，你直接遇水会死，要上船。但是船貌似不跟你走啊 QAQ。</p>
<p>　　而且设定写着只能有一条 <code>raft</code>。</p>
<p>　　咱就来个偷天换日，自己造诺亚方舟铺满整条河（因为懒得计算）。</p>
<p>　　首先定义诺亚方舟的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"noah"</span>, {
    <span class="string">'type'</span>: <span class="string">'dynamic'</span>,
    <span class="string">'symbol'</span>: <span class="string">'a'</span>,
    <span class="string">'color'</span>: <span class="string">'#420'</span>,
    <span class="string">'transport'</span>: <span class="literal">true</span>,
    <span class="string">'behavior'</span>: <span class="function"><span class="keyword">function</span><span class="params">(me)</span> {</span>
    }
});
</pre></td></tr></table></figure>

<p>　　然后呢把它铺满整条大河吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; map.getWidth(); x++) {
    <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">5</span>; y &lt; <span class="number">15</span>; y++) {
        map.placeObject(x, y, <span class="string">'noah'</span>);
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p>一条大河，两岸宽，风吹稻花香两岸。（喂喂喂，小心卡死<em>(┐「ε:)</em></p>
</blockquote>
<h2 id="Ambush">Ambush</h2>
<p>　　后来我去 <code>Untrusted</code> 的 repo 去看题解，发现他们都是去驱使这群痴汉干嘛干嘛。我感觉我的最简单暴力了——直接废了他们。</p>
<p>　　其实呢只要把碰撞函数重写一遍，这堆痴汉马上就变得人畜无害，你走过去人家还行礼呢233333333333</p>
<p>　　仔细看一下我们要完成的部分在 <code>behavior</code> 里面，所以在这里面用 <code>this</code> 是妥妥生效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">this</span>.onCollision = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>};
</pre></td></tr></table></figure>

<blockquote>
<p>看我碎蛋大粉拳！（忽然觉得下身一阵疼痛  |Д`)ノ⌒●～*</p>
</blockquote>
<h2 id="Robot">Robot</h2>
<p>　　你走一步机器人走一步，也是教学关卡。</p>
<p>　　机器人能往下走就往下走，能往右走就往右走就拿到钥匙了，最后你再追上机器人把钥匙抢过来就好了。因为机器人是可以穿过紫翔色的那扇门的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">if</span>(me.canMove(<span class="string">"down"</span>)) me.move(<span class="string">"down"</span>);
<span class="keyword">else</span> me.move(<span class="string">"right"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>站住，保护费。你不装 X 我们还是好朋友。</p>
</blockquote>
<h2 id="Robot_Nav">Robot Nav</h2>
<p>　　我居然无聊到自己把路线数出来了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> road = <span class="string">"ddddrrrrrrrrrrrrrrrrrrrrrrrrrrrrrruurrrrrrrrrrrrrrrrrddddddd"</span>;
<span class="keyword">this</span>.cur = <span class="keyword">this</span>.cur === <span class="literal">undefined</span> ? <span class="number">0</span> : (<span class="keyword">this</span>.cur + <span class="number">1</span>);

<span class="keyword">if</span>(<span class="keyword">this</span>.cur &gt;= road.length) <span class="keyword">return</span>;

<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"d"</span>) me.move(<span class="string">"down"</span>);
<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"r"</span>) me.move(<span class="string">"right"</span>);
<span class="keyword">if</span>(road[<span class="keyword">this</span>.cur] === <span class="string">"u"</span>) me.move(<span class="string">"up"</span>);
</pre></td></tr></table></figure>

<h2 id="Robot_Maze">Robot Maze</h2>
<p>　　好吧作者早就想到了有人会无聊地去数。</p>
<p>　　嘛嘛，就如作者所愿写个最基础的 DFS 了事吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="keyword">var</span> direct = {
    <span class="string">"d"</span>: <span class="string">"down"</span>,
    <span class="string">"u"</span>: <span class="string">"up"</span>,
    <span class="string">"l"</span>: <span class="string">"left"</span>,
    <span class="string">"r"</span>: <span class="string">"right"</span>
};

<span class="comment">// dfs...</span>
<span class="keyword">if</span>(<span class="literal">undefined</span> === <span class="keyword">this</span>.dfs) {
    <span class="keyword">this</span>.ans = <span class="string">""</span>;
    <span class="keyword">this</span>.step = <span class="number">0</span>;

    <span class="keyword">var</span> vis = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
        vis.push([]);
        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) vis[i].push(<span class="literal">false</span>);
    }

    <span class="keyword">var</span> dir = [
        [ <span class="number">0</span>, -<span class="number">1</span>, <span class="string">"u"</span>, <span class="string">"#f00"</span> ],
        [ <span class="number">0</span>, <span class="number">1</span>, <span class="string">"d"</span>, <span class="string">"#0f0"</span> ],
        [ -<span class="number">1</span>, <span class="number">0</span>, <span class="string">"l"</span>, <span class="string">"#00f"</span> ],
        [ <span class="number">1</span>, <span class="number">0</span>, <span class="string">"r"</span>, <span class="string">"#fff"</span> ]
    ];

    <span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> {</span>
        <span class="keyword">if</span>(x === map.getWidth() - <span class="number">2</span> && y === <span class="number">8</span>) {
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
        vis[y][x] = <span class="literal">true</span>;

        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
            <span class="keyword">var</span> newx = x + dir[i][<span class="number">0</span>];
            <span class="keyword">var</span> newy = y + dir[i][<span class="number">1</span>];

            <span class="keyword">if</span>(newx &lt; <span class="number">0</span> || newy &lt; <span class="number">0</span> ||
                newx &gt;= map.getWidth() ||
                newy &gt;= map.getHeight() ||
                vis[newy][newx] ||
                map.getObjectTypeAt(newx, newy) === <span class="string">"block"</span>
                ) <span class="keyword">continue</span>;

            <span class="keyword">var</span> oldans = <span class="keyword">this</span>.ans;
            <span class="keyword">this</span>.ans += dir[i][<span class="number">2</span>];

            <span class="keyword">if</span>(!<span class="keyword">this</span>.dfs(newx, newy)) {
                <span class="keyword">this</span>.ans = oldans;
            } <span class="keyword">else</span> {
                map.setSquareColor(x, y, dir[i][<span class="number">3</span>]);

                <span class="keyword">return</span> <span class="literal">true</span>;
            }
        }

        <span class="keyword">return</span> <span class="literal">false</span>;
    };

    <span class="keyword">this</span>.dfs(<span class="number">1</span>, <span class="number">1</span>);
    <span class="keyword">this</span>.ans += <span class="string">"dd"</span>;
}

<span class="keyword">if</span>(<span class="keyword">this</span>.step &gt;= <span class="keyword">this</span>.ans.length) <span class="keyword">return</span>;
me.move(direct[<span class="keyword">this</span>.ans[<span class="keyword">this</span>.step++]]);
</pre></td></tr></table></figure>

<blockquote>
<p>红魔馆的地下室一样呢。反正是机器人多走几步路没事，没必要用 BFS 求最优解2333333333</p>
</blockquote>
<h2 id="Crisps_Contest">Crisps Contest</h2>
<p>　　刚才那仨 2B 机器人引领你拿到了仨颜色的钥匙在这边派上用场了。</p>
<p>　　钻红菊花你需要有红钥匙，并且用了之后会少掉。其它颜色也一样。最终你要拿到 <code>A</code> 所代表的 <code>theAlgorithm</code> 走到出口。</p>
<blockquote>
<p>等等！啊咧？绿钥匙的通过判定有个地方可以修改？就是你通过绿菊花的时候需要有绿钥匙并且你可以选择你丢弃的东西。丢什么好呢？电脑？不行不行，过关还靠它呢。电话机？以后肯定要用到。其它颜色钥匙？那你肯定会被锁在某个地方出不来。那就只有丢弃 <code>theAlgorithm</code> 了——反正只要拿到 <code>theAlgorithm</code> 之后不再通过绿菊花就没事了。</p>
</blockquote>
<p>　　于是只要把绿菊花的通过判断函数里面可修改的区域改成 <code>theAlgorithm</code> 就好了。</p>
<p>　　最后走的顺序大概是：</p>
<blockquote>
<p>进左上角的门拿到<span style="color: yellow;">黄药屎</span>和<span style="color: blue;">蓝药屎</span>出来。然后右上角把<span style="color: red;"><strong>红</strong></span>和<span style="color: blue;"><strong>蓝</strong></span>拿出来。然后向下直捣黄龙，左黄菊花进拿到 <code>theAlgorithm</code> 蓝菊花通过拿到<span style="color: yellow;">黄药屎</span>然后再黄菊花出。</p>
<p>大功告成！走向胜利的出口吧！</p>
<p><strong>自古红蓝出 CP！</strong></p>
</blockquote>
<h2 id="Exceptional_Crossing">Exceptional Crossing</h2>
<p>　　又是过河啊，这次你只能是死了，因为你的编辑区域只有在 <code>player.killedBy()</code> 里面。</p>
<blockquote>
<p>《订制死神》：这个时候让死神笑就可以了。</p>
</blockquote>
<p>　　让我们一起来玩坏它吧！在里面填上 <code>) = (0</code> 就好了。什么什么看不懂？你填进去看一下整句话就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>player.killedBy() = (<span class="number">0</span>);
</pre></td></tr></table></figure>

<p>　　然后死神就会被你玩坏了。你走过去的时候这句话执行出错了2333333</p>
<h2 id="Lasers">Lasers</h2>
<p>　　有很多隐藏线，你人必须要跟隐藏线的颜色一致才能通过，然后目前所有线都用白色给画出来。</p>
<p>　　目测作者的意思是让你把硬编码的白色改成隐藏线的颜色，这样就能把线的颜色给标记出来，然后再给电话机写个函数就是让你自己的人变色。</p>
<p>　　不过我还是用了个 Hack 的方法——</p>
<p>　　第一条线他要画就画，咱不碰它就好了，只不过在第一条线画完的后面我们把这个画线函数给 Hack 掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// using canvas to draw the line</span>
<span class="keyword">var</span> ctx = map.getCanvasContext();
ctx.beginPath();
ctx.strokeStyle = <span class="string">'white'</span>;
ctx.lineWidth = <span class="number">5</span>;
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();

createLaser = abc;
</pre></td></tr></table></figure>

<p>　　接下去是在第二片区域写下自己的画线函数吧，这题最下方检测了线的数量不能少于 25 条。么事，爷高兴画 100 条都么问题，因为我都把它缩在左上角了 2333333</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">abc</span><span class="params">()</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) {
        map.createLine([<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span><span class="params">(player)</span> {</span>
            <span class="comment">//... Ahahaha</span>
        });

        <span class="keyword">var</span> ctx = map.getCanvasContext();
        ctx.beginPath();
        ctx.strokeStyle = <span class="string">'red'</span>;
        ctx.lineWidth = <span class="number">5</span>;
        ctx.moveTo(<span class="number">1</span>, <span class="number">1</span>);
        ctx.lineTo(<span class="number">2</span>, <span class="number">2</span>);
        ctx.stroke();
    }
}
</pre></td></tr></table></figure>

<h2 id="Pointers">Pointers</h2>
<p>　　有好多传送门，每次执行随机生成传送位置，有些传送门会把你传到二小姐的地下室然后被吃掉。</p>
<p>　　我也懒得多动脑筋或者画线什么的，直接对两个都是传送门的 CP 标记一样的随机颜色就好了，最后跟着颜色走到出口去（有个坑就是有时候这个地图本身就是死局，所以得多试几次重新执行 இдஇ</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> dict = <span class="string">"0123456789ABCDEF"</span>;
<span class="keyword">if</span>(t1.getType() === <span class="string">"teleporter"</span> && t2.getType() === <span class="string">"teleporter"</span>) {
    <span class="keyword">var</span> color = <span class="string">"#"</span> + dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +
        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)] +
        dict[<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">15</span>)];

    map.setSquareColor(t1.getX(), t1.getY(), color);
    map.setSquareColor(t2.getX(), t2.getY(), color);
}
</pre></td></tr></table></figure>

<h2 id="Super_Dr-_Eval_Bros">Super Dr. Eval Bros</h2>
<p>　　好吧本意是让你设置一个 <code>timer</code> 然后一直跳啊跳的。</p>
<p>　　不过呢，定一个新方块给自己搭一座桥就是了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"❤"</span>, {
    impassable: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="literal">true</span>;
    },
    symbol: <span class="string">"❤"</span>
});
map.placeObject(<span class="number">20</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">21</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">22</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">23</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">24</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">25</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">26</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">27</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">28</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
map.placeObject(<span class="number">29</span>, <span class="number">12</span>, <span class="string">"❤"</span>);
</pre></td></tr></table></figure>

<blockquote>
<p>你只要打个电话桥就会出现的。</p>
</blockquote>
<h2 id="Document_Object_Madness">Document Object Madness</h2>
<p>　　好神奇！好奇葩！我键盘 <code>hjkl</code> 乱按一通就过了。</p>
<h2 id="Boss_Fight">Boss Fight</h2>
<p>　　打 Boss 了。</p>
<p>　　好吧我承认我 Cheat 了——原谅我用了 <code>console.log</code>。</p>
<blockquote>
<p>因为当我打开控制台的时候下面的语句出现在我的眼里：</p>
<blockquote>
<p><strong><em>If you can read this, you are cheating!</em></strong></p>
<p><strong><em>But really, you don’t need this console to play the game. Walk around using arrow keys (or Vim keys), and pick up the computer (⌘). Then the fun begins!</em></strong></p>
</blockquote>
</blockquote>
<p>　　嘛嘛，无论如何，过关了就好。</p>
<p>　　这题呢是要让所有的 <code>boss</code> 给毁灭掉即可—— 当所有的 <code>boss</code> 毁灭之后会爆出任务道具 <code>theAlgorithm</code> 然后就能通关了。</p>
<p>　　后来我发现可以让子弹消灭 <code>boss</code>。但是我当时没这么做。</p>
<p>　　我先弄了堵墙把子弹挡住先：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>map.defineObject(<span class="string">"保命的"</span>, {
    impassable: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="literal">true</span>;
    },
    symbol: <span class="string">"❤"</span>,
    onCollision: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    }
});

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; map.getWidth(); i++) {
    map.placeObject(i, <span class="number">9</span>, <span class="string">"保命的"</span>);
}
</pre></td></tr></table></figure>

<p>　　这下你就能捡到电话机了——然后给电话机写回调函数。</p>
<p>　　怎么说呢，当你每用一次电话机，我就把当前存在于屏幕的 <code>boss</code> 和 <code>bullet</code> 给分开罗列，然后把 <code>boss</code> 的 <code>_destroy</code>（警察叔叔，就是这个函数是我 <code>console.log</code> 出来的）给嫁接到 <code>bullet</code> 的 <code>_destroy</code> 去。</p>
<p>　　这样会出现什么样的结果呢？——当子弹碰到墙的时候就会销毁，这个时候会触发 <code>_destroy</code> 函数，但是这个时候的 <code>_destroy</code> 函数已经会变成了 <code>boss</code> 的了，也就是说这个时候子弹不会被销毁反而是某一个 <code>boss</code> 的 <code>_destroy</code> 函数被调用然后被销毁了。</p>
<p>　　再怎么说这都是 Hack 的办法，所以并不会触发 <code>boss</code> 的 <code>onDestroy</code> 函数也就是说即使所有 <code>boss</code> 都没了也不会出现 <code>theAlgorithm</code> 这玩意儿。</p>
<blockquote>
<p>自己动手丰衣足食！</p>
</blockquote>
<p>　　敌人不给我们我们就自己造呗！反正通关判定是——<code>boss</code> 数量为 <code>0</code> 且你有 <code>theAlgorithm</code> 这个道具。</p>
<p>　　所以说当所有 <code>boss</code> 都被销毁之后，我们自己去 <code>map.replaceObject</code> 一个 <code>theAlgorithm</code> 道具即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>map.getPlayer().setPhoneCallback(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> bosses = [];
    <span class="keyword">var</span> bullets = [];
    <span class="keyword">var</span> objects = map.getDynamicObjects();
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) {
        <span class="keyword">if</span>(objects[i].getType() == <span class="string">"boss"</span>) {
            bosses.push(objects[i]);
        } <span class="keyword">else</span> {
            bullets.push(objects[i]);
        }
    }
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(bosses.length, bullets.length); i++) {
        bullets[i]._destroy = bosses[i]._destroy;
    }

    <span class="keyword">if</span>(bosses.length === <span class="number">0</span>) {
        map.placeObject(map.getPlayer().getX(), map.getPlayer().getY() + <span class="number">1</span>,
            <span class="string">'theAlgorithm'</span>);
    }
});
</pre></td></tr></table></figure>

<p>　　以上代码写完后就开始打 <code>boss</code> 吧！赶紧去拿到电话机，然后你会发现打一个电话 <code>boss</code> 就少一堆，那感觉倍爽儿！</p>
<h2 id="End_of_the_Line">End of the Line</h2>
<p>　　马上要通关了。这里是个坑，开始我还以为这里就是真·通关了 QAQ。</p>
<p>　　随后看看后面还是有关卡啊。但是我突然发现 <code>&lt;ctrl+0&gt;</code> 跳出来的 menu 左边多出了文件夹！然后进去随意翻看了。</p>
<p>　　最后发现原来是要修改 <code>scripts/objects.js</code> 文件→＿→。</p>
<p>　　好吧，分析通关验证来看，这一关的 <code>map.finalLevel</code> 为 <code>true</code>。所以我们只需要把 <code>scripts/objects.js</code> 文件里面的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span>(!game.map.finalLevel) {
    game._moveToNextLevel();
}
</pre></td></tr></table></figure>

<p>给改成如果是 <code>finalLevel</code> 就跑到下一关去就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span>(game.map.finalLevel) {
    game._moveToNextLevel();
}
</pre></td></tr></table></figure>

<h2 id="Credits">Credits</h2>
<p>　　由于事先文章结构没有写好，就接这关的坑位来小结吧 0. 0。（反正人家只是序幕章了</p>
<p>　　好的，其实也什么总结的，但是总觉得得有这么个小结才对。</p>
<p>　　找工作啊找工作——有想要我的请联系我 2333333333</p>
<p>　　联系资料在 <a href="http://xcoder.in/curriculumvitae/">CV</a> 里面。</p>
]]></content>
    
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="untrusted" scheme="http://xcoder.in/tags/untrusted/"/>
    
      <category term="游戏" scheme="http://xcoder.in/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos2d-x 3.1.1 开发环境搭建（Win篇）]]></title>
    <link href="http://xcoder.in/2014/06/07/cocos2d-311-setup/"/>
    <id>http://xcoder.in/2014/06/07/cocos2d-311-setup/</id>
    <published>2014-06-07T11:34:02.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>由于偷懒，所以在此感谢 Etond 的指导（喂喂喂，明明是自己懒得看文档，明明 <a href="README"><code>READEME.md</code></a> 里面就有！(´≖◞౪◟≖)</p>
<p>　　另，在搭建环境的时候，最好保证你在<span style="background: #222;">墙外</span>。以及我默认觉得大家已经有了 <code>Python</code> 环境和 <code>JDK</code>。</p>
<h2 id="前驱工作">前驱工作</h2>
<p>　　先去 <a href="http://www.cocos2d-x.org/download" target="_blank">cocos2d-x 官网</a>下压缩包，放到一个只有神知道的世界里面。</p>
<p>　　接下去需要安装仨东西：</p>
<h3 id="Android_SDK">Android SDK</h3>
<p>　　<a href="http://developer.android.com/sdk/index.html#download" target="_blank">这东西</a>真尼玛大啊！我家的小水管真吃不起。</p>
<p>　　然后把 <strong>adt-bundle-…zip</strong> 这个包压缩到任意木有中文和空格的路径下面。</p>
<h3 id="NDK">NDK</h3>
<p>　　<a href="http://developer.android.com/tools/sdk/ndk/index.html#download" target="_blank">这小伙伴</a>也不小啊。都是 500M 的主儿啊（٩(ŏ﹏ŏ、)۶</p>
<p>　　也解压到一个地方不用管它。</p>
<h3 id="Ant">Ant</h3>
<p>　　据说这货是阿帕奇出的？总之下载地址在<a href="http://ant.apache.org/bindownload.cgi" target="_blank">这里</a>。</p>
<h2 id="安装">安装</h2>
<p>　　哦对了你还得有个 Python 路径，这里就不累述了。接下去在命令行里面执行 Cocos2d 的 <code>setup.py</code> 文件即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>/&gt; py setup<span class="preprocessor">.py</span>
</pre></td></tr></table></figure>

<p>　　接下去终端会停在下面一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> NDK_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　在后面输入你放好的 NDK 目录即可。</p>
<p>　　如果下面又出现了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> ANDROID_SDK_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　你只需在里面输入你刚放好的 Android SDK 的目录即可。（注意是要刚才的 SDK 压缩包解压出来的 sdk 路径）</p>
<p>　　再如果下面还出现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please enter <span class="operator">the</span> path <span class="operator">of</span> ANT_ROOT (<span class="operator">or</span> press Enter <span class="built_in">to</span> skip):
</pre></td></tr></table></figure>

<p>　　那么再把 Ant 的路径搞上去就好了。（又得注意这里得是 Ant 的 bin 目录）</p>
<p>　　最后确保终端（或者说命令行）里面出现如下字样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Please restart <span class="operator">the</span> terminal <span class="operator">or</span> restart computer <span class="built_in">to</span> make added <span class="keyword">system</span> variables take effect
</pre></td></tr></table></figure>

<p>　　然后你把终端关了再开一个就好了。至此，大致就安装完毕了。</p>
<h2 id="新建一个_Demo_项目">新建一个 Demo 项目</h2>
<p>　　随意跑到一个目录下面执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> cocos <span class="literal">new</span> FirstGame <span class="attribute">-p</span> <span class="keyword">in</span><span class="built_in">.</span>xcoder<span class="built_in">.</span>firstgame <span class="attribute">-l</span> cpp <span class="attribute">-d</span> FirstGame
</pre></td></tr></table></figure>

<blockquote>
<p>大致意思就是说创建一个新的项目路径，叫 <code>FirstGame</code>，其包名叫 <code>in.xcoder.firstgame</code>，然后语言是 <code>cpp</code>，最后 <code>-d</code> 是路径。</p>
</blockquote>
<p>　　命令详情帮助可以看 <code>cocos --help</code>。</p>
<h3 id="编译_Demo">编译 Demo</h3>
<p>　　读标题，是 Win 篇。所以我们跑到项目路径下面的 <code>proj.win32</code> 目录下面用 M$ VS 打开 <code>FirstGame.sln</code> 就可以打开刚创建的模板项目了。</p>
<p>　　无论如何先编译看看吧！～</p>
<p>　　如何？跑起来了吧？</p>
<h3 id="打包_Demo">打包 Demo</h3>
<p>　　这里就讲讲如何打包安卓的版本吧：</p>
<h4 id="Debug_版本">Debug 版本</h4>
<p>　　跑到你的项目目录下面（即有 <code>.cocos-project.json</code> 文件的目录），然后执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>/&gt; cocos <span class="command">run</span> -p android
</pre></td></tr></table></figure>

<p>　　等工具编译打包完成就 OK 了。（记得要查安卓手机并且调试模式哦～）</p>
<h4 id="Release_版本">Release 版本</h4>
<p>　　如果要上传到 Google Play 之类的地方，需要有签名。所以发布 Release 版本之前，你先得搞好自己的签名。</p>
<h5 id="Keytool">Keytool</h5>
<p>　　在终端跑到你的项目路径下面，然后执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> keytool <span class="attribute">-genkey</span> <span class="attribute">-v</span> <span class="attribute">-keystore</span> FirstGame<span class="built_in">.</span>keystore <span class="attribute">-alias</span> FirstGame <span class="attribute">-keyalg</span> RSA <span class="attribute">-keysize</span> <span class="number">2048</span> <span class="attribute">-validaty</span> <span class="number">10000</span>
</pre></td></tr></table></figure>

<p>　　照着命令行给的提示完成创建密钥即可。</p>
<h5 id="编译">编译</h5>
<p>　　生成之后啊就直接执行编译命令了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">/</span><span class="subst">&gt;</span> cocos run <span class="attribute">-p</span> android <span class="attribute">-m</span> release
</pre></td></tr></table></figure>

<p>　　在里面呢最后会让你输入 <code>.keystore</code> 文件的路径。</p>
<p>　　我们输入相对路径，由于我们刚才把这个文件搞在项目根目录，所以我们只需要输入 <code>../FirstGame.keystore</code> 即可。接下去他会让你输入密码、别名和别名信息的密码。你都正确输入一遍他就会安安分分跑在你的手机里面了。</p>
<h4 id="仨版本的文件路径">仨版本的文件路径</h4>
<p>　　上面都弄好之后，你的仨版本 <code>*.apk</code> 文件也就生成了。很多人可能很困惑，为什么是仨版本。因为其中 Release 版本还分带签名和没签名版本。</p>
<p>　　总之那个路径在 <code>publish/android</code> 下面，里面有仨 <code>*.apk</code> 文件，你拿出来发布就可以了。</p>
<h2 id="小结">小结</h2>
<p>　　其实也没什么结不结的，这些东西你们自己去看看官方文档就好了。总之就这样了吧，以上。</p>
]]></content>
    
    
      <category term="cocos2d" scheme="http://xcoder.in/tags/cocos2d/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【转】TCP 的那些事儿（上）]]></title>
    <link href="http://xcoder.in/2014/06/07/tcp-those-things-1/"/>
    <id>http://xcoder.in/2014/06/07/tcp-those-things-1/</id>
    <published>2014-06-06T17:47:10.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习 TCP 本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于 TCP 这个协议的细节，我还是推荐你去看 <a href="http://www.kohala.com/start/" target="_blank">W.Richard Stevens</a> 的《<a href="http://book.douban.com/subject/1088054/" target="_blank">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下 <a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC793</a> 以及后面 N 多的 RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>　　之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>　　所以，本文不会面面俱到，只是对 TCP 协议、算法和原理的科普。</p>
<p>　　我本来只想写一个篇幅的文章的，但是 TCP 真 TMD 的复杂，比 C++ 复杂多了，这 30 多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍TCP的流迭、拥塞处理。</li>
</ul>
<p>　　废话少说，首先，我们需要知道 TCP 在网络 OSI 的七层模型中的第四层 —— 传输层(Transport)，IP 在第三层 —— 网络层(Network)，ARP 在第二层 —— 数据链路层(Data Link)，在第二层上的数据，我们叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。</p>
<p>　　首先，我们需要知道，我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h2 id="TCP头格式">TCP头格式</h2>
<p>　　接下来，我们来看一下 TCP 头的格式</p>
<p><img src="TCP-Header-01.jpg" alt="TCP 头格式 1"></p>
<center>TCP 头格式 1（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank">图片来源</a>）</center>

<p>　　你需要注意这么几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（<code>src_ip</code>, <code>src_port</code>, <code>dst_ip</code>, <code>dst_port</code>）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong><em>Sequence Number</em></strong> 是包的序号，用来<strong>解决网络包乱序（reordering）问题</strong>。</li>
<li><strong><em>Acknowledgement Number</em></strong> 就是 ACK —— 用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong><em>Window</em></strong> 又叫 <strong><em>Advertised-Window</em></strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong><em>TCP Flag</em></strong> ，也就是包的类型，主要是<strong>用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p>　　关于其它的东西，可以参看下面的图示</p>
<p><img src="TCP-Header-02.jpg" alt="TCP 头格式 2"></p>
<center>TCP 头格式 2（<a href="http://nmap.org/book/tcpip-ref.html" target="_blank">图片来源</a>）</center>

<h2 id="TCP的状态机">TCP的状态机</h2>
<p>　　其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。</p>
<p>　　下面是：“<strong>TCP 协议的状态机</strong>”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank">图片来源</a>） 和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以 TCP 协议其实也挺坑爹的）</p>
<p><img src="tcpfsm.png" alt="TCP 协议的状态机"> <img src="tcp_open_close.jpg" alt="握手次数"></p>
<p>　　很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p>
<ul>
<li><strong>对于建链接的 3 次握手</strong>，主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number） —— 所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li>
<li><strong>对于 4 次挥手</strong>，其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达T IME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li>
</ul>
<p><img src="tcpclosesimul.png" alt="两端同时断开链接"></p>
<center>两端同时断开链接（<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm" target="_blank">图片来源</a>）</center>

<p>　　另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时 SYN 超时</strong>。试想一下，如果 server 端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的 ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。在 Linux 下，默认重试次数为 5 次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 - 1 = 63s，TCP 才会把断开这个连接。</li>
<li><strong>关于 SYN Flood 攻击</strong>。一些恶意的人就为此制造了 SYN Flood 攻击 —— 给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫 <code>tcp_syncookies</code> 的参数来应对这个事 —— 当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，请先千万别用 <code>tcp_syncookies</code> 来处理正常的大负载的连接的情况。因为，<code>synccookies</code> 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：<code>tcp_synack_retries</code> 可以用他来减少重试次数；第二个是：<code>tcp_max_syn_backlog</code>，可以增大 SYN 连接数；第三个是：<code>tcp_abort_on_overflow</code> 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于 ISN 的初始化</strong>。ISN 是不能 hard code 的，不然会出问题的 —— 比如：如果连接建好后始终用 1 来做 ISN，如果 client 发了 30 个 segment 过去，但是网络断了，于是 client 重连，又用了 1 做 ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client 的 Sequence Number 可能是 3，而 Server 端认为 client 端的这个号是 30 了。全乱了。RFC793 中说，ISN 会和一个假的时钟绑在一起，这个时钟会在每4微秒对 ISN 做加一操作，直到超过 2^32，又从 0 开始。这样，一个ISN的周期大约是 4.55 个小时。因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过 Maximum Segment Lifetime（缩写为 MSL - Wikipedia 语条），所以，只要 MSL 的值小于 4.55 小时，那么，我们就不会重用到 ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的 ISN 的描述，相信你也知道 MSL 是怎么来的了。我们注意到，在 TCP 的状态图中，从 TIME_WAIT 状态到 CLOSED 状态，有一个超时设置，这个超时设置是 2 * MSL（RFC793 定义了 MSL 为 2 分钟，Linux 设置成了 30s）为什么要这有 TIME_WAIT？为什么不直接给转成 CLOSED 状态呢？主要有两个原因：<ol>
<li>TIME_WAIT 确保有足够的时间让对端收到了 ACK，如果被动关闭的那方没有收到 Ack，就会触发被动端重发 Fin，一来一去正好 2 个MSL；</li>
<li>有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
</ol>
</li>
<li><strong>关于 TIME_WAIT 数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT 是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫 <code>tcp_tw_reuse</code>，另一个叫 <code>tcp_tw_recycle</code> 的参数，这两个参数默认值都是被关闭的，后者 recyle 比前者 resue 更为激进，resue 要温柔一些。另外，如果使用 <code>tcp_tw_reuse</code>，必需设置 <code>tcp_timestamps = 1</code>，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑 —— 可能会让 TCP 连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank">官方文档</a>上说的一样“<strong><em>It should not be changed without advice/request of technical experts</em></strong>”）。<ol>
<li><strong>关于 <code>tcp_tw_reuse</code></strong>。官方文档上说 <code>tcp_tw_reuse</code> 加上 <code>tcp_timestamps</code>（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要 <code>tcp_timestamps</code> 在两边都被打开（你可以读一下 <code>tcp_twsk_unique</code> 的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于 <code>tcp_tw_recycle</code></strong>。如果是 <code>tcp_tw_recycle</code> 被打开了话，会假设对端开启了 <code>tcp_timestamps</code>，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建链接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）（如果你想观摩一下 Linux 的内核代码，请参看源码 <code>tcp_timewait_state_process</code>）。</li>
<li><strong>关于 <code>tcp_max_tw_buckets</code></strong>。这个是控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗 DDoS 攻击的。也说的默认值 180000 并不小。这个还是需要根据实际情况考虑。</li>
</ol>
</li>
</ul>
<blockquote>
<p>Again，使用 <code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 来解决 TIME_WAIT 的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank">RFC 1122</a>） 。</p>
</blockquote>
<h2 id="数据传输中的_Sequence_Number">数据传输中的 Sequence Number</h2>
<p>　　下图是我从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 <code>Statistics -&gt; Flow Graph…</code>）</p>
<p><img src="tcp_data_seq_num.jpg" alt="数据传输图"></p>
<p>　　你可以看到，SeqNum 的增加是和传输的字节数相关的。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。</p>
<blockquote>
<p><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum —— 相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了。</p>
</blockquote>
<h2 id="TCP重传机制">TCP重传机制</h2>
<p>　　TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>　　注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<h3 id="超时重传机制">超时重传机制</h3>
<p>　　一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4 —— 意味着 3 和 4 都收到了。</p>
<p>　　但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。</p>
<p>　　对此有两种选择：</p>
<ul>
<li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li>
<li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li>
</ul>
<p>　　这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p>
<h3 id="快速重传机制">快速重传机制</h3>
<p>　　于是，TCP 引入了一种叫 <strong><em>Fast Retransmit</em></strong> 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。<strong><em>Fast Retransmit</em></strong> 的好处是不用等 timeout 了再重传。</p>
<p>　　比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack = 2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：</p>
<p><img src="FASTIncast021.png" alt="快速重传"></p>
<p>　　Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是重转之前的一个还是重装所有的问题。对于上面的示例来说，是重传 #2 呢还是重传 #2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2) 是谁传回来的？也许发送端发了 20 份数据，是 #6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p>
<h3 id="SACK_方法">SACK 方法</h3>
<p>　　另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（参看 <a href="http://tools.ietf.org/html/rfc2018" target="_blank">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：</p>
<p><img src="tcp_sack_example-1024x577.jpg" alt="SACK方法"></p>
<p>　　这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过 <code>tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<p>　　这里还需要注意一个问题 —— 接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</p>
<blockquote>
<p><strong>注意</strong>：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank">TCP SACK的性能权衡</a>》</p>
</blockquote>
<h3 id="Duplicate_SACK_–_重复收到数据的问题">Duplicate SACK – 重复收到数据的问题</h3>
<p>　　Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a> 里有详细描述和示例。下面举几个例子（来源于 <a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a>）</p>
<p>　　D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li>
<li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li>
</ul>
<h4 id="示例一：ACK_丢包">示例一：ACK 丢包</h4>
<p>　　下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000 - 3499），于是接收端发现重复收到，于是回了一个 SACK = 3000 - 3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK —— 旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="attribute">Transmitted  Received    ACK Sent
Segment      Segment     (Including SACK Blocks)

3000-3499    3000-3499   3500 (ACK dropped)
3500-3999    3500-3999   4000 (ACK dropped)
3000-3499    3000-3499   4000, SACK</span>=<span class="string">3000-3500
                                    ---------</span>
</pre></td></tr></table></figure>

<h4 id="示例二：网络延误">示例二：网络延误</h4>
<p>　　下面的示例中，网络包（1000 - 1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK = 1000 - 1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK —— 标识收到了重复的包。</p>
<p>　　这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="xml"><span class="tag"><span class="attribute">Transmitted</span>    <span class="attribute">Received</span>    <span class="attribute">ACK</span> <span class="attribute">Sent</span>
<span class="attribute">Segment</span>        <span class="attribute">Segment</span>     (<span class="attribute">Including</span> <span class="attribute">SACK</span> <span class="attribute">Blocks</span>)
 
<span class="attribute">500-999</span>        <span class="attribute">500-999</span>     <span class="attribute">1000</span>
<span class="attribute">1000-1499</span>      (<span class="attribute">delayed</span>)
<span class="attribute">1500-1999</span>      <span class="attribute">1500-1999</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-2000</span>
<span class="attribute">2000-2499</span>      <span class="attribute">2000-2499</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-2500</span>
<span class="attribute">2500-2999</span>      <span class="attribute">2500-2999</span>   <span class="attribute">1000</span>, <span class="attribute">SACK</span>=<span class="value">1500-3000</span>
<span class="attribute">1000-1499</span>      <span class="attribute">1000-1499</span>   <span class="attribute">3000</span>
               <span class="attribute">1000-1499</span>   <span class="attribute">3000</span>, <span class="attribute">SACK</span>=<span class="value">1000-1500</span>
                                      <span class="attribute">---------</span></span></span>
</pre></td></tr></table></figure>

<p>　　可见，引入了 D-SACK，有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</li>
<li>是不是自己的 timeout 太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称 reordering）</li>
<li>网络上是不是把我的数据包给复制了。</li>
</ol>
<p>　　<strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。</strong></p>
<p>　　Linux 下的 <code>tcp_dsack</code> 参数用于开启这个功能（Linux 2.4 后默认打开）</p>
<p>　　好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《<a href="http://coolshell.cn/articles/11609.html" target="_blank">TCP的那些事（下）</a>》</p>
<p>　　[原文链接：<a href="http://coolshell.cn/articles/11564.html" target="_blank">http://coolshell.cn/articles/11564.html</a>]</p>
]]></content>
    
    
      <category term="TCP" scheme="http://xcoder.in/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个任务队列的 module]]></title>
    <link href="http://xcoder.in/2014/06/03/scartlet-task/"/>
    <id>http://xcoder.in/2014/06/03/scartlet-task/</id>
    <published>2014-06-02T16:17:38.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>事情很曲折，我某天在萌否收音机里面听到了一首歌，很好听，叫 <code>hypnotized</code>，于是红心了。</p>
<p>　　过了几天我再去听——发现这首歌变了。</p>
<p>　　最后经过多方面求证，我大概得出结果就是应该有人传错了歌，然后后来有人重新传了一遍，导致我听的不是原来那首歌了。那我那天听的那首歌到底叫什么名字呢？</p>
<p>　　然后大致看了一下，虽然歌被重新传了，但是<a href="http://moe.fm/music/9600" target="_blank">这里</a>显示的这首歌的时间没变！还是11分钟，目测是数据库没更新。</p>
<p>　　于是我就想了个笨办法，去爬收音机里面所有 tag 为 <code>東方project</code> 的专辑，然后跑到专辑页看歌曲的长度。</p>
<p>　　问题来了，如果我直接爬，然后爬完 <code>callback</code> 之后又直接爬，没有任何间隔，就相当于我在 <code>DDOS</code> 它的站子。或者即使没那么严重——反正最后到一定程度并发太大我就访问不了了。</p>
<p>　　于是我就想到了做一个任务队列的 module。该 module 的作用就是把一堆任务扔到队列中，完成一个才开始下一个。</p>
<p>　　然后如果同时执行一个也太慢，module 还允许你开多几个子队列同时执行。</p>
<p>　　模块的 repo 在 <a href="https://github.com/XadillaX/scarlet-task" target="_blank">GitHub</a> 上面。名字叫 <code>Scarlet Task</code> 的原因一是我本身就喜欢二小姐，二是为了纪念这次事件我是为了找有关二小姐的歌。</p>
<p>　　要安装也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install scarlet-task
</pre></td></tr></table></figure>

<p>　　然后 repo 的 <code>README.md</code> 里面有使用方法的——大致就是实例化一个对象，然后定义好某个任务的任务标识（可以是字符串，可以是 json 对象，可以是任何类型的数据），然后再定义好处理这个任务的函数，将这个数据推倒队列中即可。然后在处理函数中任务处理完的时候执行以下任务完成的函数即可。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="任务队列" scheme="http://xcoder.in/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建 VIM 下的 Hexo 编辑环境]]></title>
    <link href="http://xcoder.in/2014/06/02/vim-hexo-environment/"/>
    <id>http://xcoder.in/2014/06/02/vim-hexo-environment/</id>
    <published>2014-06-01T20:52:30.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>本文只讲两个函数，对于 <code>markdown</code> 如何高亮之类的问题还请自行谷歌。</p>
<p>　　然后请打开你自己的 <code>.vimrc</code> 文件。</p>
<h2 id="预备工作">预备工作</h2>
<p>　　首先定义一个变量——你自己的 <code>hexo</code> 目录，如果要跨平台可以做个判断之类的，如下：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> has(<span class="string">"win32"</span>)
    <span class="built_in">let</span> g:hexoProjectPath=<span class="string">"E:\\cygwin\\home\\XadillaX\\hexo"</span>
<span class="keyword">else</span>
    <span class="built_in">let</span> g:hexoProjectPath=<span class="string">"~/hexo/"</span>
endif
</pre></td></tr></table></figure>

<h2 id="几个函数">几个函数</h2>
<h3 id="进入_Hexo_目录">进入 Hexo 目录</h3>
<p>　　这个函数大致就是让你进入你自己的 <code>Hexo</code> 路径：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">fun</span>! <span class="variable">OpenHexoProjPath</span>()
    execute <span class="string">"cd "</span> . g:hexo<span class="variable">ProjectPath</span>
endfun
</pre></td></tr></table></figure>

<h3 id="打开一篇_Post">打开一篇 Post</h3>
<p>　　接下去就是一个打开 <code>Post</code> 的函数了：</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span>! <span class="title">OpenHexoPost</span><span class="params">(...)</span></span>
    call OpenHexoProjPath()

    let filename = <span class="string">"source/_posts/"</span> . a:<span class="number">1</span> . <span class="string">".md"</span>
    execute <span class="string">"e "</span> . filename
<span class="function"><span class="keyword">endfunction</span></span>
</pre></td></tr></table></figure>

<blockquote>
<p>解析：上面的代码大意就是进入 Hexo 路径，然后设定好文件名，最后执行 <code>:e filename</code> 即可打开文件了。</p>
</blockquote>
<h3 id="新建一篇_Post">新建一篇 Post</h3>
<p>　　新建的流程跟打开相似，只不过首先要在 <code>Hexo</code> 目录下执行一遍 <code>hexo new FOO</code> 的命令而已，命令执行完毕之后再打开即可。</p>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span>! <span class="title">NewHexoPost</span><span class="params">(...)</span></span>
    call OpenHexoProjPath()

    let filename = a:<span class="number">1</span>
    execute <span class="string">"!hexo new "</span> . filename

    call OpenHexoPost(a:<span class="number">1</span>)
<span class="function"><span class="keyword">endfunction</span></span>
</pre></td></tr></table></figure>

<h2 id="指令映射">指令映射</h2>
<p>　　函数写好后我们最后把函数映射成类似于 <code>:e</code>, <code>:w</code> 之类的后面能跟着参数的指令即可。</p>
<p>　　以前木有接触过的同学可以参考一下<a href="http://vimdoc.sourceforge.net/htmldoc/usr_40.html#40.2" target="_blank">这里</a>的文档。</p>
<h3 id="打开指令">打开指令</h3>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command"><span class="keyword">command</span> -<span class="title">nargs</span>=+ <span class="title">HexoOpen</span> :<span class="title">call</span> <span class="title">OpenHexoPost</span>(<span class="string">"&lt;args&gt;"</span>)</span>
</pre></td></tr></table></figure>

<h3 id="新建指令">新建指令</h3>
<figure class="highlight vimrc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command"><span class="keyword">command</span> -<span class="title">nargs</span>=+ <span class="title">HexoNew</span> :<span class="title">call</span> <span class="title">NewHexoPost</span>(<span class="string">"&lt;args&gt;"</span>)</span>
</pre></td></tr></table></figure>

<h2 id="使用方法">使用方法</h2>
<p>　　当你做完以上步骤的时候，你就可以无论在什么目录下在 VIM 里面通过下面的指令进行新建一篇日志了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">:HexoNew</span> artical-name
</pre></td></tr></table></figure>

<p>　　以及下面的指令来打开一篇已存在的日志：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">:HexoOpen</span> artical-name
</pre></td></tr></table></figure>

<h2 id="遗留问题">遗留问题</h2>
<p>　　相信看到这里之后，大家也能自己写出一个生成的指令了，这里就不累述了，无非就是：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>:!hexo <span class="keyword">generate</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="vim" scheme="http://xcoder.in/tags/vim/"/>
    
      <category term="hexo" scheme="http://xcoder.in/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「NBUT 2014 校赛·网络同步赛」题解 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/"/>
    <id>http://xcoder.in/2014/05/05/nbut-2014-acm-contest-solution/</id>
    <published>2014-05-05T07:08:39.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>这次比赛由 <a href="http://blog.163.com/surgy_han/" target="_blank">Hungar</a>，<a href="http://www.cnblogs.com/Wine93/" target="_blank">8Mao</a> 以及我负责的。明明都读研了，还诈尸回来出题——归结起来大概是因为各种面试不顺吧，想来虐虐学弟妹们怒刷存在感。结果网络赛还是被虐得死去活来。（果然我是蒟蒻 (◓Д◒)✄╰⋃╯</p>
<p>　　好了废话不多说，还是直接上题解吧。</p>
<h2 id="Minecraft_Server_Bug">Minecraft Server Bug</h2>
<p>　　题意大概就是说一排岩浆和水，你要拿一桶水和岩浆，并且水的下标小于岩浆。</p>
<p>　　为了更便于理解，我们从后往前做。首先将序列读进来之后从后往前遍历——若是岩浆，那么岩浆数加一，如果是水，那么这桶水能选择后面岩浆的任意一桶，也就是说答案加上当前的岩浆数即可。</p>
<blockquote>
<p>注意用 <code>__int64</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n;
    <span class="keyword">char</span> ch[<span class="number">1000005</span>];
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &n))
    {
        <span class="keyword">char</span> tmp;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)
        {
            <span class="built_in">scanf</span>(<span class="string">"%c%c"</span>, ch + i, &tmp);
        }
        
        __int64 ans = <span class="number">0</span>;
        <span class="keyword">int</span> cnt = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)
        {
            <span class="keyword">if</span>(ch[i] == <span class="string">'L'</span>) cnt++;
            <span class="keyword">else</span> ans += (__int64)cnt;
        }
        
        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);
    }
    
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h2 id="Beautiful_Walls">Beautiful Walls</h2>
<p>　　一堵墙，每单位高度不定。你需要选择其中任意连续的墙，使得你选择的墙每单位的高度都是唯一的——问有多少种选法。</p>
<p>　　先求出总的种数，然后求不满足的数量，最后用总数减去不满足数即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="preprocessor">#define lint long long</span>
<span class="preprocessor">#define N 100005</span>
<span class="keyword">int</span> p[N], A[N];
lint solution(lint n)
{
    <span class="built_in">memset</span>(p, -<span class="number">1</span>, <span class="keyword">sizeof</span>(p));
    lint ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>, Max = <span class="number">0</span>;
    <span class="keyword">for</span>(lint i=<span class="number">0</span>; i &lt; n; ++i)
    {
        <span class="keyword">if</span>(~p[A[i]])
        {
            <span class="keyword">if</span>(Max &lt; p[A[i]]) Max = p[A[i]];
            p[A[i]] = i + <span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            p[A[i]] = i + <span class="number">1</span>;
        }
        ans -= Max;
    }
    <span class="keyword">return</span> ans;
}

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> n, x;
    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &n))
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)
        {
            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);
        }
        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solution(n));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="ACM" scheme="http://xcoder.in/tags/ACM/"/>
    
      <category term="算法" scheme="http://xcoder.in/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="http://xcoder.in/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[死月出品：Hero Snake 英雄蛇]]></title>
    <link href="http://xcoder.in/2014/04/11/hero-snake/"/>
    <id>http://xcoder.in/2014/04/11/hero-snake/</id>
    <published>2014-04-11T05:53:35.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注：备份到这篇日志的时候，感觉眼睛进了什么奇怪的东西。（才……才不是眼泪呢，那一定是沙子！(;´༎ຶД༎ຶ`)</p>
<p>主要引起感伤的还是这首轩辕剑的 BGM 吧。因为 Hero Snake 的BGM就是这个。</p>
<p>这篇文章原文是在 2011年5月1日 发的。游戏是跟 <strong>MatRush</strong> 在2011年寒假一起写的，虽然是我边教边写的。呵呵，转眼间三年过去了。</p>
<p>想当年我还是那么执着于游戏行业，现在纠结于到底要从事游戏行业还是互联网呢？半年真的能改变很多，要是我当时没有去汽族网实习，也许现在并不会有那么大的改变吧。</p>
<p>自从被 <a href="http://weibo.com/shyvo" target="_blank">@朴大</a> 刷了之后，我又开始着重考虑了。是不是我玩互联网只是觉得新鲜好玩而已呢？毕竟我是半路出家的，虽然有着十来年的 <code>Web经历</code>，但那都是小打小闹哇。还记得小学的时候买的第一本电脑书——<a href="http://www.amazon.cn/%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6-%E6%9C%B1%E6%83%A0%E5%BC%BA/dp/B0011A9QSA/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1397196202&amp;sr=1-1&amp;keywords=%E5%9C%A8%E7%BD%91%E4%B8%8A%E5%AE%89%E4%B8%AA%E5%AE%B6" target="_blank">《在网上安个家》</a>，到现在还记得那个时候捧着书的激动心情。</p>
<p>我是不是有点偏离了自己本身的轨道呢？总之还是在这两块领域犹豫不决。</p>
<p>废话有点扯远了，还是把文章从 Capture 备份回来再说吧。</p>
</blockquote>
<p>　　这是一款正宗基于HGE的小游戏，算是我做的游戏中自己比较满意的小游戏吧。</p>
<p>　　幕后故事是这样的：MatRush寒假找我一起做游戏，因为他们学校弄了一个蛋疼的游戏制作比赛。然后命题是贪吃蛇，于是我们加了一点自己的小创意，给他讲解了一些HGE的基础之后，就写了这个游戏了。然后因为我们都比较喜欢轩辕剑，于是BGM就是轩辕剑的《永远的三个人的快乐时光》，由于MatRush比较喜欢MapleStory，便有了素材是那些像素画面。</p>
<p>　　首先这个游戏有两种模式：单人模式和双人模式。</p>
<p>　　关于单人模式，这是一个闯关型模式，大家在每一关必须通过吃道具获得一定的分数以及吃圈圈获得一定圈圈数才能开启通往下一关的门，默认一共20关，可以自己编辑关卡，这是后话。下面是几种道具的解说：</p>
<blockquote>
<p><img src="treasure0.png" alt="开山斧"></p>
<p>开山斧：捡到这货随机获得1~3个斧头并且附赠100分数。斧头的作用是能破开木桶，安全通过，一个斧头用一次。斧头数在左下角的Axe(s)后面。</p>
<p><img src="treasure1.png" alt="命运之剪"></p>
<p>命运之剪：捡到这个之后获得100分并且给你断掉一个尾巴以降低难度。</p>
<p><img src="treasure2.png" alt="降速器"></p>
<p>降速器：因为你每吃一个圈圈会增加一定速度，而这个降速器是降低你的速度让你容易些。并且附赠100分。</p>
<p><img src="treasure8.png" alt="药水"></p>
<p>药水：药水是装饰变色用的，其实是送分的。前四种药水100分，紫色的300分。</p>
<p><img src="treasure3.png" alt="降速器"></p>
<p>骷髅头：想死的话就碰碰它试试。</p>
<p><img src="door.png" alt="传送门"></p>
<p>传送门：遇到这货就说明你功德圆满了。恭喜，可以通过它前往下一关。</p>
</blockquote>
<p>　　接下去是双人模式。双人模式因为当初设想有些问题，所以实现起来仅仅是简单的双人走啊走，看谁碰到谁谁就输。在双人模式中，先要选择一张对战地图，然后开始双人走啊走啊走。</p>
<p>　　然后Rank是排行榜，Option是游戏的一些选项，Introduction是游戏介绍，这个介绍有些蛋疼，最后不用说Exit就是退出了。</p>
<p>　　下面是关于地图编辑器的说明：</p>
<p>　　首先在游戏目录小有一个config.ini文件，是一些游戏设置。其中levelnum是游戏关卡数。注意这个数字必须要跟地图数量一致或者小于它，否则会因为找不到之后的地图而出错。地图就存在data里，命名方式是mapX.txt，从0开始。地图编辑器则在MapEditor文件夹下。操作很简单，说明都在编辑器下方的文字上，就几个快捷键。可以用鼠标操作也可以用上下左右控制方向。</p>
<p>　　最后，预祝大家玩得愉快。附上下载地址和几张预览图吧：</p>
<p>　　<a href="bin.7z">点击下载</a></p>
<p>　　<a href="https://github.com/XadillaX/hero-snake" target="_blank">代码地址</a></p>
<p><img src="1.png" alt="标题画面"><br><img src="2.png" alt="玩的画面"><br><img src="4.png" alt="双人模式"></p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="HGE" scheme="http://xcoder.in/tags/HGE/"/>
    
      <category term="游戏开发" scheme="http://xcoder.in/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 3 (未完成...)]]></title>
    <link href="http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/"/>
    <id>http://xcoder.in/2014/04/06/nodejs-cpp-addons-3/</id>
    <published>2014-04-06T08:15:39.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2014/04/03/nodejs-cpp-addons-2/">上一章</a>我们偷偷学习了如何在 <code>C++</code> 中实现 <code>Node.js</code> 调用时传参数和调用回调函数，并且我自己也心血来潮写了个<a href="/2014/04/05/cpp-class-inline-keng/#simpleini">小 Demo</a> 供大家参考。</p>
<p>　　今天我们就不复习了，直捣黄龙吧。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中类成员函数 inline 的坑]]></title>
    <link href="http://xcoder.in/2014/04/05/cpp-class-inline-keng/"/>
    <id>http://xcoder.in/2014/04/05/cpp-class-inline-keng/</id>
    <published>2014-04-05T08:55:57.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>今天我来讲一讲 <code>C++</code> 中类成员函数 <code>inline</code> 修饰符的一个坑。</p>
<p>　　这个坑是我在尝试着写我的第一个 <code>Node.js</code> 扩展 <code>simpleini</code> 时候遇到的。</p>
<h2 id="坑描述">坑描述</h2>
<p>　　因为只是尝试着写，所以懒得自己实现，于是网上找了个开源的 <code>C++</code> 阅读 ini 文件的项目，名不见经传，叫 <a href="http://miniini.tuxfamily.org/" target="_blank">miniini</a>。</p>
<p>　　好了，问题来了，当我写好我的源文件的时候，然后写好了我的 <code>binding.gyp</code> ，总之一切大功告成开始编译的时候—— <code>Windows</code> 下没问题，<code>MacOS</code> 下也可以正常运行，但是在 <code>Linux</code> 下就出问题了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>node: symbol lookup err: <span class="keyword">...</span>/simpleIni.node: undefined symbol: _ZNK10INISection10ReadStringEPKcRS1_
</pre></td></tr></table></figure>

<p>　　大致的意思呢就是说找不到 <code>INISection</code> 的 <code>ReadString</code> 函数符号。</p>
<h2 id="问题分析">问题分析</h2>
<p>　　又是怀着崇敬的心情去 <a href="http://stackoverflow.com/questions/22868307/undefined-symbol-in-node-js-c-addon-under-linux-why" target="_blank">SO</a> 求解了。</p>
<p>　　最后的解答大概<a href="http://isocpp.org/wiki/faq/inline-functions#inline-member-fns" target="_blank">如下</a>：</p>
<blockquote>
<p>内联成员函数的声明看起来像一个非内联函数的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">class</span> Fred {
<span class="keyword">public</span>:
    <span class="keyword">void</span> f(<span class="keyword">int</span> i, <span class="keyword">char</span> c);
};
</pre></td></tr></table></figure>

<p>但是你的内敛成员函数定义前面又加了 <code>inline</code> 这个关键字时，你必须把这个定义放到头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">inline</span>
<span class="keyword">void</span> Fred::f(<span class="keyword">int</span> i, <span class="keyword">char</span> c)
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>这么做的原因就是为了避免链接器 <code>unresolved external</code> 的发生。如果你不这么做，这个错误就将会在你从另外一个 <code>.cpp</code> 文件中调用它时出现。</p>
</blockquote>
<p>　　好嘛，原来是原作者自己写的代码有问题啊。但是不得不说一下又涨姿势了。C++还真是有千奇百怪的坑和错误啊。</p>
<h2 id="解决方案">解决方案</h2>
<p>　　最后的解决方案大致就是把函数定义放到头文件中去，或者在函数声明前面也加上 <code>inline</code> 关键字。</p>
<h2 id="simpleini">simpleini</h2>
<p>　　我的第一个 <code>C++</code> 模块，叫 <code>simpleini</code> ，其实只是抱着试试看 <code>Node.j</code> 的 <code>C++</code> 模块是不是这么写的而已，并没有多大实际用处。Repo 在 <a href="https://github.com/XadillaX/node-simple-ini" target="_blank">Github</a> 上。</p>
<p>　　然后用法很简单，先安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install simpleini
</pre></td></tr></table></figure>

<p>　　然后下面的代码就是例子了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> simpleIni = <span class="built_in">require</span>(<span class="string">"simpleini"</span>);

console.log(simpleIni.open(<span class="string">"./node_modules/simpleini/src/miniini-0.9/test/test.ini"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));
console.log(simpleIni.read(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>));
console.log(simpleIni.read(<span class="string">"SETTINGS"</span>, <span class="string">"sections"</span>));
console.log(simpleIni.read(<span class="string">"vals"</span>, <span class="string">"float"</span>));
</pre></td></tr></table></figure>

<p>　　读取配置的时候第一个参数是 <code>Section</code>，第二个参数是 <code>Key</code>，第三个参数是取不到该值时的默认值。</p>
]]></content>
    
    
      <category term="Programming" scheme="http://xcoder.in/tags/Programming/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 2]]></title>
    <link href="http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/"/>
    <id>http://xcoder.in/2014/04/03/nodejs-cpp-addons-2/</id>
    <published>2014-04-03T14:37:15.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>好，今天让我们更深入地搞基吧！</p>
<h2 id="温故而知新，可以为湿矣">温故而知新，可以为湿矣</h2>
<p>　　首先请大家记住这个 V8 的在线手册——<a href="http://izs.me/v8-docs/main.html" target="_blank">http://izs.me/v8-docs/main.html</a>。</p>
<p>　　还记得上次的 <code>building.gyp</code> 文件吗？</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"addon"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"addon.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>

<p>　　就像这样，举一反三，如果多几个 <code>*.cc</code> 文件的话就是这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>"sources": [ "addon.cc", "myexample.cc" ]
</pre></td></tr></table></figure>

<p>　　上次我们把俩步骤分开了，实际上配置和编译可以放在一起的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure build
</pre></td></tr></table></figure>

<p>　　复习完了吗？没？！</p>
<p><img src="mama.jpg" alt="啪"></p>
<p>　　好的，那我们继续吧。</p>
<h2 id="表番">表番</h2>
<h3 id="函数参数">函数参数</h3>
<p>　　现在我们终于要讲参数了呢。</p>
<p>　　让我们设想有这样一个函数 <code>add(a, b)</code> 代表把 <code>a</code> 和 <code>b</code> 相加返回结果，所以先把函数外框写好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;

    <span class="comment">//... 又来！</span>
}
</pre></td></tr></table></figure>

<h4 id="Arguments">Arguments</h4>
<p>　　这个就是函数的参数了。我们不妨先看看 v8 的<a href="http://izs.me/v8-docs/classv8_1_1Arguments.html" target="_blank">官方手册参考</a>。</p>
<ul>
<li><code>int Length() const</code></li>
<li><code>Local&lt;Value&gt; operator[](int i) const</code></li>
</ul>
<p>　　其它的我们咱不关心，这两个可重要了！一个代表传入函数的参数个数，另一个中括号就是通过下标索引来访问第 <code>n</code> 个参数的。</p>
<p>　　所以如上的需求，我们大致就可以理解为 <code>args.Length()</code> 为 <code>2</code>，<code>args[0]</code> 代表 <code>a</code> 以及 <code>args[1]</code> 代表 <code>b</code> 了。并且我们要判断这两个数的类型必须得是 <code>Number</code>。</p>
<p>　　注意到没，中括号的索引操作符返回结果是一个 <code>Local&lt;Value&gt;</code> 也就是 <code>Node.js</code> 的所有类型基类。所以传进来的参数类型不定的，我们必须得自己判断是什么参数。这就关系到了这个 <code>Value</code> 类型的一些<a href="http://izs.me/v8-docs/classv8_1_1Value.html" target="_blank">函数</a>了。</p>
<ul>
<li><code>IsArray()</code></li>
<li><code>IsBoolean()</code></li>
<li><code>IsDate()</code></li>
<li><code>IsFunction()</code></li>
<li><code>IsInt32()</code></li>
<li><code>IsNativeError()</code></li>
<li><code>IsNull()</code></li>
<li><code>IsNumber()</code></li>
<li><code>IsRegExp()</code></li>
<li><code>IsString()</code></li>
<li>…</li>
</ul>
<p>　　我就不一一列举了，剩下的自己看文档。｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡</p>
<h4 id="ThrowException">ThrowException</h4>
<p>　　这个是我们等下要用到的一个函数。具体在 <a href="http://izs.me/v8-docs/namespacev8.html#a2469af0ac719d39f77f20cf68dd9200e" target="_blank">v8 文档</a>中可以找到。</p>
<p>　　顾名思义，就是抛出错误啦。执行这个语句之后，相当于在 <code>Node.js</code> 本地文件中执行了一条 <code>throw()</code> 语句一样。比如说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
</pre></td></tr></table></figure>

<p>　　就相当于执行了一条 <code>Node.js</code> 的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong number of arguments"</span>);
</pre></td></tr></table></figure>

<h4 id="Undefined()">Undefined()</h4>
<p>　　这个函数呢也在<a href="http://izs.me/v8-docs/namespacev8.html#ad39cfade81e77137fc11ff3a24284340" target="_blank">文档</a>里面。</p>
<p>　　具体就是一个空值，因为有些函数并不需要返回什么具体的值，或者说没有返回值，这个时候就需要用 <code>Undefined()</code> 来代替了。</p>
<h4 id="动手吧骚年！">动手吧骚年！</h4>
<p>　　在理解了以上的几个要点之后，我相信你们很快就能写出 <code>a + b</code> 的逻辑了，我就把 <code>Node.js</code> 官方手册的代码抄过来给你们过一遍就算完事了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; Add(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    
    <span class="comment">// 代表了可以传入 2 个以上的参数，但实际上我们只用前两个</span>
    <span class="keyword">if</span>(args.Length() &lt; <span class="number">2</span>)
    {
        <span class="comment">// 抛出错误</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
        
        <span class="comment">// 返回空值</span>
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 若前两个参数其中一个不是数字的话</span>
    <span class="keyword">if</span>(!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber())
    {
        <span class="comment">// 抛出错误并返回空值</span>
        ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong arguments"</span>)));
        <span class="keyword">return</span> scope.Close(Undefined());
    }
    
    <span class="comment">// 具体参考 v8 文档</span>
    <span class="comment">//     http://izs.me/v8-docs/classv8_1_1Value.html#a6eac2b07dced58f1761bbfd53bf0e366)</span>
    <span class="comment">// 的 `NumberValue` 函数</span>
    Local&lt;Number&gt; num = Number::New(args[<span class="number">0</span>]-&gt;NumberValue() + args[<span class="number">1</span>]-&gt;NumberValue());
    
    <span class="keyword">return</span> scope.Close(num);
}
</pre></td></tr></table></figure>

<p>　　函数大功告成！</p>
<p>　　最后把尾部的导出函数给写好就 OK 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> Init(Handle&lt;Object&gt; exports)
{
    exports-&gt;Set(String::NewSymbol(<span class="string">"add"</span>),
        FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　等你编译好之后，我们就能这样用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> addon = <span class="built_in">require</span>(<span class="string">'./build/Release/addon'</span>);
console.log(addon.add(<span class="number">1</span>, <span class="number">1</span>) + <span class="string">"b"</span>);
</pre></td></tr></table></figure>

<p>　　你会看到一个 <code>2b</code> ！✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p>
<h3 id="回调函数">回调函数</h3>
<p>　　上一章我们只讲了个 <code>Hello world</code>，这一章阿婆主就良心发现一下，再来个回调函数的写法。</p>
<p>　　惯例我们先写好框架：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
  HandleScope scope;

  <span class="comment">// ... 噼里啪啦噼里啪啦</span>

  <span class="keyword">return</span> scope.Close(Undefined());
}
</pre></td></tr></table></figure>

<p>　　然后我们决定它的用法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>func(<span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
    console.log(msg);
});
</pre></td></tr></table></figure>

<p>　　即它会给回调函数传入一个参数，我们设想它是一个字符串，然后我们可以 <code>console.log()</code> 出来看。</p>
<h4 id="首先你要有一个字符串系列">首先你要有一个字符串系列</h4>
<p>　　废话不多说，先给它一个字符串喂饱了再说吧。<em>(√ ζ ε:)</em></p>
<p>　　不过我们得让这个字符串是通用类型的，因为 <code>Node.js</code> 代码是弱类型的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>));
</pre></td></tr></table></figure>

<p>　　什么？你问我什么是 <code>Local&lt;Value&gt;</code>？</p>
<p>　　那我稍稍讲一下吧，参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>和<a href="http://izs.me/v8-docs/classv8_1_1Local.html" target="_blank">V8参考文档</a>。</p>
<p>　　如文档所示，<code>Local&lt;T&gt;</code> 实际上继承自 <code>Handle&lt;T&gt;</code>，我记得<a href="/2014/04/02/nodejs-cpp-addons-1/#Handle&lt;Value">上一章</a>已经讲过 <code>Handle&lt;T&gt;</code> 这个东西了。</p>
<p>　　然后下面就是讲 Local 了。</p>
<blockquote>
<p>Handle 有两种类型， Local Handle 和 Persistent Handle ，类型分别是 <code>Local&lt;T&gt; : Handle&lt;T&gt;</code> 和 <code>Persistent&lt;T&gt; : Handle&lt;T&gt;</code> ，前者和 <code>Handle&lt;T&gt;</code> 没有区别生存周期都在 scope 内。而后者的生命周期脱离 scope ，你需要手动调用 <code>Persistent::Dispose</code> 结束其生命周期。也就是说 Local Handle 相当于在 C++`在栈上分配对象而 Persistent Handle 相当于 C++ 在堆上分配对象。</p>
</blockquote>
<h4 id="然后你要有个参数表系列">然后你要有个参数表系列</h4>
<p>　　终端命令行调用 C/C++ 之后怎么取命令行参数？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])
{
    <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>　　对了，这里的 <code>argc</code> 就是命令行参数个数，<code>argv[]</code> 就是各个参数了。那么调用 <code>Node.js</code> 的回调函数，<code>v8</code> 也采用了类似的<a href="http://izs.me/v8-docs/classv8_1_1Function.html#ac61877494d2d8bb81fcef96003ec4059" target="_blank">方法</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>V8EXPORT Local&lt;Value&gt; v8::Function::Call(Handle&lt;Object&gt;recv,
    <span class="keyword">int</span> argc,
    Handle&lt;Value&gt; argv[]
);
</pre></td></tr></table></figure>

<blockquote>
<p><del>QAQ 卡在了 <code>Handle&lt;Object&gt; recv</code> 了！！！明天继续写。</del></p>
</blockquote>
<p>　　好吧，新的一天开始了我感觉我充满了力量。(∩^o^)⊃━☆ﾟ.*･｡</p>
<p>　　经过我多方面求证（<a href="http://segmentfault.com/q/1010000000456217" target="_blank">SegmentFault</a>和<a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a>以及一个扣扣群），终于解决了上面这个函数仨参数的意思。</p>
<p>　　后面两个参数就不多说了，一个是参数个数，另一个就是一个参数的数组了。至于第一个参数 <code>Handle&lt;Object&gt; recv</code>，StackOverflow 仁兄的解释是这样的：</p>
<blockquote>
<p>It is the same as apply in JS. In JS, you do</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> context = ...;
cb.apply(context, [ ...args...]);
</pre></td></tr></table></figure>

<p>The object passed as the first argument becomes this within the function scope. More documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank">MDN</a>. If you don’t know JS well, you can read more about JS’s this here: <a href="http://unschooled.org/2012/03/understanding-javascript-this/" target="_blank">http://unschooled.org/2012/03/understanding-javascript-this/</a></p>
<p style="text-align: right;">—— 摘自 <a href="http://stackoverflow.com/questions/22842908/what-does-the-first-argument-of-functioncall-in-v8-engine-mean/22848601?noredirect=1#22848601" target="_blank">StackOverflow</a></p>

</blockquote>
<p>　　总之其作用就是指定了被调用函数的 <code>this</code> 指针。这个 <code>Call</code> 的用法就跟 JavaScript 中的 <code>bind()</code>、<code>call()</code>、<code>apply()</code> 类似。</p>
<p>　　所以我们要做的事情就是先把参数表建好，然后传入这个 <code>Call</code> 函数供其执行。</p>
<p>　　第一步，显示转换函数，因为本来是 <code>Object</code> 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
</pre></td></tr></table></figure>

<p>　　第二步，建立参数表（数组）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
</pre></td></tr></table></figure>

<h4 id="最后调用函数系列">最后调用函数系列</h4>
<p>　　调用 <code>cb</code> ，把参数传进去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>cb-&gt;Call(Context::GetCurrent()-&gt;Global(), <span class="number">1</span>, argv);
</pre></td></tr></table></figure>

<p>　　这里第一个参数 <code>Context::GetCurrent()-&gt;Global()</code> 所代表的意思就是获取全局上下文作为函数的 <code>this</code>；第二个参数就是参数表中的个数（毕竟虽然 <code>Node.js</code> 的数组是有长度属性的，但是 <code>C++</code> 里面数组的长度实际上系统是不知道的，还得你自己传进一个数来说明数组长度）；最后一个参数就是刚才我们建立好的参数表了。</p>
<h4 id="终章之结束文件系列">终章之结束文件系列</h4>
<p>　　相信这一步大家已经轻车熟路了吧，就是把函数写好，然后放进导出函数里面，最后申明一下。</p>
<p>　　我就直接放出代码吧，或者直接跑去 <code>Node.js</code> 的<a href="http://nodejs.org/api/addons.html#addons_callbacks" target="_blank">文档</a>看也行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;

Handle&lt;Value&gt; RunCallback(<span class="keyword">const</span> Arguments& args)
{
    HandleScope scope;
    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">0</span>]);
    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">1</span>;
    Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(<span class="string">"hello world"</span>)) };
    cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);
    
    <span class="keyword">return</span> scope.Close(Undefined());
}

<span class="keyword">void</span> Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module)
{
    module-&gt;Set(String::NewSymbol(<span class="string">"exports"</span>),
        FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)
</pre></td></tr></table></figure>

<p>　　Well done! 最后剩下的步骤就自己去吧。至于 <code>Js</code> 里面这么调用这个函数，我在<a href="#回调函数">之前</a>已经提到过了。</p>
<h2 id="番外">番外</h2>
<p>　　嘛嘛，我感觉我的学习笔记写得越来越奔放了求破～</p>
<p>　　今天就先写到这里吧，写学习笔记的过程中我又涨姿势了，比如说那个 <code>Call</code> 函数的参数意义。</p>
<p>　　如果你们觉得本系列学习笔记对你们还有帮助的话，就来和我一起搞基吧么么哒～Σ&gt;―(〃°ω°〃)♡→</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Node.js和C++一起搞基 —— 1]]></title>
    <link href="http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/"/>
    <id>http://xcoder.in/2014/04/02/nodejs-cpp-addons-1/</id>
    <published>2014-04-01T16:53:22.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>N久之前的一个坑——用 <strong>Node.js</strong> 来重构 NBUT 的 <strong>Online Judge</strong>，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧</p>
<p>　　总之我们现在要做的其实简而言之就是——用C/C++来实现 <strong>Node.js</strong> 的模块。</p>
<h2 id="准备工作">准备工作</h2>
<p>　　工欲善其事，必先<del>耍流氓</del>利其器。</p>
<h3 id="node-gyp">node-gyp</h3>
<p>　　首先你需要一个 <code>node-gyp</code> 模块。</p>
<p>　　在任意角落，执行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install node<span class="attribute">-gyp</span> <span class="attribute">-g</span>
</pre></td></tr></table></figure>


<p>　　在进行一系列的 <code>blahblah</code> 之后，你就安装好了。</p>
<h3 id="Python">Python</h3>
<p>　　然后你需要有个 <code>python</code> 环境。</p>
<p>　　自己去<a href="http://python.org/" target="_blank">官网</a>搞一个来。</p>
<blockquote>
<p><strong>注意：</strong> 根据 <code>node-gyp</code> 的<a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">GitHub</a>显示，请务必保证你的 <code>python</code> 版本介于 <code>2.5.0</code> 和 <code>3.0.0</code> 之间。</p>
</blockquote>
<h3 id="编译环境">编译环境</h3>
<p>　　嘛嘛，我就偷懒点不细写了，还请自己移步到 <a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">node-gyp</a> 去看编译器的需求。并且倒腾好。</p>
<h2 id="入门">入门</h2>
<p>　　我就拿<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官网的入门 Hello World</a>说事儿了。</p>
<h3 id="Hello_World">Hello World</h3>
<p>　　请准备一个 <code>C++</code> 文件，比如就叫 <del>sb.cc</del> hello.cc。</p>
<p>　　然后我们一步步来，先往里面搞出头文件和定义好命名空间：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="preprocessor">#include &lt;v8.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;
</pre></td></tr></table></figure>


<h4 id="主要函数">主要函数</h4>
<p>　　接下去我们写一个函数，其返回值是 <code>Handle&lt;Value&gt;</code>。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(const Arguments&amp; args)
{
    //<span class="keyword">...</span> 嗷嗷待写
}
</pre></td></tr></table></figure>


<p>　　然后我来粗粗解析一下这些东西：</p>
<h5 id="Handle&lt;Value&gt;">Handle&lt;Value&gt;</h5>
<p>　　做人要有节操，我事先申明我是从<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>(<a href="http://cnodejs.org/user/fool" target="_blank">@fool</a>)参考的。</p>
<blockquote>
<p>V8 里使用 Handle 类型来托管 JavaScript 对象，与 C++ 的 std::sharedpointer 类似，Handle 类型间的赋值均是直接传递对象引用，但不同的是，V8 使用自己的 GC 来管理对象生命周期，而不是智能指针常用的引用计数。</p>
<p>JavaScript 类型在 C++ 中均有对应的自定义类型，如 String 、 Integer 、 Object 、 Date 、 Array 等，严格遵守在 JavaScript 中的继承关系。 C++ 中使用这些类型时，必须使用 Handle 托管，以使用 GC 来管理它们的生命周期，而不使用原生栈和堆。</p>
</blockquote>
<p>　　而这个所谓的 <strong>Value</strong> ，从 V8 引擎的头文件 <a href="http://code.google.com/p/v8/source/browse/trunk/include/v8.h#1417" target="_blank">v8.h</a> 中的各种继承关系中可以看出来，其实就是 JavaScript 中各种对象的基类。</p>
<p>　　在了解了这件事之后，我们大致能明白上面那段函数的申明的意思就是说，我们写一个 <code>Hello</code> 函数，其返回的是一个不定类型的值。</p>
<blockquote>
<p><strong>注意：</strong> 我们只能返回特定的类型，即在 Handle 托管下的 String 啊 Integer 啊等等等等。</p>
</blockquote>
<h5 id="Arguments">Arguments</h5>
<p>　　这个就是传入这个函数的参数了。我们都知道在 <code>Node.js</code> 中，参数个数是乱来的。而这些参数传进去到 <code>C++</code> 中的时候，就转变成了这个 <code>Arguments</code> 类型的对象了。</p>
<p>　　具体的用法我们在后面再说，在这里只需要明白这个是个什么东西就好。（为毛要卖关子？因为 <code>Node.js</code> 官方文档中的<a href="https://github.com/rvagg/node-addon-examples" target="_blank">例子</a>就是分开来讲的，我现在只是讲第一个 <code>Hello World</code> 的例子而已( ´థ౪థ）σ</p>
<h4 id="添砖加瓦">添砖加瓦</h4>
<p>　　接下去我们就开始添砖加瓦了。就最简单的两句话：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(<span class="keyword">const</span> Arguments&amp; args)
{
    HandleScope <span class="keyword">scope</span>;
    <span class="keyword">return</span> <span class="keyword">scope</span>.Close(String::New(<span class="string">"world"</span>));
}
</pre></td></tr></table></figure>


<p>　　这两句话是什么意思呢？大致的意思就是返回一个 <code>Node.js</code> 中的字符串 <code>&quot;world&quot;</code>。</p>
<h5 id="HandleScope">HandleScope</h5>
<p>　　同参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>。</p>
<blockquote>
<p>Handle 的生命周期和 C++ 智能指针不同，并不是在 C++ 语义的 scope 内生存（即{} 包围的部分），而需要通过 HandleScope 手动指定。HandleScope 只能分配在栈上，HandleScope 对象声明后，其后建立的 Handle 都由 HandleScope 来管理生命周期，HandleScope 对象析构后，其管理的 Handle 将由 GC 判断是否回收。</p>
</blockquote>
<p>　　所以呢，我们得在需要管理他的生命周期的时候申明这个 <code>Scope</code> 。好的，那么为什么我们的代码不这么写呢？</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Handle</span><span class="subst">&lt;</span>Value<span class="subst">&gt;</span> Hello(const Arguments<span class="subst">&amp;</span> args)
{
    HandleScope scope;
    <span class="keyword">return</span> <span class="built_in">String</span><span class="tag">::New</span>(<span class="string">"world"</span>);
}
</pre></td></tr></table></figure>


<p>　　因为当函数返回时，<code>scope</code> 会被析构，其管理的Handle也都将被回收，所以这个 <code>String</code> 就会变得没有意义。</p>
<p>　　所以呢 V8 就想出了个神奇的点子——<code>HandleScope::Close(Handle&lt;T&gt; Value)</code> 函数！这个函数的用处就是关闭这个 Scope 并且把里面的参数转交给上一个 Scope 管理，也就是进入这个函数前的 Scope。</p>
<p>　　于是就有了我们之前的代码 <code>scope.Close(String::New(&quot;world&quot;));</code>。</p>
<h5 id="String::New">String::New</h5>
<p>　　这个 <code>String</code> 类所对应的就是 <code>Node.js</code> 中原生的字符串类。继承自 <code>Value</code> 类。与此类似，还有：</p>
<ul>
<li>Array</li>
<li>Integer</li>
<li>Boolean</li>
<li>Object</li>
<li>Date</li>
<li>Number</li>
<li>Function</li>
<li>…</li>
</ul>
<p>　　这些东西有些是继承自 <code>Value</code>，有些是二次继承。我们这里就不多做研究，自己可以看看 V8 的代码（至少是头文件）研究研究或者看看这个<a href="http://bespin.cz/~ondras/html/classv8_1_1Value.html#a70d4afaccc7903e6a01f40a46ad04188" target="_blank">手册</a>。</p>
<p>　　而这个 <code>New</code> 呢？<a href="http://bespin.cz/~ondras/html/classv8_1_1String.html" target="_blank">这里</a>可以看的。就是新建一个 <code>String</code> 对象。</p>
<p>　　至此，这个主要函数我们就解析完毕了。</p>
<h4 id="导出对象">导出对象</h4>
<p>　　我们来温习一下，如果是在 <code>Node.js</code> 里面写的话，我们怎么导出函数或者对象什么的呢？</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>exports.hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
</pre></td></tr></table></figure>


<p>　　那么，在 <code>C++</code> 中我们该如何做到这一步呢？</p>
<h5 id="初始化函数">初始化函数</h5>
<p>　　首先，我们写个初始化函数：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>void init(Handle&lt;Object&gt; exports)
{
    //<span class="keyword">...</span> 嗷嗷待写你妹啊！<span class="comment">#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</span>
}
</pre></td></tr></table></figure>


<p>　　这是龟腚！函数名什么的无所谓，但是传入的参数一定是一个 <code>Handle&amp;lt;Object&gt;</code>，代表我们下面将要在这货上导出东西。</p>
<p>　　然后，我们就在这里面写上导出的东西了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="literal">void</span> init(<span class="keyword">Handle</span><span class="subst">&lt;</span>Object<span class="subst">&gt;</span> exports)
{
    exports<span class="subst">-&gt;</span><span class="built_in">Set</span>(<span class="built_in">String</span><span class="tag">::NewSymbol</span>(<span class="string">"hello"</span>),
        FunctionTemplate<span class="tag">::New</span>(Hello)<span class="subst">-&gt;</span>GetFunction());
}
</pre></td></tr></table></figure>


<p>　　大致的意思就是说，为这个 <code>exports</code> 对象添加一个字段叫 <code>hello</code>，所对应的东西是一个<a href="http://bespin.cz/~ondras/html/classv8_1_1FunctionTemplate.html" target="_blank">函数</a>，而这个函数就是我们亲爱的 <code>Hello</code> 函数了。</p>
<p>　　用伪代码写直白点就是：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">void</span> init(Handle&lt;Object&gt; <span class="built_in">exports</span>)
{
    <span class="built_in">exports</span>.Set(<span class="string">"hello"</span>, <span class="reserved">function</span> hello);
}
</pre></td></tr></table></figure>


<p>　　大功告成！</p>
<p>　　（大功告成你妹啊！闭嘴( ‘д‘⊂彡☆))Д´)</p>
<h5 id="真·导出">真·导出</h5>
<p>　　这才是最后一步，我们最后要申明，这个就是导出的入口，所以我们在代码的末尾加上这一行：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">NODE_MODULE(hello, init)</span>
</pre></td></tr></table></figure>


<p>　　纳了个尼？！这又是什么东西？</p>
<p>　　别着急，这个 <code>NODE_MODULE</code> 是一个宏，它的意思呢就是说我们采用 <code>init</code> 这个初始化函数来把要导出的东西导出到 <code>hello</code> 中。那么这个 <code>hello</code> 哪来呢？</p>
<p>　　<strong>它来自文件名！</strong>对，没错，它来自文件名。你并不需要事先申明它，你也不必担心不能用，总之你的这个最终编译好的二进制文件名叫什么，这里的 <code>hello</code> 你就填什么，当然要除去后缀名了。</p>
<p>　　详见<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官方文档</a>。</p>
<blockquote>
<p>Note that all Node addons must export an initialization function:</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> Initialize (Handle&lt;<span class="built_in">Object</span>&gt; exports);
NODE_MODULE(module_name, Initialize)
</pre></td></tr></table></figure>

<p>There is no semi-colon after NODE_MODULE as it’s not a function (see node.h).</p>
<p>The module_name needs to match the filename of the final binary (minus the .node suffix).</p>
</blockquote>
<h3 id="编译_(๑•́_₃_•̀๑)">编译 (๑•́ ₃ •̀๑)</h3>
<p>　　来吧，让我们一起编译吧！</p>
<p>　　我们再新建一个类似于 <code>Makefile</code> 的归档文件吧——<code>binding.gyp</code>。</p>
<p>　　并且在里面添加这样的<a href="https://github.com/TooTallNate/node-gyp#the-bindinggyp-file" target="_blank">代码</a>：</p>
<figure class="highlight"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"hello"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"hello.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>


<p>　　为什么这么写呢？可以参考 <code>node-gyp</code> 的<a href="http://code.google.com/p/gyp/wiki/GypUserDocumentation#Skeleton_of_a_typical_Chromium_.gyp_file" target="_blank">官方文档</a>。</p>
<h4 id="configure">configure</h4>
<p>　　在文件搞好之后，我们要在这个目录下面执行这个命令了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure
</pre></td></tr></table></figure>


<p>　　如果一切正常的话，应该会生成一个 <code>build</code> 的目录，然后里面有相关文件，也许是 <strong>M$ Visual Studio</strong> 的 <code>vcxproj</code> 文件等，也许是 <code>Makefile</code> ，视平台而定。</p>
<h4 id="build">build</h4>
<p>　　<code>Makefile</code> 也生成好之后，我们就开始构造编译了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp build
</pre></td></tr></table></figure>


<p>　　等到一切编译完成，才算是真正的大功告成了！不信你去看看 <code>build/Release</code> 目录，下面是不是有一个 <code>hello.node</code> 文件了？没错，这个就是 C++ 等下要给 Node.js 捡的肥皂！</p>
<h3 id="搞基吧！Node_ヽ(✿ﾟ▽ﾟ)ノ_C++">搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</h3>
<p>　　我们在刚才那个目录下新建一个文件 <code>jianfeizao.js</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> addon = <span class="built_in">require</span>(<span class="string">"./build/Release/hello"</span>);
<span class="built_in">console</span>.log(addon.hello());
</pre></td></tr></table></figure>


<p>　　看到没！看到没！出来了出来了！Node.js 和 C++ 搞基的结果！这个 <code>addon.hello()</code> 就是我们之前在 C++ 代码中写的 <code>Handle&lt;Value&gt; Hello(const Arguments&amp; args)</code> 了，我们现在就已经把它返回的值给输出了。</p>
<h2 id="洗洗睡吧，下节更深入">洗洗睡吧，下节更深入</h2>
<p>　　时间不早了，今天就写到这里了，至此为止大家都能搞出最基础的 <strong>Hello world</strong> 的 C++ 扩展了吧。下一次写的应该会更深入一点，至于下一次是什么时候，我也不知道啦其实。<br>　　（喂喂喂，撸主怎么可以这么不负责！(ｏﾟﾛﾟ)┌┛Σ(ﾉ´<em>ω</em>`)ﾉ</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="C++" scheme="http://xcoder.in/tags/C++/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[～公众档所～项目解析]]></title>
    <link href="http://xcoder.in/2014/03/27/node-public-file-house/"/>
    <id>http://xcoder.in/2014/03/27/node-public-file-house/</id>
    <published>2014-03-26T17:34:04.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>所谓“公众档所”，其实就是一个公共的临时网盘了。这个东西是一个老物了，在我刚接触 <code>Expressjs</code> 的时候写的。当时还随便搞了一下 <code>backbone.js</code>，但是没有深入，勿笑。关于深入构架 <code>Expressjs</code> 方面也没做，只是粗粗写了下最基础的路由，所以整个文件结构也不是很规范。但是应该能比较适合刚学 <code>Node.js</code> 以及刚接触 <code>Expressjs</code> 的人吧。</p>
<p>　　Repo地址在<a href="https://github.com/XadillaX/public-file-house" target="_blank">我的Github</a>上。Demo地址在 <a href="http://dang.kacaka.ca/" target="_blank">http://dang.kacaka.ca/</a>，由于个人电脑的不稳定性，所以不保证你们随时可以访问，保不定哪天就失效了，所以最好的办法还是自己 <code>clone</code> 下来啪啪啪。</p>
<p>　　它所需要的东西大致就是 <code>Expressjs</code> + <code>Redis</code> + <code>Backbone</code> 了。不过都是最最基础的代码。</p>
<h2 id="部署">部署</h2>
<p>　　把部署写在最前面是为了能让你们自己电脑上有一个能跑的环境啦。公众档所在我自己这边的环境里面是由三台电脑组成的。</p>
<ul>
<li>网关“服务器”。这是我这边环境一致对外的机器。实际上是一片树莓派，装了 <code>nginx</code>，然后对内部做反向代理。</li>
<li>本体“服务器”。跑了 <strong>公众档所</strong> 本体。</li>
<li>数据库“服务器”。我们用的数据库实际上不是严格意义上的数据库，只是 <code>redis</code> 罢了，也没做与其它数据库的持久化，只是用了他内部自带的持久化。</li>
</ul>
<p>　　<strong>如果你们装一台机子上，那么就是：</strong></p>
<p>　　将 <code>repo</code> 给 clone 到自己的机子上。</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="constant">XadillaX</span>/public-file-house
</pre></td></tr></table></figure>


<p>　　装好 <strong>redis</strong>，并根据需要修改 <code>redis.conf</code> 文件。</p>
<p>　　执行 <code>redis.sh</code> 文件开启数据库。如果你自己本身已经开启数据库或者用其它方法开启了，请忽略上面数据库相关步骤。</p>
<p>　　然后打开 <code>commonConst.js</code> 文件进行编辑，把相关的一些信息改成自己所需要的。</p>
<p>　　哦对了，还有一个“洁癖相关”的步骤。我以前年轻不懂事，把 <code>node_modules</code> 文件夹也给加到版本库中了，而且也在里面居然自己加了两个没有弄到 <code>nmp</code> 去的模块（<strong>而且这两个模块本来就不应该放在这个文件夹下，但是不要在意这些细节，反正我现在肯定不会做这么傻的事了</strong>）。</p>
<p>　　至于为什么不要这么做，就跟 <code>node_modules</code> 文件夹的意义相关了。而且里面有可能有一些在我本机编译好的模块，所以最好还是清理下自己重新装一遍为佳。</p>
<p>　　具体呢大致就是把 <code>node_modules</code> 文件夹里面的 <code>alphaRandomer.js</code> 文件和 <code>smpEncoder.js</code> 文件拷贝出来备份到任意文件夹，然后删除整个 <code>node_module</code> 文件夹。接下去跑到项目根目录执行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install
</pre></td></tr></table></figure>


<p>　　把三方模块重新装好之后，把刚才拷出去的俩文件放回这个目录下。（<strong>但是以后你们自己写别的项目的话千万别学我这个坏样子啊，以前年轻不懂事 QAQ</strong>）</p>
<p>　　最后跑起来就行啦：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node pfh.js
</pre></td></tr></table></figure>


<h2 id="解析">解析</h2>
<p>接下去就是要剖析这小破东西了。</p>
<h3 id="基础文件">基础文件</h3>
<h4 id="pfh-js">pfh.js</h4>
<p>　　这个文件其实是 <code>Expressjs</code> 自动生成的，以前不是很懂他，所以也没怎么动，基本上是保持原封不动的。</p>
<h4 id="router-js">router.js</h4>
<p>　　这个是路由定义的文件。比较丑陋的一种方法，把需要定义的所有路由都写进两个 <code>json</code> 对象中，一个 <code>POST</code> 和一个 <code>GET</code>。</p>
<p>　　看过 <code>Expressjs</code> 文档的人或者教程的人都知道，最基础的路由注册写法其实就是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>app.<span class="keyword">get</span>(<span class="keyword">KEY</span>, <span class="keyword">FUNCTION</span>);
</pre></td></tr></table></figure>


<p>　　或者：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>app.post(KEY, <span class="function"><span class="keyword">FUNCTION</span>);</span>
</pre></td></tr></table></figure>


<p>　　所以我下面有一个函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>exports.setRouter = <span class="function"><span class="keyword">function</span><span class="params">(app)</span> {</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.getRouter) {
        app.<span class="keyword">get</span>(key, <span class="keyword">this</span>.getRouter[key]);
    }

    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.postRouter) {
        app.post(key, <span class="keyword">this</span>.postRouter[key]);
    }
};
</pre></td></tr></table></figure>


<p>　　其大致意思就是把之前我们定义好的两个路由对象里的内容一一给注册到系统的路由当中去。这个是我最初最简陋的思想，不过后来我把它稍稍完善了一下写到<a href="https://github.com/XadillaX/exframess/blob/master/config/router.js#L17" target="_blank">别的地方</a>去了。</p>
<h3 id="模型">模型</h3>
<h4 id="model/fileModel-js">model/fileModel.js</h4>
<p>　　这个就是模型层了，主要就是 <code>redis</code> 的一些操作了。在这里我用的是 <a href="https://github.com/mranney/node_redis" target="_blank"><code>redis</code></a> 这个模块，具体的用法大家可以看它 <code>repo</code> 的 <code>README.md</code> 文件。</p>
<p>　　大致就三个函数：</p>
<ol>
<li><code>fileModel.prototype.keyExists</code>: 判断某个提取码存在与否。</li>
<li><code>fileModel.prototype.get</code>: 获取某个验证码的文件信息。</li>
<li><code>fileModel.prototype.addFile</code>: 添加一个文件信息。</li>
</ol>
<blockquote>
<p>不过有个坏样子大家不要学，<code>Node.js</code> 大家都约定俗成的回调函数参数一般都是 <code>callback(err, data, blahblah...)</code> 的，第一个参数都是错误，如果没错误都是 <code>null</code> 或者是 <code>undefined</code> 的。但是以前也没这种意识，所以回调函数的参数也都是比较乱的。</p>
</blockquote>
<h3 id="控制器">控制器</h3>
<h4 id="action/index-js">action/index.js</h4>
<p>　　这是一些基础控制器。</p>
<h5 id="exports-index">exports.index</h5>
<p>　　纯粹的首页显示。</p>
<h5 id="exports-download">exports.download</h5>
<p>　　文件下载控制器。由代码可知，首先获取 <code>token</code> 和 <code>code</code>。 <code>token</code> 是验证 <strong>URL</strong> 的有效性而 <code>code</code> 即提取码了。</p>
<p>　　期间我们验证了下 <code>token</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>if(!functions<span class="preprocessor">.verifyBlahblah</span>(token)) {
    resp<span class="preprocessor">.redirect</span>(baseConfig<span class="preprocessor">.webroot</span>)<span class="comment">;</span>
}
</pre></td></tr></table></figure>


<p>　　而这个 <code>verifyBlahblah</code> 函数就在<a href="https://github.com/XadillaX/public-file-house/blob/master/plugin/functions.js#L21" target="_blank">这个文件</a>里面。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>exports.verifyBlahblah = <span class="function"><span class="keyword">function</span><span class="params">(blahblah)</span> {</span>
    <span class="keyword">var</span> <span class="keyword">array</span> = blahblah.split(<span class="string">"^"</span>);
    <span class="keyword">var</span> time = <span class="keyword">array</span>[<span class="keyword">array</span>.length - <span class="number">1</span>];
    <span class="keyword">array</span>.pop();

    <span class="keyword">var</span> encoder = <span class="keyword">require</span>(<span class="string">"smpEncoder"</span>);

    <span class="keyword">try</span> {
        <span class="keyword">var</span> text = encoder.norBack(<span class="keyword">array</span>, time.toString());
        text = encoder.decode(text);
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">var</span> now = text.substr(<span class="number">0</span>, <span class="number">10</span>);
    <span class="keyword">var</span> token = text.substr(<span class="number">10</span>);

    <span class="keyword">if</span>(parseInt(Date.now() / <span class="number">1000</span>) - parseInt(now) &gt; <span class="number">300</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">if</span>(token !== <span class="keyword">require</span>(<span class="string">"../commonConst"</span>).token) <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">return</span> <span class="keyword">true</span>;
};
</pre></td></tr></table></figure>


<p>　　大体意思就是把其打散到数组里面，其中时间戳是最后一位。然后解密。最后验证解密后的 <code>token</code> 是否等于系统的 <code>token</code> 以及时间戳有没有过期。</p>
<p>　　大家通过截取 <code>Chrome</code> 或者 <code>Firefox</code> 的请求信息，不难发现有这么个地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="xml">Request URL:http://localhost/download?file=</span><span class="number">662</span><span class="xml">ZE&amp;token=</span><span class="number">65</span><span class="xml"></span><span class="keyword">^97</span><span class="xml"></span><span class="keyword">^74</span><span class="xml"></span><span class="keyword">^68</span><span class="xml"></span><span class="keyword">^106</span><span class="xml"></span><span class="keyword">^125</span><span class="xml"></span><span class="keyword">^88</span><span class="xml"></span><span class="keyword">^115</span><span class="xml"></span><span class="keyword">^65</span><span class="xml"></span><span class="keyword">^96</span><span class="xml"></span><span class="keyword">^66</span><span class="xml"></span><span class="keyword">^105</span><span class="xml"></span><span class="keyword">^127</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^87</span><span class="xml"></span><span class="keyword">^123</span><span class="xml"></span><span class="keyword">^123</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^84</span><span class="xml"></span><span class="keyword">^124</span><span class="xml"></span><span class="keyword">^114</span><span class="xml"></span><span class="keyword">^125</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^121</span><span class="xml"></span><span class="keyword">^99</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^100</span><span class="xml"></span><span class="keyword">^118</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^98</span><span class="xml"></span><span class="keyword">^124</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^109</span><span class="xml"></span><span class="keyword">^98</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^100</span><span class="xml"></span><span class="keyword">^80</span><span class="xml"></span><span class="keyword">^119</span><span class="xml"></span><span class="keyword">^120</span><span class="xml"></span><span class="keyword">^87</span><span class="xml"></span><span class="keyword">^119</span><span class="xml"></span><span class="keyword">^105</span><span class="xml"></span><span class="keyword">^116</span><span class="xml"></span><span class="keyword">^8</span><span class="xml"></span><span class="keyword">^1395904110</span><span class="xml">
Request Method:GET
Status Code:</span><span class="number">200</span><span class="xml"> OK</span>
</pre></td></tr></table></figure>


<p>　　而这一坨 <code>65^97^74^68^106^125^88^115^65^96^66^105^127^114^87^123^123^114^84...^1395904110</code> 便是所谓的 <code>token</code> 了。而且本来就是个demo，这个 <code>token</code> 也就是随便做做样子罢了。</p>
<p>　　接下去通过验证之后，便可以从数据库中读取文件信息了。如果有文件，那么通过 <code>resp.download</code> 函数呈现给用户。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> fileModel = <span class="keyword">new</span> FileModel();
fileModel.get(code, <span class="function"><span class="keyword">function</span><span class="params">(status, error, obj)</span> {</span>
    <span class="keyword">if</span>(error) resp.redirect(baseConfig.webroot);
    <span class="keyword">else</span> {
        <span class="keyword">if</span>(obj === <span class="literal">null</span>) {
            resp.redirect(baseConfig.webroot + <span class="string">"/get/"</span> + code + <span class="string">"/not-exist"</span>);
        } <span class="keyword">else</span> {
            resp.download(baseConfig.uploadDir + code, <span class="built_in">require</span>(<span class="string">"urlencode"</span>)(obj.filename));
        }
    }
});
</pre></td></tr></table></figure>


<h5 id="exports-getToken">exports.getToken</h5>
<p>　　这个函数就是生产一个有效的 <code>token</code> 用的。在前端是通过 <strong>ajax</strong> 来获取的。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> encoder = <span class="built_in">require</span>(<span class="string">"smpEncoder"</span>);
<span class="keyword">var</span> token = baseConfig.token;
<span class="keyword">var</span> now = <span class="built_in">parseInt</span>(<span class="built_in">Date</span>.now() / <span class="number">1000</span>);
<span class="keyword">var</span> result = encoder.encode(now + token);
result = encoder.norGo(result, now.toString());
<span class="keyword">var</span> resultString = <span class="string">""</span>;
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++) resultString += (result[i] + <span class="string">"^"</span>);
</pre></td></tr></table></figure>


<p>　　大体呢就是根据目前的时间戳和系统 <code>token</code> 一起加密生产一个有效的 <code>token</code>。</p>
<h5 id="exports-send2fetion">exports.send2fetion</h5>
<p>　　通过自己的飞信给自己发送提取码以备忘。</p>
<p>　　这里的话用了一个 <code>fetion-sender</code> 的模块。<code>Repo</code> 在<a href="https://github.com/XadillaX/fetion-sender" target="_blank">这里</a>。</p>
<h4 id="action/upload-js">action/upload.js</h4>
<p>　　这个文件里面其实就一个 <code>exports.upload</code> 函数，另一个是生成提取码用的。</p>
<h5 id="function_genAlphaKey(time,_callback)">function genAlphaKey(time, callback)</h5>
<p>　　生成提取码。我们假设最多尝试10次，若尝试10次还没有生成唯一的验证码就输出错误让用户重试。所以就有了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">genAlphaKey</span><span class="params">(time, callback)</span> {</span>
    <span class="keyword">var</span> keyLength = config.uploadLen;
    <span class="keyword">var</span> filename = alphaRandomer.rand(keyLength);
    <span class="keyword">var</span> fileModel = <span class="keyword">new</span> FileModel();

    fileModel.keyExists(filename, <span class="function"><span class="keyword">function</span><span class="params">(status, result)</span> {</span>
        <span class="keyword">if</span>(!status) {
            <span class="keyword">if</span>(time &lt; maxTryTime) {
                genAlphaKey(time + <span class="number">1</span>, callback);
            }
            <span class="keyword">else</span> {
                callback(<span class="literal">false</span>, result, <span class="string">""</span>);
            }

            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(result) genAlphaKey(time, callback);
            <span class="keyword">else</span> {
                callback(<span class="literal">true</span>, <span class="string">""</span>, filename);
            }
        }
    });
}
</pre></td></tr></table></figure>


<p>　　不断地生成定长的提取码，然后通过模型的 <code>keyExists</code> 函数来确定这个提取码是否存在，如果存在了就递归调用重新生成，否则就直接回调。</p>
<h5 id="exports-upload">exports.upload</h5>
<p>　　上传文件的页面了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>if(req<span class="preprocessor">.files</span><span class="preprocessor">.files</span><span class="preprocessor">.length</span> !== <span class="number">1</span>) {
    result<span class="preprocessor">.status</span> = false<span class="comment">;</span>
    result<span class="preprocessor">.msg</span> = <span class="string">"请用正确的姿势喂我文件。"</span><span class="comment">;</span>
    resp<span class="preprocessor">.send</span>(<span class="number">200</span>, result)<span class="comment">;</span>
    return<span class="comment">;</span>
}

var fileInfo = req<span class="preprocessor">.files</span><span class="preprocessor">.files</span>[<span class="number">0</span>]<span class="comment">;</span>
if(fileInfo<span class="preprocessor">.size</span> &gt; config<span class="preprocessor">.maxUploadSize</span>) {
    result<span class="preprocessor">.status</span> = false<span class="comment">;</span>
    result<span class="preprocessor">.msg</span> = <span class="string">"文件太大啦，公众档所一次只能吃10M的文件哦。"</span><span class="comment">;</span>
    resp<span class="preprocessor">.send</span>(<span class="number">200</span>, result)<span class="comment">;</span>
    return<span class="comment">;</span>
}
</pre></td></tr></table></figure>


<p>　　前面一堆话大致就是做下有效性判断而已。然后调用函数来生成有效的提取码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>genAlphaKey(<span class="number">1</span>, <span class="keyword">function</span>(status, msg, filename) {
    <span class="keyword">...</span>
});
</pre></td></tr></table></figure>


<p>　　如果生成成功的话就往数据库中添加文件信息：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>var fileModel = new FileModel();
fileModel.addFile(filename,
    fileInfo.name,
    fileInfo.headers[<span class="string">"content-type"</span>],
    <span class="keyword">function</span>(status, msg) {
        <span class="keyword">...</span>
    }
);
</pre></td></tr></table></figure>


<p>　　如果添加也成功了的话，那么把刚上传到临时文件夹的文件给移动到上传文件储存目录中，以便以后可以被下载：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>fs.rename(fileInfo.path, uploadDir + filename, <span class="keyword">function</span>(err) {
    <span class="keyword">...</span>
});
</pre></td></tr></table></figure>


<p>　　如果移动也成功了的话，那么返回一个成功的json信息：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">result</span>.status = <span class="keyword">true</span>;
<span class="keyword">result</span>.code = filename;
resp.send(<span class="number">200</span>, <span class="keyword">result</span>);
</pre></td></tr></table></figure>


<h3 id="视图">视图</h3>
<p>　　这里视图就一个 <code>index.ejs</code> 。然后通过 <code>backbone.js</code> 来调用不同的页内模板和逻辑来实现的类似于 <strong>SPA <del>(Solus Par Agula)</del> (Single Page Application)</strong> 的效果。</p>
<h4 id="views/index/index-ejs">views/index/index.ejs</h4>
<p>　　像类似于下面的这种就是 <code>backbone.js</code> 的模板概念了：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;script type=<span class="string">"text/template"</span> id=<span class="string">"faq-template"</span>&gt;
<span class="keyword">...</span>
&lt;/script&gt;
</pre></td></tr></table></figure>


<p>　　到时候就可以通过 <code>backbone.js</code> 中的函数来填充到页面实体当中去。</p>
<h4 id="public/js/index-js">public/js/index.js</h4>
<p>　　在拥有了所有的前端js依赖之后，这个文件就是这个 <code>SPA</code> 的入口了。</p>
<p>　　逻辑很简单：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> workspace = <span class="literal">null</span>;
$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    workspace = <span class="keyword">new</span> Workspace();
    Backbone.history.start({ pushState: <span class="literal">true</span>, hashChange: <span class="literal">false</span> });
});
</pre></td></tr></table></figure>


<p>　　新建一个 <code>Workscpace</code>，然后对 <code>backbone</code> 进行一点配置。</p>
<blockquote>
<p>To indicate that you’d like to use HTML5 pushState support in your application, use Backbone.history.start({pushState: true}). If you’d like to use pushState, but have browsers that don’t support it natively use full page refreshes instead, you can add {hashChange: false} to the options.</p>
<p style="text-align: right">——摘自 <a href="http://backbonejs.org/#History-start" target="_blank">backbonejs.org</a></p>

</blockquote>
<p>　　然后这个 <code>Workspace</code> 即这个 <code>SPA</code> 的本体了。</p>
<h4 id="public/backbone/router/workspace-js">public/backbone/router/workspace.js</h4>
<p>　　这里定义了几个路由，即什么路由要用哪个类去处理。这样才能在 <code>URL</code> 当中各种跳转。其实无非就是把待渲染元素渲染成页内模板，然后把页面的各种事件响应逻辑改掉即可。对于 <code>Backbone</code> 我其实只用过两次，现在也忘不大多了，怕误人子弟，所以一些具体的函数啊用法啊还是去参考下官网比较好来着。</p>
<h4 id="public/backbone/view/*-js">public/backbone/view/*.js</h4>
<p>　　就是各路由所对应的视图了。</p>
<h5 id="uploadView-js">uploadView.js</h5>
<p>　　比如说 <code>uploadView.js</code> 文件当中，执行渲染函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    render      : <span class="keyword">function</span>() {
        $(this.el).html(Mustache.to_html(
            this.template
        ));

        $(<span class="string">"#uploadfile"</span>).fileupload({
            url         : <span class="string">"../../upload.pfh"</span>,
            dataType    : <span class="string">"json"</span>,
            done        : this.uploaded,
            progressall : this.processUpload,
            start       : this.startUpload
        });

        $(<span class="string">".template"</span>).show(<span class="string">"normal"</span>);

        <span class="keyword">return</span> this;
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　就是用页内模板来渲染：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$(this<span class="preprocessor">.el</span>)<span class="preprocessor">.html</span>(Mustache<span class="preprocessor">.to</span>_html(
    this<span class="preprocessor">.template</span>
))<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>　　而这个 <code>this.el</code> 是在 <code>Workspace</code> 中定义的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    upload      : <span class="keyword">function</span>() {
        var uploadView = new UploadView({ el: <span class="string">"#main-template-container"</span> });
        uploadView.render();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　如你所见，就是这个 <code>#main-template-container</code> 了。</p>
<p>　　这个渲染完毕之后，然后把 <code>#uploadfile</code> 给变成上传按钮（用了 <strong>jquery.fileupload.js</strong>）。再然后把渲染好的页面给 <code>show</code> 出来。</p>
<p>　　然后这个　<code>uploadView.js</code> 中还定义了两个<a href="http://backbonejs.org/#View-delegateEvents" target="_blank">响应事件</a>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    events      : {
        <span class="string">"click .upbutton"</span>   : <span class="string">"upload"</span>,
        <span class="string">"click #uploadpage-to-download"</span> : <span class="string">"goDownload"</span>
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　即在按下 <code>.upbutton</code> 的时候会执行 <code>upload</code> 函数，在按下“去下载”的按钮时会执行 <code>goDownload</code> 函数。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    upload      : <span class="keyword">function</span>() {
        $(<span class="string">"#uploadfile"</span>).click();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　执行上传函数的时候，实际上是自动触动了 <code>#uploadfile</code> 按钮的 <code>click</code> 事件。这个时候就会按照之前定义好的 <code>$(&quot;#uploadfile&quot;).fileupload(...)</code> 去处理了。</p>
<h5 id="getView-js">getView.js</h5>
<p>　　这个是获取文件的视图。</p>
<p>　　渲染时会获取 <code>code</code> 。这个 <code>code</code> 同样是 <code>Workspace</code> 传入的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    get         : <span class="keyword">function</span>(code, err) {
        var getView = new GetView({ el: <span class="string">"#main-template-container"</span> });
        getView.setCode(code);
        <span class="keyword">if</span>(err !== undefined) getView.setError(err);
        getView.render();
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　上面关于 <code>get</code> 的路由是 <code>get/:code</code> 之类的，所以这个 <code>code</code> 会作为一个路由参数传给 <code>get</code> 函数。</p>
<p>　　有了这个 <code>code</code> 之后就可以把页面渲染出来了。这就是为什么我们地址输入 <code>http://localhost/get/XXXXX</code> 的时候输入框里面就有提取码了。把这个渲染出来之后，我们对“二维码”的两张图片做下响应：鼠标移动上去会显示出来。再然后我们要获取二维码了（<code>this.genQRCode()</code>）：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>    ...,
    
    genQRCode   : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> code = <span class="keyword">this</span>.code;

        <span class="keyword">var</span> dpage = <span class="string">"http://dang.kacaka.ca/get/"</span> + code;
        dpage = UrlEncode(dpage);
        <span class="keyword">var</span> img = <span class="string">'&lt;img style="width: 150; height: 150;" src="https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl='</span> + dpage + <span class="string">'" /&gt;'</span>;

        $(<span class="string">"#download-page-qr"</span>).attr(<span class="string">"data-content"</span>, img);

        <span class="keyword">var</span> opage = <span class="string">"http://dang.kacaka.ca/download?"</span>;
        <span class="keyword">this</span>.getToken(<span class="function"><span class="keyword">function</span><span class="params">(token)</span> {</span>
            <span class="keyword">if</span>(<span class="literal">undefined</span> === token) {
                $(<span class="string">"#download-origin-qr"</span>).attr(<span class="string">"data-content"</span>, <span class="string">'&lt;div style="text-align: center;"&gt;二维码生成失败。&lt;/div&gt;'</span>);
                <span class="keyword">return</span>;
            }

            opage += <span class="string">"token="</span> + token;
            opage += <span class="string">"&amp;file="</span> + code;
            opage = UrlEncode(opage);
            <span class="keyword">var</span> img = <span class="string">'&lt;div style="text-align: center;"&gt;&lt;img style="width: 150; height: 150;" src="https://chart.googleapis.com/chart?cht=qr&amp;chs=150x150&amp;choe=UTF-8&amp;chld=L|4&amp;chl='</span> + opage + <span class="string">'" /&gt;&lt;br /&gt;&lt;small&gt;该二维码有效期五分钟。&lt;/small&gt;&lt;/div&gt;'</span>;
            $(<span class="string">"#download-origin-qr"</span>).attr(<span class="string">"data-content"</span>, img);
        });

        <span class="keyword">if</span>(<span class="string">""</span> === <span class="keyword">this</span>.code) {
            $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
        } <span class="keyword">else</span> $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"inline-block"</span>);
    }
</pre></td></tr></table></figure>


<p>　　无非就是调用谷歌的 API 然后生成图片地址放上去罢了。一个地址就是当前页面地址，另一个就是加上 <code>token</code> 之后的直接下载地址。</p>
<p>　　如你所见，获取token是通过ajax往服务器请求的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    getToken    : <span class="keyword">function</span>(callback) {
        $.get(<span class="string">"../../blahblah"</span>, {}, <span class="keyword">function</span>(e) {
            callback(e.token);
        });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　然后事件的话：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    events      : {
        <span class="string">"click #downloadpage-to-upload"</span> : <span class="string">"toUpload"</span>,
        <span class="string">"click #download-btn"</span>   : <span class="string">"toDownload"</span>,
        <span class="string">"keydown #download-code"</span>: <span class="string">"toDownloadKeydown"</span>,

        <span class="string">"keyup #download-code"</span>  : <span class="string">"navCode"</span>
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　按了“去上传”按钮会跑去上传。如果按下“下载”按钮就下载文件了。然后输入框里面弹起键盘的话，会导致输入框文字变化，这个时候就要更新二维码以及URL了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    navCode     : <span class="keyword">function</span>() {
        var code = $(<span class="string">"#download-code"</span>).val();
        workspace.navigate(<span class="string">"get/"</span> + code);
        this.code = code;

        <span class="keyword">if</span>(code === <span class="string">""</span>) {
            $(<span class="string">"h2 small"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
        } <span class="keyword">else</span> {
            this.genQRCode();
        }
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　每当输入框变化之后，地址栏就要变成新的 <code>get/:code</code> (<code>workspace.navigate(&quot;get/&quot; + code)</code>) 了，然后重新获取一遍二维码。</p>
<p>　　下载按钮的逻辑代码如下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    toDownload  : <span class="keyword">function</span>() {
        var code = $(<span class="string">"#download-code"</span>).val();
        workspace.navigate(<span class="string">"get/"</span> + code);
        this.getToken(<span class="keyword">function</span>(token) {
            <span class="keyword">if</span>(token === undefined) {
                alert(<span class="string">"获取验证信息失败，请稍后重试。"</span>);
            } <span class="keyword">else</span> {
                var url = <span class="string">"../../download?file="</span> + code + <span class="string">"&amp;token="</span> + token;
                window.location.href = url;
            }
        });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　反正就是根据 <code>code</code> 来生成地址，然后从获取token的地址中把token拿出来拼接成下载地址之后再访问（<code>window.location.href = url</code>）就好了。</p>
<h5 id="uploadedView-js">uploadedView.js</h5>
<p>　　这个视图是上传成功视图。功能很简单，就是现实下提取码，然后飞信能发送一下，以及能复制验证码罢了。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>    ...,
    
    render      : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(<span class="literal">undefined</span> === <span class="keyword">this</span>.code) {
            workspace.navigate(<span class="string">"upload"</span>, { trigger: <span class="literal">true</span>, replace: <span class="literal">true</span> });
            <span class="keyword">return</span>;
        }

        $(<span class="keyword">this</span>.el).html(Mustache.to_html(
            <span class="keyword">this</span>.template,
            { code: <span class="keyword">this</span>.code }
        ));

        <span class="keyword">var</span> phoneinfo = store.get(<span class="string">"fetion-info"</span>);
        <span class="keyword">if</span>(<span class="literal">undefined</span> !== phoneinfo) {
            $(<span class="string">"#phonenumber"</span>).val(phoneinfo.phonenumber);
            $(<span class="string">"#password"</span>).val(phoneinfo.password);
        }

        $(<span class="string">".template"</span>).show(<span class="string">"normal"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            $(<span class="string">'#copy-code-btn-parent'</span>).zclip({
                path:<span class="string">'../../ZeroClipboard.swf'</span>,
                copy:<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                    <span class="keyword">return</span> $(<span class="string">"#code-input"</span>).val();
                },
                afterCopy: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                    alert(<span class="string">"提取码已经成功复制到剪切板了。"</span>);
                }
            });
        });

        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    
    ...
</pre></td></tr></table></figure>


<p>　　通过判断有没有 <code>code</code> 来判断是否上传成功。这个 <code>code</code> 的来源是 <code>uploadView.js</code> 中的 <code>uploaded (done: this.uploaded)</code> 函数：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    uploaded    : <span class="keyword">function</span>(e, data) {
        var result = data.result;
        <span class="keyword">if</span>(!result.status) {
            $(<span class="string">"#progress"</span>).css(<span class="string">"display"</span>, <span class="string">"none"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).html(<span class="string">"已上传 0%"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).attr(<span class="string">"aria-valuenow"</span>, <span class="string">"0"</span>);
            $(<span class="string">"#progress .progress-bar"</span>).css(<span class="string">"width"</span>, <span class="string">"0%"</span>);

            $(<span class="string">"#upload-div #feed-doc"</span>).removeClass(<span class="string">"alert-info"</span>);
            $(<span class="string">"#upload-div #feed-doc"</span>).addClass(<span class="string">"alert-danger"</span>);
            $(<span class="string">"#upload-div #feed-doc"</span>).html(result.msg);
            $(<span class="string">"#upload-div #feed-doc"</span>).css(<span class="string">"display"</span>, <span class="string">"block"</span>);
            <span class="keyword">return</span>;
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {
            store.set(<span class="string">"code"</span>, result.code);
            workspace.navigate(<span class="string">"uploaded"</span>, { trigger: true, replace: true });

            <span class="keyword">return</span>;
        }
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　<code>e</code> 和 <code>data</code> 这两个参数哪来？首先这个 <code>uploaded</code> 函数是在之前渲染的时候定义成 <code>jquery.fileupload</code> 的上传结束回调函数的，所以这两个参数自然是 <code>jquery.fileupload</code> 传过来的。详见<a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Options#done" target="_blank">这里</a>。</p>
<p>　　总之就是上次成功之后，这个upload函数会获取一个 <code>code</code>，然后它就会拿这个 <code>code</code> 存到 <code>store</code> 中。这个 <code>store.js</code> 是一个 <code>localStorage</code> 的封装。它的代码和文档在<a href="https://github.com/cloudhead/store.js" target="_blank">这里</a>。</p>
<p>　　存好之后让 <code>Workspace</code> 给导航到 <code>uploaded</code> 视图中。</p>
<p>　　而这个 <code>uploaded</code> 视图的初始化函数里面有这样的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="keyword">...</span>,
    
    initialize  : <span class="keyword">function</span>() {
        this.code = store.get(<span class="string">"code"</span>);
        var self = this;

        $(<span class="string">"#sending"</span>).click(self.sending);
        $(<span class="string">"#cancel-sending"</span>).click(self.cancelSending);
        $(<span class="string">"#phonenumber, #password"</span>).keydown(<span class="keyword">function</span>(e) { <span class="keyword">if</span>(e.keyCode === <span class="number">13</span>) self.sending(); });
    },
    
    <span class="keyword">...</span>
</pre></td></tr></table></figure>


<p>　　就是初始化的时候，从 <code>localStorage</code> 中把 <code>code</code> 给取出来。</p>
<h2 id="结束">结束</h2>
<p>　　代码量少，用到的东西也是基础；不过以前的代码由于不了解 <code>Node.js</code> 啊 <code>Expressjs</code> 啊等等的，所以导致代码杂乱无章、脏乱无比，所以一定程度上阻碍了可读性的存在。</p>
<p>　　希望本文能给各位看官稍稍理清思路。我也不必写得面面俱到，只是在某个程度上点题一下而已。更多的大家自己看代码即可了。不过希望还不要把大家给误导了就好，毕竟这代码我自己现在看觉得好丢脸啊 QAQ。大家就去其糟粕取其精华吧。（喂喂喂，我去年买了个表，哪有什么精华啊！</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="Project Parse" scheme="http://xcoder.in/tags/Project%20Parse/"/>
    
      <category term="Document" scheme="http://xcoder.in/categories/Document/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浙江大学XPlan项目新闻爬虫手机屏幕适配文档]]></title>
    <link href="http://xcoder.in/2013/12/28/xplan-spider-doc/"/>
    <id>http://xcoder.in/2013/12/28/xplan-spider-doc/</id>
    <published>2013-12-28T00:00:00.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><strong>XPlan</strong> 是一个“基于校园强关系的社交应用”的开发代号。其中有一个功能是从学校网站上通过网络爬虫（Web Crawler）形式将学校新闻抓取到XPlan自身的数据库当中。</p>
<p>而这里出现的一个问题就是学校网站上面的文章是通过类似于 <a href="http://kindeditor.net/" target="_blank"><code>KindEditor</code></a>、<a href="http://ueditor.baidu.com/website/" target="_blank"><code>UEditor</code></a>这类<strong>在线富文本编辑器</strong>生成的代码。</p>
<p>这类代码有几个共性：</p>
<ol>
<li>代码有大量冗余、多重无用嵌套。</li>
<li>非常低的代码可读性。</li>
<li>在PC浏览器中表现力不错，往往能以低效的代码实现预期排版。</li>
</ol>
<p>所以这些富文本编辑器可以在PC各大内核浏览器中表现良好，但是不便人工修改代码。</p>
<p>而 <strong>XPlan</strong> 确是一个由智能手机主导的应用，新闻将会通过一个 <strong>WebView</strong> 体现出来。所以就需要一定的方法将这些脏乱的代码适配成手机屏幕下表现力良好的代码。</p>
<h2 id="预处理">预处理</h2>
<p>在这里，我们将新闻的代码锁定在新闻内容排版，而排除了其它类似于新闻标题、新闻作者等其它信息。</p>
<p>以我们浙江大学软件学院为例，我们爬取的新闻内容代码将如下：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;div class=<span class="string">"vid_wz"</span>&gt;
    <span class="keyword">...</span>
&lt;/div&gt;
</pre></td></tr></table></figure>


<p>所有内容将被包括在这个类型为 <code>vid_wz</code> 的 <code>div</code> 当中。</p>
<p>这时，我们将其包括在一个自己实现定义好的模板当中。该模板与新闻内容将会形成一个完整的网页，包括完整的 <code>html</code>、<code>head</code>、<code>body</code> 等标签。</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>新闻内页<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">article</span> <span class="attribute">id</span>=<span class="value">"_xplan-wrapper"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"vid_wz"</span>&gt;</span>
            ...
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">article</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>这里需要注意的一点的就是其中的一个 <code>meta</code> 标签：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
</pre></td></tr></table></figure>


<p>它的意思是定义 <code>viewport</code> 的一些属性，实现了初步的手机网页适配。</p>
<h3 id="Viewport">Viewport</h3>
<p>手机浏览器是把页面放在一个虚拟窗口（即 <code>viewport</code>）中，用户可以通过平移和缩放来看网页的不同部分。</p>
<p>通过 <code>viewport</code> 我们能对页面的一些缩放进行手机适配。</p>
<p>我们所需要做的仅是在 <code>head</code> 中插入一个 <code>meta</code> 标签，命名为 <code>viewport</code>，然后定义好其 <code>content</code>。</p>
<p><code>content</code> 的语法如下：</p>
<h4 id="width">width</h4>
<p>控制 <code>viewport</code> 的宽度，可以指定一个值或者特殊的值，如 <code>device-width</code> 为设备宽度。</p>
<h4 id="height">height</h4>
<p>与 <code>width</code> 相对应，指定高度</p>
<h4 id="initial-scale">initial-scale</h4>
<p>初始缩放，即页面初始缩放程度。这是一个浮点值，是页面大小的一个乘数。例如，如果你设置初始缩放为 <code>1.0</code>，那么页面在展现的时候就会以分辨率的1:1来展现。如果你设置为<code>2.0</code>，那么这个页面就会放大为2倍。</p>
<h4 id="maximum-scale">maximum-scale</h4>
<p>最大放大倍数。</p>
<h4 id="user-scaleble">user-scaleble</h4>
<p>用户调整缩放，即用户是否能改变页面缩放程度。如果为 <code>yes</code> 即为可以， <code>no</code> 为不可以。</p>
<h2 id="Cheerio模块*">Cheerio模块*</h2>
<p>由于 <strong>XPlan</strong> 的后端是基于 <code>node.js</code> 构架的，所以 <strong>cheerio</strong> 模块是一个 <code>node.js</code> 专有的模块。</p>
<p>它的作用是将一段HTML代码转换为一棵DOM元素树。</p>
<p>在其官网上是这么诠释的：为服务端定制的快速、灵活、轻量级实现的 jQuery 内核。通常熟悉 jQuery 使用的开发者应该会对其使用方法比较熟悉。</p>
<p>所以在我们做接下去适配修改的之前，我们需要将我们刚才生成的完整HTML代码 转换为一棵我们可以操作的DOM元素树。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var cheerio = <span class="keyword">require</span>(<span class="string">"cheerio"</span>);
$ = cheerio.load(<span class="keyword">...</span>);
</pre></td></tr></table></figure>


<p>这时我们便能以熟悉的jQuery模式对其进行操作了，如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"p"</span>).html(<span class="string">"hello foo!"</span>);
</pre></td></tr></table></figure>


<h2 id="Bootstrap">Bootstrap</h2>
<p>Bootstrap是Twitter推出的一个开源的用于前端开发的工具包。它有一个非常好的响应式的页面风格，使其在个尺寸屏幕上表现良好。</p>
<p>为了能更好适应屏幕，我们决定采用其自带的栅格系统，于是刚才的页面模板就有了新的变化：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>新闻内页<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=UTF-8"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">article</span> <span class="attribute">class</span>=<span class="value">"container"</span> <span class="attribute">id</span>=<span class="value">"_xplan-wrapper"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-md-12"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"vid_wz"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">article</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>首先最外框的 <code>container</code>，用其包裹的元素将实现居中对齐。在不同的媒体查询阈值范围内都为 <code>container</code> 设置了 <code>width</code>，用以匹配栅格系统。</p>
<p><code>row</code> 是一行栅格系统的外包元素。一行可以有12个栅格。</p>
<p>以 <code>.col-md-</code> 开头的栅格的最大 <code>container</code> 宽度为970，最大列宽为78，并能自适应屏幕。</p>
<h2 id="细节处理">细节处理</h2>
<p>在完成了以上操作以后，我们将对各元素进行微调处理。</p>
<p>好在在手机浏览器或者 <code>WebView</code> 中，对各种字体的设置不是非常敏感，所以我们仍然可以不处理一些关于字体变更的设置，以减轻开发量。</p>
<p>这里距几个微调的例子。</p>
<h3 id="&lt;img_/&gt;">&lt;img /&gt;</h3>
<p>在新闻当中，图片充当的基本上是新闻照片的角色，在手机当中以单行出现为佳。</p>
<p>而 Bootstrap 当中本身就有元素类型来让图片元素响应屏幕宽度，并可以加上圆角边框。</p>
<p>所以我们需要做的就是为所有图片加上响应的类型：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"img"</span>).addClass(<span class="string">"img-thumbnail"</span>);
<span class="variable">$(</span><span class="string">"img"</span>).addClass(<span class="string">"img-responsive"</span>);
<span class="variable">$(</span><span class="string">"img"</span>).removeAttr(<span class="string">"style"</span>);
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意：</strong> 最后的一个移除 <code>img</code> 元素自带的 <code>style</code> 属性是因为在文章发布的时候，有可能会被富文本编辑器自动加上一些宽高、边框等信息。为了统一所有图片风格以及让响应式生效，需要将其 <code>style</code> 属性全部移除。</p>
</blockquote>
<p>下面是是适配前与适配后的对比：</p>
<p><img src="./xplan-news-2.jpg" alt="适配前"><br><img src="./xplan-news-1.jpg" alt="适配后"></p>
<h3 id="&lt;table&gt;&lt;/table&gt;">&lt;table&gt;&lt;/table&gt;</h3>
<p>对于 <code>table</code> 元素也需要对它进行自适配，不然很有可能会溢出屏幕，使其多出了一个横向的滚动条。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"table"</span>).removeAttr(<span class="string">"style"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).removeAttr(<span class="string">"border"</span>);

<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table-bordered"</span>);
<span class="variable">$(</span><span class="string">"table"</span>).addClass(<span class="string">"table-striped"</span>);
</pre></td></tr></table></figure>


<p>上面两句是移除 <code>table</code> 的原有的一些风格信息以及属性。后面是为其加上 Bootstrap 特有的 <code>table</code> 类型。</p>
<p>当然，更多的 <code>table</code> 元素还需要其它更多操作。不过就目前为止，<strong>XPlan</strong> 还没有着手关于 <code>table</code> 的更深一层容错处理。不过这里可以提供一个思路。</p>
<p>比如说 <a href="http://www.cst.zju.edu.cn/index.php?c=Index&amp;a=detail&amp;catid=72&amp;id=1885" target="_blank">这篇文章中</a>，不知道是谁给的在线富文本编辑器勇气，使其下面几张图片都各自被一个 <code>table</code> 及其子元素所包含。更有甚者，有一篇文章的一个段落被一个 <code>table</code> 所包容，并且在其左侧还有一个看不见的 <code>td</code> 元素。</p>
<p>我们可以提供的思路就是如果一个 <code>table</code> 只有一行一列就直接将其内容取出并删除该 <code>table</code> 。</p>
<h3 id="&lt;a_/&gt;">&lt;a /&gt;</h3>
<p>超链接元素是一个新闻与用户互动的比较重要的元素之一。我们需要保持其美观性。</p>
<p>举几个例子来说，我们可以将超链接以一个类按钮的形式出现：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"a"</span>).removeAttr(<span class="string">"style"</span>);
<span class="variable">$(</span><span class="string">"a"</span>).addClass(<span class="string">"btn btn-default btn-xs btn-info"</span>);
</pre></td></tr></table></figure>


<p>然后我们甚至可以对其做一些细微的词汇修改。</p>
<p>比如当新闻发布者上传了一个附件然后不负责任地直接将文件名贴上的时候，我们可以贴心地将其显示文字改为“下载附件”。</p>
<p>再比如发布者直接以URL形式显示一个超链接的时候，我们可以贴心地将其改变为“打开链接”等等。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>$(<span class="string">"a"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">(idx, elem)</span> {</span>
    <span class="keyword">if</span>($(<span class="keyword">this</span>).html().match(<span class="regexp">/.*\.(doc|xls|ppt|docx|xlsx|pptx)/</span>)) {
        $(<span class="keyword">this</span>).html(<span class="string">"&lt;i class='glyphicon glyphicon-paperclip'&gt;&lt;/i&gt; 下载附件"</span>);
        $(<span class="keyword">this</span>).removeClass(<span class="string">"btn-info"</span>);
        $(<span class="keyword">this</span>).addClass(<span class="string">"btn-warning"</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span>($(<span class="keyword">this</span>).html().match(<span class="regexp">/http.*\/\/.*/</span>)) {
        $(<span class="keyword">this</span>).html(<span class="string">"&lt;i class='glyphicon glyphicon-flag'&gt;&lt;/i&gt; 打开链接"</span>);
        $(<span class="keyword">this</span>).removeClass(<span class="string">"btn-info"</span>);
        $(<span class="keyword">this</span>).addClass(<span class="string">"btn-warning"</span>);
    }
});
</pre></td></tr></table></figure>


<p>然后我们再处理几个由于误操作而增加的错误链接，如在经上面操作后，还存在着url与显示内容相关的超链接可以直接取消，如这类：</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>让我们荡<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"起双桨"</span>&gt;</span>起双桨<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>


<h2 id="结束语">结束语</h2>
<p>至此，当下版本的 <strong>XPlan</strong> 的新闻爬虫手机屏幕适配基本完成。其中当然还存在着一些细节处理和显示错误处理的不足，但是已经定下了基本的适配思路。</p>
<p>我们还在探索更好的适配方法，而当下的适配形式暂时已经可以满足了我们项目的需求。</p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="XPlan" scheme="http://xcoder.in/tags/XPlan/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TopCoder SRM 589 DIV 2]]></title>
    <link href="http://xcoder.in/2013/08/31/srm-589-div2/"/>
    <id>http://xcoder.in/2013/08/31/srm-589-div2/</id>
    <published>2013-08-31T00:00:00.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>好久没撸 <strong>TC</strong> 了，手都生了。前两天刚折腾好 <strong>LinuxMint</strong> + <strong>Cinnamon</strong>，顺便手贱把 <strong>TC</strong> 环境配好了。</p>
<p>　　随便进去扯了一套最新的 <strong>SRM</strong> 来搞，全跑完之后才发现原来这场比赛还处于 <strong>System Running</strong> 阶段。于是知道了比赛一结束还在 <strong>Running</strong> 的时候你就已经可以自己拉出来做了。小绿名大家不要笑。</p>
<!-- 我是小小分割符 -->

<h2 id="Summary">Summary</h2>
<p>　　这次 <strong>DIV 2</strong> 的难度一般，一道签到题加两道普通的 <strong>DP</strong>。</p>
<p>　　<a href="https://github.com/XadillaX/xadillax-topcoder/tree/master/code/SRM589-DIV2" target="_blank">Code on GitHub</a>.</p>
<h2 id="250pt_-_Goose_Tattarrattat">250pt - Goose Tattarrattat</h2>
<p>题意很简单，就是给你一个字符串，问你最少改变多少字符让字符串所有字符都一样。</p>
<p>签到题，找最多的字符跟总长度一减就OK了。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">#define SIZE(x) ((int)(x.size()))</span>
<span class="preprocessor">#define LENGTH(x) ((int)(x.length()))</span>
<span class="keyword">class</span> GooseTattarrattatDiv2 
{
<span class="keyword">public</span>:
    <span class="keyword">int</span> getmin(<span class="built_in">string</span> S);
};

<span class="keyword">int</span> GooseTattarrattatDiv2::getmin(<span class="built_in">string</span> S)
{
    <span class="keyword">int</span> maxsame = <span class="number">0</span>;
    <span class="stl_container"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;</span> mp;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(S); i++)
    {
    	mp[S[i]]++;
    	maxsame = max(maxsame, mp[S[i]]);
    }
    
    <span class="keyword">return</span> LENGTH(S) - maxsame;
}
</pre></td></tr></table></figure>


<h2 id="500pt_-_Gears">500pt - Gears</h2>
<p>有 <strong><em>N</em></strong> 个齿轮围成一圈，相邻两个齿轮要反方向转才能正常运转不卡到其它轮子。你要从中间拿掉几个齿轮（留空了就不影响其左边的左边的齿轮），问最少拿掉几个使得所有齿轮能正常转。</p>
<p>我们建两个二维 <strong><em>dp</em></strong> 数组，或者一个三维 <strong><em>dp</em></strong> 数组：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>dp[<span class="link_label">i</span>][<span class="link_reference">0|1</span>][<span class="link_label">0|1</span>]
</pre></td></tr></table></figure>


<p>第一维 <code>i</code> 代表当前是第 <code>i</code> 个齿轮。第二维若是 <code>0</code> 则表示这个齿轮拿走，若是 <code>1</code> 代表留下。第三维若是 <code>0</code> 则代表第一个齿轮拿走，<code>1</code> 代表第一个齿轮留下。整个数组的每个元素就代表该齿轮留下或者拿走且第一个齿轮是留下或者拿走的情况下的最少拿走齿轮数。</p>
<p>所以我们能得到几个状态转移方程：</p>
<blockquote>
<h3 id="第一个齿轮">第一个齿轮</h3>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp[<span class="link_label">i</span>][<span class="link_reference">0</span>][<span class="link_label">0</span>] = 1;
dp[<span class="link_label">i</span>][<span class="link_reference">0</span>][<span class="link_label">1</span>] = INF;
dp[<span class="link_label">i</span>][<span class="link_reference">1</span>][<span class="link_label">1</span>] = 0;
dp[<span class="link_label">i</span>][<span class="link_reference">1</span>][<span class="link_label">0</span>] = INF;
</pre></td></tr></table></figure>


<blockquote>
<h3 id="第二个齿轮">第二个齿轮</h3>
<p>如果与第一个同向那么就有了一留一走或者两个都走的情况。否则就是四种情况都可以。</p>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">if</span>(与第一个齿轮同向)
<span class="cell">{
    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = INF;
}</span>
<span class="keyword">else</span> 
<span class="cell">{
    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
    dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
    dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
    dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
}</span>
</pre></td></tr></table></figure>


<blockquote>
<h3 id="之后的所有齿轮">之后的所有齿轮</h3>
<p>若该齿轮与前一个齿轮方向相同 ，那么该齿轮留下的时候，前一个齿轮必须得走，那么就是 <code>dp[i - 1][0][?]</code>;该齿轮走的时候，前一个齿轮可走可留，就是 <code>dp[i - 1][0|1][?] + 1</code> 的稍微小一点那个。</p>
<p>若方向不相同 ，那么就是该齿轮留下的时候，前一个齿轮也可以留下。</p>
</blockquote>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">if</span>(与前一个齿轮同向)
{
    dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];
    dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>];

    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
    dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + <span class="number">1</span>;
}
<span class="keyword">else</span> 
{
    dp [i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);
    dp [i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);

    dp [i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
    dp [i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;
}
</pre></td></tr></table></figure>


<p>最后若最后一个齿轮与第一个齿轮同向，那么在 <code>dp[i - 1][0][0]</code>、<code>dp[i - 1][0][1]</code>、<code>dp[i - 1][1][0]</code> 中挑一个。若不同向，那么多了个 <code>dp[i - 1][1][1]</code> 这个选择。</p>
<p>下面就是代码了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre>class GearsDiv2 
{
public:
    <span class="keyword">int</span> getmin(<span class="keyword">string</span> Directions);
};

<span class="keyword">int</span> GearsDiv2::getmin(<span class="keyword">string</span> Directions)
{
    <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">2</span>][<span class="number">2</span>];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(Directions); i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
        {
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">10000000</span>;
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">10000000</span>;
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(i == <span class="number">1</span>)
        {
            <span class="keyword">if</span>(Directions[i] == Directions[i - <span class="number">1</span>])
            {
                dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
                
                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
                dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10000000</span>;
            }
            <span class="keyword">else</span>
            {
                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;
                dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;
                dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;
            }
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(Directions[i] == Directions[i - <span class="number">1</span>])
        {
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>];
            
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) + <span class="number">1</span>;
        }
        <span class="keyword">else</span>
        {
            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);
            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);
            
            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]) + <span class="number">1</span>;
            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;
        }
    }
    
    <span class="keyword">int</span> ans;
    <span class="keyword">int</span> mi = LENGTH(Directions) - <span class="number">1</span>;
    <span class="keyword">if</span>(Directions[mi] == Directions[<span class="number">0</span>])
    {
        ans = <span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">0</span>], <span class="keyword">min</span>(dp[mi][<span class="number">1</span>][<span class="number">0</span>], dp[mi][<span class="number">0</span>][<span class="number">1</span>]));
    }
    <span class="keyword">else</span>
    {
        ans = <span class="keyword">min</span>(<span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">0</span>], dp[mi][<span class="number">1</span>][<span class="number">1</span>]), <span class="keyword">min</span>(dp[mi][<span class="number">0</span>][<span class="number">1</span>], dp[mi][<span class="number">1</span>][<span class="number">0</span>]));
    }
    
    <span class="keyword">return</span> ans;
}
</pre></td></tr></table></figure>


<h2 id="1000pt_-_Flipping_Bits">1000pt - Flipping Bits</h2>
<p>给你一个 <strong>01串</strong> 与一个正整数 <strong><em>M</em></strong>。<strong>01串</strong> 有如下三种操作:</p>
<ul>
<li>随便反转一位（0 -&gt; 1, 1 -&gt; 0）。</li>
<li>将开头 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
<li>将末尾 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
</ul>
<p>问最少需要几步将整个字符串变成都是 <code>1</code>。</p>
<p>这又是一个 <strong>DP</strong> 的题目。</p>
<p>我们先设有 <strong><em>G</em></strong> 组，一组 <strong><em>M</em></strong> 个 <code>01字符</code>。那么就能有</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">0|1</span>]
dp2[<span class="link_label">i</span>][<span class="link_reference">0|1</span>]
</pre></td></tr></table></figure>


<p>其中 <code>i</code> 代表第 <code>i</code> 组，第二维如果是 <code>0</code> 就代表这一组采用一位位反转的操作将这组全变成 <code>1</code>，如果是 <code>1</code> 则将整组全部反转再采用一位位反转的操作将这组全变成 <code>1</code> 。至于 <code>dp1</code> 和 <code>dp2</code> 则代表从头到尾和从尾到头。</p>
<p>由于只有 <code>0</code> 和 <code>1</code> 反转，那么一组反转两次就能还原原状——这是一个非常重要的性质。</p>
<p>如果某一组采用<strong>整组反转</strong>的操作，若前一组也是<strong>整组反转</strong>，那么就相当于操作次数不变，只是将前一组的反转范围延续到这一组；若前一组是<strong>非整组反转</strong>，那么就相当于从头到这一组反转之后，前面的所有组再反转回去——相当于是多了两次操作。于是就有了（先只拿 <code>dp1</code> 作为例子）：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">1</span>] = min(
<span class="code">    dp[i - 1][0] + 这一组1的数量 + 2,</span>
<span class="code">    dp[i - 1][1] + 这一组1的数量 </span>
);
</pre></td></tr></table></figure>


<p>如果某一组采用<strong>非整组反转</strong>，那么操作次数就是前一组的<strong>整组反转</strong>或者<strong>非整组反转</strong>的操作次数加上这一组 <code>0</code> 的数量：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>dp1[<span class="link_label">i</span>][<span class="link_reference">0</span>] = min(
<span class="code">    dp[i - 1][0] + 这一组0的数量,</span>
<span class="code">    dp[i - 1][0] + 这一组0的数量</span>
);
</pre></td></tr></table></figure>


<p>用上面的转移方程把正反向都求了一遍之后，我们就可以求总答案了，总答案就是我们枚举中间只有<strong>操作1</strong>的段的首尾，加上该中间段前部分的 <strong><em>dp</em></strong> 答案和其后部分的 <strong><em>dp</em></strong> 答案，取出最小值就是了。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre><span class="keyword">class</span> FlippingBitsDiv2 
{
<span class="keyword">public</span>:
    <span class="keyword">int</span> getmin(<span class="stl_container"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;</span> S, <span class="keyword">int</span> M);
    
    <span class="built_in">string</span> str;
    <span class="keyword">int</span> group;
    <span class="keyword">int</span> tn1[<span class="number">2600</span>], tnsum1[<span class="number">2600</span>];
    <span class="keyword">int</span> tn2[<span class="number">2600</span>], tnsum2[<span class="number">2600</span>];
    
    <span class="keyword">int</span> dp1[<span class="number">2600</span>][<span class="number">2</span>];
    <span class="keyword">int</span> dp2[<span class="number">2600</span>][<span class="number">2</span>];
    
    <span class="keyword">int</span> calcsum(<span class="keyword">int</span> l, <span class="keyword">int</span> r)
    {
        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> tot = tnsum1[r] - tnsum1[l - <span class="number">1</span>];
        <span class="keyword">return</span> tot;
    }
};

<span class="keyword">int</span> FlippingBitsDiv2::getmin(<span class="stl_container"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;</span> S, <span class="keyword">int</span> M)
{
    str = <span class="string">""</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE(S); i++) str += S[i];
    group = LENGTH(str) / M;
    ZERO(tn1);
    ZERO(tn2);
    
    <span class="comment">// init.</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++)
    {
        <span class="keyword">int</span> op = i * M;
        <span class="keyword">int</span> ed = op + M;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = op; j &lt; ed; j++)
        {
            <span class="keyword">if</span>(str[j] == <span class="string">'0'</span>) tn1[i]++, tn2[group - i - <span class="number">1</span>]++;
        }
        
        dp1[i][<span class="number">0</span>] = <span class="number">100000</span>;
        dp1[i][<span class="number">1</span>] = <span class="number">100000</span>;
        dp2[i][<span class="number">0</span>] = <span class="number">100000</span>;
        dp2[i][<span class="number">1</span>] = <span class="number">100000</span>;
    }
    
    <span class="comment">// tnsum</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>) tnsum1[<span class="number">0</span>] = tn1[<span class="number">0</span>], tnsum2[<span class="number">0</span>] = tn2[<span class="number">0</span>];
        <span class="keyword">else</span>
        {
            tnsum1[i] = tnsum1[i - <span class="number">1</span>] + tn1[i];
            tnsum2[i] = tnsum2[i - <span class="number">1</span>] + tn2[i];
        }
    }
    
    <span class="comment">// dp.</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= group; i++)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
        {
            dp1[i][<span class="number">0</span>] = dp1[i][<span class="number">1</span>] = dp2[i][<span class="number">0</span>] = dp2[i][<span class="number">1</span>] = <span class="number">0</span>;
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(i == <span class="number">1</span>)
        {
            <span class="comment">// head -&gt; tail</span>
            dp1[i][<span class="number">0</span>] = tn1[i - <span class="number">1</span>];
            dp1[i][<span class="number">1</span>] = <span class="number">1</span> + (M - tn1[i - <span class="number">1</span>]);
            
            <span class="comment">// tail -&gt; head</span>
            dp2[i][<span class="number">0</span>] = tn2[i - <span class="number">1</span>];
            dp2[i][<span class="number">1</span>] = <span class="number">1</span> + (M - tn2[i - <span class="number">1</span>]);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// head -&gt; tail</span>
            dp1[i][<span class="number">0</span>] = min(
                dp1[i - <span class="number">1</span>][<span class="number">0</span>] + tn1[i - <span class="number">1</span>],
                dp1[i - <span class="number">1</span>][<span class="number">1</span>] + tn1[i - <span class="number">1</span>]
            );
            dp1[i][<span class="number">1</span>] = min(
                dp1[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> + (M - tn1[i - <span class="number">1</span>]),
                dp1[i - <span class="number">1</span>][<span class="number">1</span>] + (M - tn1[i - <span class="number">1</span>])
            );
            
            <span class="comment">// tail -&gt; head</span>
            dp2[i][<span class="number">0</span>] = min(
                dp2[i - <span class="number">1</span>][<span class="number">0</span>] + tn2[i - <span class="number">1</span>],
                dp2[i - <span class="number">1</span>][<span class="number">1</span>] + tn2[i - <span class="number">1</span>]
            );
            dp2[i][<span class="number">1</span>] = min(
                dp2[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> + (M - tn2[i - <span class="number">1</span>]),
                dp2[i - <span class="number">1</span>][<span class="number">1</span>] + (M - tn2[i - <span class="number">1</span>])
            );
        }
    }
    
    <span class="keyword">int</span> minans = <span class="number">100000000</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= group; i++)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= group - i; j++)
        {
            <span class="keyword">int</span> zzl = i;
            <span class="keyword">int</span> zzr = group - j - <span class="number">1</span>;
            
            minans = min(minans,
                min(dp1[i][<span class="number">0</span>], dp1[i][<span class="number">1</span>]) +
                min(dp2[j][<span class="number">0</span>], dp2[j][<span class="number">1</span>]) +
                calcsum(zzl, zzr)
                );
        }
    }
    
    <span class="keyword">return</span> minans;
}
</pre></td></tr></table></figure>
]]></content>
    
    
      <category term="TopCoder" scheme="http://xcoder.in/tags/TopCoder/"/>
    
      <category term="SRM" scheme="http://xcoder.in/tags/SRM/"/>
    
      <category term="Programming" scheme="http://xcoder.in/categories/Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（壹）——基本语法和类型]]></title>
    <link href="http://xcoder.in/2013/08/16/node-4-base/"/>
    <id>http://xcoder.in/2013/08/16/node-4-base/</id>
    <published>2013-08-16T00:00:00.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Node.js</strong> 的基础是 <strong>JavaScript</strong> 这门 <strong><em>脚本语言</em></strong>。而大多数的脚本语言一个共同的特点就是“<a href="http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.92.8C.E5.BC.B1.E5.9E.8B.E5.88.A5" target="_blank">弱类型</a>”。</p>
<p>　　不同于 <strong>PHP</strong> 的是，<strong>PHP</strong> 就是是有了新变量也无需申明，而 <strong>JavaScript</strong> 则还是需要 <code>var</code> 来申明一下的。而这个 <code>var</code> 涵盖了 <strong>C++</strong> 中的<code>int</code>、<code>string</code>、<code>char</code>等一切类型的含义，甚至是 <code>function</code>。</p>
<p>　　本篇以及后篇的所有内容都是在 <strong>Linux</strong> 或者 <strong>Cygwin</strong> 下用 <strong>vim</strong> 进行编辑（若不是则请自行转变成你自己的方法），然后在命令行下进行查看结果的。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="基本语法">基本语法</h2>
<h3 id="变量声明">变量声明</h3>
<p>在 <strong>C/C++</strong> 中，我们这么声明变量的：</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">void</span> foo() {}

<span class="keyword">int</span> a = <span class="number">0</span>;
<span class="keyword">char</span> b = <span class="string">'a'</span>;
<span class="keyword">float</span> c = <span class="number">1.0f</span>;
<span class="keyword">void</span> (*d)() = foo;  <span class="comment">///&lt; 忘了是不是这么写的了，总之是函数指针</span>
</pre></td></tr></table></figure>


<p>而在 <strong>Node.js</strong> 中则是这样的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>}

<span class="keyword">var</span> a = <span class="number">0</span>;
<span class="keyword">var</span> b = <span class="string">'a'</span>;
<span class="keyword">var</span> c = <span class="number">1.0</span>;
<span class="keyword">var</span> d = foo;
</pre></td></tr></table></figure>


<p>所以，无论是什么类型的变量，在 <strong>Node.js</strong> 中都是以一个 <code>var</code> 来解决的。</p>
<h3 id="循环语句">循环语句</h3>
<h4 id="for…i">for…i</h4>
<p>这个循环语句基本上跟 <strong>C/C++</strong> 一样，都是</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; foo; i++)
{
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<p>而鉴于 <strong>Node.js</strong> 是弱类型，所以只需要：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; foo; i++) {
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<h4 id="for…in">for…in</h4>
<p>这是一种后有型的循环语句，类似于 <strong>PHP</strong> 的 <code>foreach</code>。</p>
<p>比如我们有一个 <strong>JSON对象</strong> 如下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = {
    <span class="string">"hello"</span>     : <span class="string">"world"</span>,
    <span class="string">"node"</span>      : <span class="string">"js"</span>,
    <span class="string">"blahblah"</span>  : <span class="string">"bar"</span>
};
</pre></td></tr></table></figure>


<p>这个时候我们就可以用 <code>for...in</code> 来循环遍历了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">for</span>(<span class="reserved">var</span> key <span class="keyword">in</span> foo) {
    <span class="built_in">console</span>.log(key + <span class="string">": "</span> + foo[key]);
}
</pre></td></tr></table></figure>


<p>我们如果在命令行中打入下面的命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node foo.js
</pre></td></tr></table></figure>


<p>屏幕上就会显示下面的内容了：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">hello</span>: <span class="string">world</span>
<span class="attribute">node</span>: <span class="string">js</span>
<span class="attribute">blahblah</span>: <span class="string">bar</span>
</pre></td></tr></table></figure>


<blockquote>
<p><strong>提示</strong>：由上可知，<code>for...in</code> 语句是用来遍历 <strong>JSON对象</strong>、<strong>数组</strong>、<strong>对象</strong>的键名的，而不提供键值的遍历。如果要获取键值，只能通过</p>
</blockquote>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>foo[<span class="tag">&lt;<span class="title">当前键名</span>&gt;</span>]
</pre></td></tr></table></figure>


<p>的形式来获取。这个跟 <strong>PHP</strong> 的 <code>foreach</code> 还是有一定区别的。</p>
<h4 id="while…do,_do…while">while…do, do…while</h4>
<p>这个就不多做解释了，跟其它语言没什么大的区别，无非就是如果有变量声明的话，需要用 <code>var</code> 就够了。</p>
<h3 id="运算符">运算符</h3>
<h4 id="+,_-,_*,_/">+, -, *, /</h4>
<p>这几个运算符也就这样，要注意的是 <code>+</code>。它既可以作用于字符串，也可以作用于数值运算。弱类型语言虽然说类型是弱的，数字有时候可以以字符串的形态出现，字符串有时候可以用数值的形态出现，但是在必要的时候也还是要说一下它是什么类型的，我们可以用下面的代码去看看结果：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">var</span> a = <span class="string">"1"</span>;
<span class="reserved">var</span> b = <span class="number">2</span>;
<span class="built_in">console</span>.log(a + b);
<span class="built_in">console</span>.log(parseInt(a) + b);
</pre></td></tr></table></figure>


<blockquote>
<p>这里的 <code>parseInt</code> 是 <strong>Node.js</strong> 的一个内置函数，作用是将一个字符串解析成 <code>int</code> 类型的变量。</p>
</blockquote>
<p>上面的代码执行结果是</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>12
3
</pre></td></tr></table></figure>


<p>第一个 <code>console.log</code> 结果是 <code>12</code>，由于 <code>a</code> 是字符串，所以 <code>b</code> 也被系统以字符串的姿态进行加操作，结果就是将两个字符串黏连在一起就变成了 <code>12</code>。而第二个 <code>console.log</code> 结果是 <code>3</code>，是因为我们将第一个 <code>a</code> 转变为了 <code>int</code> 类型，两个 <code>int</code> 型的变量相加即数值相加，结果当然就是 <code>3</code> 了。</p>
<h4 id="==,_===,_!=,_!==">==, ===, !=, !==</h4>
<p>这里有一点要解释，当这个逻辑运算符长度为 <code>2</code> 的时候（<code>==</code>, <code>!=</code>），只是判断外在的值是不是一样的，而不会判断类型。如</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="literal">a</span> = <span class="number">1</span>, b = <span class="string">"1"</span><span class="comment">;</span>
console.log(<span class="literal">a</span> == b)<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>它输出的结果就是 <code>true</code>。但是如果我们在中间判断的时候再加上一个等号，那么就是严格判断了，需要类型和值都一样的时候才会是 <code>true</code>，否则就是 <code>false</code>。也就是说</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="literal">a</span> = <span class="number">1</span>, b = <span class="string">"1"</span><span class="comment">;</span>
console.log(<span class="literal">a</span> === b)<span class="comment">;</span>
</pre></td></tr></table></figure>


<p>的时候，返回的结果就是 <code>false</code> 了，因为 <code>a</code> 是 <code>int</code> 型的，而 <code>b</code> 则是字符串。</p>
<blockquote>
<p>顺带着就把条件语句讲了吧，其实这里的 <code>if</code> 跟别的语言没什么两样，就是几个逻辑运算符两个等号三个等号的问题。所以就不多做累述了。</p>
</blockquote>
<h4 id="typeof">typeof</h4>
<p>这里我姑且把它当成是一个运算符而不是函数了。</p>
<p>这个运算符的作用是判断一个变量的类型，会返回一个字符串，即类型名，具体的执行下面的代码就知道了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="reserved">function</span> foo() {}

<span class="reserved">var</span> a = <span class="number">0</span>;
<span class="reserved">var</span> b = <span class="string">'嘘~蛋花汤在睡觉。'</span>;
<span class="reserved">var</span> c = <span class="number">1.0</span>;
<span class="reserved">var</span> d = foo;
<span class="reserved">var</span> e = { <span class="string">"a"</span> : a };
<span class="reserved">var</span> f = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];
<span class="reserved">var</span> g = <span class="literal">null</span>;
<span class="reserved">var</span> h = <span class="literal">undefined</span>;

<span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> g);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> h);
</pre></td></tr></table></figure>


<p>这里的执行结果就将会是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="built_in">number</span>
<span class="keyword">string</span>
<span class="built_in">number</span>
<span class="function"><span class="keyword">function</span></span>
object
object
object
undefined
</pre></td></tr></table></figure>


<h3 id="null,_undefined,_NaN">null, undefined, NaN</h3>
<p>在 <strong>JavaScript</strong> 中，有三个特殊的值，如标题所示。其中第一个大家可能都比较熟悉吧，<strong>C/C++</strong> 里面也有，不过是大写的，其本质就是一个</p>
<figure class="highlight"><figcaption><span>c++</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#<span class="keyword">define</span> NULL 0</span>
</pre></td></tr></table></figure>


<p>而在 <strong>JavaScript</strong> 中，这三个值所代表的意义都不同。</p>
<h4 id="null">null</h4>
<p><code>null</code> 是一种特殊的 <strong>object</strong>，大致的意思就是空。比如说：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">null</span>;
</pre></td></tr></table></figure>


<p>大家都能看懂，就不多做解释了。但是跟 <strong>C/C++</strong> 不同的是，这个 <code>null</code> 跟 <code>0</code> 不相等。</p>
<h4 id="undefined">undefined</h4>
<p>这个东西的意思就是说这个变量未声明。为了能够更好地区分 <code>null</code>，我们的样例代码如下写：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="reserved">var</span> a = {
    <span class="string">"foo"</span>       : <span class="literal">null</span>
};
<span class="built_in">console</span>.log(a[<span class="string">"foo"</span>]);
<span class="built_in">console</span>.log(a[<span class="string">"bar"</span>]);
</pre></td></tr></table></figure>


<p>上面的代码中，我们让 <code>a[&quot;foo&quot;]</code> 的值为空，即 <code>null</code>。而压根没有声明 <code>a[&quot;bar&quot;]</code> 这个东西，它连空都不是。输出的结果大家都差不多应该猜到了：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="literal">null</span>
<span class="literal">undefined</span>
</pre></td></tr></table></figure>


<h4 id="NaN">NaN</h4>
<p>这是一个空的数值，是一个特殊的 <code>number</code>。它的全称是 <code>Not a Number</code>。有点奇怪，大家可以理解为 <strong>不是数字形态，或者数值出错的 <code>number</code> 类型变量</strong>。</p>
<p>多在浮点型数值运算错误（如被0除）的情况下出现，甚至可以是用户自己让一个变量等于 <code>NaN</code> 以便返回一个错误值让大家知道这个函数运算出错了云云。</p>
<h3 id="小杂碎">小杂碎</h3>
<p>其它剩余的语句也跟已存在的其它语言差不多，比如说 <code>break</code> 啊、<code>switch</code> 啊、<code>continue</code> 啊等等等等。</p>
<h2 id="变量类型">变量类型</h2>
<p>这一节主要讲的是 <strong>JavaScript</strong> 对象，其它类型差不多一带而过吧。</p>
<h3 id="基础类型">基础类型</h3>
<p><strong>Node.js</strong> 包含的基础类型差不多有如下几个：</p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>array</li>
</ul>
<p>其中前三种类型可以直接赋值，而 <code>array</code> 的赋值只是一个引用赋值而已，在新变量中改变某个值的话旧变量的值也会改变，直接可以试试下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">var</span> foo = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];
<span class="reserved">var</span> bar = foo;
bar[<span class="number">0</span>] = <span class="number">3</span>;
<span class="built_in">console</span>.log(foo);
</pre></td></tr></table></figure>


<p>它得出的结果是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[ <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span> ]
</pre></td></tr></table></figure>


<p>也就是说 <code>array</code> 要是复制出一个新的数组的话，不能用直接赋值的方法，而必须“<strong><a href="#深拷贝">深拷贝</a></strong>”。</p>
<p>这里有必要讲一下 <code>array</code> 的三种创建方法。</p>
<p>第一种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="built_in">Array</span>();
dog[<span class="number">0</span>] = <span class="string">"嘘~"</span>;
dog[<span class="number">1</span>] = <span class="string">"蛋花汤"</span>;
dog[<span class="number">2</span>] = <span class="string">"在睡觉"</span>;
</pre></td></tr></table></figure>


<p>第二种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="string">"嘘~"</span>, <span class="string">"蛋花汤"</span>, <span class="string">"在睡觉"</span> );
</pre></td></tr></table></figure>


<p>第四种：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = [
    <span class="string">"嘘~"</span>,
    <span class="string">"蛋花汤"</span>,
    <span class="string">"在睡觉"</span>
];
</pre></td></tr></table></figure>


<p>我个人比较喜欢第三种写法，比较简洁。</p>
<h3 id="JSON对象">JSON对象</h3>
<p>这里我把 <strong>JSON对象</strong> 单独拎出来而不是把它归类为 <strong>JavaScript对象</strong>，如果觉得我有点误人子弟就可以直接跳过这一节了。</p>
<p>本人对于 <strong>JSON对象</strong> 和 <strong>JavaScript</strong> 对象的区分放在 <strong>是否只用来存储数据，而并非是一个类的实例化</strong>。其实 <strong>JSON</strong> 的本质便是 <strong>JavaScript Object Notation</strong>。</p>
<blockquote>
<p>更多有关 <strong><a href="http://zh.wikipedia.org/wiki/JSON" target="_blank">JSON</a></strong> 的信息请自行百科。</p>
</blockquote>
<p>在 <strong>Node.js</strong> 中声明一个 <strong>JSON对象</strong> 非常简单：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> dog = {
    <span class="string">"pre"</span>       : <span class="string">"嘘~"</span>,
    <span class="string">"sub"</span>       : {
        <span class="string">"name"</span>  : <span class="string">"蛋花汤"</span>,
        <span class="string">"act"</span>   : <span class="string">"在睡觉"</span>,
        <span class="string">"time"</span>  : <span class="number">12</span>
    },

    <span class="string">"suf"</span>       : [ <span class="string">"我说了"</span>, <span class="string">"它在睡觉"</span>, <span class="string">"就是在睡觉"</span> ]
};
</pre></td></tr></table></figure>


<p>有两种方式能得到 <strong>JSON对象</strong> 中的某个键名的键值，第一种是用点连接，第二种是用中括号：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>dog<span class="preprocessor">.pre</span><span class="comment">;</span>
dog[<span class="string">"pre"</span>]<span class="comment">;</span>
</pre></td></tr></table></figure>


<blockquote>
<p><strong>试试看</strong>：现在你自己动手试试看，用 <code>for...in</code> 的形式遍历一遍上面的 <code>JSON对象</code>。别忘了用上 <code>typeof</code> 喵~</p>
</blockquote>
<h3 id="类（对象）的基础">类（对象）的基础</h3>
<p>严格意义上来讲，<strong>Node.js</strong> 的类不能算是类，其实它只是一个函数的集合体，加一些成员变量。它的本质其实是一个函数。</p>
<p>不过为了通俗地讲，我们接下去以及以后都将其称为“类”，实例化的叫“对象”。</p>
<p>因为类有着很多 <strong>函数</strong> 的特性，或者说它的本质就是一个 <strong>函数</strong>，所以这里面我们可能一不留神就顺带着把函数基础给讲了。</p>
<h4 id="类的声明和实例化">类的声明和实例化</h4>
<p>声明一个类非常简单，大家不要笑：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">function</span> foo() {
    //<span class="keyword">...</span>
}
</pre></td></tr></table></figure>


<p>好了，我们已经写好了一个 <code>foo</code> 类了。</p>
<blockquote>
<p>真的假的？！真的。</p>
</blockquote>
<p>不信？不信你可以接下去打一段代码看看：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> bar = <span class="keyword">new</span> foo();
</pre></td></tr></table></figure>


<p>别看它是一个函数，如果以这样的形式（<code>new</code>）写出来，它就是这个类的实例化。</p>
<p>而这个所谓的 <code>foo()</code> 其实就是这个 <code>foo()</code> 类的构造函数。</p>
<h4 id="成员变量">成员变量</h4>
<p>成员变量有好两种方法。</p>
<p>第一种就是在类的构造函数或者任何构造函数中使用 <code>this.&lt;变量名&gt;</code> 。你可以在任何时候声明一个成员变量，在外部不影响使用，反正就算在还未声明的时候使用它，也会有一个 <code>undefined</code> 来撑着。所以说这就是第一种方法：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
}
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意</strong>：只有在加了 <code>this</code> 的时候才是调用类的<strong>成员变量</strong>，否则只是函数内的一个局部变量而已。要分清楚有没有 <code>this</code> 的时候变量的作用范围。</p>
</blockquote>
<p>第二种方法就是在构造函数或者任何成员函数外部声明，其格式是 <code>&lt;类名&gt;.prototype.&lt;变量名&gt;</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">function</span> foo() {
    //<span class="keyword">...</span>
}

foo.prototype.hello = <span class="string">"world"</span>;
</pre></td></tr></table></figure>


<p>无聊上面哪种方法都是对成员变量的声明，我们可以看看效果：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> bar = <span class="keyword">new</span> foo();
<span class="built_in">console</span>.log(bar.hello);
</pre></td></tr></table></figure>


<p>甚至你可以这么修改这个类：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
}

foo.prototype.hello = <span class="string">"蛋花汤"</span>;
</pre></td></tr></table></figure>


<p>然后再用上面的代码输出。</p>
<blockquote>
<p>想想看为什么输出的还是 <code>world</code> 而不是 <code>蛋花汤</code>。</p>
</blockquote>
<h4 id="构造函数">构造函数</h4>
<p>我们之前说过了这个 <code>foo()</code> 实际上是一个 <strong>构造函数</strong>。那么显然我们可以给构造函数传参数，所以就有了下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 代码2.1</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(hello)</span> {</span>
    <span class="keyword">if</span>(hello === <span class="literal">undefined</span>) {
        <span class="keyword">this</span>.hello = <span class="string">"world"</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">this</span>.hello = hello;
    }
}
</pre></td></tr></table></figure>


<p>我们看到上面有一个奇葩的判断 <code>if(hello === undefined)</code>，这个判断有什么用呢？第一种可能，就是开发者很蛋疼地特意传进去一个 <code>undefined</code> 进去，这个时候它是 <code>undefined</code> 无可厚非。</p>
<p>还有一种情况。我们一开始就说了 <strong>JavaScript</strong> 是一门弱类型语言，其实不仅仅是弱类型，它的传参数也非常不严谨。你可以多传或者少传（只要保证你多传或者少传的时候可以保证程序不出错，或者逻辑不出错），原则上都是可以的。多传的参数会被自动忽略，而少传的参数会以 <code>undefined</code> 补足。</p>
<p>看看下面的代码就明白了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
<span class="keyword">var</span> bar1 = <span class="keyword">new</span> foo();
<span class="keyword">var</span> bar2 = <span class="keyword">new</span> foo(<span class="string">"蛋花汤"</span>);
</pre></td></tr></table></figure>


<p>请自行输出一下两个 <code>bar</code> 的 <code>hello</code> 变量，会发现一个是 <strong>world</strong> 一个是 <strong>蛋花汤</strong>。显而易见，我们的第一个 <code>bar1</code> 在声明的时候，被 <strong>Node.js</strong> 自动看成了：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> bar1 = <span class="keyword">new</span> foo(<span class="literal">undefined</span>);
</pre></td></tr></table></figure>


<p>所以就有了它是 <strong>world</strong> 一说。</p>
<p>还有就是在这个构造函数中，我们看到了传进去的参数是 <code>hello</code> 而这个类中本来就有个成员变量就是 <code>this.hello</code>。不过我们之前说过了有 <code>this</code> 和没 <code>this</code> 的时候作用域不同，那个参数只是作用于构造函数中，而加了 <code>this</code> 的那个则是成员变量。用一个 <code>this</code> 就马上区分开来他们了，所以即使同名也没关系。</p>
<h4 id="成员函数">成员函数</h4>
<h5 id="成员函数声明">成员函数声明</h5>
<p>成员函数的声明跟成员变量的第二种声明方法差不多，即 <code>&lt;类名&gt;.prototype.&lt;函数名&gt; = &lt;函数&gt;;</code></p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
<span class="function"><span class="keyword">function</span> <span class="title">setHello</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
foo.prototype.setHello = setHello;

bar1.setHello(<span class="string">"鸡蛋饼"</span>);
</pre></td></tr></table></figure>


<p>上面这段代码显而易见，我们实现了 <code>foo</code> 类的 <code>setHello</code> 函数，能通过它修改 <code>foo.hello</code> 的值。</p>
<p>但是这么写是不是有点麻烦？接下去我要讲一个 <strong>JavaScript</strong> 函数重要的特性了。</p>
<h4 id="★_匿名函数">★ 匿名函数</h4>
<p>很多时候我们的某些函数只在一个地方被引用或者调用，那么我们为这个函数起一个名字就太不值了，没必要，所以我们可以临时写好这个函数，直接让引用它的人引用它，调用它的人调用它。所以函数可以省略函数名，如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>至于怎么引用或者调用呢？如果是上面的那个类需要引用的话，就是写成这样的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>foo.prototype.setHello = <span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>这样的写法跟 <strong><a href="#成员函数声明">2.3.3.1. 成员函数声明</a></strong> 是一个效果的，而且省了很多的代码量。而且实际上，基本上的类成员函数的声明都是采用这种匿名函数的方式来声明的。</p>
<p>至于说怎么样让匿名函数被调用呢？这通常用于传入一个只被某个函数调用的函数时这样写。</p>
<p>比如我们有一个函数的原型是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 我们将传入a，b两个变量，
 * 在算出a+b的值后，交由func(num)
 * 去进行输出
 */</span>
function sumab(a, b, func) {
    <span class="keyword">var</span> c = a + b;
    func(a, b, c);
}
</pre></td></tr></table></figure>


<p>比如我们有两个版本的输出函数，一个是中文输出，一个是英文输出，那么如果不用匿名函数时候是这么写的：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">zh</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" + "</span> + b + <span class="string">" 的值是："</span> + <span class="built_in">sum</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">en</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" plus "</span> + b + <span class="string">" is "</span> + <span class="built_in">sum</span>);
}

sumab(<span class="number">1</span>, <span class="number">2</span>, zh);
sumab(<span class="number">3</span>, <span class="number">4</span>, en);
</pre></td></tr></table></figure>


<p>执行一遍这段代码，输出的结果将会是：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="number">1</span> + <span class="number">2</span> 的值是：<span class="number">3</span>
<span class="number">3</span> plus <span class="number">4</span> <span class="keyword">is</span> <span class="number">7</span>
</pre></td></tr></table></figure>


<p>这样的代码如果采用匿名函数的形式则将会是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>sumab(<span class="number">1</span>, <span class="number">2</span>, <span class="function"><span class="keyword">function</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" + "</span> + b + <span class="string">" 的值是："</span> + <span class="built_in">sum</span>);
});
sumab(<span class="number">3</span>, <span class="number">4</span>, <span class="function"><span class="keyword">function</span><span class="params">(a, b, sum)</span> {</span>
    <span class="transposed_variable">console.</span>log(a + <span class="string">" plus "</span> + b + <span class="string">" is "</span> + <span class="built_in">sum</span>);
});
</pre></td></tr></table></figure>


<p>这种形式通常使用于回调函数。回调机制算是 <strong>Node.js</strong> 或者说 <strong>JavaScript</strong> 的精髓。在以后的篇章会做介绍。</p>
<h4 id="成员函数声明的匿名函数声明方式">成员函数声明的匿名函数声明方式</h4>
<p>虽然上一节讲过了，不过还是再讲一遍吧。</p>
<p>通常我们声明类的成员函数时候都是用匿名函数来声明的，因为反正那个函数也就是这个类的一个成员函数而已，不会在其它地方被单独引用或者调用，所以就有了下面的代码：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 上接代码2.1</span>
foo.prototype.setHello = <span class="function"><span class="keyword">function</span><span class="params">(hello)</span> {</span>
    <span class="keyword">this</span>.hello = hello;
}
</pre></td></tr></table></figure>


<p>这样我们就使得 <code>foo</code> 类有了 <code>setHello</code> 这个函数了。</p>
<h4 id="类的随意性">类的随意性</h4>
<p>这个又是我胡扯的。所谓类的随意性即 <strong>JavaScript</strong> 中你可以在任何地方修改你的类，这跟 <strong>Ruby</strong> 有着一定的相似之处。</p>
<p>比如说 <code>string</code> ，它其实也是一个类，有着诸如 <code>length</code> 这样的成员变量，也有 <code>indexOf</code>、<code>substr</code> 等成员函数。但是万一我们觉得这个 <code>string</code> 有些地方不完善，想加自己的方法，那么可以在你想要的地方给它增加一个函数，比如：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="built_in">String</span>.prototype.sb = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> newstr = <span class="string">""</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {
        <span class="keyword">if</span>(i % <span class="number">2</span> === <span class="number">0</span>) newstr += <span class="string">"s"</span>;
        <span class="keyword">else</span> newstr += <span class="string">"b"</span>;
    }

    <span class="keyword">return</span> newstr;
};
</pre></td></tr></table></figure>


<p>这个函数的意思就是填充一个字符串，使其变成 <code>sb</code> 的化身。</p>
<p>我们来测试一下：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var <span class="keyword">str</span> = <span class="string">"嘘~蛋花汤在睡觉。"</span>;
console.<span class="keyword">log</span>(<span class="keyword">str</span>.sb());
</pre></td></tr></table></figure>


<p>你将会得到这样的结果：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbsbsbsbs
</pre></td></tr></table></figure>


<blockquote>
<p>你跟你的电脑说“嘘~蛋花汤在睡觉。”，你的电脑会骂你四次半傻逼。（赶快砸了它）</p>
</blockquote>
<h2 id="附">附</h2>
<h3 id="深拷贝">深拷贝</h3>
<p>所谓深拷贝就是自己新建一个数组或者对象，把源数组或者对象中的基础类型变量值一个个手动拷过去，而不是只把源数组或者对象的引用拿过来。所以这就涉及到了一个递归的调用什么的。</p>
<p>下面是我实现的一个深拷贝函数，大家可以写一个自己的然后加入到自己的 <strong>Node.js</strong> 知识库中。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span><span class="params">(src)</span> {</span>
    <span class="keyword">var</span> dest = {};
    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> src) {
        <span class="keyword">if</span>(<span class="keyword">typeof</span> src === <span class="string">"object"</span>) dest[key] = cloneObject(src[key]);
        <span class="keyword">else</span> dest[key] = src[key];
    }

    <span class="keyword">return</span> dest;
}
</pre></td></tr></table></figure>


<h3 id="系统默认对象参考手册">系统默认对象参考手册</h3>
<ul>
<li><strong>字符串</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_string.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_string.asp</a></li>
<li><strong>数字</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_number.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_number.asp</a></li>
<li><strong>数组</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_array.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_array.asp</a></li>
<li><strong>布尔</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_boolean.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_boolean.asp</a></li>
<li><strong>日期</strong>: <a href="http://www.w3school.com.cn/js/jsref_obj_date.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_date.asp</a></li>
<li><strong>数学库</strong>：<a href="http://www.w3school.com.cn/js/jsref_obj_math.asp" target="_blank">http://www.w3school.com.cn/js/jsref_obj_math.asp</a></li>
</ul>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（负贰）——环境]]></title>
    <link href="http://xcoder.in/2013/08/15/node-2-environment-in-windows/"/>
    <id>http://xcoder.in/2013/08/15/node-2-environment-in-windows/</id>
    <published>2013-08-15T00:00:00.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>由于<a href="#linux-环境">Linux</a>中的环境搭建比较简单，所以草草略过。</p>
<p>　　其实<a href="#windows-环境">Windows</a>下也不算麻烦，但是这里会讲一定量的别的环境的搭建。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="Linux_环境">Linux 环境</h2>
<p>讲到这个就很简单了，跟着下面的 <strong>bash</strong> 操作即可：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$ cd /usr/<span class="built_in">local</span>/bin
$ wget http:<span class="comment">//nodejs.org/dist/v0.00.00/node-v0.00.00-linux-x00.tar.gz</span>
$ tar zxf node<span class="attribute">-v0</span><span class="number">.00</span><span class="number">.00</span><span class="attribute">-linux</span><span class="attribute">-x00</span><span class="built_in">.</span>tar<span class="built_in">.</span>gz
$ cd node<span class="attribute">-v0</span><span class="number">.00</span><span class="number">.00</span><span class="attribute">-linux</span><span class="attribute">-x00</span>
</pre></td></tr></table></figure>


<blockquote>
<p>其中将上方的 <strong>v0.00.00</strong> 替换成 <strong>Node.js</strong> 最新的版本号，把 <strong>x00</strong> 替换成你自己电脑的位数。</p>
<p>也可以直接去官网 <a href="http://nodejs.org/download/" target="_blank">http://nodejs.org/download/</a> 找到相应的地址。</p>
</blockquote>
<p>最后将其的连接加入到 <code>/usr/bin</code> 下即可。</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$ </span>cd bin
<span class="variable">$ </span>ln node /usr/bin
<span class="variable">$ </span>ln npm /usr/bin
</pre></td></tr></table></figure>


<blockquote>
<p><strong>注意</strong>： 该用 <code>sudo</code> 的地方就用 <code>sudo</code> 或者 <code>su</code> 。</p>
</blockquote>
<p>至此，<strong>Linux</strong> 下的 <strong>Node.js</strong> 环境基本搭建完毕。</p>
<h2 id="Windows_环境">Windows 环境</h2>
<h3 id="Cygwin_安装和配置">Cygwin 安装和配置</h3>
<p><strong><em>Cygwin</em></strong> 是一个在 <strong><em>Windows</em></strong> 平台上运行的 <strong><em>Unix</em></strong> 模拟环境。对于学习 <strong><em>Unix/Linux</em></strong> 操作环境，或者从 <strong><em>Unix</em></strong> 到 <strong><em>Windows</em></strong> 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 <strong><em>GNU工具集</em></strong> 在 <strong><em>Windows</em></strong> 上进行嵌入式系统开发，非常有用。</p>
<h4 id="Cygwin_安装">Cygwin 安装</h4>
<p>我们先跑到 <strong>Cygwin</strong> 的官网上去把东西下来：</p>
<blockquote>
<p><a href="http://cygwin.com/install.html" target="_blank">http://cygwin.com/install.html</a></p>
<blockquote>
<p>注意，最好下 <strong>x86</strong> 的包，因为我们之后要讲一个 <code>cyg-apt</code> 的脚本插件，这是一个能让 <strong>Cygwin</strong> 能跟 <strong>Linux</strong> 一样通过脚本从源安装软件包的脚本。为了方便修改，我们将其下成 <strong>x86</strong> 的版本。</p>
</blockquote>
</blockquote>
<p>然后就是安装步骤了。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-1.png" alt="从网络安装"></center><br><center><small>[图2.1]</small></center>

<p>到 <strong>[图2.1]</strong> 这个步骤的时候，选择默认的 <code>Install from Internet</code> 即可。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-2.png" alt="选择安装路径"></center><br><center><small>[图2.2]</small></center>

<p>在 <strong>[图2.2]</strong> 的时候选一个安装路径。</p>
<blockquote>
<p><strong>注意</strong>：尽可能让这个安装路径简单，而不要是类似于</p>
<p><code>c:\Program Files\blahblah</code></p>
<p>这样的文件路径。</p>
</blockquote>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-3.png" alt="本地包路径"></center><br><center><small>[图2.3]</small></center>

<p><strong>[图2.3]</strong> 的时候选一个本地包的路径，我这里选的是 <code>e:\cygwin\tmp</code>。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-4.png" alt="直连"></center><br><center><small>[图2.4]</small></center>

<p><strong>[图2.4]</strong> 选择直接连接。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-5.png" alt="163"></center><br><center><small>[图2.5]</small></center>

<p>我们国内的用户源还是选择 <code>163</code> 的速度比较快。所以在 <strong>[图2.5]</strong> 这一步的时候就直接选用默认的 <code>163</code> 的源了。如果不是默认的话，请选中它。</p>
<p>在 <strong>Select Package</strong> 也就是选择预安装的软件的时候，把下列表中的软件包勾选起来：</p>
<blockquote>
<ul>
<li><strong>wget</strong>: 在 <strong>Utils</strong> 中</li>
<li><strong>vim</strong>: 在 <strong>Editors</strong> 中</li>
<li><strong>gcc</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>gcc-g++</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>make</strong>: 在 <strong>Devel</strong> 中</li>
<li><strong>cmake</strong>: 在 <strong>Devel</strong> 中</li>
</ul>
</blockquote>
<p>若是这些选项已经被选起来了就不用再选了，如果没有选起来则把它选中。</p>
<p>勾选好了之后就可以下一步安装了，直至安装完毕，你就可以打开你的 <strong>Cygwin</strong> 了。</p>
<center><img src="http://blog-xcoder-in.qiniudn.com/cygwin-install-6.png" alt="Cygwin"></center><br><center><small>[图2.6]</small></center>

<blockquote>
<p><strong>提示</strong>：你可以点击窗口左上角的小图片，然后里面的 <strong>Options</strong> 中，你可以调整你自己的 <strong>Cygwin</strong> 外观。</p>
</blockquote>
<h3 id="vim_配置">vim 配置</h3>
<p>上一步我们已经选中了 <strong>vim</strong> ，也就是说我们已经在 <strong>Cygwin</strong> 中装上了 <strong>vim</strong>。但是由于这里的 <strong>vim</strong> 默认配置非常蛋疼，所以我们得改一下。</p>
<p>在你的 <strong>Cygwin</strong> 中一句句输入下面的命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>$ cd /home/&lt;你自己的用户名&gt;
$ wget http://blog-xcoder-<span class="keyword">in</span><span class="preprocessor">.qiniudn</span><span class="preprocessor">.com</span>/<span class="preprocessor">.vimrc</span>
$ mkdir <span class="preprocessor">.vim</span>
$ cd <span class="preprocessor">.vim</span>
$ mkdir colors
$ cd colors
$ wget http://blog-xcoder-<span class="keyword">in</span><span class="preprocessor">.qiniudn</span><span class="preprocessor">.com</span>/molokai<span class="preprocessor">.vim</span>
</pre></td></tr></table></figure>


<p>这样你的 <strong>vim</strong> 就用上了上面的那个地址的配置文件，当然你也可以编辑你自己的配置文件或者说从网上下别的配置文件以满足你的个性化需求。</p>
<p><strong>vim</strong> 配置以及使用请参照：<a href="https://wiki.archlinux.org/index.php/Vim" target="_blank">https://wiki.archlinux.org/index.php/Vim</a></p>
<blockquote>
<p>事无巨细问 <strong>ArchWiki</strong>。</p>
<div style="text-align: right;"><em>— <a href="https://github.com/kalxd" target="_blank">kalxd</a></em></div>

</blockquote>
<h3 id="apt-cyg">apt-cyg</h3>
<blockquote>
<p>apt-cyg is a command-line installer for Cygwin which cooperates with Cygwin Setup and uses the same repository. The syntax is similar to apt-get.</p>
<div style="text-align: right;"><em>— From apt-cyg googlecode page</em></div>

</blockquote>
<p>总之意思就是说 <code>apt-cyg</code> 是类似于 <strong>Linux</strong> 中的 <code>apt-get</code>， <code>yum</code>, <code>zypper</code> 等命令行软件包安装器一样，可以通过</p>
<ul>
<li><code>apt-cyg install &lt;package names&gt;</code> 来安装软件包</li>
<li><code>apt-cyg remove &lt;package names&gt;</code> 来移除软件包</li>
<li><code>apt-cyg update</code> 来更新 setup.ini</li>
<li><code>apt-cyg show</code> 来列出已安装的软件包</li>
<li><code>apt-cyg find &lt;pattern(s)&gt;</code> 来查找符合条件的软件包</li>
<li><code>apt-cyg describe &lt;pattern(s)&gt;</code> 来描述符合条件的软件包</li>
<li><code>apt-cyg packageof &lt;commands or files&gt;</code> 来定位其父软件包</li>
</ul>
<h4 id="apt-cyg_安装">apt-cyg 安装</h4>
<p>其实也不能说是安装，纯粹是把脚本从网络上拷到自己的 <strong>Cygwin</strong> 的环境目录中。</p>
<p>在你的 <strong>Cygwin</strong> 中输入以下命令：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>cd /usr/local/bin
<span class="variable">$ </span>wget <span class="symbol">http:</span>/<span class="regexp">/apt-cyg.googlecode.com/svn</span><span class="regexp">/trunk/apt</span>-cyg
</pre></td></tr></table></figure>


<p>这样你就“安装”好了 <strong>apt-cyg</strong> 了。不过这里用的是默认的源，所有东西都是默认的。</p>
<p>如果你现在已经心安理得或者不想折腾了可以跳过 <strong><a href="#apt-cyg-修改">2.1.3.2. apt-cyg 修改</a></strong>，如果你想把源换成 <code>163</code> 的话那么稍微看一下吧。</p>
<h4 id="apt-cyg_修改">apt-cyg 修改</h4>
<p>接下去我们要对 <strong>apt-cyg</strong> 做一些编辑。</p>
<p>你有下面两个选择：</p>
<ol>
<li>如果你想学习 <strong>vim</strong> 操作或者你已经熟悉了，那么直接使用 <code>vim apt-cyg</code> 来进行编辑。</li>
<li>如果你是懒人还是想要直接编辑的话，请跑到你的 <strong>Cygwin</strong> 的安装目录，找到 <strong>usr</strong> 文件夹，飞进 <strong>local/bin</strong> 目录中去，用你自己喜欢的文本编辑器打开并编辑。</li>
</ol>
<p>大约是 <code>68</code> 行上下吧，有一句是：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>  mirror=ftp://mirror<span class="preprocessor">.mcs</span><span class="preprocessor">.anl</span><span class="preprocessor">.gov</span>/pub/cygwin
</pre></td></tr></table></figure>


<p>将其改成：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">  mirror</span>=<span class="string">http://mirrors.163.com/cygwin</span>
</pre></td></tr></table></figure>


<p>还有就是大概在 <code>98</code> 行和 <code>105</code> 行左右：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    wget -N $mirror/setup.bz2
    <span class="keyword">...</span>
    wget -N $mirror/setup.ini
</pre></td></tr></table></figure>


<p>修改成：</p>
<figure class="highlight"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    wget -N $mirror/x86/setup.bz2
    <span class="keyword">...</span>
    wget -N $mirror/x86/setup.ini
</pre></td></tr></table></figure>


<p>至此，你的 <strong>Cygwin</strong> 环境基本完成，以后可以再慢慢完善。</p>
<h3 id="Node-js_安装">Node.js 安装</h3>
<p>这个就很简单了，打开 <strong><a href="http://nodejs.org/download/" target="_blank">Node.js</a></strong> 官网下载安装即可。</p>
<blockquote>
<p>选择 <strong>Windows Installer (.msi)</strong> 或者 <strong>Windows Binary (.exe)</strong>。</p>
</blockquote>
<p>安装好后就能直接在 <strong>Cygwin</strong> 里面使用了。</p>
<h2 id="真·Hello_World">真·Hello World</h2>
<p>现在，无论你是 <strong>Linux</strong> 用户还是 <strong>Windows</strong> 用户，都可以用一样的步骤来完成下面的 <code>Hello World</code> 了。</p>
<p>随便跑一个目录里面新建一个文件并且用 <strong>vim</strong> 编辑：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>vim hello.js
</pre></td></tr></table></figure>


<p>在里面输入下面的东西：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"Hello world!"</span>);
</pre></td></tr></table></figure>


<p>然后退出 <strong>vim</strong> 执行：</p>
<figure class="highlight"><figcaption><span>sh</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node hello.js
</pre></td></tr></table></figure>


<p>终于，<strong>真·Hello world</strong> 出现在了你的眼前，而不需要借助 <strong><a href="http://ideone.com/" target="_blank">IDEOne</a></strong> 了。</p>
<p><strong><em>To be continued…</em></strong></p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起撸Node.JS（负叁）——概述]]></title>
    <link href="http://xcoder.in/2013/08/13/node-1-summary/"/>
    <id>http://xcoder.in/2013/08/13/node-1-summary/</id>
    <published>2013-08-13T00:00:00.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>本系列教程主要是写给我带的那帮熊孩子们看的。我自己的 <strong>Node.js</strong> 水平半斤八两，措辞之中也免不了有自己错误的理解，会误人子弟。但是对于初学者来说，某些自己助记的理解还是可取的。有些概念性的错误可以等他们进一步深入研究之后再自行更正。</p>
<p>　　由于那帮人大多还处于使用 <strong>M$ Windows</strong> 的令人不愉快的阶段，所以本教程将会退而求其次，使其在 <strong>Cygwin</strong> 中模拟 <strong>linux</strong> 的命令（Windows的bat脚本实在是让人不敢恭维）。以及在这里会讲述一些 <strong>Git</strong> 操作的初步。当然，如果你已经在使用 <strong>linux</strong> 进行开发的话，可以跳过前面一堆令人感到厌烦的环境配置章节。或者你在使用 <strong>M$ Windows</strong> 但却不想改变自己的脚本习惯的话，也可以选择性地跳过一些章节和步骤。</p>
<p><!-- 我是小小分割符 --></p>
<h2 id="Node-JS是什么？">Node.JS是什么？</h2>
<p>很多人都知道JS是一门语言，而且是一门脚本语言，其全称就是 <strong>JavaScript</strong>，而且与所谓的 <strong>Java</strong> 没有一个屁的关系。</p>
<h3 id="前端_JavaScript">前端 JavaScript</h3>
<p>在好多年前，<strong>JavaScript</strong> 是网页的一个寄生虫，它必须依赖于网页的浏览器中才能执行，并且作为网页的一部分，以</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="comment">//blahblah...</span>
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<p>标签进行包含，这样才能提供其上下文环境。或者说将其单独写入一个 <code>*.js</code> 文件中，并且在网页里以</p>
<figure class="highlight"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"foo/bar.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<p>的形式将其包含进来。</p>
<p>但总而言之，<strong>JavaScript</strong> 只是寄生在网页里面的一只小小可怜虫罢了。它的作用无非就是使网页的交互性更强，页面效果更多而已。</p>
<p>后来，这帮不甘寂寞的人类将 <strong>JavaScript</strong> 从网页（或者说前端）的帝国中独立了出来（小心快递），于是就出现了 <strong>CommonJS</strong>。</p>
<h3 id="CommonJS">CommonJS</h3>
<p><strong>CommonJS</strong> 其实不是一门新的语言，甚至都不能说它是一个新的解释器——实际上它只是一个概念或者是一个规范。</p>
<p>在这个规范中，它定义了很多 <strong>API</strong> ，讲通俗点或者直截了当点就是函数啊类啊什么的，而这些 <strong>API</strong> 是为那些普通应用程序（Native App）而非浏览器应用使用。它的终极目标就是提供一个类似于 <strong>Python</strong>、<strong>Ruby</strong> 之类的脚本一样的标准库，开发者可以用这样的东西一样来做到 <strong>Python</strong>、<strong>Ruby</strong> 能做到的事，而非仅仅局限于网页中的效果或者功能实现，它也可以跑在本地。</p>
<p>所以说下面的事情对于 <strong>JavaScript</strong> 来说不再是梦：</p>
<ul>
<li>服务端JavaScript应用</li>
<li>命令行工具</li>
<li>图形界面应用</li>
<li>混合应用（Titanium、Adobe AIR等）</li>
</ul>
<p>那么，它具体弥补了 <strong>前端JavaScript</strong> 的哪些空白呢？其实这也涉及了很多 <strong>前端JavaScript</strong> 所没有涉及的东西，如二进制、编码、IO、文件、系统、断言测试、套接字、事件队列、Worker、控制台等等。</p>
<p>关于 <strong>CommonJS</strong> 的更进一步了解可以翻阅一下其 <strong><a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank">Wiki</a></strong>。</p>
<h3 id="Node-JS">Node.JS</h3>
<p>上面讲了那么多，却始终停留在“规范”这个层面上。而 <strong>Node.JS</strong> 的出现便是让 <strong>CommonJS</strong> 成为了现实。</p>
<p>这里要大家明确的一点的就是 <strong>Node.JS</strong> 并不是一门新的语言，它的语言还是 <strong>JavaScript</strong> ，硬要说是一门新的语言那也应该是 <strong>Common JavaScript</strong>。<strong>Node.JS</strong> 只是 <strong>CommonJS</strong> 的一个<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8" target="_blank">解释器</a>罢了。</p>
<p>它是基于 <strong>Google</strong> 的 <strong>V8虚拟机</strong>(Chrome浏览器所使用的JavaScript执行环境) 的一个解释器。</p>
<p>很多人印象中的概念还是没能摆脱 <strong>前端JavaScript</strong> 的阴霾，认为 <strong>JavaScript</strong> 就是做网站的， <strong>Node.JS</strong> 也是如此。</p>
<p>包括本人在 <strong><a href="http://cnodejs.org/" target="_blank">cnodejs.org</a></strong> 中看到的帖子大多也都是讲 <strong>Node.JS</strong> 如何如何做网站（服务端）云云，如何如何使用 <strong>Express</strong> 模块来搭建一个网站云云。</p>
<blockquote>
<p>这是一个误区。</p>
</blockquote>
<p><strong>PHP</strong> 还能用 <strong><a href="http://www.php-cli.com/" target="_blank">PHP-CLI</a></strong> 来写个脚本放本地跑呢，<strong>Node.JS</strong> 更是可以写任何程序。虽然这么讲有些夸大了，但是我这么说的理由是希望大家能摆脱这么一个误区。</p>
<p>举个简单的例子吧，大家都是搞过 <strong>ACM</strong> 的孩子了，总对终端窗口的输入输出有一定感觉了吧。现在给我以最快速度码一个 <strong><em><a href="http://acm.nbut.edu.cn/problem/view.xhtml?id=1000" target="_blank">A + B Problem</a></em></strong> 给我看看。</p>
<p>轻车熟路，我知道。但是你们现在做的事用 <strong>Node.JS</strong> 同样能做到。</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>process.stdin.resume();
process.stdin.setEncoding(<span class="string">"utf8"</span>);
process.stdin.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
    <span class="keyword">var</span> datas = chunk.trim().split(<span class="string">"\n"</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; datas.length; i++) {
        <span class="keyword">var</span> ab = datas[i].trim().split(<span class="string">" "</span>);
        <span class="keyword">var</span> a = <span class="built_in">parseInt</span>(ab[<span class="number">0</span>]);
        <span class="keyword">var</span> b = <span class="built_in">parseInt</span>(ab[<span class="number">1</span>]);
        console.log(a + b);
    }
});
</pre></td></tr></table></figure>


<p>由于<del>我们学校</del>我的前任学校OJ不支持 <strong>Node.JS</strong>，所以请你们移步到 <strong><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1000" target="_blank">AIZU OJ</a></strong> 去把上面的代码交过去看看结果看。</p>
<blockquote>
<p><strong>注意</strong>：语言要选择 <strong>JavaScript</strong>。</p>
</blockquote>
<p>怎么样，同样能过题的对吧？</p>
<h2 id="小结">小结</h2>
<p>上面对这些东西做了个简单的介绍，我需要你们知道的东西很简单：</p>
<ol>
<li><strong>Node.JS</strong> 是一个脚本解释器，用的语言是 <strong>JavaScript</strong>。</li>
<li><strong>Node.JS</strong> 功能很强大，不是只能拿来做网站的，眼光放开阔些。</li>
<li>给我好好学。</li>
</ol>
<h2 id="番外">番外</h2>
<blockquote>
<p>有个码畜老了，想学学书法来修身养性。当他展开宣纸，犹豫了半天之后，终于挥毫泼墨，在纸上龙飞凤舞写下几个大字：</p>
<blockquote>
<p><strong><em>Hello World</em></strong></p>
</blockquote>
</blockquote>
<p>虽然这一篇文章没有讲到任何 <strong>Node.JS</strong> 的语法，但是还是可以让你们练练书法的。</p>
<p><strong>C语言</strong> 的标准输出函数是 <code>printf</code>，而 <strong>Node.JS</strong> 的标准输出则是：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(<span class="string">"blahblah..."</span>);
</pre></td></tr></table></figure>


<p>好的，即使没有装上 <strong>Node.JS</strong> 环境也阻止不了我们向世界问好。</p>
<p>打开 <strong><a href="http://ideone.com/" target="_blank">IDEOne</a></strong>，将你的 <code>Hello World</code> 贴到编辑框中，然后在左侧的语言栏里面选中 <strong>Node.JS</strong> ，点击送出，你就能看到你的第一个 <strong>Node.JS</strong> 程序的运行结果了。</p>
<p><strong><em>To be continued…</em></strong></p>
]]></content>
    
    
      <category term="Node.js" scheme="http://xcoder.in/tags/Node.js/"/>
    
      <category term="JavaScript" scheme="http://xcoder.in/tags/JavaScript/"/>
    
      <category term="一起撸Node.JS" scheme="http://xcoder.in/tags/%E4%B8%80%E8%B5%B7%E6%92%B8Node.JS/"/>
    
      <category term="NodeJS" scheme="http://xcoder.in/categories/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于JavaScript中callback函数的this指针重定义]]></title>
    <link href="http://xcoder.in/2013/07/15/javascript-callback-this-bind/"/>
    <id>http://xcoder.in/2013/07/15/javascript-callback-this-bind/</id>
    <published>2013-07-15T06:20:29.000Z</published>
    <updated>2014-07-30T03:07:18.000Z</updated>
    <content type="html"><![CDATA[<p>最近在写 <strong>NBUT Virtual Judge</strong> 的内核框架，用的又是 <strong>Node.JS</strong> 了，把它当作一个本地运行的脚本不断进行轮询。</p>
<p>　　众所周知JS中的一个精髓就是异步回调。</p>
<p>　　所以在我自己写的框架中也经常会出现类似于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>foo.bar(a, b, <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>});
</pre></td></tr></table></figure>

<p>　　总而言之就是写一个函数，这个函数将会调用一个回调函数。</p>
<p>　　但是问题出现了：在那个回调函数 <code>function</code> 中，你如果使用了一个 <code>this</code> 指针的话，它将会指向根，而不是 <code>foo</code> 的本体。</p>
<p>　　那么如果我们想在 <code>function</code> 中也用 <code>this</code> 来指代这个 <code>foo</code> 对象该怎么办呢？</p>
<p>　　结果还是IRC有用。本人跑 <strong>Node.JS</strong> 的 <strong>IRC</strong> 上问了这个问题，结果有人就这样回复我了：</p>
<blockquote>
<p>13:07 &lt;shama&gt; xadillax: foo(a, b callback.bind(foo))</p>
<p>13:10 &lt;olalonde&gt; foo (a, b fn) { fn = fn.bind(this); …. }</p>
</blockquote>
<p>　　然后还很热心地给了我个网址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>
<p>　　总之最后得出的结论就是说：</p>
<p>　　你只要给你的 <code>callback</code> 函数指定一个 <code>this</code> 指针即可。</p>
<p>　　如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> cb = callback.bind(foo);
foo.bar(a, b, cb);
</pre></td></tr></table></figure>

<p>　　这样就能在回调函数中使用foo来作为其this指针了。</p>
]]></content>
    
    
      <category term="老博客备份归档" scheme="http://xcoder.in/tags/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
      <category term="Javascript" scheme="http://xcoder.in/tags/Javascript/"/>
    
      <category term="老博客备份归档" scheme="http://xcoder.in/categories/%E8%80%81%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
</feed>
