<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="好久没撸 TC 了，手都生了。前两天刚折腾好 LinuxMint + Cinnamon，顺便手贱把 TC 环境配好了。
　　随便进去扯了一套最新的 SRM 来搞，全跑完之后才发现原来这场比赛还处于 System Running 阶段。于是知道了比赛一结束还在 Running 的时候你就已经可以自己拉"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>TopCoder SRM 589 DIV 2 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/XadillaX">&#xe71f;</a><a target="_blank" href="https://www.zhihu.com/people/XadillaX">&#xe63f;</a><a target="_blank" href="https://weibo.com/XadillaX" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>TopCoder SRM 589 DIV 2</h1><span class="post-meta">写于<time> 2013 年 08 月 31 日 00 时 00 分</time><br>更新于<time> 2022 年 12 月 31 日 15 时 33 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">1.</span> <span class="toc-text">Summary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#250pt-Goose-Tattarrattat"><span class="toc-number">2.</span> <span class="toc-text">250pt - Goose Tattarrattat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#500pt-Gears"><span class="toc-number">3.</span> <span class="toc-text">500pt - Gears</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%BD%BF%E8%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">第一个齿轮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%BD%BF%E8%BD%AE"><span class="toc-number">3.2.</span> <span class="toc-text">第二个齿轮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E9%BD%BF%E8%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">之后的所有齿轮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1000pt-Flipping-Bits"><span class="toc-number">4.</span> <span class="toc-text">1000pt - Flipping Bits</span></a></li></ol></div><p>　　好久没撸 <strong>TC</strong> 了，手都生了。前两天刚折腾好 <strong>LinuxMint</strong> + <strong>Cinnamon</strong>，顺便手贱把 <strong>TC</strong> 环境配好了。</p>
<p>　　随便进去扯了一套最新的 <strong>SRM</strong> 来搞，全跑完之后才发现原来这场比赛还处于 <strong>System Running</strong> 阶段。于是知道了比赛一结束还在 <strong>Running</strong> 的时候你就已经可以自己拉出来做了。小绿名大家不要笑。</p>
<!-- 我是小小分割符 -->

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>　　这次 <strong>DIV 2</strong> 的难度一般，一道签到题加两道普通的 <strong>DP</strong>。</p>
<p>　　<a target="_blank" rel="noopener" href="https://github.com/XadillaX/xadillax-topcoder/tree/master/code/SRM589-DIV2">Code on GitHub</a>.</p>
<h2 id="250pt-Goose-Tattarrattat"><a href="#250pt-Goose-Tattarrattat" class="headerlink" title="250pt - Goose Tattarrattat"></a>250pt - Goose Tattarrattat</h2><p>题意很简单，就是给你一个字符串，问你最少改变多少字符让字符串所有字符都一样。</p>
<p>签到题，找最多的字符跟总长度一减就OK了。</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">#define SIZE(x) ((int)(x.size()))</span><br><span class="line">#define LENGTH(x) ((int)(x.length()))</span><br><span class="line">class GooseTattarrattatDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(string S);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int GooseTattarrattatDiv2::getmin(string S)</span><br><span class="line">&#123;</span><br><span class="line">    int maxsame = 0;</span><br><span class="line">    map&lt;char, int&gt; mp;</span><br><span class="line">    for(int i = 0; i &lt; LENGTH(S); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	mp[S[i]]++;</span><br><span class="line">    	maxsame = max(maxsame, mp[S[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return LENGTH(S) - maxsame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="500pt-Gears"><a href="#500pt-Gears" class="headerlink" title="500pt - Gears"></a>500pt - Gears</h2><p>有 <strong><em>N</em></strong> 个齿轮围成一圈，相邻两个齿轮要反方向转才能正常运转不卡到其它轮子。你要从中间拿掉几个齿轮（留空了就不影响其左边的左边的齿轮），问最少拿掉几个使得所有齿轮能正常转。</p>
<p>我们建两个二维 <strong><em>dp</em></strong> 数组，或者一个三维 <strong><em>dp</em></strong> 数组：</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp[i][0|1][0|1]</span><br></pre></td></tr></table></figure>

<p>第一维 <code>i</code> 代表当前是第 <code>i</code> 个齿轮。第二维若是 <code>0</code> 则表示这个齿轮拿走，若是 <code>1</code> 代表留下。第三维若是 <code>0</code> 则代表第一个齿轮拿走，<code>1</code> 代表第一个齿轮留下。整个数组的每个元素就代表该齿轮留下或者拿走且第一个齿轮是留下或者拿走的情况下的最少拿走齿轮数。</p>
<p>所以我们能得到几个状态转移方程：</p>
<blockquote>
<h3 id="第一个齿轮"><a href="#第一个齿轮" class="headerlink" title="第一个齿轮"></a>第一个齿轮</h3></blockquote>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp[i][0][0] = 1;</span><br><span class="line">dp[i][0][1] = INF;</span><br><span class="line">dp[i][1][1] = 0;</span><br><span class="line">dp[i][1][0] = INF;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="第二个齿轮"><a href="#第二个齿轮" class="headerlink" title="第二个齿轮"></a>第二个齿轮</h3><p>如果与第一个同向那么就有了一留一走或者两个都走的情况。否则就是四种情况都可以。</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">if(与第一个齿轮同向)</span><br><span class="line">&#123;</span><br><span class="line">    dp[1][0][1] = 1;</span><br><span class="line">    dp[1][1][0] = 1;</span><br><span class="line">    dp[1][0][0] = 2;</span><br><span class="line">    dp[1][1][1] = INF;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    dp[i][0][0] = 2;</span><br><span class="line">    dp[i][0][1] = 1;</span><br><span class="line">    dp[i][1][0] = 1;</span><br><span class="line">    dp[i][1][1] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="之后的所有齿轮"><a href="#之后的所有齿轮" class="headerlink" title="之后的所有齿轮"></a>之后的所有齿轮</h3><p>若该齿轮与前一个齿轮方向相同 ，那么该齿轮留下的时候，前一个齿轮必须得走，那么就是 <code>dp[i - 1][0][?]</code>;该齿轮走的时候，前一个齿轮可走可留，就是 <code>dp[i - 1][0|1][?] + 1</code> 的稍微小一点那个。</p>
<p>若方向不相同 ，那么就是该齿轮留下的时候，前一个齿轮也可以留下。</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">if(与前一个齿轮同向)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][1][0] = dp[i - 1][0][0];</span><br><span class="line">    dp[i][1][1] = dp[i - 1][0][1];</span><br><span class="line"></span><br><span class="line">    dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">    dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][0]) + 1;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    dp [i][1][0] = min(dp[i - 1][0][0], dp[i - 1][1][0]);</span><br><span class="line">    dp [i][1][1] = min(dp[i - 1][0][1], dp[i - 1][1][1]);</span><br><span class="line"></span><br><span class="line">    dp [i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">    dp [i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][1]) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后若最后一个齿轮与第一个齿轮同向，那么在 <code>dp[i - 1][0][0]</code>、<code>dp[i - 1][0][1]</code>、<code>dp[i - 1][1][0]</code> 中挑一个。若不同向，那么多了个 <code>dp[i - 1][1][1]</code> 这个选择。</p>
<p>下面就是代码了：</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">class GearsDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(string Directions);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int GearsDiv2::getmin(string Directions)</span><br><span class="line">&#123;</span><br><span class="line">    int dp[100][2][2];</span><br><span class="line">    for(int i = 0; i &lt; LENGTH(Directions); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0][0] = 1;</span><br><span class="line">            dp[i][0][1] = 10000000;</span><br><span class="line">            dp[i][1][1] = 0;</span><br><span class="line">            dp[i][1][0] = 10000000;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(Directions[i] == Directions[i - 1])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][0][1] = 1;</span><br><span class="line">                dp[i][1][0] = 1;</span><br><span class="line">                </span><br><span class="line">                dp[i][0][0] = 2;</span><br><span class="line">                dp[i][1][1] = 10000000;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][0][0] = 2;</span><br><span class="line">                dp[i][0][1] = 1;</span><br><span class="line">                dp[i][1][0] = 1;</span><br><span class="line">                dp[i][1][1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(Directions[i] == Directions[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][1][0] = dp[i - 1][0][0];</span><br><span class="line">            dp[i][1][1] = dp[i - 1][0][1];</span><br><span class="line">            </span><br><span class="line">            dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">            dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][0][1]) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][1][0] = min(dp[i - 1][0][0], dp[i - 1][1][0]);</span><br><span class="line">            dp[i][1][1] = min(dp[i - 1][0][1], dp[i - 1][1][1]);</span><br><span class="line">            </span><br><span class="line">            dp[i][0][0] = min(dp[i - 1][1][0], dp[i - 1][0][0]) + 1;</span><br><span class="line">            dp[i][0][1] = min(dp[i - 1][1][1], dp[i - 1][1][1]) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ans;</span><br><span class="line">    int mi = LENGTH(Directions) - 1;</span><br><span class="line">    if(Directions[mi] == Directions[0])</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(dp[mi][0][0], min(dp[mi][1][0], dp[mi][0][1]));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(min(dp[mi][0][0], dp[mi][1][1]), min(dp[mi][0][1], dp[mi][1][0]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1000pt-Flipping-Bits"><a href="#1000pt-Flipping-Bits" class="headerlink" title="1000pt - Flipping Bits"></a>1000pt - Flipping Bits</h2><p>给你一个 <strong>01串</strong> 与一个正整数 <strong><em>M</em></strong>。<strong>01串</strong> 有如下三种操作:</p>
<ul>
<li>随便反转一位（0 -&gt; 1, 1 -&gt; 0）。</li>
<li>将开头 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
<li>将末尾 <code>k * M</code> 位反转。k 可以是任何正整数。</li>
</ul>
<p>问最少需要几步将整个字符串变成都是 <code>1</code>。</p>
<p>这又是一个 <strong>DP</strong> 的题目。</p>
<p>我们先设有 <strong><em>G</em></strong> 组，一组 <strong><em>M</em></strong> 个 <code>01字符</code>。那么就能有</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][0|1]</span><br><span class="line">dp2[i][0|1]</span><br></pre></td></tr></table></figure>

<p>其中 <code>i</code> 代表第 <code>i</code> 组，第二维如果是 <code>0</code> 就代表这一组采用一位位反转的操作将这组全变成 <code>1</code>，如果是 <code>1</code> 则将整组全部反转再采用一位位反转的操作将这组全变成 <code>1</code> 。至于 <code>dp1</code> 和 <code>dp2</code> 则代表从头到尾和从尾到头。</p>
<p>由于只有 <code>0</code> 和 <code>1</code> 反转，那么一组反转两次就能还原原状——这是一个非常重要的性质。</p>
<p>如果某一组采用<strong>整组反转</strong>的操作，若前一组也是<strong>整组反转</strong>，那么就相当于操作次数不变，只是将前一组的反转范围延续到这一组；若前一组是<strong>非整组反转</strong>，那么就相当于从头到这一组反转之后，前面的所有组再反转回去——相当于是多了两次操作。于是就有了（先只拿 <code>dp1</code> 作为例子）：</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][1] = min(</span><br><span class="line">    dp[i - 1][0] + 这一组1的数量 + 2,</span><br><span class="line">    dp[i - 1][1] + 这一组1的数量 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果某一组采用<strong>非整组反转</strong>，那么操作次数就是前一组的<strong>整组反转</strong>或者<strong>非整组反转</strong>的操作次数加上这一组 <code>0</code> 的数量：</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">dp1[i][0] = min(</span><br><span class="line">    dp[i - 1][0] + 这一组0的数量,</span><br><span class="line">    dp[i - 1][0] + 这一组0的数量</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用上面的转移方程把正反向都求了一遍之后，我们就可以求总答案了，总答案就是我们枚举中间只有<strong>操作1</strong>的段的首尾，加上该中间段前部分的 <strong><em>dp</em></strong> 答案和其后部分的 <strong><em>dp</em></strong> 答案，取出最小值就是了。</p>
<figure class="highlight plaintext"><figcaption><span>cpp</span></figcaption><table><tr><td class="code"><pre><span class="line">class FlippingBitsDiv2 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getmin(vector &lt;string&gt; S, int M);</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    int group;</span><br><span class="line">    int tn1[2600], tnsum1[2600];</span><br><span class="line">    int tn2[2600], tnsum2[2600];</span><br><span class="line">    </span><br><span class="line">    int dp1[2600][2];</span><br><span class="line">    int dp2[2600][2];</span><br><span class="line">    </span><br><span class="line">    int calcsum(int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(l &gt; r) return 0;</span><br><span class="line">        int tot = tnsum1[r] - tnsum1[l - 1];</span><br><span class="line">        return tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int FlippingBitsDiv2::getmin(vector &lt;string&gt; S, int M)</span><br><span class="line">&#123;</span><br><span class="line">    str = &quot;&quot;;</span><br><span class="line">    for(int i = 0; i &lt; SIZE(S); i++) str += S[i];</span><br><span class="line">    group = LENGTH(str) / M;</span><br><span class="line">    ZERO(tn1);</span><br><span class="line">    ZERO(tn2);</span><br><span class="line">    </span><br><span class="line">    // init.</span><br><span class="line">    for(int i = 0; i &lt; group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int op = i * M;</span><br><span class="line">        int ed = op + M;</span><br><span class="line">        for(int j = op; j &lt; ed; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[j] == &#x27;0&#x27;) tn1[i]++, tn2[group - i - 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp1[i][0] = 100000;</span><br><span class="line">        dp1[i][1] = 100000;</span><br><span class="line">        dp2[i][0] = 100000;</span><br><span class="line">        dp2[i][1] = 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // tnsum</span><br><span class="line">    for(int i = 0; i &lt; group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0) tnsum1[0] = tn1[0], tnsum2[0] = tn2[0];</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tnsum1[i] = tnsum1[i - 1] + tn1[i];</span><br><span class="line">            tnsum2[i] = tnsum2[i - 1] + tn2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // dp.</span><br><span class="line">    for(int i = 0; i &lt;= group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i][0] = dp1[i][1] = dp2[i][0] = dp2[i][1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            // head -&gt; tail</span><br><span class="line">            dp1[i][0] = tn1[i - 1];</span><br><span class="line">            dp1[i][1] = 1 + (M - tn1[i - 1]);</span><br><span class="line">            </span><br><span class="line">            // tail -&gt; head</span><br><span class="line">            dp2[i][0] = tn2[i - 1];</span><br><span class="line">            dp2[i][1] = 1 + (M - tn2[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // head -&gt; tail</span><br><span class="line">            dp1[i][0] = min(</span><br><span class="line">                dp1[i - 1][0] + tn1[i - 1],</span><br><span class="line">                dp1[i - 1][1] + tn1[i - 1]</span><br><span class="line">            );</span><br><span class="line">            dp1[i][1] = min(</span><br><span class="line">                dp1[i - 1][0] + 2 + (M - tn1[i - 1]),</span><br><span class="line">                dp1[i - 1][1] + (M - tn1[i - 1])</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            // tail -&gt; head</span><br><span class="line">            dp2[i][0] = min(</span><br><span class="line">                dp2[i - 1][0] + tn2[i - 1],</span><br><span class="line">                dp2[i - 1][1] + tn2[i - 1]</span><br><span class="line">            );</span><br><span class="line">            dp2[i][1] = min(</span><br><span class="line">                dp2[i - 1][0] + 2 + (M - tn2[i - 1]),</span><br><span class="line">                dp2[i - 1][1] + (M - tn2[i - 1])</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minans = 100000000;</span><br><span class="line">    for(int i = 0; i &lt;= group; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0; j &lt;= group - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int zzl = i;</span><br><span class="line">            int zzr = group - j - 1;</span><br><span class="line">            </span><br><span class="line">            minans = min(minans,</span><br><span class="line">                min(dp1[i][0], dp1[i][1]) +</span><br><span class="line">                min(dp2[j][0], dp2[j][1]) +</span><br><span class="line">                calcsum(zzl, zzr)</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return minans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2013/08/31/srm-589-div2/";</script><script>var DISQUS_IDENTIFIER = "2013/08/31/srm-589-div2/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2022<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a target="_blank" rel="noopener" href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $(block).find("td.gutter").remove();
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        if($(this).parent().is("article")) {
            $(this).wrap("<p style='text-align: center;'></p>");
        } else {
            $(this).parent().css("text-align", "center");
        }
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>