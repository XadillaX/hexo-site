<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="背景最近有在做 RocketMQ 社区的 Node.js SDK，是基于 RocketMQ 的 C SDK 封装的 Addon，而 C 的 SDK 则是基于 C++ SDK 进行的封装。
然而，却出现了一个诡异的问题，就是当我在消费信息的时候，发现在 macOS 下得到的消息居然是乱码，也就是说 L"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>一次 macOS 下 C++ 的 STL 踩坑记录 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/XadillaX">&#xe71f;</a><a target="_blank" href="https://www.zhihu.com/people/XadillaX">&#xe63f;</a><a target="_blank" href="https://weibo.com/XadillaX" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>一次 macOS 下 C++ 的 STL 踩坑记录</h1><span class="post-meta">写于<time> 2018 年 12 月 07 日 18 时 51 分</time><br>更新于<time> 2022 年 12 月 31 日 15 时 33 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">重现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ-C-SDK-%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B"><span class="toc-number">3.</span> <span class="toc-text">RocketMQ C++ SDK 源码查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">柳暗花明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E4%B9%B1%E7%A0%81-Bug"><span class="toc-number">5.</span> <span class="toc-text">回到乱码 Bug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%B0%8F-Demo-%E9%AA%8C%E8%AF%81"><span class="toc-number">6.</span> <span class="toc-text">更小 Demo 验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol></div><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有在做 RocketMQ 社区的 Node.js SDK，是基于 RocketMQ 的 C SDK 封装的 Addon，而 C 的 SDK 则是基于 C++ SDK 进行的封装。</p>
<p>然而，却出现了一个诡异的问题，就是当我在消费信息的时候，发现在 macOS 下得到的消息居然是乱码，也就是说 Linux 下居然是正常的。</p>
<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><blockquote>
<p>首先我们要知道一个函数是 <code>const char* GetMessageTopic(CMessageExt* msg)</code>，用于从一个 <code>msg</code> 指针中获取它的 Topic 信息。</p>
</blockquote>
<p>乱码的代码可以有好几个版本，是我在排查的时候做的各种改变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往 JavaScript 的 `object` 对象中插入键名为 `topic` 的值为 `GetMessageTopic`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法：乱码</span></span><br><span class="line">Nan::<span class="built_in">Set</span>(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::<span class="built_in">New</span>(<span class="string">&quot;topic&quot;</span>).<span class="built_in">ToLocalChecked</span>(),</span><br><span class="line">  Nan::<span class="built_in">New</span>(<span class="built_in">GetMessageTopic</span>(msg)).<span class="built_in">ToLocalChecked</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法：乱码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* temp = <span class="built_in">GetMessageTopic</span>(msg);</span><br><span class="line">Nan::<span class="built_in">Set</span>(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::<span class="built_in">New</span>(<span class="string">&quot;topic&quot;</span>).<span class="built_in">ToLocalChecked</span>(),</span><br><span class="line">  Nan::<span class="built_in">New</span>(temp).<span class="built_in">ToLocalChecked</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法：乱码</span></span><br><span class="line"><span class="function">string <span class="title">GetMessageColumn</span><span class="params">(CMessageExt* msg, <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* orig = <span class="built_in">GetMessageTopic</span>(msg);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(orig);</span><br><span class="line">  <span class="type">char</span> temp[len + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp, orig, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* temp = <span class="built_in">GetMessageColumn</span>(msg, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">Nan::<span class="built_in">Set</span>(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::<span class="built_in">New</span>(<span class="string">&quot;topic&quot;</span>).<span class="built_in">ToLocalChecked</span>(),</span><br><span class="line">  Nan::<span class="built_in">New</span>(temp).<span class="built_in">ToLocalChecked</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>并且很诡异的是，当我在调试第三种写法的时候，我发现在 <code>const char* orig = GetMessageTopic(msg);</code> 这一部的时候 <code>orig</code> 的值是正确的。而一步步单步运行下去，一直到 <code>memcpy</code> 执行结束的时候，<code>orig</code> 内存块里面的字符串居然被莫名其妙修改成乱码了。</p>
<p>参考如下：</p>
<p><img src="https://s1.ax1x.com/2018/12/07/F3KN59.gif"></p>
<p>这就不能忍了。</p>
<p>当我锲而不舍的时候，发现当我改成这样之后，返回的值就对了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">GetMessageColumn</span><span class="params">(CMessageExt* msg, <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* orig = <span class="built_in">GetMessageTopic</span>(msg);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(orig);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> temp[len + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[i] = orig[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做一些其它操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* temp = <span class="built_in">GetMessageColumn</span>(msg, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">Nan::<span class="built_in">Set</span>(</span><br><span class="line">  object, <span class="comment">// v8 中的 JavaScript 层对象</span></span><br><span class="line">  Nan::<span class="built_in">New</span>(<span class="string">&quot;topic&quot;</span>).<span class="built_in">ToLocalChecked</span>(),</span><br><span class="line">  Nan::<span class="built_in">New</span>(temp).<span class="built_in">ToLocalChecked</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但问题在于，在“其它操作”中，<code>orig</code> 还是会变成一堆乱码。当前返回能正确的原因是因为我在它变成乱码之前，用可以“不触发”变成乱码的操作先把 <code>orig</code> 的字符串给赋值到另一个字符数组中，最后返回那个新的数组。</p>
<p>问题看似解决了，但是这种诡异、危险的行为始终是我心中的一颗丧门钉，不处理总之是慌的。</p>
<h2 id="RocketMQ-C-SDK-源码查看"><a href="#RocketMQ-C-SDK-源码查看" class="headerlink" title="RocketMQ C++ SDK 源码查看"></a>RocketMQ C++ SDK 源码查看</h2><p>在排查的过程中，我去看了 RocketMQ 的 C++ 和 C SDK 的实现，我把重要的内容摘出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MQMessage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string::string <span class="title">getTopic</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_topic;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_topic;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MQMessageExt 是继承自 MQMessage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetMessageTopic</span><span class="params">(CMessageExt *msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ((MQMessageExt *) msg)-&gt;<span class="built_in">getTopic</span>().<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读一下这段代码，在 <code>GetMessageTopic</code> 中，先得到了一个 <code>getTopic</code> 的 STL 字符串，然后调用它的 <code>c_str()</code> 返回 <code>const char*</code>。一切看起来是那么美好，没有问题。</p>
<p>但我后来在多次调试的时候发现，对于同一个 <code>msg</code> 进行调用 <code>GetMessageTopic</code> 得到的指针居然不一样！我是不是发现了什么新大陆？</p>
<p>诚然，<code>msg-&gt;getTopic()</code> 返回了一个字符串对象，并且是通过拷贝构造从 <code>m_topic</code> 那边来的。依稀记得大学时候看的 STL 源码解析，根据 STL 字符串的 Copy-On-Write 来说，我没做任何改变的情况下，它们不应该是同源的吗？</p>
<p><strong>事实证明，我当时的这个“想当然”就差点让我查不出问题来了。</strong></p>
<h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>在我捉鸡了好久之后一直毫无头绪之后，在参考资料 1 中获得了灵感，我开始打开脑洞（请原谅我这个坑还找了很久，毕竟我主手武器还是 Node.js），会不会现在的 String 都不是 Copy-On-Write 了？但是 Linux 下又是正常的哇。</p>
<p>后来我在网上找是不是有人跟我遇到一样的问题，最后还是找到了端倪。</p>
<blockquote>
<p>不同的 stl 标准库实现不同， 比如 CentOS 6.5 默认的 stl::string 实现就是 『Copy-On-Write』， 而 macOS（10.10.5）实现就是『Eager-Copy』。</p>
</blockquote>
<p>说得白话一点就是，不同库实现不一样。Linux 用的是 libstdc++，而 macOS 则是 libc++。而 libc++ 的 String 实现中，是不写时拷贝的，一开始赋值就采用深拷贝。也就是说就算是两个一样的字符串，在不同的两个 String 对象中也不会是同源。</p>
<p>其实深挖的话内容还有很多的，例如《Effective STL》中的第 15 条也有提及 String 实现有多样性；以及大多数的现代编译器中 String 也都有了 Short String Optimization 的特性；等等。</p>
<h2 id="回到乱码-Bug"><a href="#回到乱码-Bug" class="headerlink" title="回到乱码 Bug"></a>回到乱码 Bug</h2><p>得到了上面的结论之后，这个 Bug 的原因就知道了。</p>
<p><code>((MQMessageExt *) msg)-&gt;getTopic()</code> 得到了一个函数中的栈内存字符串变量。</p>
<ul>
<li>在 Linux 中，就算是栈内存变量，但是它的 <code>c_str()</code> 还是源字符串指向的指针，所以函数声明周期结束，这个栈内存中的字符串被释放，<code>c_str()</code> 指向的内存还坚挺着；</li>
<li>在 macOS 下，由于字符串是栈内存分配的，字符串又是深拷贝，所以 <code>c_str()</code> 的生命周期是跟着字符串本身来的，一旦函数调用结束，该字符串就被释放了，相应地 <code>c_str()</code> 对应内存中的内容也被释放。</li>
</ul>
<p>综上所述，在 macOS 下，我通过 <code>GetMessageTopic()</code> 得到的内容其实是一个已经被释放内存的地址。虽然通过 <code>for</code> 可以趁它的内存块被复制之前赶紧抢救出来，但是这种操作一块已经被释放的内存行为总归是危险的，因为它的内存块随时可能被覆盖，这也就是之前乱码的本质了。</p>
<h2 id="更小-Demo-验证"><a href="#更小-Demo-验证" class="headerlink" title="更小 Demo 验证"></a>更小 Demo 验证</h2><p>对于 STL 在这两个平台上不同的行为，我也抽出了一个最小化的 Demo，各位看官可以在自己的电脑上试试看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%.8X 0x%.8X\n&quot;</span>, a.<span class="built_in">c_str</span>(), <span class="built_in">func1</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在 Linux 下（如 Ubuntu 14.04）运行会输出两个一样的指针地址，而在 macOS 下执行则输出的是两个不一样的指针。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在语言、库的使用中，我们不能去使用一个没有明确在文档中定义的行为的“特性”。例如文档中没跟你说它用的是 Copy-On-Write 技术，也就说明它可能在未来任何时候不通知你就去改掉，而你也不容易去发现它。你就去用已经定义好的行为即可，就是说 <code>c_str()</code> 返回的是字符串的一个真实内容，我们就要认为它是跟随着 String 的生命周期，哪怕它其中有黑科技。</p>
<p>毕竟，下面这个才是 C++ reference 中提到的定义，我们不能臆想人家一定是 COW 行为：</p>
<blockquote>
<p>Returns a pointer to a null-terminated character array with data equivalent to those stored in the string.</p>
<p>The pointer is such that the range <code>[c_str(); c_str() + size()]</code> is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</p>
</blockquote>
<p>这一样可以引申到 JavaScript 上来，例如较早的 ECMAScript 262 第三版对于一个对象的定义中，键名在对象中的顺序也是未定义的，当时就不能讨巧地看哪个浏览器是怎么样一个顺序来进行输出，毕竟对于未定义的行为，浏览器随时改了你也不能声讨它什么。</p>
<p>好久没写文了，码字能力变弱了。</p>
<p>以上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27627413/why-does-calling-c-str-on-a-function-that-returns-a-string-not-work/50490703#50490703">Why does calling c_str() on a function that returns a string not work?</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://libcxx.llvm.org/#why">Why a new C++ Standard Library for C++11?</a>》</li>
<li>《Effective STL》第 15 条：注意 String 实现的多样性</li>
<li>《<a target="_blank" rel="noopener" href="https://yanyiwu.com/work/2016/01/30/copy-on-write-stl.html">C++ 之 stl::string 写时拷贝导致的问题</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cthon/p/9181979.html">C++ 再探 String 之eager-copy、COW 和 SSO 方案</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10e6564536ed">C++ Short String Optimization stackoverflow 回答集锦以及我的思考</a>》</li>
</ol>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2018/12/07/a-macos-stl-keng/";</script><script>var DISQUS_IDENTIFIER = "2018/12/07/a-macos-stl-keng/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2022<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a target="_blank" rel="noopener" href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $(block).find("td.gutter").remove();
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        if($(this).parent().is("article")) {
            $(this).wrap("<p style='text-align: center;'></p>");
        } else {
            $(this).parent().css("text-align", "center");
        }
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>