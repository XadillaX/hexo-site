

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="小鳥遊死月">
    
    <meta name="description" content="N久之前的一个坑——用 Node.js 来重构 NBUT 的 Online Judge，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧
　　总之我们现在要做的其实简而言之就是——用C/C++来实现 Node.js 的模块。
准备工作
　　工欲善其事，必先耍流氓利其">
    
    

    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>让Node.js和C++一起搞基 —— 1 | 艾克斯の編碼者 · 一個偽宅级别的蒟蒻碼畜。</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script> 
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://xcoder.in/" title="艾克斯の編碼者">艾克斯の編碼者</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                <p class="navbar-text pull-right">一個偽宅级别的蒟蒻碼畜。</p>

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/">首页</a></li>
                    
                    <li id="nav-archives"><a href="/archives">归档</a></li>
                    
                    <li id="nav-tags"><a href="/tags">标签</a></li>
                    
                    <li id="nav-categories"><a href="/categories">分类</a></li>
                    
                    <li id="nav-curriculumvitae"><a href="/curriculumvitae">关于</a></li>
                    
                    <li id="nav-links"><a href="/links">链接</a></li>
                    
                    
                    <li><a href="https://github.com/XadillaX" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/images/background/";
    var backArray = [ "1.jpeg", "2.jpeg", "3.jpeg", "4.jpeg", "5.jpeg", "6.jpeg", "img/iPad_Photo_20140328181354FGPM.JPG", "img/iPad_Photo_20140328181218SLUY.JPG", "img/iPad_Photo_20140328181239ME9E.JPG", "img/iPad_Photo_20140328175718BF7T.JPG", "likeit/465_16170978_35afb62980c6d1a.jpg", "likeit/wallpaper-86487.jpg", "likeit/wallpaper-651939.jpg", "likeit/wallpaper-648634.jpg", "likeit/wallpaper-657798.jpg", "likeit/wallpaper-1479749.jpg", "likeit/wallpaper-1961179.jpg", "likeit/wallpaper-1947874.jpg", "likeit/wallpaper-2055407.jpg", "likeit/wallpaper-2060090.png", "likeit/wallpaper-2142870.jpg", "likeit/wallpaper-2078006.jpg", "likeit/wallpaper-2127699.jpg", "likeit/wallpaper-2211066.jpg", "likeit/wallpaper-2588686.jpg", "likeit/wallpaper-2639031.jpg", "likeit/wallpaper-2430341.jpg", "likeit/wallpaper-2294985.jpg", "likeit/wallpaper-2705897.jpg", "likeit/wallpaper-2063319.jpg", "likeit/wallpaper-2060101.jpg", "likeit/wallpaper-1970791.jpg", "img/iPad_Photo_20140328174508AZ11.JPG", "img/new/iPad_Photo_201403281903078UKK.JPG", "img/iPad_Photo_20140328175639RA5N.JPG", "img/iPad_Photo_20140328175820DYAC.JPG", "img/iPad_Photo_201403281806230195.JPG", "img/new/iPad_Photo_201403281919292STQ.JPG", "img/new/iPad_Photo_20140328190703781D.JPG", "flandre/p541758_2girls barefoot bat_wings bed blonde_hair blue_hair feet fetal_position flandre_scarlet flat_chest hat nude red_eyes ~.jpg", "flandre/p575023_blonde_hair flandre_scarlet hat horumon multiple_persona ponytail red_eyes side_ponytail touhou wings.jpg", "flandre/p569665_2girls barefoot blonde_hair blue_hair flandre_scarlet hat highres kinoko red_eyes remilia_scarlet siblings sisters to~.jpg", "flandre/p566082_blonde_hair flandre_scarlet hat mitsuki_(artist) ponytail red_eyes short_hair side_ponytail touhou wings.jpg", "flandre/p548132_2girls bat_wings blonde_hair blue_eyes blue_hair flandre_scarlet hat kaedena_akino mask moon red_eyes red_moon remili~.jpg", "flandre/p552906_flandre_scarlet gusutafu hong_meiling izayoi_sakuya koakuma patchouli_knowledge remilia_scarlet swimsuit touhou.jpg", "flandre/p551605_flandre_scarlet kona-ta touhou.jpg", "flandre/p551983_asuka_roze danmaku flandre_scarlet remilia_scarlet touhou.jpg", "likeit/465_16170978_2b89f5997bcff44.jpg", "likeit/wallpaper-616321.jpg", "likeit/wallpaper-343717.jpg", "likeit/wallpaper-1595016.jpg", "likeit/wallpaper-1952396.jpg", "likeit/wallpaper-2060096.jpg", "likeit/wallpaper-2315398.jpg", "likeit/wallpaper-2674370.jpg", "likeit/wallpaper-2838683.jpg", "likeit/wallpaper-2564028.png", "likeit/wallpaper-1382762.jpg", "likeit/wallpaper-1128042.jpg", "likeit/wallpaper-1396368.jpg", "likeit/wallpaper-1403569.png", "likeit/wallpaper-1593633.jpg", "likeit/wallpaper-1395408.jpg", "flandre/p539131_blonde_hair flandre_scarlet hat plastic_eraser red_eyes scenery short_hair solo touhou.jpg", "flandre/p555228_flandre_scarlet hong_meiling izayoi_sakuya patchouli_knowledge remilia_scarlet shomon swimsuit touhou.jpg", "flandre/p556145_book flandre_scarlet flower hairband hakurei_reimu hat hitoto hong_meiling izayoi_sakuya kirisame_marisa koakuma patc~.jpg", "flandre/p561220_arikichi_gen blonde_hair blue_eyes blue_hair braid flandre_scarlet izayoi_sakuya ponytail red_eyes remilia_scarlet sh~.jpg", "flandre/p541363_blonde_hair flandre_scarlet hat laevatein magic_circle poncho_(pixiv) red_eyes side_ponytail touhou wings.jpg",  ];
    //console.log(backArray);
        
    $(function() {
        // page-id...
        var pageId = "2014/04/02/nodejs-cpp-addons-1/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>
    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>让Node.js和C++一起搞基 —— 1</h1>
        
        <div class="time-info">
发表于:<time datetime="2014-04-01T16:53:22.000Z" itemprop="datePublished">2014年04月02日</time>,
更新于:<time datetime="2014-07-30T03:07:18.000Z" itemprop="dateModified">2014年07月30日</time>,
By <a href="http://xcoder.in/" title="小鳥遊死月">小鳥遊死月</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">大纲</strong>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node-gyp"><span class="toc-number">1.1.</span> <span class="toc-text">node-gyp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python"><span class="toc-number">1.2.</span> <span class="toc-text">Python</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译环境"><span class="toc-number">1.3.</span> <span class="toc-text">编译环境</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#入门"><span class="toc-number">2.</span> <span class="toc-text">入门</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello_World"><span class="toc-number">2.1.</span> <span class="toc-text">Hello World</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要函数"><span class="toc-number">2.1.1.</span> <span class="toc-text">主要函数</span></a></li><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Handle&lt;Value&gt;"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Handle&lt;Value&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Arguments"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Arguments</span></a></li></ol><li class="toc-item toc-level-4"><a class="toc-link" href="#添砖加瓦"><span class="toc-number">2.1.2.</span> <span class="toc-text">添砖加瓦</span></a></li><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HandleScope"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">HandleScope</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String::New"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">String::New</span></a></li></ol><li class="toc-item toc-level-4"><a class="toc-link" href="#导出对象"><span class="toc-number">2.1.3.</span> <span class="toc-text">导出对象</span></a></li><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化函数"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">初始化函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#真·导出"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">真·导出</span></a></li></ol></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#编译_(๑•́_₃_•̀๑)"><span class="toc-number">2.2.</span> <span class="toc-text">编译 (๑•́ ₃ •̀๑)</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#configure"><span class="toc-number">2.2.1.</span> <span class="toc-text">configure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build"><span class="toc-number">2.2.2.</span> <span class="toc-text">build</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#搞基吧！Node_ヽ(✿ﾟ▽ﾟ)ノ_C++"><span class="toc-number">2.3.</span> <span class="toc-text">搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#洗洗睡吧，下节更深入"><span class="toc-number">3.</span> <span class="toc-text">洗洗睡吧，下节更深入</span></a></li></ol>
            </div>
            
            <p>N久之前的一个坑——用 <strong>Node.js</strong> 来重构 NBUT 的 <strong>Online Judge</strong>，包括评测端也得重构一遍。（至于什么时候完成大家就不要关心了，(／‵Д′)／~ ╧╧</p>
<p>　　总之我们现在要做的其实简而言之就是——用C/C++来实现 <strong>Node.js</strong> 的模块。</p>
<h2 id="准备工作">准备工作</h2>
<p>　　工欲善其事，必先<del>耍流氓</del>利其器。</p>
<h3 id="node-gyp">node-gyp</h3>
<p>　　首先你需要一个 <code>node-gyp</code> 模块。</p>
<p>　　在任意角落，执行：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install node<span class="attribute">-gyp</span> <span class="attribute">-g</span>
</pre></td></tr></table></figure>


<p>　　在进行一系列的 <code>blahblah</code> 之后，你就安装好了。</p>
<h3 id="Python">Python</h3>
<p>　　然后你需要有个 <code>python</code> 环境。</p>
<p>　　自己去<a href="http://python.org/" target="_blank">官网</a>搞一个来。</p>
<blockquote>
<p><strong>注意：</strong> 根据 <code>node-gyp</code> 的<a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">GitHub</a>显示，请务必保证你的 <code>python</code> 版本介于 <code>2.5.0</code> 和 <code>3.0.0</code> 之间。</p>
</blockquote>
<h3 id="编译环境">编译环境</h3>
<p>　　嘛嘛，我就偷懒点不细写了，还请自己移步到 <a href="https://github.com/TooTallNate/node-gyp#installation" target="_blank">node-gyp</a> 去看编译器的需求。并且倒腾好。</p>
<h2 id="入门">入门</h2>
<p>　　我就拿<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官网的入门 Hello World</a>说事儿了。</p>
<h3 id="Hello_World">Hello World</h3>
<p>　　请准备一个 <code>C++</code> 文件，比如就叫 <del>sb.cc</del> hello.cc。</p>
<p>　　然后我们一步步来，先往里面搞出头文件和定义好命名空间：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;node.h&gt;</span>
<span class="preprocessor">#include &lt;v8.h&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> v8;
</pre></td></tr></table></figure>


<h4 id="主要函数">主要函数</h4>
<p>　　接下去我们写一个函数，其返回值是 <code>Handle&lt;Value&gt;</code>。</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(const Arguments&amp; args)
{
    //<span class="keyword">...</span> 嗷嗷待写
}
</pre></td></tr></table></figure>


<p>　　然后我来粗粗解析一下这些东西：</p>
<h5 id="Handle&lt;Value&gt;">Handle&lt;Value&gt;</h5>
<p>　　做人要有节操，我事先申明我是从<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>(<a href="http://cnodejs.org/user/fool" target="_blank">@fool</a>)参考的。</p>
<blockquote>
<p>V8 里使用 Handle 类型来托管 JavaScript 对象，与 C++ 的 std::sharedpointer 类似，Handle 类型间的赋值均是直接传递对象引用，但不同的是，V8 使用自己的 GC 来管理对象生命周期，而不是智能指针常用的引用计数。</p>
<p>JavaScript 类型在 C++ 中均有对应的自定义类型，如 String 、 Integer 、 Object 、 Date 、 Array 等，严格遵守在 JavaScript 中的继承关系。 C++ 中使用这些类型时，必须使用 Handle 托管，以使用 GC 来管理它们的生命周期，而不使用原生栈和堆。</p>
</blockquote>
<p>　　而这个所谓的 <strong>Value</strong> ，从 V8 引擎的头文件 <a href="http://code.google.com/p/v8/source/browse/trunk/include/v8.h#1417" target="_blank">v8.h</a> 中的各种继承关系中可以看出来，其实就是 JavaScript 中各种对象的基类。</p>
<p>　　在了解了这件事之后，我们大致能明白上面那段函数的申明的意思就是说，我们写一个 <code>Hello</code> 函数，其返回的是一个不定类型的值。</p>
<blockquote>
<p><strong>注意：</strong> 我们只能返回特定的类型，即在 Handle 托管下的 String 啊 Integer 啊等等等等。</p>
</blockquote>
<h5 id="Arguments">Arguments</h5>
<p>　　这个就是传入这个函数的参数了。我们都知道在 <code>Node.js</code> 中，参数个数是乱来的。而这些参数传进去到 <code>C++</code> 中的时候，就转变成了这个 <code>Arguments</code> 类型的对象了。</p>
<p>　　具体的用法我们在后面再说，在这里只需要明白这个是个什么东西就好。（为毛要卖关子？因为 <code>Node.js</code> 官方文档中的<a href="https://github.com/rvagg/node-addon-examples" target="_blank">例子</a>就是分开来讲的，我现在只是讲第一个 <code>Hello World</code> 的例子而已( ´థ౪థ）σ</p>
<h4 id="添砖加瓦">添砖加瓦</h4>
<p>　　接下去我们就开始添砖加瓦了。就最简单的两句话：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Handle&lt;Value&gt; Hello(<span class="keyword">const</span> Arguments&amp; args)
{
    HandleScope <span class="keyword">scope</span>;
    <span class="keyword">return</span> <span class="keyword">scope</span>.Close(String::New(<span class="string">"world"</span>));
}
</pre></td></tr></table></figure>


<p>　　这两句话是什么意思呢？大致的意思就是返回一个 <code>Node.js</code> 中的字符串 <code>&quot;world&quot;</code>。</p>
<h5 id="HandleScope">HandleScope</h5>
<p>　　同参考自<a href="http://cnodejs.org/topic/4f16442ccae1f4aa270010c5" target="_blank">这里</a>。</p>
<blockquote>
<p>Handle 的生命周期和 C++ 智能指针不同，并不是在 C++ 语义的 scope 内生存（即{} 包围的部分），而需要通过 HandleScope 手动指定。HandleScope 只能分配在栈上，HandleScope 对象声明后，其后建立的 Handle 都由 HandleScope 来管理生命周期，HandleScope 对象析构后，其管理的 Handle 将由 GC 判断是否回收。</p>
</blockquote>
<p>　　所以呢，我们得在需要管理他的生命周期的时候申明这个 <code>Scope</code> 。好的，那么为什么我们的代码不这么写呢？</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">Handle</span><span class="subst">&lt;</span>Value<span class="subst">&gt;</span> Hello(const Arguments<span class="subst">&amp;</span> args)
{
    HandleScope scope;
    <span class="keyword">return</span> <span class="built_in">String</span><span class="tag">::New</span>(<span class="string">"world"</span>);
}
</pre></td></tr></table></figure>


<p>　　因为当函数返回时，<code>scope</code> 会被析构，其管理的Handle也都将被回收，所以这个 <code>String</code> 就会变得没有意义。</p>
<p>　　所以呢 V8 就想出了个神奇的点子——<code>HandleScope::Close(Handle&lt;T&gt; Value)</code> 函数！这个函数的用处就是关闭这个 Scope 并且把里面的参数转交给上一个 Scope 管理，也就是进入这个函数前的 Scope。</p>
<p>　　于是就有了我们之前的代码 <code>scope.Close(String::New(&quot;world&quot;));</code>。</p>
<h5 id="String::New">String::New</h5>
<p>　　这个 <code>String</code> 类所对应的就是 <code>Node.js</code> 中原生的字符串类。继承自 <code>Value</code> 类。与此类似，还有：</p>
<ul>
<li>Array</li>
<li>Integer</li>
<li>Boolean</li>
<li>Object</li>
<li>Date</li>
<li>Number</li>
<li>Function</li>
<li>…</li>
</ul>
<p>　　这些东西有些是继承自 <code>Value</code>，有些是二次继承。我们这里就不多做研究，自己可以看看 V8 的代码（至少是头文件）研究研究或者看看这个<a href="http://bespin.cz/~ondras/html/classv8_1_1Value.html#a70d4afaccc7903e6a01f40a46ad04188" target="_blank">手册</a>。</p>
<p>　　而这个 <code>New</code> 呢？<a href="http://bespin.cz/~ondras/html/classv8_1_1String.html" target="_blank">这里</a>可以看的。就是新建一个 <code>String</code> 对象。</p>
<p>　　至此，这个主要函数我们就解析完毕了。</p>
<h4 id="导出对象">导出对象</h4>
<p>　　我们来温习一下，如果是在 <code>Node.js</code> 里面写的话，我们怎么导出函数或者对象什么的呢？</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>exports.hello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
</pre></td></tr></table></figure>


<p>　　那么，在 <code>C++</code> 中我们该如何做到这一步呢？</p>
<h5 id="初始化函数">初始化函数</h5>
<p>　　首先，我们写个初始化函数：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>void init(Handle&lt;Object&gt; exports)
{
    //<span class="keyword">...</span> 嗷嗷待写你妹啊！<span class="comment">#ﾟÅﾟ）⊂彡☆))ﾟДﾟ)･∵</span>
}
</pre></td></tr></table></figure>


<p>　　这是龟腚！函数名什么的无所谓，但是传入的参数一定是一个 <code>Handle&amp;lt;Object&gt;</code>，代表我们下面将要在这货上导出东西。</p>
<p>　　然后，我们就在这里面写上导出的东西了：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="literal">void</span> init(<span class="keyword">Handle</span><span class="subst">&lt;</span>Object<span class="subst">&gt;</span> exports)
{
    exports<span class="subst">-&gt;</span><span class="built_in">Set</span>(<span class="built_in">String</span><span class="tag">::NewSymbol</span>(<span class="string">"hello"</span>),
        FunctionTemplate<span class="tag">::New</span>(Hello)<span class="subst">-&gt;</span>GetFunction());
}
</pre></td></tr></table></figure>


<p>　　大致的意思就是说，为这个 <code>exports</code> 对象添加一个字段叫 <code>hello</code>，所对应的东西是一个<a href="http://bespin.cz/~ondras/html/classv8_1_1FunctionTemplate.html" target="_blank">函数</a>，而这个函数就是我们亲爱的 <code>Hello</code> 函数了。</p>
<p>　　用伪代码写直白点就是：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="reserved">void</span> init(Handle&lt;Object&gt; <span class="built_in">exports</span>)
{
    <span class="built_in">exports</span>.Set(<span class="string">"hello"</span>, <span class="reserved">function</span> hello);
}
</pre></td></tr></table></figure>


<p>　　大功告成！</p>
<p>　　（大功告成你妹啊！闭嘴( ‘д‘⊂彡☆))Д´)</p>
<h5 id="真·导出">真·导出</h5>
<p>　　这才是最后一步，我们最后要申明，这个就是导出的入口，所以我们在代码的末尾加上这一行：</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">NODE_MODULE(hello, init)</span>
</pre></td></tr></table></figure>


<p>　　纳了个尼？！这又是什么东西？</p>
<p>　　别着急，这个 <code>NODE_MODULE</code> 是一个宏，它的意思呢就是说我们采用 <code>init</code> 这个初始化函数来把要导出的东西导出到 <code>hello</code> 中。那么这个 <code>hello</code> 哪来呢？</p>
<p>　　<strong>它来自文件名！</strong>对，没错，它来自文件名。你并不需要事先申明它，你也不必担心不能用，总之你的这个最终编译好的二进制文件名叫什么，这里的 <code>hello</code> 你就填什么，当然要除去后缀名了。</p>
<p>　　详见<a href="http://nodejs.org/api/addons.html#addons_hello_world" target="_blank">官方文档</a>。</p>
<blockquote>
<p>Note that all Node addons must export an initialization function:</p>
<figure class="highlight"><figcaption><span>cpp</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> Initialize (Handle&lt;<span class="built_in">Object</span>&gt; exports);
NODE_MODULE(module_name, Initialize)
</pre></td></tr></table></figure>

<p>There is no semi-colon after NODE_MODULE as it’s not a function (see node.h).</p>
<p>The module_name needs to match the filename of the final binary (minus the .node suffix).</p>
</blockquote>
<h3 id="编译_(๑•́_₃_•̀๑)">编译 (๑•́ ₃ •̀๑)</h3>
<p>　　来吧，让我们一起编译吧！</p>
<p>　　我们再新建一个类似于 <code>Makefile</code> 的归档文件吧——<code>binding.gyp</code>。</p>
<p>　　并且在里面添加这样的<a href="https://github.com/TooTallNate/node-gyp#the-bindinggyp-file" target="_blank">代码</a>：</p>
<figure class="highlight"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"hello"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"hello.cc"</span> ]
    </span>}
  ]
</span>}
</pre></td></tr></table></figure>


<p>　　为什么这么写呢？可以参考 <code>node-gyp</code> 的<a href="http://code.google.com/p/gyp/wiki/GypUserDocumentation#Skeleton_of_a_typical_Chromium_.gyp_file" target="_blank">官方文档</a>。</p>
<h4 id="configure">configure</h4>
<p>　　在文件搞好之后，我们要在这个目录下面执行这个命令了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp configure
</pre></td></tr></table></figure>


<p>　　如果一切正常的话，应该会生成一个 <code>build</code> 的目录，然后里面有相关文件，也许是 <strong>M$ Visual Studio</strong> 的 <code>vcxproj</code> 文件等，也许是 <code>Makefile</code> ，视平台而定。</p>
<h4 id="build">build</h4>
<p>　　<code>Makefile</code> 也生成好之后，我们就开始构造编译了：</p>
<figure class="highlight"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>node-gyp build
</pre></td></tr></table></figure>


<p>　　等到一切编译完成，才算是真正的大功告成了！不信你去看看 <code>build/Release</code> 目录，下面是不是有一个 <code>hello.node</code> 文件了？没错，这个就是 C++ 等下要给 Node.js 捡的肥皂！</p>
<h3 id="搞基吧！Node_ヽ(✿ﾟ▽ﾟ)ノ_C++">搞基吧！Node ヽ(✿ﾟ▽ﾟ)ノ C++</h3>
<p>　　我们在刚才那个目录下新建一个文件 <code>jianfeizao.js</code>：</p>
<figure class="highlight"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="reserved">var</span> addon = <span class="built_in">require</span>(<span class="string">"./build/Release/hello"</span>);
<span class="built_in">console</span>.log(addon.hello());
</pre></td></tr></table></figure>


<p>　　看到没！看到没！出来了出来了！Node.js 和 C++ 搞基的结果！这个 <code>addon.hello()</code> 就是我们之前在 C++ 代码中写的 <code>Handle&lt;Value&gt; Hello(const Arguments&amp; args)</code> 了，我们现在就已经把它返回的值给输出了。</p>
<h2 id="洗洗睡吧，下节更深入">洗洗睡吧，下节更深入</h2>
<p>　　时间不早了，今天就写到这里了，至此为止大家都能搞出最基础的 <strong>Hello world</strong> 的 C++ 扩展了吧。下一次写的应该会更深入一点，至于下一次是什么时候，我也不知道啦其实。<br>　　（喂喂喂，撸主怎么可以这么不负责！(ｏﾟﾛﾟ)┌┛Σ(ﾉ´<em>ω</em>`)ﾉ</p>

            
            <section class="comment">
	<div class="ds-thread"></div>
</section>

<script type="text/javascript">
  var duoshuoQuery = {short_name:"xcoder-ghost"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 
        </div>
    </div>
</article>

    <footer id="footer">
    <div id="bottom-tip">
        艾克斯の編碼者 —— <small>一個偽宅级别的蒟蒻碼畜。</small>
    </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a> 主题</small><br />
        <small>&copy; 2014 XadillaX</small>
    </footer>
</body>
</html>
