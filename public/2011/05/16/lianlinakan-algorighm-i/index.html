<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 Kalxd 的对话。
正文　　刚忙完邀请赛，蹭了块铜。刚才在逛别人博客的时候看别人的文章，突然心血来潮想记一些东西。
　　连连看是我学HGE做的第一个小游"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>连连看核心算法小分享——1 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>连连看核心算法小分享——1</h1><span class="post-meta">写于<time> 2011 年 05 月 16 日 12 时 30 分</time><br>更新于<time> 2021 年 01 月 01 日 20 时 57 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BF%86%E6%97%B6%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">回忆时间</span></a></li></ol></div><p>　　<strong>注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 <code>Kalxd</code> 的对话。</strong></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>　　刚忙完邀请赛，蹭了块铜。刚才在逛别人博客的时候看别人的文章，突然心血来潮想记一些东西。</p>
<p>　　连连看是我学HGE做的第一个小游戏，素材用的是QQ的。时间大概是去年国庆吧。好吧，废话不多说，就讲讲连连看怎么找到能消的两块吧。</p>
<p>　　首先来回顾一下消方块的规则，一共有三种可能性：</p>
<ol>
<li>直线消除（包括水平或者垂直）</li>
<li>一个拐角消除</li>
<li>两个拐角消除</li>
</ol>
<p>　　嗯，接下去我们就针对每种可能性开始写代码。</p>
<p>　　首先讲讲一些定义：</p>
<p>　　座标结构体，这个结构体包含了x、y的值以及一些座标中常用的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地图座标结构体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 地图座标结构体，包含x轴值、y轴值</span></span><br><span class="line"><span class="comment"> * 以及一些操作函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;                                          <span class="comment">///&lt; x轴</span></span><br><span class="line">    <span class="keyword">int</span> y;                                          <span class="comment">///&lt; y轴</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载构造函数</span></span><br><span class="line"><span class="comment">     * 将x、y值各初始化为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CoorType()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数重载</span></span><br><span class="line"><span class="comment">     * 将x、y各赋值为b、a</span></span><br><span class="line"><span class="comment">     * @param a 将要赋值的y轴数值</span></span><br><span class="line"><span class="comment">     * @param b 将要赋值的x轴数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CoorType(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置座标</span></span><br><span class="line"><span class="comment">     * 将x、y各赋值为b、a</span></span><br><span class="line"><span class="comment">     * @param a 将要赋值的y轴数值</span></span><br><span class="line"><span class="comment">     * @param b 将要赋值的x轴数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算符&quot;+=&quot;重载</span></span><br><span class="line"><span class="comment">     * 将此座标与另一座标相加</span></span><br><span class="line"><span class="comment">     * @param &amp;a 另一座标</span></span><br><span class="line"><span class="comment">     * @return 返回结果座标值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CoorType &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        y += a.y, x += a.x;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载运算符&quot;!=&quot;</span></span><br><span class="line"><span class="comment">     * 判断与另一座标是否表示同一个值</span></span><br><span class="line"><span class="comment">     * @param &amp;a 另一座标</span></span><br><span class="line"><span class="comment">     * @return 返回布尔类型表示是否相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y != a.y || x != a.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断此座标是否合法</span></span><br><span class="line"><span class="comment">     * 若出界则不合法</span></span><br><span class="line"><span class="comment">     * @return 返回布尔类型表示是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt; MAP_HEIGHT &amp;&amp; x &lt; MAP_WIDTH) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　然后是关于地图数组的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];</span><br></pre></td></tr></table></figure>
<p>　　接着是路径结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 路线结构体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 合法路线结构体</span></span><br><span class="line"><span class="comment"> * 储存最多四个点（起点终点和两个转折点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointPath</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> bExist;                                    <span class="comment">///&lt; 是否有路径</span></span><br><span class="line">    <span class="keyword">int</span> Num;                                        <span class="comment">///&lt; 驻点个数</span></span><br><span class="line">    CoorType Points[<span class="number">4</span>];                             <span class="comment">///&lt; 各驻点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　接着可以正式开始了。首先我们来想一下，哪些条件各符合上面三种情况的哪一种。对于一条直线的，显然是x相等或者y相等；对于有一个转折点的话，我们只需要判断起点横向画线（或者纵向），然后终点纵向画线（或者横向），然后从起点到交点以及从交点到终点各可行不；对于两个转折点，其中一个转折点的x或者y跟起点的x或者y相等，另一个转折点跟终点的x或者y相等。于是这两个转折点就根据这样的性质进行枚举。因为连连看的地图比较小，所以这种O(n^2)的时间复杂度不碍事。</p>
<p>　　为了方便，我们写一个 <code>Abled(CoorType, CoorType, bool, bool);</code> 函数来进行判断两个点（当然两点是在同一直线上的）是否有同路（即中间没有东西挡着）。我们先放着这个Abled不管，先实现寻路过程吧。</p>
<p>　　我是用一个CMapSearch类来实现的，声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 地图搜索类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据指定地图搜索出各合法路径。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMapSearch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];                                             <span class="comment">///&lt; 地图数据矩阵</span></span><br><span class="line">    PointPath dis[MAP_HEIGHT][MAP_WIDTH][MAP_HEIGHT][MAP_WIDTH];                <span class="comment">///&lt; 路径数组</span></span><br><span class="line">    STLMap grap;                                                                <span class="comment">///&lt; STL映射</span></span><br><span class="line">    CoorType dir[<span class="number">4</span>];                                                            <span class="comment">///&lt; 常量座标增量</span></span><br><span class="line">    PointPath Hint;                                                             <span class="comment">///&lt; 提示时用的合法路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 两点寻径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对(x1, y1)和(x2, y2)进行寻径</span></span><br><span class="line"><span class="comment">     * @param x1 第一个座标的x轴</span></span><br><span class="line"><span class="comment">     * @param y1 第一个座标的y轴</span></span><br><span class="line"><span class="comment">     * @param x2 第二个座标的x轴</span></span><br><span class="line"><span class="comment">     * @param y2 第二个座标的y轴</span></span><br><span class="line"><span class="comment">     * @return 返回一个路线结构体的值，若不存在路径，则结构体的bExist为假</span></span><br><span class="line"><span class="comment">     * @see Abled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">DoSearch</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param _Map[][Map_Width] 地图矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CMapSearch(<span class="keyword">int</span> _Map[][MAP_WIDTH]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~CMapSearch(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 载入地图</span></span><br><span class="line"><span class="comment">     * 从矩阵中载入地图到对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param _Map[][Map_Width] 地图矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadMap</span><span class="params">(<span class="keyword">int</span> _Map[][MAP_WIDTH])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 搜索地图</span></span><br><span class="line"><span class="comment">     * 对整个地图进行搜索每两个相同方块之间的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return 如果存在至少一条路径则返回真，否则为假，用于是否重列</span></span><br><span class="line"><span class="comment">     * @see CreateSTLMap</span></span><br><span class="line"><span class="comment">     * @see DoSearch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建map映射</span></span><br><span class="line"><span class="comment">     * 创建一个方块ID的映射，对每个ID创建一条的该ID的方块在地图中的各座标的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateSTLMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 判断是否有障碍</span></span><br><span class="line"><span class="comment">     * 对于a、b两座标（在同一直线）进行判断期间是否有方块障碍而导致不能连线</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a 座标a（头座标）</span></span><br><span class="line"><span class="comment">     * @param b 座标b（尾座标）</span></span><br><span class="line"><span class="comment">     * @param head 若包括头座标则为true，否则为false</span></span><br><span class="line"><span class="comment">     * @param tail 若包括尾座标则为true，否则为false</span></span><br><span class="line"><span class="comment">     * @return 若有障碍则返回false，否则为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Abled</span><span class="params">(CoorType a, CoorType b, <span class="keyword">bool</span> head = <span class="literal">false</span>, <span class="keyword">bool</span> tail = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 得到路径</span></span><br><span class="line"><span class="comment">     * 得到两个座标的连线具体路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param y1 第一个座标的y轴</span></span><br><span class="line"><span class="comment">     * @param x1 第一个座标的x轴</span></span><br><span class="line"><span class="comment">     * @param y2 第二个座标的y轴</span></span><br><span class="line"><span class="comment">     * @param x2 第二个座标的x轴</span></span><br><span class="line"><span class="comment">     * @return 返回一个路线结构体，表示该两个座标直接的路线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">GetPath</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 得到提示路径</span></span><br><span class="line"><span class="comment">     * 得到一条提示的路径的相应两个方块</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &amp;a 接受第一个方块ID的变量</span></span><br><span class="line"><span class="comment">     * @param &amp;b 接受第二个方块ID的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetRandomHint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　然后我这个分享里所讲的算法就是DoSearch和Abled函数了，因为其它函数就是用于“提示”道具的。在DoSearch中我们先定义两个临时变量，一个是返回值（一个PointPath），四个座标变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PointPath ans;</span><br><span class="line">CoorType a(y1, x1), b(y2, x2), c, d;</span><br></pre></td></tr></table></figure>
<p>　　其中a、b表示起点和终点，c、d表示可能用到的两个转折点。</p>
<p>　　首先我们先来判断直线情况吧，这种情况比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是直线</span></span><br><span class="line"><span class="keyword">if</span>(a.x == b.x || a.y == b.y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Abled(a, b, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ans.bExist = <span class="literal">true</span>;</span><br><span class="line">        ans.Num = <span class="number">2</span>;</span><br><span class="line">        ans.Points[<span class="number">0</span>] = a, ans.Points[<span class="number">1</span>] = b;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于这种情况，我们只需直接判断a、b直接有没有通路就好，如果有通路我们就将结果记录到ans中并返回即可。</p>
<p>　　而有一个转折点、两个转折点的情况以及Abled函数将在下一篇文章中小分享一下。</p>
<h2 id="回忆时间"><a href="#回忆时间" class="headerlink" title="回忆时间"></a>回忆时间</h2><p>　　然后下面就是在这篇文章里面我跟 <code>Kalxd</code> 的对话了，想想现在真是沧海桑田啊。</p>
<p>　　CSS 样式早已经不在了，截图里面是一篇白板</p>
<p><img src="comment.png" alt="评论回忆"></p>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2011/05/16/lianlinakan-algorighm-i/";</script><script>var DISQUS_IDENTIFIER = "2011/05/16/lianlinakan-algorighm-i/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2021<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a target="_blank" rel="noopener" href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $(block).find("td.gutter").remove();
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        if($(this).parent().is("article")) {
            $(this).wrap("<p style='text-align: center;'></p>");
        } else {
            $(this).parent().css("text-align", "center");
        }
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>