<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 Kalxd 的对话。
正文　　刚忙完邀请赛，蹭了块铜。刚才在逛别人博客的时候看别人的文章，突然心血来潮想记一些东西。
　　连连看是我学HGE做的第一个小游"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>连连看核心算法小分享——1 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>连连看核心算法小分享——1</h1><span class="post-meta">写于<time> 2011 年 05 月 16 日 12 时 30 分</time><br>更新于<time> 2016 年 12 月 27 日 15 时 54 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-number">1.</span> <span class="toc-text">正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回忆时间"><span class="toc-number">2.</span> <span class="toc-text">回忆时间</span></a></li></ol></div><p>　　<strong>注：这篇文章我到现在也没有填第二篇的坑。数据没了重新从 Capture 里面取出来，看看舍不得，于是把这篇文章也拿回来了。权当纪念吧，以及当时和 <code>Kalxd</code> 的对话。</strong></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>　　刚忙完邀请赛，蹭了块铜。刚才在逛别人博客的时候看别人的文章，突然心血来潮想记一些东西。</p>
<p>　　连连看是我学HGE做的第一个小游戏，素材用的是QQ的。时间大概是去年国庆吧。好吧，废话不多说，就讲讲连连看怎么找到能消的两块吧。</p>
<p>　　首先来回顾一下消方块的规则，一共有三种可能性：</p>
<ol>
<li>直线消除（包括水平或者垂直）</li>
<li>一个拐角消除</li>
<li>两个拐角消除</li>
</ol>
<p>　　嗯，接下去我们就针对每种可能性开始写代码。</p>
<p>　　首先讲讲一些定义：</p>
<p>　　座标结构体，这个结构体包含了x、y的值以及一些座标中常用的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 地图座标结构体</span><br><span class="line"> *</span><br><span class="line"> * 地图座标结构体，包含x轴值、y轴值</span><br><span class="line"> * 以及一些操作函数。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> CoorType &#123;</span><br><span class="line">    <span class="keyword">int</span> x;                                          <span class="comment">///&lt; x轴</span></span><br><span class="line">    <span class="keyword">int</span> y;                                          <span class="comment">///&lt; y轴</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 重载构造函数</span><br><span class="line">     * 将x、y值各初始化为-1</span><br><span class="line">     */</span></span><br><span class="line">    CoorType()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造函数重载</span><br><span class="line">     * 将x、y各赋值为b、a</span><br><span class="line">     * @param a 将要赋值的y轴数值</span><br><span class="line">     * @param b 将要赋值的x轴数值</span><br><span class="line">     */</span></span><br><span class="line">    CoorType(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 设置座标</span><br><span class="line">     * 将x、y各赋值为b、a</span><br><span class="line">     * @param a 将要赋值的y轴数值</span><br><span class="line">     * @param b 将要赋值的x轴数值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        y = a, x = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 运算符"+="重载</span><br><span class="line">     * 将此座标与另一座标相加</span><br><span class="line">     * @param &amp;a 另一座标</span><br><span class="line">     * @return 返回结果座标值</span><br><span class="line">     */</span></span><br><span class="line">    CoorType &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        y += a.y, x += a.x;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 重载运算符"!="</span><br><span class="line">     * 判断与另一座标是否表示同一个值</span><br><span class="line">     * @param &amp;a 另一座标</span><br><span class="line">     * @return 返回布尔类型表示是否相等</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> CoorType &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y != a.y || x != a.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断此座标是否合法</span><br><span class="line">     * 若出界则不合法</span><br><span class="line">     * @return 返回布尔类型表示是否合法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIll</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt; MAP_HEIGHT &amp;&amp; x &lt; MAP_WIDTH) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　然后是关于地图数组的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];</span><br></pre></td></tr></table></figure>
<p>　　接着是路径结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 路线结构体</span><br><span class="line"> *</span><br><span class="line"> * 合法路线结构体</span><br><span class="line"> * 储存最多四个点（起点终点和两个转折点）</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> PointPath &#123;</span><br><span class="line">    <span class="keyword">bool</span> bExist;                                    <span class="comment">///&lt; 是否有路径</span></span><br><span class="line">    <span class="keyword">int</span> Num;                                        <span class="comment">///&lt; 驻点个数</span></span><br><span class="line">    CoorType Points[<span class="number">4</span>];                             <span class="comment">///&lt; 各驻点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　接着可以正式开始了。首先我们来想一下，哪些条件各符合上面三种情况的哪一种。对于一条直线的，显然是x相等或者y相等；对于有一个转折点的话，我们只需要判断起点横向画线（或者纵向），然后终点纵向画线（或者横向），然后从起点到交点以及从交点到终点各可行不；对于两个转折点，其中一个转折点的x或者y跟起点的x或者y相等，另一个转折点跟终点的x或者y相等。于是这两个转折点就根据这样的性质进行枚举。因为连连看的地图比较小，所以这种O(n^2)的时间复杂度不碍事。</p>
<p>　　为了方便，我们写一个 <code>Abled(CoorType, CoorType, bool, bool);</code> 函数来进行判断两个点（当然两点是在同一直线上的）是否有同路（即中间没有东西挡着）。我们先放着这个Abled不管，先实现寻路过程吧。</p>
<p>　　我是用一个CMapSearch类来实现的，声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 地图搜索类</span><br><span class="line"> *</span><br><span class="line"> * 根据指定地图搜索出各合法路径。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> CMapSearch</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Map[MAP_HEIGHT][MAP_WIDTH];                                             <span class="comment">///&lt; 地图数据矩阵</span></span><br><span class="line">    PointPath dis[MAP_HEIGHT][MAP_WIDTH][MAP_HEIGHT][MAP_WIDTH];                <span class="comment">///&lt; 路径数组</span></span><br><span class="line">    STLMap grap;                                                                <span class="comment">///&lt; STL映射</span></span><br><span class="line">    CoorType dir[<span class="number">4</span>];                                                            <span class="comment">///&lt; 常量座标增量</span></span><br><span class="line">    PointPath Hint;                                                             <span class="comment">///&lt; 提示时用的合法路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 两点寻径</span><br><span class="line">     *</span><br><span class="line">     * 对(x1, y1)和(x2, y2)进行寻径</span><br><span class="line">     * @param x1 第一个座标的x轴</span><br><span class="line">     * @param y1 第一个座标的y轴</span><br><span class="line">     * @param x2 第二个座标的x轴</span><br><span class="line">     * @param y2 第二个座标的y轴</span><br><span class="line">     * @return 返回一个路线结构体的值，若不存在路径，则结构体的bExist为假</span><br><span class="line">     * @see Abled</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">DoSearch</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param _Map[][Map_Width] 地图矩阵</span><br><span class="line">     */</span></span><br><span class="line">    CMapSearch(<span class="keyword">int</span> _Map[][MAP_WIDTH]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 析构函数</span><br><span class="line">     */</span></span><br><span class="line">    ~CMapSearch(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 载入地图</span><br><span class="line">     * 从矩阵中载入地图到对象</span><br><span class="line">     *</span><br><span class="line">     * @param _Map[][Map_Width] 地图矩阵</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadMap</span><span class="params">(<span class="keyword">int</span> _Map[][MAP_WIDTH])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 搜索地图</span><br><span class="line">     * 对整个地图进行搜索每两个相同方块之间的路径</span><br><span class="line">     *</span><br><span class="line">     * @return 如果存在至少一条路径则返回真，否则为假，用于是否重列</span><br><span class="line">     * @see CreateSTLMap</span><br><span class="line">     * @see DoSearch</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 创建map映射</span><br><span class="line">     * 创建一个方块ID的映射，对每个ID创建一条的该ID的方块在地图中的各座标的链表</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateSTLMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 判断是否有障碍</span><br><span class="line">     * 对于a、b两座标（在同一直线）进行判断期间是否有方块障碍而导致不能连线</span><br><span class="line">     *</span><br><span class="line">     * @param a 座标a（头座标）</span><br><span class="line">     * @param b 座标b（尾座标）</span><br><span class="line">     * @param head 若包括头座标则为true，否则为false</span><br><span class="line">     * @param tail 若包括尾座标则为true，否则为false</span><br><span class="line">     * @return 若有障碍则返回false，否则为true</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Abled</span><span class="params">(CoorType a, CoorType b, <span class="keyword">bool</span> head = <span class="literal">false</span>, <span class="keyword">bool</span> tail = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 得到路径</span><br><span class="line">     * 得到两个座标的连线具体路径</span><br><span class="line">     *</span><br><span class="line">     * @param y1 第一个座标的y轴</span><br><span class="line">     * @param x1 第一个座标的x轴</span><br><span class="line">     * @param y2 第二个座标的y轴</span><br><span class="line">     * @param x2 第二个座标的x轴</span><br><span class="line">     * @return 返回一个路线结构体，表示该两个座标直接的路线</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">PointPath <span class="title">GetPath</span><span class="params">(<span class="keyword">int</span> y1, <span class="keyword">int</span> x1, <span class="keyword">int</span> y2, <span class="keyword">int</span> x2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @brief 得到提示路径</span><br><span class="line">     * 得到一条提示的路径的相应两个方块</span><br><span class="line">     *</span><br><span class="line">     * @param &amp;a 接受第一个方块ID的变量</span><br><span class="line">     * @param &amp;b 接受第二个方块ID的变量</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetRandomHint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　然后我这个分享里所讲的算法就是DoSearch和Abled函数了，因为其它函数就是用于“提示”道具的。在DoSearch中我们先定义两个临时变量，一个是返回值（一个PointPath），四个座标变量：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PointPath ans;</span><br><span class="line">CoorType a(y1, x1), b(y2, x2), c, d;</span><br></pre></td></tr></table></figure>
<p>　　其中a、b表示起点和终点，c、d表示可能用到的两个转折点。</p>
<p>　　首先我们先来判断直线情况吧，这种情况比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是直线</span></span><br><span class="line"><span class="keyword">if</span>(a.x == b.x || a.y == b.y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Abled(a, b, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ans.bExist = <span class="literal">true</span>;</span><br><span class="line">        ans.Num = <span class="number">2</span>;</span><br><span class="line">        ans.Points[<span class="number">0</span>] = a, ans.Points[<span class="number">1</span>] = b;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于这种情况，我们只需直接判断a、b直接有没有通路就好，如果有通路我们就将结果记录到ans中并返回即可。</p>
<p>　　而有一个转折点、两个转折点的情况以及Abled函数将在下一篇文章中小分享一下。</p>
<h2 id="回忆时间"><a href="#回忆时间" class="headerlink" title="回忆时间"></a>回忆时间</h2><p>　　然后下面就是在这篇文章里面我跟 <code>Kalxd</code> 的对话了，想想现在真是沧海桑田啊。</p>
<p>　　CSS 样式早已经不在了，截图里面是一篇白板</p>
<p><img src="comment.png" alt="评论回忆"></p>
<hr><section class="comment"><div class="ds-thread" data-thread-key="/2011/05/16/lianlinakan-algorighm-i/" data-title="连连看核心算法小分享——1" data-url="https://xcoder.in/2011/05/16/lianlinakan-algorighm-i/"></div></section><script>var _shortName = "xcoder-ghost";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2016<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="//cdn.bootcss.com/highlight.js/9.9.0/highlight.min.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : $(block).attr("class")) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>