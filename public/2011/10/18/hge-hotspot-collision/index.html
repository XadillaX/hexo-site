<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="碰撞检测始终是做2D游戏中的一个热点话题，我本人并没有做过这类游戏，所以一切只是理论而已，不过正打算做这么个小游戏练练手。
　　前几天在HGE的群里看到有人突然问到如何判断鼠标有没有点到人（点到纹理的透明区域不算），从而引申出了碰撞检测问题。
　　他的问题相对好实现，只要算出纹理所按的点是不是透明即"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>HGE做格斗游戏的热点图片碰撞检测法 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>HGE做格斗游戏的热点图片碰撞检测法</h1><span class="post-meta">写于<time> 2011 年 10 月 18 日 15 时 22 分</time><br>更新于<time> 2017 年 12 月 11 日 15 时 59 分</time></span><div class="article-toc"><strong>大纲</strong></div><p>　　碰撞检测始终是做2D游戏中的一个热点话题，我本人并没有做过这类游戏，所以一切只是理论而已，不过正打算做这么个小游戏练练手。</p>
<p>　　前几天在HGE的群里看到有人突然问到如何判断鼠标有没有点到人（点到纹理的透明区域不算），从而引申出了碰撞检测问题。</p>
<p>　　他的问题相对好实现，只要算出纹理所按的点是不是透明即可。</p>
<p>　　接下来我得做下碰撞检测的笔记：</p>
<p>　　碰撞检测最常用一个方法就是关节设置（当然我并没有做过），关节设置的话因为只是判断多边形的重叠状况，算法的复杂度低、效率高，虽然做工有点粗，但总体效果还是性价比比较高的一种方法。当然，这样的方法需要对每一帧的纹理都设置一个关节，对于人工的代价就稍微大了一些了，并且还要写个关节编辑器啊神马的，于是乎代码量又增加了。我这次是和同寝室木有一点基础的童鞋一起练手的，所以并没有打算引进这个方法。</p>
<p>　　于是我就用了另一种稍微“非主流”一些的方法了——逐像素判断。</p>
<p>　　但是逐像素判断还是有问题的——如果你的一个“效果”因为“温度过高”而不需要显示，直接隐藏，但又算伤害，这时纹理的逐像素就失去了意义。于是又有了个“臃肿”的办法，为需要“额外附加像素”的纹理另做一张图片，这张图片上有两种区域——热点区和非热点区。我们把需要“当做空气”的那些区域一律用某一种极其不常用的颜色覆盖，如 <code>ff00ff</code> 这种变态的粉色，然后其它区域的颜色就随你怎么搞了。我们载入的时候两张纹理一起载入，显示的时候显示正常的纹理，而在碰撞检测的时候用“热点图片”来进行逐像素检测。</p>
<p>　　与上面的关节设置法比较的话，人工的工作量我个人认为是大大地减少了，至于对于机器的执行能力来说，把时间复杂度提到了 <code>O(mn)</code> ，平方级的复杂度了，即纹理相交区域的宽和高。</p>
<p>　　我们来看一下这种碰撞检测的大体流程吧：</p>
<ol>
<li>获得两个精灵的矩形，并得到相交矩形。若无相交则直接返回 <code>false</code>。</li>
<li>根据相交矩形，我们可以得到精灵1、2的纹理中需要检测的初始座标。</li>
<li>将精灵1、精灵2的热点图片的相交区域的那一部分像素拷贝出来备用。（因为有可能两个纹理句柄是一样的，不好同时 <code>lock</code>）</li>
<li>开始对于拷贝出来的像素信息逐一判断对应像素点是否都“不是空气”，若都“不是空气”则可以判断为碰撞。</li>
</ol>
<p>　　当然以上的流程我们还可以优化一下，省去拷贝的那一段时间。我们可以直接 <code>hge-&gt;Texture_Lock()</code> 来进行得到两个纹理的像素信息的首指针，如果两个纹理其实只是一个纹理的话，则只需 <code>hge-&gt;Texture_Lock()</code> 一次，而另一个指针也只想 <code>hge-&gt;Texture_Lock</code> 即可，然后直接开始判断。</p>
<p>　　下面献上我这个函数的实现以及测试代码和素材：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief   Test the collision by the "hot" texture</span><br><span class="line"> * @author  XadillaX</span><br><span class="line"> * @email   admin@xcoder.in</span><br><span class="line"> * @date    2011/10/18</span><br><span class="line"> * @http://xcoder.in</span><br><span class="line"> *</span><br><span class="line"> * @param spr1 The first sprite to test the collision</span><br><span class="line"> * @param x1 "x" of top-left corner of sprite 1</span><br><span class="line"> * @param y1 "y" of top-left corner of sprite 1</span><br><span class="line"> * @param spr2 The second sprite to test the collision</span><br><span class="line"> * @param x2 "x" of top-left corner of sprite 2</span><br><span class="line"> * @param y2 "y" of top-left corner of sprite 2</span><br><span class="line"> * @param hot1 The "hot" texture for sprite 1. It will be the default texture of spr1 if it equal to 0</span><br><span class="line"> * @param hot2 The "hot" texture for sprite 2. It will be the default texture of spr2 if it equal to 0</span><br><span class="line"> * @param airColor The color which considered of "air"</span><br><span class="line"> *</span><br><span class="line"> * @return if they are collided, return true</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCollision</span><span class="params">(hgeSprite* spr1, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, hgeSprite* spr2, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, HTEXTURE hot1 = <span class="number">0</span>, HTEXTURE hot2 = <span class="number">0</span>, DWORD airColor = <span class="number">0xffff00ff</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Set the rect */</span></span><br><span class="line">    hgeRect r1, r2;</span><br><span class="line">    r1.Set(x1, y1, x1 + spr1-&gt;GetWidth(), y1 + spr1-&gt;GetHeight());</span><br><span class="line">    r2.Set(x2, y2, x2 + spr2-&gt;GetWidth(), y2 + spr2-&gt;GetHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Test for the intersect of rectangles */</span></span><br><span class="line">    <span class="keyword">if</span>(r1.Intersect(&amp;r2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x[] = &#123; x1, x2, x1 + spr1-&gt;GetWidth(), x2 + spr2-&gt;GetWidth() &#125;;</span><br><span class="line">        <span class="keyword">int</span> y[] = &#123; y1, y2, y1 + spr1-&gt;GetHeight(), y2 + spr2-&gt;GetHeight() &#125;;</span><br><span class="line">        <span class="built_in">std</span>::sort(x, x + <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(y, y + <span class="number">4</span>);</span><br><span class="line">        hgeRect r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Set the rectangle area where the two rectangles intersected. */</span></span><br><span class="line">        r.Set(x[<span class="number">1</span>], y[<span class="number">1</span>], x[<span class="number">2</span>], y[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The start point of sprite1 and sprite2. (From the intersected area) */</span></span><br><span class="line">        <span class="keyword">int</span> sx1, sy1, sx2, sy2;</span><br><span class="line">        sx1 = x[<span class="number">1</span>] - x1;</span><br><span class="line">        sy1 = y[<span class="number">1</span>] - y1;</span><br><span class="line">        sx2 = x[<span class="number">1</span>] - x2;</span><br><span class="line">        sy2 = y[<span class="number">1</span>] - y2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Get the "hotspot" of texture */</span></span><br><span class="line">        HTEXTURE hTex1 = hot1;</span><br><span class="line">        HTEXTURE hTex2 = hot2;</span><br><span class="line">        <span class="keyword">if</span>(hTex1 == <span class="number">0</span>) hTex1 = spr1-&gt;GetTexture();</span><br><span class="line">        <span class="keyword">if</span>(hTex2 == <span class="number">0</span>) hTex2 = spr2-&gt;GetTexture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> tx1, ty1, tw1, th1, tx2, ty2, tw2, th2;</span><br><span class="line">        <span class="keyword">int</span> w1 = hge-&gt;Texture_GetWidth(hTex1), w2 = hge-&gt;Texture_GetWidth(hTex2);</span><br><span class="line">        spr1-&gt;GetTextureRect(&amp;tx1, &amp;ty1, &amp;tw1, &amp;th1);</span><br><span class="line">        spr2-&gt;GetTextureRect(&amp;tx2, &amp;ty2, &amp;tw2, &amp;th2);</span><br><span class="line"></span><br><span class="line">        DWORD* color1 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];</span><br><span class="line">        DWORD* color2 = <span class="keyword">new</span> DWORD[(x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>])];</span><br><span class="line">        DWORD* color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Copy the effectivearea of texture 1 */</span></span><br><span class="line">        color = hge-&gt;Texture_Lock(hTex1, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)</span><br><span class="line">            &#123; </span><br><span class="line">                color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty1 + sy1) * w1 + (<span class="keyword">int</span>)tx1 + sx1 + i * w1 + j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        hge-&gt;Texture_Unlock(hTex1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Copy the effectivearea of texture 2 */</span></span><br><span class="line">        color = hge-&gt;Texture_Lock(hTex2, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++) </span><br><span class="line">            &#123; </span><br><span class="line">                color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] = color[((<span class="keyword">int</span>)ty2 + sy2) * w2 + (<span class="keyword">int</span>)tx2 + sx2 + i * w1 + j]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        hge-&gt;Texture_Unlock(hTex2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Test for the collision */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y[<span class="number">2</span>] - y[<span class="number">1</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">2</span>] - x[<span class="number">1</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(color1[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor &amp;&amp; color2[i * (x[<span class="number">2</span>] - x[<span class="number">1</span>]) + j] != airColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">delete</span> []color1;</span><br><span class="line">                    <span class="keyword">delete</span> []color2;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []color1;</span><br><span class="line">        <span class="keyword">delete</span> []color2;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="src.rar">点击下载</a></p>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2011/10/18/hge-hotspot-collision/";</script><script>var DISQUS_IDENTIFIER = "hge-hotspot-collision";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2017<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>