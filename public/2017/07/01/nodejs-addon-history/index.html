<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="本文由我首发于 GitChat 中。

前言在 Node.js 开发领域中，原生 C++ 模块的开发一直是一个被人冷落的角落。但是实际上在必要的时候，用 C++ 进行 Node.js 的原生模块开发能有意想不到的好处。

性能提升。很多情况下，使用 C++ 进行 Node.js 原生模块开发的性能会"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>从暴力到 NAN 再到 NAPI——Node.js 原生模块开发方式变迁 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>从暴力到 NAN 再到 NAPI——Node.js 原生模块开发方式变迁</h1><span class="post-meta">写于<time> 2017 年 07 月 01 日 15 时 55 分</time><br>更新于<time> 2017 年 12 月 11 日 15 时 59 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不变应万变"><span class="toc-number">2.</span> <span class="toc-text">不变应万变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原生模块本质"><span class="toc-number">2.1.</span> <span class="toc-text">原生模块本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-gyp"><span class="toc-number">2.2.</span> <span class="toc-text">node-gyp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GYP"><span class="toc-number">2.2.1.</span> <span class="toc-text">GYP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#做的事情"><span class="toc-number">2.2.2.</span> <span class="toc-text">做的事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子命令"><span class="toc-number">2.2.3.</span> <span class="toc-text">子命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时代在召唤"><span class="toc-number">3.</span> <span class="toc-text">时代在召唤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#黑暗时代：node-waf"><span class="toc-number">3.1.</span> <span class="toc-text">黑暗时代：node-waf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封建时代：暴力！暴力！暴力！"><span class="toc-number">3.2.</span> <span class="toc-text">封建时代：暴力！暴力！暴力！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#城堡时代：Native-Abstractions-for-Node-js"><span class="toc-number">3.3.</span> <span class="toc-text">城堡时代：Native Abstractions for Node.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#帝国时代：符合-ABI-的-N-API"><span class="toc-number">3.4.</span> <span class="toc-text">帝国时代：符合 ABI 的 N-API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模块初始化"><span class="toc-number">3.4.1.</span> <span class="toc-text">模块初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数声明"><span class="toc-number">3.4.2.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-完整代码"><span class="toc-number">3.4.3.</span> <span class="toc-text">Demo 完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#binding-gyp"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">binding.gyp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addon-cc"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">addon.cc</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘风破浪"><span class="toc-number">3.4.4.</span> <span class="toc-text">乘风破浪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向下兼容"><span class="toc-number">3.4.5.</span> <span class="toc-text">向下兼容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div><blockquote>
<p>本文由我首发于 <a href="http://gitbook.cn/books/5938f4ae8b55d47644b7a445/index.html" target="_blank" rel="external">GitChat</a> 中。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Node.js 开发领域中，原生 C++ 模块的开发一直是一个被人冷落的角落。但是实际上在必要的时候，用 C++ 进行 Node.js 的原生模块开发能有意想不到的好处。</p>
<ul>
<li>性能提升。很多情况下，使用 C++ 进行 Node.js 原生模块开发的性能会比纯 Node.js 开发要高，少数情况除外。</li>
<li>开发成本节约。在一些即有的 C++ 代码上做封装，开发成本远远低于从零开始写 Node.js 代码。</li>
<li>Node.js 无法完成的工作。个别情况，开发者只能得到一个库的静态连接库或者动态链接库以及一堆 C++ 头文件，其余都是黑盒的，这种情况就不得不使用 C++ 进行模块开发了。</li>
</ul>
<p>本文将从早期的 Node.js 开始，逐渐披露 Node.js 原生 C++ 模块开发方式的变迁。一直到最后，会比较详细地对 Node.js v8.x 新出的原生模块开发接口 N-API 做一次初步的尝试和解析，使得大家对 Node.js 原生 C++ 模块开发的固有印象（认为特别麻烦）有一个比较好的改观，让大家都来尝试一下 Node.js 原生 C++ 模块的开发。</p>
<h2 id="不变应万变"><a href="#不变应万变" class="headerlink" title="不变应万变"></a>不变应万变</h2><p>虽然 Node.js 原生 C++ 模块开发方式有了很大的改变，但是有一些内容是不变的，至少到现在来说都是基本上没什么 Breaking 的变化。</p>
<h3 id="原生模块本质"><a href="#原生模块本质" class="headerlink" title="原生模块本质"></a>原生模块本质</h3><p>这就要从 Node.js 最本质的 C++ 模块开发讲起了。举个例子，我们在 Linux 下有一个合法的原生模块 <strong>ons.node</strong>，它其实是一个二进制文件，使用文本编辑器无法正常地看出什么鬼，直到我们遇到了二进制文件查看器。</p>
<p><img src="http://images.gitbook.cn/81655b10-4cbe-11e7-920d-2570ff832158" alt="ons.node 二进制内容"></p>
<p>眼尖的同学会看到它的 Magic Number[^1] 是 <code>0x7F454C46</code>，其按位的 ASCII 码代表的字符串是 <code>ELF</code>。于是答案呼之欲出，这就是一个 Linux 下的动态链接库文件。</p>
<p>事实上，不只是在 Linux 中。当一个 Node.js 的 C++ 模块在 OSX 下编译会得到一个后缀是 <strong>*.node</strong> 本质上是 <strong>*.dylib</strong> 的动态链接库；而在 Windows 下则会得到一个后缀是 <strong>*.node</strong> 本质上是 <strong>*.dll</strong> 的动态链接库。</p>
<p>这么一个模块在 Node.js 中被 <code>require</code> 的时候，是通过 <code>process.dlopen()</code> 对其进行引入的。我们来看一下 Node.js v6.9.4 的 <code>DLOpen</code>[^2] 函数吧：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">void DLOpen(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">  Environment* env = Environment::GetCurrent(args);</span><br><span class="line">  uv_lib_t lib;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Local&lt;Object&gt; module = args[0]-&gt;ToObject(env-&gt;isolate());</span><br><span class="line">  node::Utf8Value filename(env-&gt;isolate(), args[1]);</span><br><span class="line"></span><br><span class="line">  // 使用 uv_dlopen 加载链接库</span><br><span class="line">  const bool is_dlopen_error = uv_dlopen(*filename, &amp;lib);</span><br><span class="line">  node_module* const mp = modpending;</span><br><span class="line">  modpending = nullptr;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // 将加载的链接库句柄转移到 mp 上</span><br><span class="line">  mp-&gt;nm_dso_handle = lib.handle;</span><br><span class="line">  mp-&gt;nm_link = modlist_addon;</span><br><span class="line">  modlist_addon = mp;</span><br><span class="line"></span><br><span class="line">  Local&lt;String&gt; exports_string = env-&gt;exports_string();</span><br><span class="line"></span><br><span class="line">  // exports_string 其实就是 `"exports"`</span><br><span class="line">  // 这句的意思是 `exports = module.exports`</span><br><span class="line">  Local&lt;Object&gt; exports = module-&gt;Get(exports_string)-&gt;ToObject(env-&gt;isolate());</span><br><span class="line"></span><br><span class="line">  if (mp-&gt;nm_context_register_func != nullptr) &#123;</span><br><span class="line">    mp-&gt;nm_context_register_func(exports, module, env-&gt;context(), mp-&gt;nm_priv);</span><br><span class="line">  &#125; else if (mp-&gt;nm_register_func != nullptr) &#123;</span><br><span class="line">    mp-&gt;nm_register_func(exports, module, mp-&gt;nm_priv);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    uv_dlclose(&amp;lib);</span><br><span class="line">    env-&gt;ThrowError("Module has no declared entry point.");</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照逻辑来讲，这个加载过程其实就是下面这样的。</p>
<ol>
<li>通过 <code>uv_dlopen</code> 加载链接库。</li>
<li>将加载的链接库挂到原生模块链表中去。</li>
<li>通过 <code>mp-&gt;nm_register_func()</code> 初始化这个模块，并得到该有的 <code>module</code> 和 <code>module.exports</code>。</li>
</ol>
<p>流程走下来就跟这个流程图差不多。</p>
<p><img src="http://images.gitbook.cn/4c391290-4cc0-11e7-be96-bb59812ba34f" alt="DLOpen 流程图"></p>
<h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><p>这货是 Node.js 中编译原生模块用的。自从 Node.js v0.8 之后，它就跟 Node.js 黏上了，在此之前它的默认编译帮助包是 node-waf[^3]，对于老 Noder 来说应该不会陌生的。</p>
<h4 id="GYP"><a href="#GYP" class="headerlink" title="GYP"></a>GYP</h4><p>node-gyp 是基于 GYP[^4] 的。它会识别包或者项目中的 <strong>binding.gyp</strong>[^5] 文件，然后根据该配置文件生成各系统下能进行编译的项目，如 Windows 下生成 Visual Studio 项目文件（<strong>*.sln</strong> 等），Unix 下生成 Makefile。在生成这些项目文件之后，node-gyp 还能调用各系统的编译工具（如 GCC）来将项目进行编译，得到最后的动态链接库 <strong>*.node</strong> 文件。</p>
<blockquote>
<p>从上面的描述中大家可以看到，Windows 下编译 C++ 原生模块是依赖 Visual Studio 的，这就是为什么大家在安装一些 Node.js 包的时候会需要你事先安装好 Vusual Studio 了。</p>
<p>事实上，对于并没有 Visual Studio 需求的同学们来说，它不是必须的，毕竟 node-gyp 只依赖它的编译器，而不是 IDE。想要精简化安装的同学可以直接访问 <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">http://landinghub.visualstudio.com/visual-cpp-build-tools</a> 下载 Visual CPP Build Tools 安装，或者通过 <code>$ npm install --global --production windows-build-tools</code> 命令行的方式安装，就能得到你该得到的编译工具了。</p>
</blockquote>
<p>说了那么多，让大家见识一下 <strong>binding.gyp</strong> 的基本结构吧。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># binding.gyp</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "targets": [&#123;</span><br><span class="line">    "target_name": "addon1",</span><br><span class="line">    "sources": [ "1/addon.cc", "1/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon2",</span><br><span class="line">    "sources": [ "2/addon.cc", "2/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon3",</span><br><span class="line">    "sources": [ "3/addon.cc", "3/myobject.cc" ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    "target_name": "addon4",</span><br><span class="line">    "sources": [ "4/addon.cc", "4/myobject.cc" ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段配置讲述了这么一个故事：</p>
<ul>
<li>定义了 4 个 C++ 原生模块。</li>
<li>每个模块的源码分别是 <strong>*/addon.cc</strong> 和 <strong>*/myobject.cc</strong>。</li>
<li>4 个模块名分别是 <strong>addon1</strong> 至 <strong>addon4</strong>。</li>
<li>隐藏故事：通过正规途径编译好后，这些模块存在于 <strong>build/Release/addon*.node</strong> 中。</li>
</ul>
<p>关于 GYP 配置文件的更多内容，大家可自行去官方文档观摩，在脚注中有 GYP 的链接。</p>
<h4 id="做的事情"><a href="#做的事情" class="headerlink" title="做的事情"></a>做的事情</h4><p>node-gyp 除了自身是基于 GYP 的之外，它还做了一些额外的事情。首先，在我们编译一个 C++ 原生扩展的时候，它会去指定目录下（通常是 <strong>~/.node-gyp</strong> 目录下）搜我们当前 Node.js 版本的头文件和静态连接库文件，若不存在，它就会火急火燎跑去 Node.js 官网下载。</p>
<p>这是一个 Windows 下 node-gyp 下载的指定版本 Node.js 头文件和库文件的目录结构。</p>
<p><img src="http://images.gitbook.cn/fca37040-4cc4-11e7-920d-2570ff832158" alt="Windows 下的 Node.js 头文件与库文件"></p>
<p>这个头文件目录会在 node-gyp 进行编译时，以 <code>&quot;include_dirs&quot;</code> 字段的形式合并进我们事先写好的 <strong>binding.gyp</strong> 中，总而言之，这里面的所有头文件能被直接 <code>#include &lt;&gt;</code>。</p>
<h4 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h4><p>node-gyp 是一个命令行的程序，在安装好后能通过 <code>$ node-gyp</code> 直接运行它。它有一些子命令供大家使用。</p>
<ul>
<li><code>$ node-gyp configure</code>：通过当前目录的 binding.gyp 生成项目文件，如 Makefile 等；</li>
<li><code>$ node-gyp build</code>：将当前项目进行构建编译，前置操作必须先 <code>configure</code>；</li>
<li><code>$ node-gyp clean</code>：清理生成的构建文件以及输出目录，说白了就是把目录清理了；</li>
<li><code>$ node-gyp rebuild</code>：相当于依次执行了 <code>clean</code>、<code>configure</code> 和 <code>build</code>；</li>
<li><code>$ node-gyp install</code>：手动下载当前版本的 Node.js 的头文件和库文件到对应目录。</li>
</ul>
<h2 id="时代在召唤"><a href="#时代在召唤" class="headerlink" title="时代在召唤"></a>时代在召唤</h2><blockquote>
<p>第 N 套国际 Node.js 开发者原生 C++ 模块开发方式，时代在召唤。</p>
</blockquote>
<p>除去前文中讲的一些不变的内容，还有很多内容是一直在变化的，虽然说用老旧的开发方式也是可以开发出能用的 C++ 原生模块，但是旧不如新。</p>
<p>而且，其实目前来说 node-gyp 的地位也有可能在未来进行变化。因为当年 Chromium 是通过 GYP 来管理它的构建配置的，现如今已经步入了 GN[^6] 的殿堂，是否也意味着 node-gyp 有一天也会被可能叫做 node-gn 的东西给取代呢？</p>
<p>话不多说，先来看看沧海桑田的故事吧。</p>
<h3 id="黑暗时代：node-waf"><a href="#黑暗时代：node-waf" class="headerlink" title="黑暗时代：node-waf"></a>黑暗时代：node-waf</h3><p>在 Node.js 0.8 之前，通常在开发 C++ 原生模块的时候，是通过 node-waf 构建的。当然彼 node-waf 不是现在在 NPM 仓库上能搜到的 node-waf 了，当年那个 node-waf 早就年久失修了。</p>
<p>这个东西使用一种叫 wscript 的文件来配置。自 Node.js 升上 0.8 之后，就自带了 node-gyp 的支持，从此就不再需要 wscript 了。</p>
<p>不过就是因为有这个青黄交接的时候，那段时间的各种使用 C++ 来开发 Node.js 原生扩展的包为了兼容 0.8 前后版本的 Node.js，通常都是 binding.gyp 和 wscript 共存的。</p>
<p>大家可以来看一下 <strong>node-mysql-libmysqlclient</strong> 这个包在当年相应时间段的时候的<a href="https://github.com/Sannis/node-mysql-libmysqlclient/tree/9545ea7485fcc8b07b7c56c5ec3575938bfd4e5f" target="_blank" rel="external">仓库文件</a>。为了支持 node-gyp，有一个 binding.gyp 文件，然后还存留着 wscript 配置文件。</p>
<h3 id="封建时代：暴力！暴力！暴力！"><a href="#封建时代：暴力！暴力！暴力！" class="headerlink" title="封建时代：暴力！暴力！暴力！"></a>封建时代：暴力！暴力！暴力！</h3><p>在早期的时候，Node.js 原生 C++ 模块开发方式是非常暴力的，直接使用其提供的原生模块开发头文件。</p>
<p>开发者直接深入到 Node.js 的各种 API，以及 Google V8 的 API。</p>
<p>举个最简单的例子，在几年前，你的 Node.js C++ 原生扩展代码可能是长这样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    HandleScope scope;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowException(</span><br><span class="line">            Exception::TypeError(</span><br><span class="line">                String::New(<span class="string">"Wrong number of arguments."</span>)));</span><br><span class="line">        <span class="keyword">return</span> scope.Close(Undefined());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scope.Close(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Handle&lt;Object&gt; exports)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    exports-&gt;Set(String::NewSymbol(<span class="string">"echo"</span>),</span><br><span class="line">        FunctionTemplate::New(Echo)-&gt;GetFunction());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个最简单的 <code>echo</code> 函数，返回传进来的参数。写作 JavaScript 相当于是这样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.echo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Wrong number of arguments."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遗憾的是，这样的代码如果发成一个包，你现在是无论如何无法安装的，除非你用的是 0.10.x 的 Node.js 版本。</p>
<p>为什么这么说呢，这段代码的确是在 Node.js 0.10.x 的时候可以用的。但是再往上升 Google V8 的大版本，这段代码就无法适用了，讲粗暴点就是没办法再编译通过了。</p>
<p>就拿 Node.js 6.x 版本的 Google V8 来说，函数声明的对比是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure>
<p>事实上，根本不需要等到 6.x。上面的代码到 0.12 就已经无法再编译通过了。不只是函数声明的变化，连句柄作用域[^7]的声明方式都变了。</p>
<p>如果要让它在 Node.js 6.x 下能编译，就需要改代码，就像这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="keyword">if</span>(args.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isolate-&gt;ThrowException(</span><br><span class="line">            Exception::TypeError(</span><br><span class="line">                String::NewFromUtf8(isolate, <span class="string">"Wrong number of arguments."</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    args.GetReturnValue().Set(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local&lt;Object&gt; exports)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"echo"</span>, Echo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，以黑暗时代的方式进行 Node.js 原生模块开发的时候，一个版本只能支持特定几个版本的 Node.js，一旦 Node.js 的底层 API 以及 Google V8 的 API 发生变化，而这些原生模块又依赖了变化了的 API 的话，包就作废了。除非包的维护者去支持新版的 API，不过这样依赖，老版 Node.js 下就又无法编译通过新版的包了。</p>
<p>这就很尴尬了。</p>
<h3 id="城堡时代：Native-Abstractions-for-Node-js"><a href="#城堡时代：Native-Abstractions-for-Node-js" class="headerlink" title="城堡时代：Native Abstractions for Node.js"></a>城堡时代：Native Abstractions for Node.js</h3><p>在经历了黑暗时代的尴尬局面之后，2013 年年中，一个救世主突然现世。</p>
<p>它的名字叫作 <a href="https://github.com/nodejs/nan" target="_blank" rel="external">NAN</a>，全称 Native Abstractions for Node.js，即 Node.js 原生模块抽象接口。</p>
<blockquote>
<p>NAN 由 <a href="https://github.com/rvagg" target="_blank" rel="external">Rod Vagg</a> 和 <a href="https://github.com/kkoopa" target="_blank" rel="external">Benjamin Byholm</a> 两手带大，记名在 GitHub 的 Rod Vagg 账号下。并且在 Node.js 与 io.js 黑历史的年代，这个在 GitHub 上面项目移到了 io.js 的组织下面；后来由于两家又重归于好，NAN 最终归属到了 <a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a> 这个组织下面。</p>
</blockquote>
<p>总之在 NAN 出现之后，Node.js 的原生开发方式进入了城堡时代，并且一直持续到现在，甚至可能会持续到好久之后。</p>
<p>说 NAN 是 Node.js 原生模块抽象接口可能还是有点抽象，那么讲明白点，它就是一堆宏判断。比如声明一个函数的时候，只需要通过下面的一个宏就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAN_METHOD(Echo)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NAN 的宏会判断当前编译时候的 Node.js 版本，根据不同版本的 Node.js 来展开不同的结果。这会儿就又会提到先前的两个函数声明对比了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure>
<p><code>NAN_METHOD</code> 将会在不同版本的 Node.js 下被 NAN 展开成上面两个这样。</p>
<p>而且 NAN 可不只是提供了 <code>NAN_METHOD</code> 一个宏，它还有一坨一坨数不清的宏供开发者使用。</p>
<p>比如声明句柄作用域的 <code>Nan::HandleScope</code>、能黑盒调起 libuv[^8] 进行事件循环上的异步操作的 <code>Nan::AsyncWorker</code> 等。</p>
<p>于是，在城堡时代，大家的 C++ 原生模块代码都差不多长这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAN_METHOD(Echo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(info.Length() &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Nan::ThrowError(<span class="string">"Wrong number of arguments."</span>);</span><br><span class="line">        <span class="keyword">return</span> info.GetReturnValue().Set(Nan::Undefined());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.GetReturnValue().Set(info[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAN_MODULE_INIT(InitAll)</span><br><span class="line">&#123;</span><br><span class="line">    Nan::Set(</span><br><span class="line">        target,</span><br><span class="line">        Nan::New&lt;String&gt;(<span class="string">"echo"</span>).ToLocalChecked(),</span><br><span class="line">        Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Echo)).ToLocalChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处就是，代码只需要随着 NAN 的升级做改变就好，它会帮你兼容各不同 Node.js 版本，使其在任意版本都能被编译使用。</p>
<blockquote>
<p>即使是 NAN 这样的好物，也有自己的一个使命，使命之外的东西会被逐渐剥离。比如 0.10.x 和 0.12.x 等版本就应该要退出历史舞台了，NAN 会逐渐放弃对它们的兼容和支持。</p>
</blockquote>
<h3 id="帝国时代：符合-ABI-的-N-API"><a href="#帝国时代：符合-ABI-的-N-API" class="headerlink" title="帝国时代：符合 ABI 的 N-API"></a>帝国时代：符合 ABI 的 N-API</h3><p>自从前几天 Node.js v8.0.0 发布之后，Node.js 推出了全新的用于开发 C++ 原生模块的接口，N-API。</p>
<blockquote>
<p>据官方文档所述，它的发音就是一个单独的 <code>N</code>，加上 API，即四个英文字母单独发音。</p>
</blockquote>
<p>这东西相较于先前三个时代有什么不同呢？为什么会是更进一步的帝国时代呢？</p>
<p>首先，我们知道，即使是在 NAN 的开发方式下，一次编写好的代码在不同版本的 Node.js 下也需要重新编译，否则版本不符的话 Node.js 无法正常载入一个 C++ 扩展。即一次编写，到处编译。</p>
<p>而 N-API 相较于 NAPI 来说，它把 Node.js 的所有底层数据结构全部黑盒化，抽象成 N-API 当中的接口。</p>
<p>不同版本的 Node.js 使用同样的接口，这些接口是稳定地 ABI 化的，即应用二进制接口（Application Binary Interface）。这使得在不同 Node.js 下，只要 ABI 的版本号一致，编译好的 C++ 扩展就可以直接使用，而不需要重新编译。事实上，在支持 N-API 接口的 Node.js 中，的确就指定了当前 Node.js 所使用的 ABI 版本。</p>
<p>为了使得以后的 C++ 扩展开发、维护更方便，N-API 致力于以下的几个目标：</p>
<ul>
<li>以 C 的风格提供稳定 ABI 接口；</li>
<li>消除 Node.js 版本的差异；</li>
<li>消除 JavaScript 引擎的差异（如 Google V8、Microsoft ChakraCore 等）。</li>
</ul>
<p>而这些 API 主要就是用来创建和操作 JavaScript 的值了，我们就再也不用直接使用 Google V8 提供的数据类型了。毕竟在 NAN 中，就算我们有时候看不到 Google V8 的影子，实际上在宏展开后还是无数的 Google V8 数据结构。</p>
<p>为了达成上述隐藏的目标，N-API 的姿势就变成了这样：</p>
<ul>
<li>提供头文件 <strong>node_api.h</strong>；</li>
<li>任何 N-API 调用都返回一个 <code>napi_status</code> 枚举，来表示这次调用成功与否；</li>
<li>N-API 的返回值由于被 <code>napi_status</code> 占坑了，所以真实返回值由传入的参数来继承，如传入一个指针让函数操作；</li>
<li>所有 JavaScript 数据类型都被黑盒类型 <code>napi_value</code> 封装，不再是类似于 <code>v8::Object</code>、<code>v8::Number</code> 等类型；</li>
<li>如果函数调用不成功，可以通过 <code>napi_get_last_error_info</code> 函数来获取最后一次出错的信息。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>哪怕是现在的 Node.js v8.x 版本，N-API 仍处于一个实验状态，个人认为还有非常长的一段路要走，所以大家在生产环境中还不必太过于激进，不过 N-API 依然是大势所趋；不过对于使用老版本的 Node.js 开发者来说，大家也不要着急，即使 N-API 是在 v8.x 才正式集成进 Node.js，在其它旧版本的 Node.js 中依然可以将 N-API 作为外挂式的头文件9中使用，只不过无法做到跨版本的特性，这只是它做的向后兼容的一个事情而已。</p>
</blockquote>
<p>关于 N-API 一系列的函数可以访问它的<a href="https://nodejs.org/docs/v8.0.0/api/n-api.html" target="_blank" rel="external">文档</a>了解更多详情，现在我们来点料儿让大家对 N-API 的印象不是那么抽象。</p>
<h4 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h4><p>在封建时代和 NAN 所处的，模块的初始化是交给 Node.js 提供的宏来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NODE_MODULE(addon, Init)</span><br></pre></td></tr></table></figure>
<p>而到了当前的 N-API，它就变成了 N-API 的一个宏了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NAPI_MODULE(addon, Init)</span><br></pre></td></tr></table></figure>
<p>相应地，这个初始化函数 <code>Init</code> 的写法也会有所改变。比如这是封建时代和 NAN 时代的两种不同写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"echo"</span>, Echo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NAN 写法</span></span><br><span class="line">NAN_MODULE_INIT(Init)</span><br><span class="line">&#123;</span><br><span class="line">    Nan::Set(</span><br><span class="line">        target,</span><br><span class="line">        Nan::New&lt;String&gt;(<span class="string">"echo"</span>).ToLocalChecked(),</span><br><span class="line">        Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Echo)).ToLocalChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而到了 N-API 的时候，这个 <code>Init</code> 函数就该是这样的了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(napi_env env, napi_value exports, napi_value <span class="keyword">module</span>, <span class="keyword">void</span>* priv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于设置 exports 对象的描述结构体</span></span><br><span class="line">    napi_property_descriptor desc =</span><br><span class="line">        &#123; <span class="string">"echo"</span>, <span class="number">0</span>, Echo, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, napi_default, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 "echo" 设置到 exports 去</span></span><br><span class="line">    status = napi_define_properties(env, exports, <span class="number">1</span>, &amp;desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>napi_property_descriptor</code> 是用于设置对象属性的描述结构体，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* utf8name;</span><br><span class="line"></span><br><span class="line">  napi_callback method;</span><br><span class="line">  napi_callback getter;</span><br><span class="line">  napi_callback setter;</span><br><span class="line">  napi_value value;</span><br><span class="line"></span><br><span class="line">  napi_property_attributes attributes;</span><br><span class="line">  <span class="keyword">void</span>* data;</span><br><span class="line">&#125; napi_property_descriptor;</span><br></pre></td></tr></table></figure>
<p>那么上面 <code>Init</code> 函数中的 <code>desc</code> 意思就是，即将被挂在的对象下会挂一个叫 <code>&quot;echo&quot;</code> 的东西，它的函数是 <code>Echo</code>，其它的 <code>getter</code>、<code>setter</code> 等全是空指针，而属性则是 <code>napi_default</code>。</p>
<blockquote>
<p><code>napi_property_attributes</code> 除了 <code>napi_default</code> 之外，还有诸如只读、是否可枚举等属性。</p>
</blockquote>
</blockquote>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>还记得之前的两种函数声明吗？第三次再搬过来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Handle&lt;Value&gt; Echo(<span class="keyword">const</span> Arguments&amp; args);    <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Echo</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure>
<p>在 N-API 中，你不用再被告知需要有 C++ 基础，C 即可。因为在 N-API 里面，声明一个 <code>Echo</code> 是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">napi_value <span class="title">Echo</span><span class="params">(napi_env env, napi_callback_info info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    napi_value argv[<span class="number">1</span>];</span><br><span class="line">    status = napi_get_cb_info(env, info, &amp;argc, argv, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(status != napi_ok || argc &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        napi_throw_type_error(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// napi_value 实际上是一个指针，返回空指针表示无返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> argv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要：</strong>目前 8.0.0 和 8.1.0 版本的 Node.js 官方文档中，关于 N-API 的各种接口文档错误颇多，所以还是要以能使用的接口为准。</p>
<p>而且现在大家也有很多人正在帮忙一起修复文档。例如现在的 JavaScript 函数声明返回值其实是 <code>napi_value</code>，而官方文档上还是老旧的 <code>void</code>。又比如 <code>`napi_property_descriptor_desc</code> 结构体中，在 <code>utf8name</code> 之后还有一个 <code>napi_value</code> 的变量，而文档中却是没有的。</p>
<p>这也是为什么我前面强调目前来说 N-API 还处于试验阶段。毕竟 API 并没有完全稳定下来，还处于一个快速迭代的步伐中，文档的更新并未跟上代码的更新。至少在笔者写作的当前是这样的（现在日期 2017 年 6 月 9 日）。</p>
</blockquote>
<p>上面代码分步解析。</p>
<ul>
<li>通过 <code>napi_get_cb_info</code> 获取当次函数请求的参数信息，包括参数数量和参数体（参数体以 <code>napi_value</code> 的数组形式体现）；</li>
<li>看看解析有无出错（<code>status</code> 不等于 <code>napi_ok</code>）或者看看参数数量是否小于 1；<ul>
<li>若解析出错或者参数数量小于 1，通过 <code>napi_throw_type_error</code> 在 JavaScript 层抛出一个错误对象，并返回；</li>
<li>若无错则继续进行；</li>
</ul>
</li>
<li>返回 <code>argv[0]</code>，即第一个参数。</li>
</ul>
<h4 id="Demo-完整代码"><a href="#Demo-完整代码" class="headerlink" title="Demo 完整代码"></a>Demo 完整代码</h4><p>这里放上这个 Echo 样例的完整代码，大家可以拿回家试试看。</p>
<h5 id="binding-gyp"><a href="#binding-gyp" class="headerlink" title="binding.gyp"></a>binding.gyp</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [ <span class="string">"addon.cc"</span> ],</span><br><span class="line">    <span class="attr">"cflags!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"cflags_cc!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"xcode_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"GCC_ENABLE_CPP_EXCEPTIONS"</span>: <span class="string">"YES"</span>,</span><br><span class="line">      <span class="attr">"CLANG_CXX_LIBRARY"</span>: <span class="string">"libc++"</span>,</span><br><span class="line">      <span class="attr">"MACOSX_DEPLOYMENT_TARGET"</span>: <span class="string">"10.7"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"msvs_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"VCCLCompilerTool"</span>: &#123; <span class="attr">"ExceptionHandling"</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="addon-cc"><a href="#addon-cc" class="headerlink" title="addon.cc"></a>addon.cc</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">napi_value <span class="title">Echo</span><span class="params">(napi_env env, napi_callback_info info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> argc = <span class="number">1</span>;</span><br><span class="line">    napi_value argv[<span class="number">1</span>];</span><br><span class="line">    status = napi_get_cb_info(env, info, &amp;argc, argv, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(status != napi_ok || argc &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        napi_throw_type_error(env, <span class="string">"Wrong number of arguments"</span>);</span><br><span class="line">        status = napi_get_undefined(env, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> argv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(napi_env env, napi_value exports, napi_value <span class="keyword">module</span>, <span class="keyword">void</span>* priv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    napi_status status;</span><br><span class="line">    napi_property_descriptor desc =</span><br><span class="line">        &#123; <span class="string">"echo"</span>, <span class="number">0</span>, Echo, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, napi_default, <span class="number">0</span> &#125;;</span><br><span class="line">    status = napi_define_properties(env, exports, <span class="number">1</span>, &amp;desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAPI_MODULE(addon, Init)</span><br></pre></td></tr></table></figure>
<h4 id="乘风破浪"><a href="#乘风破浪" class="headerlink" title="乘风破浪"></a>乘风破浪</h4><p>在完成了代码之后，大家赶紧试一下代码吧。</p>
<p>首先在 Node.js v8.x 下进行试验，把这两段代码分别放到同一个目录下，命名好后，执行这样的终端命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node-gyp rebuild</span><br><span class="line">...</span><br><span class="line">$ node --napi-modules</span><br><span class="line">(node:52264) Warning: N-API is an experimental feature and could change at any time</span><br><span class="line">&gt; const addon = require(<span class="string">"./build/Release/addon"</span>);</span><br><span class="line">undefined</span><br><span class="line">&gt; addon.echo(<span class="string">"2333"</span>);</span><br><span class="line"><span class="string">'2333'</span></span><br><span class="line">&gt; addon.echo(<span class="string">"蛋花汤🐶"</span>, <span class="string">"南瓜饼🐱"</span>);</span><br><span class="line"><span class="string">'蛋花汤🐶'</span></span><br><span class="line">&gt; addon.echo();</span><br><span class="line">TypeError: Wrong number of arguments</span><br><span class="line">    at repl:1:7</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:44:33)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:239:29)</span><br><span class="line">    at bound (domain.js:301:14)</span><br><span class="line">    at REPLServer.runBound [as <span class="built_in">eval</span>] (domain.js:314:12)</span><br><span class="line">    at REPLServer.onLine (repl.js:433:10)</span><br><span class="line">    at emitOne (events.js:120:20)</span><br><span class="line">    at REPLServer.emit (events.js:210:7)</span><br><span class="line">    at REPLServer.Interface._onLine (readline.js:278:10)</span><br><span class="line">    at REPLServer.Interface._line (readline.js:625:8)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>还是因为试验特性，目前在 Node.js v8.x 要加载和执行 N-API 的 C++ 扩展的话，在启动 <code>node</code> 的时候需要加上 <code>--napi-modules</code> 参数，表示这次执行要启用 N-API 特性。</p>
</blockquote>
<p>效果显而易见，在刚启动 Node.js REPL 的时候，你会得到一个警告。</p>
<blockquote>
<p>(node:52264) Warning: N-API is an experimental feature and could change at any time</p>
</blockquote>
<p>表示它目前还不是特别稳定，但是值得我们展望未来。然后在我们 <code>require()</code> 扩展的时候，我们就得到了一个拥有 <code>echo</code> 函数的对象了。</p>
<p>我们尝试了三种调用方式。第一次是规规矩矩传入一个参数，<code>echo</code> 如期返回我们传入的参数 <code>&quot;2333&quot;</code>；第二次传入两个参数，<code>echo</code> 返回了第一个参数 <code>&quot;蛋花汤🐶&quot;</code>；最后一次我们没传任何参数，这个时候就走到了 C++ 扩展中判断函数参数数量失败的条件分支，就抛出了一个 <code>Wrong number of arguments</code> 的错误对象。</p>
<p>总之，它按照我们的预期跑起来了。并且代码里面并没有任何 Node.js 非 N-API 所暴露出来的数据结构和 V8 的数据结构——版本差异消除了。</p>
<p>接下来激动人心的时刻到了，如果读者是使用 <code>nvm</code> 来管理自己的 Node.js 版本的话，可以尝试着安装一个 8.1.0 的 Node.js 版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nvm install 8.1.0</span><br></pre></td></tr></table></figure>
<p>在安装成功切换版本成功后，尝试着直接打开 Node.js RELP，忘掉再次编译刚才编译好的扩展这一步。（不过别忘了 <code>--napi-module</code> 参数）</p>
<p>把刚才用于测试的几句 JavaScript 代码再重复地输入——N-API 诚不我欺，居然还是能输出结果。这对于以前的暴力做法和 NAN 做法来说，无疑是非常大的一个进步。</p>
<h4 id="向下兼容"><a href="#向下兼容" class="headerlink" title="向下兼容"></a>向下兼容</h4><p>至此，我希望大家还没有忘记 N-API 是自 Node.js 8.0 之后出的特性。所以之前 Demo 的代码并不能在 Node.js 8.0 之前的版本如期编译和运行。</p>
<p>辛辛苦苦写好的包，居然不能在 Node.js 6.x 下面跑，搞什么。</p>
<p><img src="http://images.gitbook.cn/25ae5fa0-4cf6-11e7-92f5-09e07d17628a" alt="当时我就不乐意了"></p>
<p>先别急着摔。文中之前也说了，有一个外挂式头文件的包，其包名是 <code>node-addon-api</code>。</p>
<p>我们就试着通过它来进行向下兼容吧。首先在我们刚才的源码目录把这个包给安装上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --save node-addon-api</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还是由于快速迭代的原因，我不能保证这个包当前版本的时效性，不过我相信大家都有探索精神，在未来版本不符导致的 API 不符的问题应该都能解决。</p>
</blockquote>
<p>然后，给我们的 <strong>binding.gyp</strong> 函数加点料，加两个字段，里面是两个指令展开。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"include_dirs": [ "&lt;!@(node -p \"require('node-addon-api').include\")" ],</span><br><span class="line">"dependencies": [ "&lt;!(node -p \"require('node-addon-api').gyp\")" ]</span><br></pre></td></tr></table></figure>
<p><code>&lt;!@</code> 和 <code>&lt;!</code> 开头的字符串在 GYP 中代表指令，表示它的值是后面的指令的执行结果。上面两条指令的返回结果分别是外挂式头文件的头文件搜索路径，以及外挂式 N-API 这个包编译成静态连接库供我们自己的包使用的依赖声明。</p>
<p>有了这两个字段后，就表示我们依赖了外挂式 N-API 头文件。而且它内部自带判断，如果版本已经达到了有 N-API 的要求，它的依赖就会是一个空依赖，即不依赖外挂式 N-API 编译的静态连接库。</p>
<p><strong>也就是说，用了外挂式的 N-API，能自动适配 Node.js 8.x 和低版本。</strong></p>
<p>于是这个 <strong>binding.gyp</strong> 现在看起来是这样子的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [ <span class="string">"addon.cc"</span> ],</span><br><span class="line">    <span class="attr">"cflags!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"cflags_cc!"</span>: [ <span class="string">"-fno-exceptions"</span> ],</span><br><span class="line">    <span class="attr">"xcode_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"GCC_ENABLE_CPP_EXCEPTIONS"</span>: <span class="string">"YES"</span>,</span><br><span class="line">      <span class="attr">"CLANG_CXX_LIBRARY"</span>: <span class="string">"libc++"</span>,</span><br><span class="line">      <span class="attr">"MACOSX_DEPLOYMENT_TARGET"</span>: <span class="string">"10.7"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"msvs_settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"VCCLCompilerTool"</span>: &#123; <span class="attr">"ExceptionHandling"</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"include_dirs"</span>: [ <span class="string">"&lt;!@(node -p \"require('node-addon-api').include\")"</span> ],</span><br><span class="line">    <span class="attr">"dependencies"</span>: [ <span class="string">"&lt;!(node -p \"require('node-addon-api').gyp\")"</span> ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于源码层面，我们就不需要作任何修改。在 Node.js v6.x 下面试试看吧。同样是使用 <strong>node-gyp rebuild</strong> 进行编译。然后通过 Node.js REPL 进去测试。</p>
<p>具体的终端输出这里就不放出来了，相信经过实验的大家都得到了自己想要的结果。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次内容主要讲解了在 Node.js 领域中原生 C++ 模块开发的方式变迁。</p>
<ul>
<li>从 node-waf 到 node-gyp，这是构建工具的一个变迁，未来说不定会是 GN 或者其它的构建工具。</li>
<li>从暴力写码，到 NAN 的出现，见证了 Node.js 社区的各种爱恨情仇，一直到现在的新生儿 N-API，为原生 C++ 模块的开发输送了新鲜的血液。</li>
</ul>
<p>目前的中坚力量仍然是 NAN 的开发方式，甚至我猜测是否未来有可能 NAN 会提供关于 N-API 的各种宏封装，使其彻底消除版本差异，包括 ABI 版本上的差异。当然这种 ABI 版本差异导致的需要多次编译问题应该还是存在的，这里指的是一次编码的差异。</p>
<p>在大家跟着本文对 N-API 进行了一次浅尝辄止的尝试之后，希望能对当下仍然处于实验状态的 N-API 充满了希冀，并对现在存在的各种坑处以包容的心态。</p>
<p>毕竟，Node.js loves you all。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>「Consider moving from gyp to gn」：<a href="https://github.com/nodejs/node/issues/6089" target="_blank" rel="external">https://github.com/nodejs/node/issues/6089</a></li>
<li>「Getting Started with Embedding · v8/v8 Wiki」：<a href="https://github.com/v8/v8/wiki/Getting-Started-with-Embedding" target="_blank" rel="external">https://github.com/v8/v8/wiki/Getting-Started-with-Embedding</a></li>
<li>「Drop support for v0.10 and v0.12?」：<a href="https://github.com/nodejs/nan/issues/676" target="_blank" rel="external">https://github.com/nodejs/nan/issues/676</a></li>
<li>「Node Loves Rust」：<a href="https://cnodejs.org/topic/593353775b07c1b24afa0638" target="_blank" rel="external">https://cnodejs.org/topic/593353775b07c1b24afa0638</a></li>
<li>「N-API | Node.js v8.0.0 Documentation」：<a href="https://nodejs.org/docs/v8.0.0/api/n-api.html" target="_blank" rel="external">https://nodejs.org/docs/v8.0.0/api/n-api.html</a></li>
<li>「doc: fix out of date sections in n-api doc」：<a href="https://github.com/nodejs/node/pull/13508" target="_blank" rel="external">https://github.com/nodejs/node/pull/13508</a></li>
</ul>
<p>[^1]: 用于定义某种文件类型的特殊标识，详见 <a href="https://en.wikipedia.org/wiki/Magic_number_(programming" target="_blank" rel="external">https://en.wikipedia.org/wiki/Magic_number_(programming</a>)<br>[^2]: 代码参见 <a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2427-L2502" target="_blank" rel="external">https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2427-L2502</a><br>[^3]: 年久失修，当前 NPM 上搜索到的 node-waf 已经不是当年的了，不过这个是 Waf 的官方仓库 <a href="https://github.com/waf-project/waf。" target="_blank" rel="external">https://github.com/waf-project/waf。</a><br>[^4]: 全称 Generate Your Projects，是谷歌开发的一套构建系统，未尽事宜详询 <a href="https://gyp.gsrc.io。" target="_blank" rel="external">https://gyp.gsrc.io。</a><br>[^5]: GYP 的配置文件的后缀就是 <em>.gyp 或者 </em>.gypi 等，是个类 JSON 文件。<br>[^6]: GN 是谷歌开发的相较于 GYP 更新更快的一套构建工具，可以参考 <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/HEAD/docs/quick_start.md" target="_blank" rel="external">https://chromium.googlesource.com/chromium/src/tools/gn/+/HEAD/docs/quick_start.md</a><br>[^7]: 让垃圾回收机制来管理 JavaScript 对象生命周期的一种类，即 HandleScope，在我的新书中将会有详解。<br>[^8]: Node.js 的异步事件循环支撑者，详询 <a href="http://www.libuv.org/" target="_blank" rel="external">http://www.libuv.org/</a><br>[^9]: 详情请查看 node-api 这个包，<a href="https://github.com/nodejs/node-api" target="_blank" rel="external">https://github.com/nodejs/node-api</a></p>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2017/07/01/nodejs-addon-history/";</script><script>var DISQUS_IDENTIFIER = "2017/07/01/nodejs-addon-history/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2017<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>