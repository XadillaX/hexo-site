<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="花瓣网的搜索架构需要重构，尤其是在索引建立或者更新层面。
　　目前的一个架构导致的结果就是时间越久，数据本体与搜索引擎索引中的数据越不同步，相差甚大。
　　新的一个架构打算从 MySQL 的 Binlog 中读取数据更新、删除、新增等历史记录，并把相应信息提取出来丢到队列中慢慢去同步。
　　所以我就"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>初探 MySQL 的 Binlog · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://xcoder.in/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/xadillax" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>初探 MySQL 的 Binlog</h1><span class="post-meta">写于<time> 2015 年 08 月 10 日 11 时 39 分</time><br>更新于<time> 2017 年 12 月 11 日 15 时 59 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-Binlog"><span class="toc-number">1.1.</span> <span class="toc-text">什么是 Binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启用-Binlog"><span class="toc-number">1.2.</span> <span class="toc-text">启用 Binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随便玩玩"><span class="toc-number">1.3.</span> <span class="toc-text">随便玩玩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构解析"><span class="toc-number">2.</span> <span class="toc-text">结构解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引文件"><span class="toc-number">2.1.</span> <span class="toc-text">索引文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binlog-文件"><span class="toc-number">2.2.</span> <span class="toc-text">Binlog 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件头"><span class="toc-number">2.2.1.</span> <span class="toc-text">文件头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件"><span class="toc-number">2.2.2.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事件头"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">事件头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件体"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">事件体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#格式描述事件"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">格式描述事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#跳转事件"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">跳转事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#各种不同的事件体"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">各种不同的事件体</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div><p>　　花瓣网的搜索架构需要重构，尤其是在索引建立或者更新层面。</p>
<p>　　目前的一个架构导致的结果就是时间越久，数据本体与搜索引擎索引中的数据越不同步，相差甚大。</p>
<p>　　新的一个架构打算从 MySQL 的 Binlog 中读取数据更新、删除、新增等历史记录，并把相应信息提取出来丢到队列中慢慢去同步。</p>
<p>　　所以我就在这里小小去了解一下 Binlog。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="什么是-Binlog"><a href="#什么是-Binlog" class="headerlink" title="什么是 Binlog"></a>什么是 Binlog</h3><p>　　MySQL Server 有四种类型的日志——Error Log、General Query Log、Binary Log 和 Slow Query Log。</p>
<p>　　第一个是错误日志，记录 mysqld 的一些错误。第二个是一般查询日志，记录 mysqld 正在做的事情，比如客户端的连接和断开、来自客户端每条 Sql Statement 记录信息；如果你想准确知道客户端到底传了什么瞎 [哔哔] 玩意儿给服务端，这个日志就非常管用了，不过它非常影响性能。第四个是慢查询日志，记录一些查询比较慢的 SQL 语句——这种日志非常常用，主要是给开发者调优用的。</p>
<p>　　剩下的第三种就是 Binlog 了，包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，也包括一些潜在改动，比如 <code>DELETE FROM ran WHERE bing = luan</code>，然而一条数据都没被删掉的这种情况。除非使用 Row-based logging，否则会包含所有改动数据的 SQL Statement。</p>
<p>　　那么 Binlog 就有了两个重要的用途——复制和恢复。比如主从表的复制，和备份恢复什么的。</p>
<h3 id="启用-Binlog"><a href="#启用-Binlog" class="headerlink" title="启用 Binlog"></a>启用 Binlog</h3><p>　　通常情况 MySQL 是默认关闭 Binlog 的，所以你得配置一下以启用它。</p>
<p>　　启用的过程就是修改配置文件 <code>my.cnf</code> 了。</p>
<p>　　至于 <code>my.cnf</code> 位置请自行寻找。例如通过 OSX 的 <code>brew</code> 安装的 <code>mysql</code> 默认配置目录通常在</p>
<blockquote>
<p>/usr/local/Cellar/mysql/$VERSION/support-files/my-default.cnf</p>
</blockquote>
<p>　　这个时候需要将它拷贝到 <code>/etc/my.cnf</code> 下面。</p>
<blockquote>
<p>详见 &lt;<a href="http://stackoverflow.com/questions/10757169/mysql-my-cnf-location" target="_blank" rel="external">StackOverflow - MySQL ‘my.cnf’ location?</a>&gt;。</p>
</blockquote>
<p>　　紧接着配置 <code>log-bin</code> 和 <code>log-bin-index</code> 的值，如果没有则自行加上去。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=master-bin</span><br><span class="line"><span class="attr">log-bin-index</span>=master-bin.index</span><br></pre></td></tr></table></figure>
<p>　　这里的 <code>log-bin</code> 是指以后生成各 Binlog 文件的前缀，比如上述使用 <code>master-bin</code>，那么文件就将会是 <code>master-bin.000001</code>、<code>master-bin.000002</code> 等。而这里的 <code>log-bin-index</code> 则指 binlog index 文件的名称，这里我们设置为 <code>master-bin.index</code>。</p>
<p>　　如果上述工作做完之后重启 MySQL 服务，你可以进入你的 MySQL CLI 验证一下是否真的启用了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mysql -u <span class="variable">$USERNAME</span> ...</span><br></pre></td></tr></table></figure>
<p>　　然后在终端里面输入下面一句 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%log_bin%'</span>;</span><br></pre></td></tr></table></figure>
<p>　　如果结果里面出来这样类似的话就表示成功了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| Variable_name                   | Value                                 |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| log_bin                         | ON                                    |</span><br><span class="line">| log_bin_basename                | /usr/<span class="built_in">local</span>/var/mysql/master-bin       |</span><br><span class="line">| log_bin_index                   | /usr/<span class="built_in">local</span>/var/mysql/master-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                   |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                   |</span><br><span class="line">| sql_log_bin                     | ON                                    |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>　　更多的一些相关配置可以参考这篇《<a href="http://blog.csdn.net/jolly10/article/details/13998761" target="_blank" rel="external">MySQL 的 binary log 初探</a>》。</p>
<h3 id="随便玩玩"><a href="#随便玩玩" class="headerlink" title="随便玩玩"></a>随便玩玩</h3><p>　　然后你就可以随便去执行一些数据变动的 SQL 语句了。当你执行了一堆语句之后就可以看到你的 Binlog 里面有内容了。</p>
<p>　　如上表所示，<code>log_bin_basename</code> 的值是 <code>/usr/local/var/mysql/master-bin</code> 就是 Binlog 的基础文件名了。</p>
<p>　　那我们进去看，比如我的这边就有这么几个文件：</p>
<p><img src="binlog-files.jpg" alt="Binlog 文件"></p>
<p>　　很容易发现，里面有 <code>master-bin.index</code> 和 <code>master-bin.000001</code> 两个文件，这两个文件在上文中有提到过了。</p>
<p>　　我们打开那个 <code>master-bin.index</code> 文件，会发现这个索引文件就是一个普通的文本文件，然后列举了各 binlog 的文件名。而 <code>master-bin.000001</code> 文件就是一堆乱码了——毕竟人家是二进制文件。</p>
<h2 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h2><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>　　索引文件就是上文中的 <code>master-bin.index</code> 文件，是一个普通的文本文件，以换行为间隔，一行一个文件名。比如它可能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master-bin.000001</span><br><span class="line">master-bin.000002</span><br><span class="line">master-bin.000003</span><br></pre></td></tr></table></figure>
<p>　　然后对应的每行文件就是一个 Binlog 实体文件了。</p>
<h3 id="Binlog-文件"><a href="#Binlog-文件" class="headerlink" title="Binlog 文件"></a>Binlog 文件</h3><p>　　Binlog 的文件结构大致由如下几个方面组成。</p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>　　文件头由一个四字节 Magic Number，其值为 <code>1852400382</code>，在内存中就是 <code>&quot;\xfe\x62\x69\x6e&quot;</code>，参考 MySQL 源码的 <a href="://github.com/mysql/mysql-server/blob/a2757a60a7527407d08115e44e889a25f22c96c6/sql/log_event.h#L187">log_event.h</a>，也就是 <code>&#39;\0xfe&#39; &#39;b&#39; &#39;i&#39; &#39;n&#39;</code>。</p>
<p>　　与平常二进制一样，通常都有一个 Magic Number 进行文件识别，如果 Magic Number 不吻合上述的值那么这个文件就不是一个正常的 Binlog。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>　　在文件头之后，跟随的是一个一个事件依次排列。每个事件都由一个事件头和事件体组成。</p>
<p>　　事件头里面的内容包含了这个事件的类型（如新增、删除等）、事件执行时间以及是哪个服务器执行的事件等信息。</p>
<p>　　第一个事件是一个事件描述符，描述了这个 Binlog 文件格式的版本。接下去的一堆事件将会按照第一个事件描述符所描述的结构版本进行解读。最后一个事件是一个衔接事件，指定了下一个 Binlog 文件名——有点类似于链表里面的 <code>next</code> 指针。</p>
<p>　　根据《<a href="High-Level Binary Log Structure and Contents">High-Level Binary Log Structure and Contents</a>》所述，不同版本的 Binlog 格式不一定一样，所以也没有一个定性。在我写这篇文章的时候，目前有三种版本的格式。</p>
<ul>
<li>v1，用于 MySQL 3.2.3</li>
<li>v3，用于 MySQL 4.0.2 以及 4.1.0</li>
<li>v4，用于 MySQL 5.0 以及更高版本</li>
</ul>
<p>　　实际上还有一个 v2 版本，不过只在早期 4.0.x 的 MySQL 版本中使用过，但是 v2 已经过于陈旧并且不再被 MySQL 官方支持了。</p>
<blockquote>
<p><strong>通常我们现在用的 MySQL 都是在 5.0 以上的了，所以就略过 v1 ~ v3 版本的 Binlog，如果需要了解 v1 ~ v3 版本的 Binlog 可以自行前往上述的《High-level…》文章查看。</strong></p>
</blockquote>
<h5 id="事件头"><a href="#事件头" class="headerlink" title="事件头"></a>事件头</h5><p>　　一个事件头有 19 字节，依次排列为四字节的时间戳、一字节的当前事件类型、四字节的服务端 ID、四字节的当前事件长度描述、四字节的下个事件位置（方便跳转）以及两字节的标识。</p>
<p>　　用 ASCII Diagram 表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+---------+------------+-------------+-------+</span><br><span class="line">|timestamp|type code|server_id|event_length|next_position|flags  |</span><br><span class="line">|4 bytes  |1 byte   |4 bytes  |4 bytes     |4 bytes      |2 bytes|</span><br><span class="line">+---------+---------+---------+------------+-------------+-------+</span><br></pre></td></tr></table></figure>
<p>　　也可以字节编造一个结构体来解读这个头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span></span><br><span class="line">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>   timestamp;</span><br><span class="line">    <span class="keyword">char</span>  type_code;</span><br><span class="line">    <span class="keyword">int</span>   server_id;</span><br><span class="line">    <span class="keyword">int</span>   event_length;</span><br><span class="line">    <span class="keyword">int</span>   next_position;</span><br><span class="line">    <span class="keyword">char</span>  flags[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你要直接用这个结构体来读取数据的话，需要加点手脚。</p>
<p>因为默认情况下 GCC 或者 G++ 编译器会对结构体进行字节对齐，这样读进来的数据就不对了，因为 Binlog 并不是对齐的。为了统一我们需要取消这个结构体的字节对齐，一个方法是使用 <code>#pragma pack(n)</code>，一个方法是使用 <code>__attribute__((__packed__))</code>，还有一种情况是在编译器编译的时候强制把所有的结构体对其取消，即在编译的时候使用 <code>fpack-struct</code> 参数，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ temp.cpp -o a -fpack-struct=1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>　　根据上述的结构我们可以明确得到各变量在结构体里面的偏移量，所以在 MySQL 源码里面（<a href="https://github.com/mysql/mysql-server/blob/5.7/libbinlogevents/include/binlog_event.h#L353" target="_blank" rel="external">libbinlogevents/include/binlog_event.h</a>）有下面几个常量以快速标记偏移：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_OFFSET    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ID_OFFSET     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_LEN_OFFSET     9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_POS_OFFSET       13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS_OFFSET         17</span></span><br></pre></td></tr></table></figure>
<p>　　而具体有哪些事件则在 <a href="https://github.com/mysql/mysql-server/blob/5.7/libbinlogevents/include/binlog_event.h#L245" target="_blank" rel="external">libbinlogevents/include/binlog_event.h#L245</a> 里面被定义。如有个 <code>FORMAT_DESCRIPTION_EVENT</code> 事件的 <code>type_code</code> 是 15、<code>UPDATE_ROWS_EVENT</code> 的 <code>type_code</code> 是 31。</p>
<p>　　还有那个 <code>next_position</code>，在 v4 版本中代表从 Binlog 一开始到下一个事件开始的偏移量，比如到第一个事件的 <code>next_position</code> 就是 4，因为文件头有一个字节的长度。然后接下去对于事件 n 和事件 n + 1 来说，他们有这样的关系：</p>
<blockquote>
<p>next_position(n + 1) = next_position(n) + event_length(n)</p>
</blockquote>
<p>　　关于 flags 暂时不需要了解太多，如果真的想了解的话可以看看 MySQL 的<a href="http://dev.mysql.com/doc/internals/en/event-flags.html" target="_blank" rel="external">相关官方文档</a>。</p>
<h5 id="事件体"><a href="#事件体" class="headerlink" title="事件体"></a>事件体</h5><p>　　事实上在 Binlog 事件中应该是有三个部分组成，<code>header</code>、<code>post-header</code> 和 <code>payload</code>，不过通常情况下我们把 <code>post-header</code> 和 <code>payload</code> 都归结为事件体，实际上这个 <code>post-header</code> 里面放的是一些定长的数据，只不过有时候我们不需要特别地关心。想要深入了解可以去查看 MySQL 的官方文档。</p>
<p>　　所以实际上一个真正的事件体由两部分组成，用 ASCII Diagram 表示就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | fixed part (post-header)   |</span><br><span class="line">| data   +----------------------------+</span><br><span class="line">|        | variable part (payload)    |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure>
<p>　　而这个 <code>post-header</code> 对于不同类型的事件来说长度是不一样的，同种类型来说是一样的，而这个长度的预先规定将会在一个“格式描述事件”中定好。</p>
<h5 id="格式描述事件"><a href="#格式描述事件" class="headerlink" title="格式描述事件"></a>格式描述事件</h5><p>　　在上文我们有提到过，在 Magic Number 之后跟着的是一个格式描述事件（Format Description Event），其实这只是在 v4 版本中的称呼，在以前的版本里面叫起始事件（Start Event）。</p>
<p>　　在 v4 版本中这个事件的结构如下面的 ASCII Diagram 所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | timestamp         0 : 4    |</span><br><span class="line">| header +----------------------------+</span><br><span class="line">|        | type_code         4 : 1    | = FORMAT_DESCRIPTION_EVENT = 15</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | server_id         5 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | event_length      9 : 4    | &gt;= 91</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | next_position    13 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | flags            17 : 2    |</span><br><span class="line">+=====================================+</span><br><span class="line">| event  | binlog_version   19 : 2    | = 4</span><br><span class="line">| data   +----------------------------+</span><br><span class="line">|        | server_version   21 : 50   |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | create_timestamp 71 : 4    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | header_length    75 : 1    |</span><br><span class="line">|        +----------------------------+</span><br><span class="line">|        | post-header      76 : n    | = array of n bytes, one byte per event</span><br><span class="line">|        | lengths for all            |   type that the server knows about</span><br><span class="line">|        | event types                |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure>
<p>　　这个事件的 <code>type_code</code> 是 15，然后 <code>event_length</code> 是大于等于 91 的值的，这个主要取决于所有事件类型数。</p>
<p>　　因为从第 76 字节开始后面的二进制就代表一个字节类型的数组了，一个字节代表一个事件类型的 <code>post-header</code> 长度，即每个事件类型固定数据的长度。</p>
<p>　　那么按照上述的一些线索来看，我们能非常快地写出一个简单的解读 Binlog 格式描述事件的代码。</p>
<blockquote>
<p>如上文所述，如果需要正常解读 Binlog 文件的话，下面的代码编译时候需要加上 <code>-fpack-struct=1</code> 这个参数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span></span><br><span class="line">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  timestamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type_code;</span><br><span class="line">    <span class="keyword">int</span>  server_id;</span><br><span class="line">    <span class="keyword">int</span>  event_length;</span><br><span class="line">    <span class="keyword">int</span>  next_position;</span><br><span class="line">    short flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/usr/local/var/mysql/master-bin.000001"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> magic_number;</span><br><span class="line">    fread(&amp;magic_number, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d - %s\n"</span>, magic_number, (<span class="keyword">char</span>*)(&amp;magic_number));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinlogEventHeader</span> <span class="title">format_description_event_header</span>;</span></span><br><span class="line">    fread(&amp;format_description_event_header, <span class="number">19</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BinlogEventHeader\n&#123;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    timestamp: %d\n"</span>, format_description_event_header.timestamp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    type_code: %d\n"</span>, format_description_event_header.type_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    server_id: %d\n"</span>, format_description_event_header.server_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    event_length: %d\n"</span>, format_description_event_header.event_length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    next_position: %d\n"</span>, format_description_event_header.next_position);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    flags[]: %d\n&#125;\n"</span>, format_description_event_header.flags);</span><br><span class="line"></span><br><span class="line">    short binlog_version;</span><br><span class="line">    fread(&amp;binlog_version, <span class="number">2</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"binlog_version: %d\n"</span>, binlog_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> server_version[<span class="number">51</span>];</span><br><span class="line">    fread(server_version, <span class="number">50</span>, <span class="number">1</span>, fp);</span><br><span class="line">    server_version[<span class="number">50</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"server_version: %s\n"</span>, server_version);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> create_timestamp;</span><br><span class="line">    fread(&amp;create_timestamp, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create_timestamp: %d\n"</span>, create_timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> header_length;</span><br><span class="line">    fread(&amp;header_length, <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"header_length: %d\n"</span>, header_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type_count = format_description_event_header.event_length - <span class="number">76</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> post_header_length[type_count];</span><br><span class="line">    fread(post_header_length, <span class="number">1</span>, type_count, fp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; type_count; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  - type %d: %d\n"</span>, i + <span class="number">1</span>, post_header_length[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个时候你得到的结果有可能就是这样的了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1852400382 - �binpz�</span><br><span class="line">BinlogEventHeader</span><br><span class="line">&#123;</span><br><span class="line">    timestamp: 1439186734</span><br><span class="line">    type_code: 15</span><br><span class="line">    server_id: 1</span><br><span class="line">    event_length: 116</span><br><span class="line">    next_position: 120</span><br><span class="line">    flags[]: 1</span><br><span class="line">&#125;</span><br><span class="line">binlog_version: 4</span><br><span class="line">server_version: 5.6.24-log</span><br><span class="line">create_timestamp: 1439186734</span><br><span class="line">header_length: 19</span><br><span class="line">  - type 1: 56</span><br><span class="line">  - type 2: 13</span><br><span class="line">  - type 3: 0</span><br><span class="line">  - type 4: 8</span><br><span class="line">  - type 5: 0</span><br><span class="line">  - type 6: 18</span><br><span class="line">  - ...</span><br></pre></td></tr></table></figure>
<p>　　一共会输出 40 种类型（从 1 到 40），如官方文档所说，这个数组从 <code>START_EVENT_V3</code> 事件开始（<code>type_code</code> 是 1）。</p>
<h5 id="跳转事件"><a href="#跳转事件" class="headerlink" title="跳转事件"></a>跳转事件</h5><p>　　跳转事件即 <code>ROTATE_EVENT</code>，其 <code>type_code</code> 是 4，其 <code>post-header</code> 长度为 8。</p>
<p>　　当一个 Binlog 文件大小已经差不多要分割了，它就会在末尾被写入一个 <code>ROTATE_EVENT</code>——用于指出这个 Binlog 的下一个文件。</p>
<p>　　它的 <code>post-header</code> 是 8 字节的一个东西，内容通常就是一个整数 <code>4</code>，用于表示下一个 Binlog 文件中的第一个事件起始偏移量。我们从上文就能得出在一般情况下这个数字只可能是四，就偏移了一个魔法数字。当然我们讲的是在 v4 这个 Binlog 版本下的情况。</p>
<p>　　然后在 <code>payload</code> 位置是一个字符串，即下一个 Binlog 文件的文件名。</p>
<h5 id="各种不同的事件体"><a href="#各种不同的事件体" class="headerlink" title="各种不同的事件体"></a>各种不同的事件体</h5><p>　　由于篇幅原因这里就不详细举例其它普通的不同事件体了，具体的详解在 <a href="http://dev.mysql.com/doc/internals/en/event-data-for-specific-event-types.html" target="_blank" rel="external">MySQL 文档</a>中一样有介绍，用到什么类型的事件体就可以自己去查询。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　本文大概介绍了 Binlog 的一些情况，以及 Binlog 的内部二进制解析结构。方便大家造轮子用——不然老用别人的轮子，只知其然而不知其所以然多没劲。</p>
<p>　　好了要下班了，就写到这里过吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://my.oschina.net/leejun2005/blog/75273" target="_blank" rel="external">MySQL’s binary log 结构简介</a>，目测原文在 <a href="http://www.taobaodba.com/html/474_mysqls-binary-log_details.html" target="_blank" rel="external">TaobaoDBA</a>（已无法访问）</li>
<li><a href="http://www.linuxidc.com/Linux/2014-09/107095.htm" target="_blank" rel="external">MySQL Binlog 的介绍</a></li>
<li><a href="http://blog.csdn.net/jolly10/article/details/13998761" target="_blank" rel="external">MySQL 的 binary log 初探</a></li>
<li><a href="http://dev.mysql.com/doc/internals/en/binary-log-structure-and-contents.html" target="_blank" rel="external">High-Level Binary Log Structure and Contents</a> and related official documents</li>
<li><a href="http://stackoverflow.com/questions/21912098/pragma-pack-vs-fpack-struct-for-intel-c" target="_blank" rel="external">#pragma pack vs -fpack-struct for Intel C</a></li>
</ol>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2015/08/10/mysql-binlog-try/";</script><script>var DISQUS_IDENTIFIER = "2015/08/10/mysql-binlog-try/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2020<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>