<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="死月·吃圡蕾特"><meta name="description" itemprop="description" content="好吧，我承认我标题党了。其实里面有很多分支条件的，是 child_process 模块中与 stdio 参数相关的函数需要加上 on(&amp;#39;data&amp;#39;) 事件处理。
哪些与 stdio 相关呢？如 child_process.spawn() 中 options 就有个可选参数 stdio"><link rel="alternative" href="/atom.xml" title="艾克斯の编码者" type="application/atom+xml"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>请务必给 child_process 加上 on('data') 处理 · 一个伪宅级别的码畜。</title><link rel="stylesheet" type="text/css" href="/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><header><a href="/"><img class="logo" src="/images/avatar.gif" alt="艾克斯の编码者" title="艾克斯の编码者"></a><h1><a href="/" alt="艾克斯の编码者" title="艾克斯の编码者">艾克斯の编码者</a></h1><p>一个伪宅级别的码畜。</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="/pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="/links" alt="链接" title="链接">链接</a></li><li><a href="/curriculumvitae" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="/atom.xml">&#xe621;</a><a target="_blank" href="https://github.com/XadillaX" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://www.zhihu.com/people/xadillax">&#xe63f;</a><a target="_blank" href="https://weibo.com/XadillaX" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>请务必给 child_process 加上 on('data') 处理</h1><span class="post-meta">写于<time> 2020 年 09 月 03 日 16 时 18 分</time><br>更新于<time> 2021 年 12 月 31 日 11 时 22 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#child-process-spawn-command-args-options"><span class="toc-number">1.</span> <span class="toc-text">child_process.spawn(command[, args][, options])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%8B"><span class="toc-number">2.</span> <span class="toc-text">实验一下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text">短字符串测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">长字符串测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%A6%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">翻车记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B-GDB-%E4%B8%80%E4%B8%8B"><span class="toc-number">3.</span> <span class="toc-text">动手 GDB 一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unix-Domain-Socket-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">Unix Domain Socket 缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%81%9C%E6%AD%A2%E8%AF%BB%E5%8F%96"><span class="toc-number">5.</span> <span class="toc-text">主进程停止读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%B5%E6%96%87%E6%A1%A3"><span class="toc-number">6.</span> <span class="toc-text">念文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></div><p>好吧，我承认我标题党了。其实里面有很多分支条件的，是 <code>child_process</code> 模块中与 <code>stdio</code> 参数相关的函数需要加上 <code>on(&#39;data&#39;)</code> 事件处理。</p>
<p>哪些与 <code>stdio</code> 相关呢？如 <code>child_process.spawn()</code> 中 <code>options</code> 就有个可选参数 <code>stdio</code>，你可以指定其为 <code>inherit</code>、<code>pipe</code>、<code>ignore</code> 等。</p>
<p>怎么算加上 <code>on(&#39;data&#39;)</code> 事件处理呢？监听这个事件算一个，将 <code>stdio</code> 指定为类似 <code>ignore</code> 这类操作也是算的。</p>
<p>接下去我就以 <code>child_process.spawn()</code> 为例展开讲吧。</p>
<h2 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a><code>child_process.spawn(command[, args][, options])</code></h2><p>我们先来看看 <code>child_process.spawn()</code> 函数：</p>
<ul>
<li><code>command</code>：要执行的命令；</li>
<li><code>[,args]</code>：执行命令时的命令行参数；</li>
<li><code>[,options]</code>：扩展选项。</li>
</ul>
<p>我们不关心前面的内容，只关心 <code>options</code> 中的 <code>stdio</code> 属性。</p>
<p><code>options.stdio</code> 可以是一个数组，也可以直接是一个字符串。</p>
<p>如果 <code>options.stdio</code> 是一个数组，则它指定了子进程对应序号的 <code>fd</code> 应该是什么。默认不配置的情况下，<code>spawn()</code> 出来的子进程对象（设为 <code>child</code>）中会有 <code>child.stdin</code>、<code>child.stdout</code> 和 <code>child.stderr</code> 三个 <code>Stream</code> 对象，而子进程的 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 三个 <code>fd</code> 会通过管道会被重定向到该三个流中——相当于 <code>options.stdio</code> 配置了 <code>&#39;pipe&#39;</code>。</p>
<p>如果 <code>options.stdio</code> 是一个字符串，则代表子进程前三个 <code>fd</code> 都是该字符串对应的含义。如 <code>&#39;pipe&#39;</code> 与 <code>[ &#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39; ]</code> 等价。</p>
<p>数组中的每个 <code>fd</code> 都可以是下面的类型（无耻摘录文档）：</p>
<ul>
<li><code>&#39;pipe&#39;</code>：在两个进程之间建立管道。在当前进程中，该管道以 <code>child.stdio[]</code> 流暴露；而 <code>child.stdin</code>、<code>child.stdout</code> 和 <code>child.stderr</code> 分别对应 <code>child.stdio[0-2]</code>。子进程的对应 <code>fd</code> 会被重定向到当前进程的对应流中；</li>
<li><code>&#39;ipc&#39;</code>：在两个进程之间建立 IPC 信道，主子进程通过 IPC 互通有无（前提是两个进程都得是 Node.js 进程），不过该类型不应用于 <code>std*</code>，而应该是数组中后续的 <code>fd</code> 中；</li>
<li><code>&#39;ignore&#39;</code>：将 <code>/dev/null</code> 给到对应的 <code>fd</code>；</li>
<li><code>&#39;inherit&#39;</code>：字面意思是继承当前进程，该配置会将子进程的对应 <code>fd</code> 通过当前进程的流重定向到当前进程对应的 <code>fd</code> 中，不过只有前三项（<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>）会生效，后续 <code>fd</code> 若配置了 <code>inherit</code> 等同于 <code>ignore</code>；</li>
<li><code>Stream</code>：直接是与子进程相关的 TTY、文件、Socket、管道等可读或者可写流对象，该流对象底层的 <code>fd</code> 会与子进程对应的 <code>fd</code> 进行共享，不过前提是流中得有个底层的文件描述符，像一个未打开的文件流对象就还没有对应的描述符；</li>
<li>正整数：与 <code>Stream</code> 类似，对应的是一个文件描述符；</li>
<li><code>null</code> / <code>undefined</code>：保持对应 <code>fd</code> 的默认值，前三个 <code>fd</code> 默认为 <code>pipe</code>，之后的为 <code>ignore</code>。</li>
</ul>
<p>了解了之后，我们就可以做限定了，本文标题的意思即 <code>pipe</code> 这类需要消费子进程 <code>stdio</code> 的操作我们需要真的消费才行。</p>
<p>其实原因也在文档中写明了，我会在本文的最后再放出来。</p>
<p>先开始做实验吧。</p>
<h2 id="实验一下"><a href="#实验一下" class="headerlink" title="实验一下"></a>实验一下</h2><p>我们先准备子进程文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="comment">// let str = Array(1000000).fill(&#x27;0000000000&#x27;).join(&#x27;&#x27;);</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件中有两句 <code>str</code> 声明，一句为注释。当我们要用短字符串的时候，就用原代码；当我们要用长字符串的时候，两句源码与注释互相替换一下。</p>
</blockquote>
<h3 id="短字符串测试"><a href="#短字符串测试" class="headerlink" title="短字符串测试"></a>短字符串测试</h3><p>我们写如下的主进程代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> child = cp.spawn(<span class="string">&#x27;node&#x27;</span>, [ <span class="string">&#x27;child.js&#x27;</span> ]);</span><br><span class="line">child.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行一下 <code>$ node index.js</code>。一切正常，我们的 <code>&#39;hello&#39;</code> 也被输出了。没问题。然后在上面的代码中加入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>再运行一下，似乎没什么变化。脱裤子放屁。我们再加点料吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> child = cp.spawn(<span class="string">&#x27;node&#x27;</span>, [ <span class="string">&#x27;child.js&#x27;</span> ]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">child.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> data += chunk.toString());</span><br><span class="line">child.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再运行一下，把 <code>&#39;123&#39;</code> 输出了。一切如我们所料一样。</p>
<h3 id="长字符串测试"><a href="#长字符串测试" class="headerlink" title="长字符串测试"></a>长字符串测试</h3><p>接下去，我们要注释掉子进程的短字符串，把长字符串放出来吧。</p>
<p>首先是「短字符串测试」中的最后一段代码，即有 <code>chunk =&gt; data += chunk.toString()</code> 这段代码的文件。运行一下 <code>$ node index.js</code> 看结果。</p>
<p>嚯，输出了一堆的 <code>&#39;0&#39;</code>，就像这样：</p>
<p><img src="https://dm.nbut.ac.cn/xcoder/2020/09/03/1599034425612-a69c7c25-5914-4f41-84c9-e2576649cc1b.png" alt="undefined"></p>
<p>看着太心烦了，把 <code>data</code> 相关的代码去掉吧，<code>stdout</code> 的 <code>data</code> 事件监听改回这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>然后在 <code>console.log</code> 那里也改回 <code>&#39;hello&#39;</code>。再运行一遍，世界清净了，只剩 <code>hello</code>。</p>
<p><strong>到目前为止，一切看起来都还算正常。</strong></p>
<h4 id="翻车记录"><a href="#翻车记录" class="headerlink" title="翻车记录"></a>翻车记录</h4><p>接下去要开始翻车了，我们把 <code>child.stdout.on</code> 这一整句去掉，让主进程代码恢复成最初的样子，顺便加点料：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> child = cp.spawn(<span class="string">&#x27;node&#x27;</span>, [ <span class="string">&#x27;child.js&#x27;</span> ]);</span><br><span class="line">child.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`噢，死月真是个沙雕呢。 x<span class="subst">$&#123;i++&#125;</span>`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>$ node index.js</code>，按下手中的回车键执行吧：</p>
<p><img src="https://dm.nbut.ac.cn/xcoder/2020/09/03/1599035285611-893903f4-8b62-4670-a391-fdc7e62efbee.gif" alt="沙雕"></p>
<blockquote>
<p>「<strong>噢，死月真是个沙雕呢。</strong>」之连环暴击。</p>
</blockquote>
<p>我们的程序卡住了。上面的源码很短，一眼就能看出来是因为没执行到 <code>process.exit(0)</code> 才卡住的。没执行到 <code>process.exit()</code> 的原因其实是因为没有触发 <code>child.on(&#39;exit&#39;)</code> 事件，再往上推，则是子进程没有退出。</p>
<p>不信他没退出的话，在「死月沙雕」的期间看看进程存活状态就知道了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep node</span><br><span class="line">xadillax 3844947  1.5  0.0 552184 31384 pts/202  Sl+  16:30   0:00 node index.js</span><br><span class="line">xadillax 3844954  1.1  0.1 612436 41620 pts/202  Sl+  16:30   0:00 node child.js</span><br></pre></td></tr></table></figure>

<h2 id="动手-GDB-一下"><a href="#动手-GDB-一下" class="headerlink" title="动手 GDB 一下"></a>动手 GDB 一下</h2><p>先不看答案，我们动手 GDB 一下看看卡哪了。大家编一个 Node.js 的 Debug 版本也要好久，为了简化过程，我们用 C 写一个最简单的子进程就能做好这个实验。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;0000000000&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc child.c -g</span><br></pre></td></tr></table></figure>

<p>生成了 <code>a.out</code>，然后改一下 JavaScript 主进程源码的 <code>spawn()</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> child = cp.spawn(<span class="string">&#x27;/tmp/lab/a.out&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>跑起来之后肯定依旧是沙雕一日游。这个时候我们拿到 PID 进行 GDB 一下吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep a.out</span><br><span class="line">xadillax 3848598  0.0  0.0   2488   588 pts/202  S+   16:46   0:00 /tmp/lab/a.out</span><br><span class="line">$ gdb</span><br><span class="line">(gdb) attach 3848598</span><br><span class="line">...</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  0x00007f066486c057 in __GI___libc_write (fd=1, buf=0x5654950b12a0, nbytes=4096) at ../sysdeps/unix/sysv/linux/write.c:26</span></span><br><span class="line"><span class="comment">#1  0x00007f06647ed00d in _IO_new_file_write (f=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;, data=0x5654950b12a0, n=4096) at fileops.c:1176</span></span><br><span class="line"><span class="comment">#2  0x00007f06647eead1 in new_do_write (to_do=4096, data=0x5654950b12a0 &#x27;0&#x27; &lt;repeats 200 times&gt;..., fp=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;) at libioP.h:948</span></span><br><span class="line"><span class="comment">#3  _IO_new_do_write (to_do=4096, data=0x5654950b12a0 &#x27;0&#x27; &lt;repeats 200 times&gt;..., fp=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;) at fileops.c:426</span></span><br><span class="line"><span class="comment">#4  _IO_new_do_write (fp=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;, data=0x5654950b12a0 &#x27;0&#x27; &lt;repeats 200 times&gt;..., to_do=4096) at fileops.c:423</span></span><br><span class="line"><span class="comment">#5  0x00007f06647ed835 in _IO_new_file_xsputn (n=10, data=&lt;optimized out&gt;, f=&lt;optimized out&gt;) at libioP.h:948</span></span><br><span class="line"><span class="comment">#6  _IO_new_file_xsputn (f=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;, data=&lt;optimized out&gt;, n=10) at fileops.c:1197</span></span><br><span class="line"><span class="comment">#7  0x00007f06647d4af2 in __vfprintf_internal (s=0x7f06649476a0 &lt;_IO_2_1_stdout_&gt;, format=0x565493233004 &quot;0000000000&quot;, ap=ap@entry=0x7ffddfc84640, mode_flags=mode_flags@entry=0) at ../libio/libioP.h:948</span></span><br><span class="line"><span class="comment">#8  0x00007f06647bfebf in __printf (format=&lt;optimized out&gt;) at printf.c:33</span></span><br><span class="line"><span class="comment">#9  0x000056549323216f in main () at child.c:4</span></span><br><span class="line">(gdb) frame 9</span><br><span class="line"><span class="comment">#9  0x000056549323216f in main () at child.c:4</span></span><br><span class="line">4           <span class="keyword">for</span> (int i = 0; i &lt; 1000000; i++) <span class="built_in">printf</span>(<span class="string">&quot;0000000000&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们看到是卡在 <code>child.c</code> 的第 4 行 <code>printf</code> 了。它上面的执行栈也是一路 <code>printf</code> 卡到底。</p>
<p>现在我们知道了，当我们不处理这些文章开始说的事件时候，子进程<strong>有可能</strong>会卡在形如 <code>printf</code> 等往 <code>stdout</code>、<code>stderr</code> 这些 <code>fd</code> 写的操作上。</p>
<h2 id="Unix-Domain-Socket-缓冲区"><a href="#Unix-Domain-Socket-缓冲区" class="headerlink" title="Unix Domain Socket 缓冲区"></a>Unix Domain Socket 缓冲区</h2><p>我们回过头去看看，我们的实验代码主子进程之间是通过什么来联立 <code>stdout</code> 的。根据最开始的文档摘录，噢，原来是 <code>pipe</code> 呢！</p>
<p><img src="https://dm.nbut.ac.cn/xcoder/2020/09/03/1599037067323-e4e0645e-ef18-4352-9f9b-d0ced7e9fa3d.png" alt="undefined"></p>
<p>通常情况下，Linux 下的管道缓冲区为 65536 字节。然而 Node.js 子进程 <code>stdio</code> 的值若为 <code>pipe</code>，则其实是建立了一个 Unix Domain Socket。</p>
<p>也就是说，子进程的 <code>stdout</code> 是一条与主进程之间建立起来的 Unix Domain Socket。其两端的进程均将该管道看做一个文件，子进程负责往其中写内容，而主进程则从中读取。</p>
<p>让我们把视线放到工地上。</p>
<p><img src="https://dm.nbut.ac.cn/xcoder/2020/09/03/1599037696714-18946a94-db52-4edb-9230-a885d4579414.png" alt="undefined"></p>
<p>管道是有大小的。如果我们堵住管道的出口，那么我们一直往管道里面灌水，最终会导致水灌不进去堵住了。这句话同样适用于我们上面的代码。</p>
<p>也就是说，我们最开始没有翻车的代码，因为输出的内容太少，占不满管道缓冲区，所以不会阻塞程序执行，最终得以安全退出；而后面翻车则是因为我们输出的内容太多了，导致不一会儿缓冲区就满了，而我们的主进程又没去消费，所以就翻车了。</p>
<h2 id="主进程停止读取"><a href="#主进程停止读取" class="headerlink" title="主进程停止读取"></a>主进程停止读取</h2><p>为什么我们 <code>on(&#39;data&#39;)</code> 了就能消费，而不加就没消费呢。按理说 Node.js 都读过来，<code>emit</code> 了事，就能继续读下一趴了。其实不是的。</p>
<p>看看 Node.js 的判断 Readable Stream 是否要读取新内容的逻辑（<a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L586-L621">https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L586-L621</a>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maybeReadMore_</span>(<span class="params">stream, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!state.reading &amp;&amp; !state.ended &amp;&amp;</span><br><span class="line">         (state.length &lt; state.highWaterMark ||</span><br><span class="line">          (state.flowing &amp;&amp; state.length === <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = state.length;</span><br><span class="line">    debug(<span class="string">&#x27;maybeReadMore read 0&#x27;</span>);</span><br><span class="line">    stream.read(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len === state.length)</span><br><span class="line">      <span class="comment">// Didn&#x27;t get any data, stop spinning.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  state.readingMore = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面其它正常的前提我们抛开不讲，如流正在读啊，还能读到数据啊什么的。</p>
<p>当 Readable Stream 内部的 Buffer 长度没到水位线（通常是 16384），或者其处于 <code>flowing</code> 状态且缓存没数据的时候，该流会继续从源读数据。</p>
<p>一个 Readable Stream 最开始的 <code>flowing</code> 状态是 <code>null</code>。也就是说在这个状态下，当达到缓存水位线之后，就不会继续读数据了。</p>
<p>那什么时候这个状态会变呢？在这里：<a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L868-L897">https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L868-L897</a>。</p>
<p>当你调用了 <code>stream.on()</code> 的时候，它会判断你这次调用所监听的事件。若事件是 <code>&#39;data&#39;</code> 且当前的 <code>flowing</code> 状态不为 <code>false</code> 的话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ev === <span class="string">&#x27;data&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// Update readableListening so that resume() may be a no-op</span></span><br><span class="line">  <span class="comment">// a few lines down. This is needed to support once(&#x27;readable&#x27;).</span></span><br><span class="line">  state.readableListening = <span class="built_in">this</span>.listenerCount(<span class="string">&#x27;readable&#x27;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try start flowing on next tick if stream isn&#x27;t explicitly paused</span></span><br><span class="line">  <span class="keyword">if</span> (state.flowing !== <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">this</span>.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Readable Stream 就会执行 <code>resume()</code>。在 <code>resume()</code> 中（<a target="_blank" rel="noopener" href="https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L955-L969">https://github.com/nodejs/node/blob/v12.18.3/lib/_stream_readable.js#L955-L969</a>）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pause() and resume() are remnants of the legacy readable stream API</span></span><br><span class="line"><span class="comment">// If the user uses them, then switch into old mode.</span></span><br><span class="line">Readable.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="built_in">this</span>._readableState;</span><br><span class="line">  <span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">&#x27;resume&#x27;</span>);</span><br><span class="line">    <span class="comment">// We flow only if there is no one listening</span></span><br><span class="line">    <span class="comment">// for readable, but we still have to call</span></span><br><span class="line">    <span class="comment">// resume()</span></span><br><span class="line">    state.flowing = !state.readableListening;</span><br><span class="line">    resume(<span class="built_in">this</span>, state);</span><br><span class="line">  &#125;</span><br><span class="line">  state[kPaused] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会将 <code>flowing</code> 设置为 <code>true</code>。正如 Node.js 文档中说的一样：</p>
<blockquote>
<p>All Readable streams begin in paused mode but can be switched to flowing mode in one of the following ways:</p>
<ul>
<li>Adding a ‘data’ event handler.</li>
<li>Calling the stream.resume() method.</li>
<li>Calling the stream.pipe() method to send the data to a Writable.</li>
</ul>
</blockquote>
<p>即所有的 Readable Stream 一开始都处于暂停状态，对其添加 <code>data</code> 事件才会开始切为 <code>flowing</code> 状态。而在暂停状态下，<code>stdio</code> 的 <code>pipe</code> 流会先缓存略大于或等于水位线的数据。</p>
<p>在暂停状态下，只有你添加了 <code>data</code> 事件处理器才会开始读取数据并丢给你；而如果你处于 <code>flowing</code> 状态，只移除消费者，那么这些数据就会丢失——因为流其实并没有暂停。</p>
<p>文档上虽说一开始处于暂停状态时我们没去监听数据，那么流就不会产生数据。<strong>实际上在内部实现上是产生了数据，而这部分数据是被缓存起来了。</strong></p>
<h2 id="念文档"><a href="#念文档" class="headerlink" title="念文档"></a>念文档</h2><p>好了，回到最开始。我之前说了“其实原因也在文档中写明了，我会在本文的最后再放出来”。现在是时间了，看看这里：<a target="_blank" rel="noopener" href="https://nodejs.org/api/child_process.html#child_process_child_process">https://nodejs.org/api/child_process.html#child_process_child_process</a>。</p>
<blockquote>
<p>By default, pipes for stdin, stdout, and stderr are established between the parent Node.js process and the spawned child. These pipes have limited (and platform-specific) capacity. If the child process writes to stdout in excess of that limit without the output being captured, the child process will block waiting for the pipe buffer to accept more data. This is identical to the behavior of pipes in the shell. Use the { stdio: ‘ignore’ } option if the output will not be consumed.</p>
</blockquote>
<p>默认情况下，<code>spawn</code> 等会在 Node.js 进程与子进程间建立 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 的管道。管道容量有限（不同平台容量不同）。如果子进程往 <code>stdout</code> 写入内容，而另一端没有捕获导致管道满了的话，在管道腾出空间前，子进程就会一直阻塞。该行为与 Shell 中的管道一致。如果我们不关心输出内容的话，请设置 <code>&#123; stdio: &#39;ignore&#39; &#125;</code>。</p>
<p>看吧，就是这个理儿。如果我们将其设为 <code>ignore</code> 的话，其三个 <code>std*</code> 就会导到 <code>/dev/null</code> 去。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>所以标题的标题党就是这个意思。</p>
<p>你一旦建立了子进程，且其 <code>stdout</code> 之类的是一个 <code>pipe</code>，你就必须对它的数据负责。哪怕你只是监听了这个事件，里面写个空函数，Node.js 也会认为你消费了，不然 Node.js 会把子进程的数据一直挂载在它 <code>Stream</code> 的缓存中，最后到一个水位（大于 16384 的时候）之后就停止读取子进程数据了。然后就会导致子进程写阻塞。</p>
<p><strong>结论就是，你在 <code>child_process.spawn()</code> 一个进程的时候，请务必监听 <code>stdio</code> 里面各 Stream 的 <code>&#39;data&#39;</code> 事件。若你不关心输出，请将 <code>stdio</code> 设置为 <code>ignore</code> 或者 <code>inherit</code>。</strong></p>
<hr><section class="comment"><div id="disqus_thread"></div></section><script>var DISQUS_PAGE_URL = "https://xcoder.in/2020/09/03/child_process_on_data/";</script><script>var DISQUS_IDENTIFIER = "2020/09/03/child_process_on_data/";</script><script>var DISQUS_SHORT_NAME = "xcoder"</script><script>var disqus_config = function() {
  this.page.url = DISQUS_PAGE_URL;
  this.page.identifier = DISQUS_IDENTIFIER;
};

(function() {
  var d = document, s = d.createElement("script");
  s.src = "https://" + DISQUS_SHORT_NAME + ".disqus.com/embed.js";
  s.setAttribute("data-timestamp", +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><footer><section class="copyright">&copy; 2016 - 2021<a href="/">死月·吃圡蕾特</a></section><section class="intro">由<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a target="_blank" rel="noopener" href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $(block).find("td.gutter").remove();
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        if($(this).parent().is("article")) {
            $(this).wrap("<p style='text-align: center;'></p>");
        } else {
            $(this).parent().css("text-align", "center");
        }
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>